/* c/zx-tas3.ds - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** ds-templ.c  -  DirectoryScript template, used in code generation
 ** Copyright (c) 2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: ds-templ.c,v 1.1 2007-08-10 17:44:49 sampo Exp $
 **
 ** 6.6.2007, created, Sampo Kellomaki (sampo@iki.fi)
 **
 ** N.B: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/



function parse_tas3_Credentials(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'usage', data.usage);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  tag = find_xml_local(x[2], 'Assertion', 1);
  h =  hash [];
  parse_sa_Assertion(h, aux1);
  data{'Assertion'} = h;
  tag = find_xml_local(x[2], 'EncryptedAssertion', 1);
  h =  hash [];
  parse_sa_EncryptedAssertion(h, aux1);
  data{'EncryptedAssertion'} = h;
  tag = find_xml_local(x[2], 'sa11_Assertion', 1);
  h =  hash [];
  parse_sa11_Assertion(h, aux1);
  data{'sa11_Assertion'} = h;
  tag = find_xml_local(x[2], 'ff12_Assertion', 1);
  h =  hash [];
  parse_ff12_Assertion(h, aux1);
  data{'ff12_Assertion'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Attribute', i); ++i) {
    h =  hash [];
    parse_sa_Attribute(h, tag);
    push data{'Attribute'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'EncryptedAttribute', i); ++i) {
    h =  hash [];
    parse_sa_EncryptedAttribute(h, tag);
    push data{'EncryptedAttribute'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'xac_Attribute', i); ++i) {
    h =  hash [];
    parse_xac_Attribute(h, tag);
    push data{'xac_Attribute'}, h;
  }

}

function build_tas3_Credentials(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'usage', data.usage);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  push body, build_sa_Assertion(data{'Assertion'});
  push body, build_sa_EncryptedAssertion(data{'EncryptedAssertion'});
  push body, build_sa11_Assertion(data{'sa11_Assertion'});
  push body, build_ff12_Assertion(data{'ff12_Assertion'});
  for d(data{'Attribute'}) push body,build_sa_Attribute(d);
  for d(data{'EncryptedAttribute'}) push body,build_sa_EncryptedAttribute(d);
  for d(data{'xac_Attribute'}) push body,build_xac_Attribute(d);

  return TAG('tas3:Credentials', attr, body);
}




function parse_tas3_ESLApply(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'ESLRef', i); ++i) {
    h =  hash [];
    parse_tas3_ESLRef(h, tag);
    push data{'ESLRef'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'Obligation', i); ++i) {
    h =  hash [];
    parse_xa_Obligation(h, tag);
    push data{'Obligation'}, h;
  }

}

function build_tas3_ESLApply(data) {
  attr = [];
  body = [];

  for d(data{'ESLRef'}) push body,build_tas3_ESLRef(d);
  for d(data{'Obligation'}) push body,build_xa_Obligation(d);

  return TAG('tas3:ESLApply', attr, body);
}




function parse_tas3_ESLPolicies(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'usage', data.usage);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  for (i=1; tag = find_xml_local(x[2], 'ESLApply', i); ++i) {
    h =  hash [];
    parse_tas3_ESLApply(h, tag);
    push data{'ESLApply'}, h;
  }

}

function build_tas3_ESLPolicies(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'usage', data.usage);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  for d(data{'ESLApply'}) push body,build_tas3_ESLApply(d);

  return TAG('tas3:ESLPolicies', attr, body);
}




function parse_tas3_ESLRef(data, x) {
  POPATTR(x[1], 'ref', data.ref);
  POPATTR(x[1], 'xpath', data.xpath);


}

function build_tas3_ESLRef(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'ref', data.ref);
  PUSHATTR(attr, 'xpath', data.xpath);


  return TAG('tas3:ESLRef', attr, body);
}




function parse_tas3_Status(data, x) {
  POPATTR(x[1], 'code', data.code);
  POPATTR(x[1], 'comment', data.comment);
  POPATTR(x[1], 'ctlpt', data.ctlpt);
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'ref', data.ref);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  for (i=1; tag = find_xml_local(x[2], 'Status', i); ++i) {
    h =  hash [];
    parse_lu_Status(h, tag);
    push data{'Status'}, h;
  }

}

function build_tas3_Status(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'code', data.code);
  PUSHATTR(attr, 'comment', data.comment);
  PUSHATTR(attr, 'ctlpt', data.ctlpt);
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'ref', data.ref);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  for d(data{'Status'}) push body,build_lu_Status(d);

  return TAG('tas3:Status', attr, body);
}




function parse_tas3_Trust(data, x) {
  POPATTR(x[1], 'vers', data.vers);

  for (i=1; tag = find_xml_local(x[2], 'TrustRanking', i); ++i) {
    h =  hash [];
    parse_tas3_TrustRanking(h, tag);
    push data{'TrustRanking'}, h;
  }

}

function build_tas3_Trust(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'vers', data.vers);

  for d(data{'TrustRanking'}) push body,build_tas3_TrustRanking(d);

  return TAG('tas3:Trust', attr, body);
}




function parse_tas3_TrustRanking(data, x) {
  POPATTR(x[1], 'metric', data.metric);
  POPATTR(x[1], 'val', data.val);


}

function build_tas3_TrustRanking(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'metric', data.metric);
  PUSHATTR(attr, 'val', data.val);


  return TAG('tas3:TrustRanking', attr, body);
}


/* EOF -- c/zx-tas3.ds */
