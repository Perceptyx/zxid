/* c/zx-cdm-enc.c - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** enc-templ.c  -  XML encoder template, used in code generation
 ** Copyright (c) 2010 Sampo Kellomaki (sampo@iki.fi), All Rights Reserved.
 ** Copyright (c) 2006-2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: enc-templ.c,v 1.27 2007-10-05 22:24:28 sampo Exp $
 **
 ** 30.5.2006, created, Sampo Kellomaki (sampo@iki.fi)
 ** 6.8.2006,  factored data structure walking to aux-templ.c --Sampo
 ** 8.8.2006,  reworked namespace handling --Sampo
 ** 26.8.2006, some CSE --Sampo
 ** 23.9.2006, added WO logic --Sampo
 ** 30.9.2007, improvements to WO encoding --Sampo
 ** 8.2.2010,  better handling of schema order encoding of unknown namespace prefixes --Sampo
 ** 27.10.2010, re-engineered namespace handling --Sampo
 **
 ** N.B: wo=wire order (needed for exc-c14n), so=schema order
 ** N.B2: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/

#include <memory.h>
#include "errmac.h"
#include "zx.h"
#include "c/zx-const.h"
#include "c/zx-data.h"
#include "c/zx-cdm-data.h"
#include "c/zx-ns.h"



#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_ADR
#define EL_STRUCT zx_cdm_ADR_s
#define EL_NS     cdm
#define EL_TAG    ADR

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_ADR) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_ADR(struct zx_ctx* c, struct zx_cdm_ADR_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:ADR")-1 + 1 + sizeof("</cdm:ADR>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->HOME;
    se && se->g.tok == zx_cdm_HOME_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:HOME")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->WORK;
    se && se->g.tok == zx_cdm_WORK_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:WORK")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->POSTAL;
    se && se->g.tok == zx_cdm_POSTAL_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:POSTAL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PARCEL;
    se && se->g.tok == zx_cdm_PARCEL_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PARCEL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->DOM;
    se && se->g.tok == zx_cdm_DOM_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:DOM")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->INTL;
    se && se->g.tok == zx_cdm_INTL_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:INTL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PREF;
    se && se->g.tok == zx_cdm_PREF_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->POBOX->gg;
       se && se->g.tok == zx_cdm_POBOX_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_POBOX(c, (struct zx_cdm_POBOX_s*)se);
  for (se = &x->EXTADR->gg;
       se && se->g.tok == zx_cdm_EXTADR_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_EXTADR(c, (struct zx_cdm_EXTADR_s*)se);
  for (se = &x->STREET->gg;
       se && se->g.tok == zx_cdm_STREET_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_STREET(c, (struct zx_cdm_STREET_s*)se);
  for (se = &x->LOCALITY->gg;
       se && se->g.tok == zx_cdm_LOCALITY_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_LOCALITY(c, (struct zx_cdm_LOCALITY_s*)se);
  for (se = &x->REGION->gg;
       se && se->g.tok == zx_cdm_REGION_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_REGION(c, (struct zx_cdm_REGION_s*)se);
  for (se = &x->PCODE->gg;
       se && se->g.tok == zx_cdm_PCODE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_PCODE(c, (struct zx_cdm_PCODE_s*)se);
  for (se = &x->CTRY->gg;
       se && se->g.tok == zx_cdm_CTRY_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_CTRY(c, (struct zx_cdm_CTRY_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:ADR", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_ADR) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_ADR(struct zx_ctx* c, struct zx_cdm_ADR_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:ADR");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->HOME;
       se && se->g.tok == zx_cdm_HOME_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:HOME", sizeof("cdm:HOME")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->WORK;
       se && se->g.tok == zx_cdm_WORK_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:WORK", sizeof("cdm:WORK")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->POSTAL;
       se && se->g.tok == zx_cdm_POSTAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:POSTAL", sizeof("cdm:POSTAL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PARCEL;
       se && se->g.tok == zx_cdm_PARCEL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PARCEL", sizeof("cdm:PARCEL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->DOM;
       se && se->g.tok == zx_cdm_DOM_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:DOM", sizeof("cdm:DOM")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->INTL;
       se && se->g.tok == zx_cdm_INTL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:INTL", sizeof("cdm:INTL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PREF;
       se && se->g.tok == zx_cdm_PREF_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PREF", sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->POBOX->gg;
       se && se->g.tok == zx_cdm_POBOX_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_POBOX(c, (struct zx_cdm_POBOX_s*)se, p);
  for (se = &x->EXTADR->gg;
       se && se->g.tok == zx_cdm_EXTADR_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_EXTADR(c, (struct zx_cdm_EXTADR_s*)se, p);
  for (se = &x->STREET->gg;
       se && se->g.tok == zx_cdm_STREET_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_STREET(c, (struct zx_cdm_STREET_s*)se, p);
  for (se = &x->LOCALITY->gg;
       se && se->g.tok == zx_cdm_LOCALITY_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_LOCALITY(c, (struct zx_cdm_LOCALITY_s*)se, p);
  for (se = &x->REGION->gg;
       se && se->g.tok == zx_cdm_REGION_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_REGION(c, (struct zx_cdm_REGION_s*)se, p);
  for (se = &x->PCODE->gg;
       se && se->g.tok == zx_cdm_PCODE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_PCODE(c, (struct zx_cdm_PCODE_s*)se, p);
  for (se = &x->CTRY->gg;
       se && se->g.tok == zx_cdm_CTRY_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_CTRY(c, (struct zx_cdm_CTRY_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:ADR>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:ADR", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_ADR) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_ADR(struct zx_ctx* c, struct zx_cdm_ADR_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_ADR(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_ADR(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_AGENT
#define EL_STRUCT zx_cdm_AGENT_s
#define EL_NS     cdm
#define EL_TAG    AGENT

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_AGENT) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_AGENT(struct zx_ctx* c, struct zx_cdm_AGENT_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:AGENT")-1 + 1 + sizeof("</cdm:AGENT>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->vCard->gg;
       se && se->g.tok == zx_cdm_vCard_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_vCard(c, (struct zx_cdm_vCard_s*)se);
  for (se = &x->EXTVAL->gg;
       se && se->g.tok == zx_cdm_EXTVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_EXTVAL(c, (struct zx_cdm_EXTVAL_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:AGENT", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_AGENT) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_AGENT(struct zx_ctx* c, struct zx_cdm_AGENT_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:AGENT");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->vCard->gg;
       se && se->g.tok == zx_cdm_vCard_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_vCard(c, (struct zx_cdm_vCard_s*)se, p);
  for (se = &x->EXTVAL->gg;
       se && se->g.tok == zx_cdm_EXTVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_EXTVAL(c, (struct zx_cdm_EXTVAL_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:AGENT>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:AGENT", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_AGENT) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_AGENT(struct zx_ctx* c, struct zx_cdm_AGENT_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_AGENT(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_AGENT(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_BDAY
#define EL_STRUCT zx_cdm_BDAY_s
#define EL_NS     cdm
#define EL_TAG    BDAY

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_BDAY) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_BDAY(struct zx_ctx* c, struct zx_cdm_BDAY_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:BDAY")-1 + 1 + sizeof("</cdm:BDAY>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:BDAY", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_BDAY) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_BDAY(struct zx_ctx* c, struct zx_cdm_BDAY_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:BDAY");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:BDAY>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:BDAY", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_BDAY) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_BDAY(struct zx_ctx* c, struct zx_cdm_BDAY_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_BDAY(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_BDAY(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_BINVAL
#define EL_STRUCT zx_cdm_BINVAL_s
#define EL_NS     cdm
#define EL_TAG    BINVAL

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_BINVAL) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_BINVAL(struct zx_ctx* c, struct zx_cdm_BINVAL_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:BINVAL")-1 + 1 + sizeof("</cdm:BINVAL>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:BINVAL", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_BINVAL) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_BINVAL(struct zx_ctx* c, struct zx_cdm_BINVAL_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:BINVAL");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:BINVAL>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:BINVAL", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_BINVAL) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_BINVAL(struct zx_ctx* c, struct zx_cdm_BINVAL_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_BINVAL(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_BINVAL(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_CALADRURI
#define EL_STRUCT zx_cdm_CALADRURI_s
#define EL_NS     cdm
#define EL_TAG    CALADRURI

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_CALADRURI) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_CALADRURI(struct zx_ctx* c, struct zx_cdm_CALADRURI_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:CALADRURI")-1 + 1 + sizeof("</cdm:CALADRURI>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->PREF;
    se && se->g.tok == zx_cdm_PREF_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->URI->gg;
       se && se->g.tok == zx_cdm_URI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_URI(c, (struct zx_cdm_URI_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:CALADRURI", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_CALADRURI) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_CALADRURI(struct zx_ctx* c, struct zx_cdm_CALADRURI_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:CALADRURI");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->PREF;
       se && se->g.tok == zx_cdm_PREF_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PREF", sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->URI->gg;
       se && se->g.tok == zx_cdm_URI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_URI(c, (struct zx_cdm_URI_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:CALADRURI>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:CALADRURI", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_CALADRURI) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_CALADRURI(struct zx_ctx* c, struct zx_cdm_CALADRURI_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_CALADRURI(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_CALADRURI(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_CALURI
#define EL_STRUCT zx_cdm_CALURI_s
#define EL_NS     cdm
#define EL_TAG    CALURI

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_CALURI) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_CALURI(struct zx_ctx* c, struct zx_cdm_CALURI_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:CALURI")-1 + 1 + sizeof("</cdm:CALURI>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->PREF;
    se && se->g.tok == zx_cdm_PREF_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->URI->gg;
       se && se->g.tok == zx_cdm_URI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_URI(c, (struct zx_cdm_URI_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:CALURI", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_CALURI) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_CALURI(struct zx_ctx* c, struct zx_cdm_CALURI_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:CALURI");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->PREF;
       se && se->g.tok == zx_cdm_PREF_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PREF", sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->URI->gg;
       se && se->g.tok == zx_cdm_URI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_URI(c, (struct zx_cdm_URI_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:CALURI>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:CALURI", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_CALURI) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_CALURI(struct zx_ctx* c, struct zx_cdm_CALURI_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_CALURI(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_CALURI(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_CAPURI
#define EL_STRUCT zx_cdm_CAPURI_s
#define EL_NS     cdm
#define EL_TAG    CAPURI

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_CAPURI) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_CAPURI(struct zx_ctx* c, struct zx_cdm_CAPURI_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:CAPURI")-1 + 1 + sizeof("</cdm:CAPURI>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->PREF;
    se && se->g.tok == zx_cdm_PREF_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->URI->gg;
       se && se->g.tok == zx_cdm_URI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_URI(c, (struct zx_cdm_URI_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:CAPURI", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_CAPURI) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_CAPURI(struct zx_ctx* c, struct zx_cdm_CAPURI_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:CAPURI");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->PREF;
       se && se->g.tok == zx_cdm_PREF_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PREF", sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->URI->gg;
       se && se->g.tok == zx_cdm_URI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_URI(c, (struct zx_cdm_URI_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:CAPURI>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:CAPURI", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_CAPURI) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_CAPURI(struct zx_ctx* c, struct zx_cdm_CAPURI_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_CAPURI(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_CAPURI(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_CATEGORIES
#define EL_STRUCT zx_cdm_CATEGORIES_s
#define EL_NS     cdm
#define EL_TAG    CATEGORIES

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_CATEGORIES) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_CATEGORIES(struct zx_ctx* c, struct zx_cdm_CATEGORIES_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:CATEGORIES")-1 + 1 + sizeof("</cdm:CATEGORIES>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->KEYWORD->gg;
       se && se->g.tok == zx_cdm_KEYWORD_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_KEYWORD(c, (struct zx_cdm_KEYWORD_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:CATEGORIES", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_CATEGORIES) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_CATEGORIES(struct zx_ctx* c, struct zx_cdm_CATEGORIES_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:CATEGORIES");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->KEYWORD->gg;
       se && se->g.tok == zx_cdm_KEYWORD_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_KEYWORD(c, (struct zx_cdm_KEYWORD_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:CATEGORIES>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:CATEGORIES", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_CATEGORIES) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_CATEGORIES(struct zx_ctx* c, struct zx_cdm_CATEGORIES_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_CATEGORIES(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_CATEGORIES(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_CLASS
#define EL_STRUCT zx_cdm_CLASS_s
#define EL_NS     cdm
#define EL_TAG    CLASS

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_CLASS) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_CLASS(struct zx_ctx* c, struct zx_cdm_CLASS_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:CLASS")-1 + 1 + sizeof("</cdm:CLASS>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->PUBLIC;
    se && se->g.tok == zx_cdm_PUBLIC_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PUBLIC")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PRIVATE;
    se && se->g.tok == zx_cdm_PRIVATE_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PRIVATE")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->CONFIDENTIAL;
    se && se->g.tok == zx_cdm_CONFIDENTIAL_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:CONFIDENTIAL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:CLASS", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_CLASS) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_CLASS(struct zx_ctx* c, struct zx_cdm_CLASS_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:CLASS");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->PUBLIC;
       se && se->g.tok == zx_cdm_PUBLIC_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PUBLIC", sizeof("cdm:PUBLIC")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PRIVATE;
       se && se->g.tok == zx_cdm_PRIVATE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PRIVATE", sizeof("cdm:PRIVATE")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->CONFIDENTIAL;
       se && se->g.tok == zx_cdm_CONFIDENTIAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:CONFIDENTIAL", sizeof("cdm:CONFIDENTIAL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:CLASS>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:CLASS", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_CLASS) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_CLASS(struct zx_ctx* c, struct zx_cdm_CLASS_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_CLASS(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_CLASS(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_CRED
#define EL_STRUCT zx_cdm_CRED_s
#define EL_NS     cdm
#define EL_TAG    CRED

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_CRED) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_CRED(struct zx_ctx* c, struct zx_cdm_CRED_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:CRED")-1 + 1 + sizeof("</cdm:CRED>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:CRED", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_CRED) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_CRED(struct zx_ctx* c, struct zx_cdm_CRED_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:CRED");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:CRED>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:CRED", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_CRED) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_CRED(struct zx_ctx* c, struct zx_cdm_CRED_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_CRED(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_CRED(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_CTRY
#define EL_STRUCT zx_cdm_CTRY_s
#define EL_NS     cdm
#define EL_TAG    CTRY

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_CTRY) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_CTRY(struct zx_ctx* c, struct zx_cdm_CTRY_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:CTRY")-1 + 1 + sizeof("</cdm:CTRY>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:CTRY", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_CTRY) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_CTRY(struct zx_ctx* c, struct zx_cdm_CTRY_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:CTRY");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:CTRY>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:CTRY", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_CTRY) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_CTRY(struct zx_ctx* c, struct zx_cdm_CTRY_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_CTRY(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_CTRY(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_DESC
#define EL_STRUCT zx_cdm_DESC_s
#define EL_NS     cdm
#define EL_TAG    DESC

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_DESC) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_DESC(struct zx_ctx* c, struct zx_cdm_DESC_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:DESC")-1 + 1 + sizeof("</cdm:DESC>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:DESC", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_DESC) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_DESC(struct zx_ctx* c, struct zx_cdm_DESC_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:DESC");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:DESC>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:DESC", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_DESC) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_DESC(struct zx_ctx* c, struct zx_cdm_DESC_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_DESC(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_DESC(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_EMAIL
#define EL_STRUCT zx_cdm_EMAIL_s
#define EL_NS     cdm
#define EL_TAG    EMAIL

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_EMAIL) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_EMAIL(struct zx_ctx* c, struct zx_cdm_EMAIL_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:EMAIL")-1 + 1 + sizeof("</cdm:EMAIL>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->HOME;
    se && se->g.tok == zx_cdm_HOME_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:HOME")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->WORK;
    se && se->g.tok == zx_cdm_WORK_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:WORK")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->INTERNET;
    se && se->g.tok == zx_cdm_INTERNET_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:INTERNET")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PREF;
    se && se->g.tok == zx_cdm_PREF_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->X400;
    se && se->g.tok == zx_cdm_X400_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:X400")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->USERID->gg;
       se && se->g.tok == zx_cdm_USERID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_USERID(c, (struct zx_cdm_USERID_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:EMAIL", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_EMAIL) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_EMAIL(struct zx_ctx* c, struct zx_cdm_EMAIL_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:EMAIL");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->HOME;
       se && se->g.tok == zx_cdm_HOME_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:HOME", sizeof("cdm:HOME")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->WORK;
       se && se->g.tok == zx_cdm_WORK_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:WORK", sizeof("cdm:WORK")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->INTERNET;
       se && se->g.tok == zx_cdm_INTERNET_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:INTERNET", sizeof("cdm:INTERNET")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PREF;
       se && se->g.tok == zx_cdm_PREF_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PREF", sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->X400;
       se && se->g.tok == zx_cdm_X400_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:X400", sizeof("cdm:X400")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->USERID->gg;
       se && se->g.tok == zx_cdm_USERID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_USERID(c, (struct zx_cdm_USERID_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:EMAIL>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:EMAIL", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_EMAIL) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_EMAIL(struct zx_ctx* c, struct zx_cdm_EMAIL_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_EMAIL(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_EMAIL(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_EXTADR
#define EL_STRUCT zx_cdm_EXTADR_s
#define EL_NS     cdm
#define EL_TAG    EXTADR

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_EXTADR) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_EXTADR(struct zx_ctx* c, struct zx_cdm_EXTADR_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:EXTADR")-1 + 1 + sizeof("</cdm:EXTADR>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:EXTADR", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_EXTADR) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_EXTADR(struct zx_ctx* c, struct zx_cdm_EXTADR_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:EXTADR");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:EXTADR>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:EXTADR", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_EXTADR) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_EXTADR(struct zx_ctx* c, struct zx_cdm_EXTADR_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_EXTADR(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_EXTADR(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_EXTVAL
#define EL_STRUCT zx_cdm_EXTVAL_s
#define EL_NS     cdm
#define EL_TAG    EXTVAL

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_EXTVAL) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_EXTVAL(struct zx_ctx* c, struct zx_cdm_EXTVAL_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:EXTVAL")-1 + 1 + sizeof("</cdm:EXTVAL>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:EXTVAL", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_EXTVAL) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_EXTVAL(struct zx_ctx* c, struct zx_cdm_EXTVAL_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:EXTVAL");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:EXTVAL>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:EXTVAL", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_EXTVAL) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_EXTVAL(struct zx_ctx* c, struct zx_cdm_EXTVAL_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_EXTVAL(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_EXTVAL(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_FAMILY
#define EL_STRUCT zx_cdm_FAMILY_s
#define EL_NS     cdm
#define EL_TAG    FAMILY

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_FAMILY) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_FAMILY(struct zx_ctx* c, struct zx_cdm_FAMILY_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:FAMILY")-1 + 1 + sizeof("</cdm:FAMILY>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:FAMILY", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_FAMILY) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_FAMILY(struct zx_ctx* c, struct zx_cdm_FAMILY_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:FAMILY");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:FAMILY>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:FAMILY", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_FAMILY) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_FAMILY(struct zx_ctx* c, struct zx_cdm_FAMILY_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_FAMILY(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_FAMILY(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_FBURL
#define EL_STRUCT zx_cdm_FBURL_s
#define EL_NS     cdm
#define EL_TAG    FBURL

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_FBURL) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_FBURL(struct zx_ctx* c, struct zx_cdm_FBURL_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:FBURL")-1 + 1 + sizeof("</cdm:FBURL>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->PREF;
    se && se->g.tok == zx_cdm_PREF_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->URI->gg;
       se && se->g.tok == zx_cdm_URI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_URI(c, (struct zx_cdm_URI_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:FBURL", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_FBURL) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_FBURL(struct zx_ctx* c, struct zx_cdm_FBURL_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:FBURL");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->PREF;
       se && se->g.tok == zx_cdm_PREF_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PREF", sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->URI->gg;
       se && se->g.tok == zx_cdm_URI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_URI(c, (struct zx_cdm_URI_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:FBURL>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:FBURL", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_FBURL) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_FBURL(struct zx_ctx* c, struct zx_cdm_FBURL_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_FBURL(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_FBURL(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_FN
#define EL_STRUCT zx_cdm_FN_s
#define EL_NS     cdm
#define EL_TAG    FN

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_FN) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_FN(struct zx_ctx* c, struct zx_cdm_FN_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:FN")-1 + 1 + sizeof("</cdm:FN>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:FN", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_FN) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_FN(struct zx_ctx* c, struct zx_cdm_FN_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:FN");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:FN>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:FN", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_FN) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_FN(struct zx_ctx* c, struct zx_cdm_FN_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_FN(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_FN(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_GEO
#define EL_STRUCT zx_cdm_GEO_s
#define EL_NS     cdm
#define EL_TAG    GEO

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_GEO) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_GEO(struct zx_ctx* c, struct zx_cdm_GEO_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:GEO")-1 + 1 + sizeof("</cdm:GEO>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->LAT->gg;
       se && se->g.tok == zx_cdm_LAT_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_LAT(c, (struct zx_cdm_LAT_s*)se);
  for (se = &x->LON->gg;
       se && se->g.tok == zx_cdm_LON_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_LON(c, (struct zx_cdm_LON_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:GEO", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_GEO) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_GEO(struct zx_ctx* c, struct zx_cdm_GEO_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:GEO");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->LAT->gg;
       se && se->g.tok == zx_cdm_LAT_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_LAT(c, (struct zx_cdm_LAT_s*)se, p);
  for (se = &x->LON->gg;
       se && se->g.tok == zx_cdm_LON_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_LON(c, (struct zx_cdm_LON_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:GEO>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:GEO", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_GEO) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_GEO(struct zx_ctx* c, struct zx_cdm_GEO_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_GEO(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_GEO(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_GIVEN
#define EL_STRUCT zx_cdm_GIVEN_s
#define EL_NS     cdm
#define EL_TAG    GIVEN

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_GIVEN) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_GIVEN(struct zx_ctx* c, struct zx_cdm_GIVEN_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:GIVEN")-1 + 1 + sizeof("</cdm:GIVEN>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:GIVEN", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_GIVEN) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_GIVEN(struct zx_ctx* c, struct zx_cdm_GIVEN_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:GIVEN");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:GIVEN>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:GIVEN", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_GIVEN) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_GIVEN(struct zx_ctx* c, struct zx_cdm_GIVEN_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_GIVEN(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_GIVEN(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_JABBERID
#define EL_STRUCT zx_cdm_JABBERID_s
#define EL_NS     cdm
#define EL_TAG    JABBERID

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_JABBERID) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_JABBERID(struct zx_ctx* c, struct zx_cdm_JABBERID_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:JABBERID")-1 + 1 + sizeof("</cdm:JABBERID>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:JABBERID", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_JABBERID) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_JABBERID(struct zx_ctx* c, struct zx_cdm_JABBERID_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:JABBERID");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:JABBERID>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:JABBERID", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_JABBERID) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_JABBERID(struct zx_ctx* c, struct zx_cdm_JABBERID_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_JABBERID(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_JABBERID(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_KEY
#define EL_STRUCT zx_cdm_KEY_s
#define EL_NS     cdm
#define EL_TAG    KEY

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_KEY) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_KEY(struct zx_ctx* c, struct zx_cdm_KEY_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:KEY")-1 + 1 + sizeof("</cdm:KEY>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->TYPE->gg;
       se && se->g.tok == zx_cdm_TYPE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_TYPE(c, (struct zx_cdm_TYPE_s*)se);
  for (se = &x->CRED->gg;
       se && se->g.tok == zx_cdm_CRED_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_CRED(c, (struct zx_cdm_CRED_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:KEY", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_KEY) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_KEY(struct zx_ctx* c, struct zx_cdm_KEY_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:KEY");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->TYPE->gg;
       se && se->g.tok == zx_cdm_TYPE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_TYPE(c, (struct zx_cdm_TYPE_s*)se, p);
  for (se = &x->CRED->gg;
       se && se->g.tok == zx_cdm_CRED_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_CRED(c, (struct zx_cdm_CRED_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:KEY>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:KEY", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_KEY) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_KEY(struct zx_ctx* c, struct zx_cdm_KEY_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_KEY(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_KEY(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_KEYWORD
#define EL_STRUCT zx_cdm_KEYWORD_s
#define EL_NS     cdm
#define EL_TAG    KEYWORD

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_KEYWORD) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_KEYWORD(struct zx_ctx* c, struct zx_cdm_KEYWORD_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:KEYWORD")-1 + 1 + sizeof("</cdm:KEYWORD>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:KEYWORD", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_KEYWORD) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_KEYWORD(struct zx_ctx* c, struct zx_cdm_KEYWORD_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:KEYWORD");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:KEYWORD>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:KEYWORD", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_KEYWORD) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_KEYWORD(struct zx_ctx* c, struct zx_cdm_KEYWORD_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_KEYWORD(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_KEYWORD(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_LABEL
#define EL_STRUCT zx_cdm_LABEL_s
#define EL_NS     cdm
#define EL_TAG    LABEL

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_LABEL) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_LABEL(struct zx_ctx* c, struct zx_cdm_LABEL_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:LABEL")-1 + 1 + sizeof("</cdm:LABEL>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->HOME;
    se && se->g.tok == zx_cdm_HOME_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:HOME")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->WORK;
    se && se->g.tok == zx_cdm_WORK_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:WORK")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->POSTAL;
    se && se->g.tok == zx_cdm_POSTAL_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:POSTAL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PARCEL;
    se && se->g.tok == zx_cdm_PARCEL_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PARCEL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->DOM;
    se && se->g.tok == zx_cdm_DOM_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:DOM")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->INTL;
    se && se->g.tok == zx_cdm_INTL_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:INTL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PREF;
    se && se->g.tok == zx_cdm_PREF_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->LINE->gg;
       se && se->g.tok == zx_cdm_LINE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_LINE(c, (struct zx_cdm_LINE_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:LABEL", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_LABEL) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_LABEL(struct zx_ctx* c, struct zx_cdm_LABEL_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:LABEL");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->HOME;
       se && se->g.tok == zx_cdm_HOME_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:HOME", sizeof("cdm:HOME")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->WORK;
       se && se->g.tok == zx_cdm_WORK_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:WORK", sizeof("cdm:WORK")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->POSTAL;
       se && se->g.tok == zx_cdm_POSTAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:POSTAL", sizeof("cdm:POSTAL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PARCEL;
       se && se->g.tok == zx_cdm_PARCEL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PARCEL", sizeof("cdm:PARCEL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->DOM;
       se && se->g.tok == zx_cdm_DOM_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:DOM", sizeof("cdm:DOM")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->INTL;
       se && se->g.tok == zx_cdm_INTL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:INTL", sizeof("cdm:INTL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PREF;
       se && se->g.tok == zx_cdm_PREF_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PREF", sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->LINE->gg;
       se && se->g.tok == zx_cdm_LINE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_LINE(c, (struct zx_cdm_LINE_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:LABEL>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:LABEL", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_LABEL) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_LABEL(struct zx_ctx* c, struct zx_cdm_LABEL_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_LABEL(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_LABEL(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_LAT
#define EL_STRUCT zx_cdm_LAT_s
#define EL_NS     cdm
#define EL_TAG    LAT

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_LAT) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_LAT(struct zx_ctx* c, struct zx_cdm_LAT_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:LAT")-1 + 1 + sizeof("</cdm:LAT>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:LAT", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_LAT) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_LAT(struct zx_ctx* c, struct zx_cdm_LAT_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:LAT");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:LAT>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:LAT", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_LAT) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_LAT(struct zx_ctx* c, struct zx_cdm_LAT_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_LAT(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_LAT(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_LINE
#define EL_STRUCT zx_cdm_LINE_s
#define EL_NS     cdm
#define EL_TAG    LINE

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_LINE) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_LINE(struct zx_ctx* c, struct zx_cdm_LINE_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:LINE")-1 + 1 + sizeof("</cdm:LINE>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:LINE", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_LINE) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_LINE(struct zx_ctx* c, struct zx_cdm_LINE_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:LINE");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:LINE>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:LINE", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_LINE) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_LINE(struct zx_ctx* c, struct zx_cdm_LINE_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_LINE(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_LINE(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_LISTMEMBER
#define EL_STRUCT zx_cdm_LISTMEMBER_s
#define EL_NS     cdm
#define EL_TAG    LISTMEMBER

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_LISTMEMBER) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_LISTMEMBER(struct zx_ctx* c, struct zx_cdm_LISTMEMBER_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:LISTMEMBER")-1 + 1 + sizeof("</cdm:LISTMEMBER>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:LISTMEMBER", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_LISTMEMBER) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_LISTMEMBER(struct zx_ctx* c, struct zx_cdm_LISTMEMBER_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:LISTMEMBER");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:LISTMEMBER>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:LISTMEMBER", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_LISTMEMBER) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_LISTMEMBER(struct zx_ctx* c, struct zx_cdm_LISTMEMBER_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_LISTMEMBER(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_LISTMEMBER(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_LOCALITY
#define EL_STRUCT zx_cdm_LOCALITY_s
#define EL_NS     cdm
#define EL_TAG    LOCALITY

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_LOCALITY) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_LOCALITY(struct zx_ctx* c, struct zx_cdm_LOCALITY_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:LOCALITY")-1 + 1 + sizeof("</cdm:LOCALITY>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:LOCALITY", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_LOCALITY) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_LOCALITY(struct zx_ctx* c, struct zx_cdm_LOCALITY_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:LOCALITY");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:LOCALITY>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:LOCALITY", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_LOCALITY) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_LOCALITY(struct zx_ctx* c, struct zx_cdm_LOCALITY_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_LOCALITY(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_LOCALITY(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_LOGO
#define EL_STRUCT zx_cdm_LOGO_s
#define EL_NS     cdm
#define EL_TAG    LOGO

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_LOGO) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_LOGO(struct zx_ctx* c, struct zx_cdm_LOGO_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:LOGO")-1 + 1 + sizeof("</cdm:LOGO>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->TYPE->gg;
       se && se->g.tok == zx_cdm_TYPE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_TYPE(c, (struct zx_cdm_TYPE_s*)se);
  for (se = &x->BINVAL->gg;
       se && se->g.tok == zx_cdm_BINVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_BINVAL(c, (struct zx_cdm_BINVAL_s*)se);
  for (se = &x->EXTVAL->gg;
       se && se->g.tok == zx_cdm_EXTVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_EXTVAL(c, (struct zx_cdm_EXTVAL_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:LOGO", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_LOGO) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_LOGO(struct zx_ctx* c, struct zx_cdm_LOGO_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:LOGO");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->TYPE->gg;
       se && se->g.tok == zx_cdm_TYPE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_TYPE(c, (struct zx_cdm_TYPE_s*)se, p);
  for (se = &x->BINVAL->gg;
       se && se->g.tok == zx_cdm_BINVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_BINVAL(c, (struct zx_cdm_BINVAL_s*)se, p);
  for (se = &x->EXTVAL->gg;
       se && se->g.tok == zx_cdm_EXTVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_EXTVAL(c, (struct zx_cdm_EXTVAL_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:LOGO>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:LOGO", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_LOGO) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_LOGO(struct zx_ctx* c, struct zx_cdm_LOGO_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_LOGO(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_LOGO(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_LON
#define EL_STRUCT zx_cdm_LON_s
#define EL_NS     cdm
#define EL_TAG    LON

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_LON) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_LON(struct zx_ctx* c, struct zx_cdm_LON_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:LON")-1 + 1 + sizeof("</cdm:LON>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:LON", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_LON) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_LON(struct zx_ctx* c, struct zx_cdm_LON_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:LON");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:LON>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:LON", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_LON) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_LON(struct zx_ctx* c, struct zx_cdm_LON_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_LON(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_LON(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_MAILER
#define EL_STRUCT zx_cdm_MAILER_s
#define EL_NS     cdm
#define EL_TAG    MAILER

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_MAILER) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_MAILER(struct zx_ctx* c, struct zx_cdm_MAILER_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:MAILER")-1 + 1 + sizeof("</cdm:MAILER>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:MAILER", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_MAILER) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_MAILER(struct zx_ctx* c, struct zx_cdm_MAILER_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:MAILER");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:MAILER>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:MAILER", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_MAILER) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_MAILER(struct zx_ctx* c, struct zx_cdm_MAILER_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_MAILER(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_MAILER(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_MIDDLE
#define EL_STRUCT zx_cdm_MIDDLE_s
#define EL_NS     cdm
#define EL_TAG    MIDDLE

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_MIDDLE) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_MIDDLE(struct zx_ctx* c, struct zx_cdm_MIDDLE_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:MIDDLE")-1 + 1 + sizeof("</cdm:MIDDLE>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:MIDDLE", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_MIDDLE) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_MIDDLE(struct zx_ctx* c, struct zx_cdm_MIDDLE_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:MIDDLE");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:MIDDLE>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:MIDDLE", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_MIDDLE) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_MIDDLE(struct zx_ctx* c, struct zx_cdm_MIDDLE_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_MIDDLE(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_MIDDLE(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_N
#define EL_STRUCT zx_cdm_N_s
#define EL_NS     cdm
#define EL_TAG    N

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_N) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_N(struct zx_ctx* c, struct zx_cdm_N_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:N")-1 + 1 + sizeof("</cdm:N>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->FAMILY->gg;
       se && se->g.tok == zx_cdm_FAMILY_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_FAMILY(c, (struct zx_cdm_FAMILY_s*)se);
  for (se = &x->GIVEN->gg;
       se && se->g.tok == zx_cdm_GIVEN_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_GIVEN(c, (struct zx_cdm_GIVEN_s*)se);
  for (se = &x->MIDDLE->gg;
       se && se->g.tok == zx_cdm_MIDDLE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_MIDDLE(c, (struct zx_cdm_MIDDLE_s*)se);
  for (se = &x->PREFIX->gg;
       se && se->g.tok == zx_cdm_PREFIX_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_PREFIX(c, (struct zx_cdm_PREFIX_s*)se);
  for (se = &x->SUFFIX->gg;
       se && se->g.tok == zx_cdm_SUFFIX_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_SUFFIX(c, (struct zx_cdm_SUFFIX_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:N", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_N) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_N(struct zx_ctx* c, struct zx_cdm_N_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:N");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->FAMILY->gg;
       se && se->g.tok == zx_cdm_FAMILY_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_FAMILY(c, (struct zx_cdm_FAMILY_s*)se, p);
  for (se = &x->GIVEN->gg;
       se && se->g.tok == zx_cdm_GIVEN_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_GIVEN(c, (struct zx_cdm_GIVEN_s*)se, p);
  for (se = &x->MIDDLE->gg;
       se && se->g.tok == zx_cdm_MIDDLE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_MIDDLE(c, (struct zx_cdm_MIDDLE_s*)se, p);
  for (se = &x->PREFIX->gg;
       se && se->g.tok == zx_cdm_PREFIX_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_PREFIX(c, (struct zx_cdm_PREFIX_s*)se, p);
  for (se = &x->SUFFIX->gg;
       se && se->g.tok == zx_cdm_SUFFIX_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_SUFFIX(c, (struct zx_cdm_SUFFIX_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:N>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:N", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_N) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_N(struct zx_ctx* c, struct zx_cdm_N_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_N(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_N(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_NICKNAME
#define EL_STRUCT zx_cdm_NICKNAME_s
#define EL_NS     cdm
#define EL_TAG    NICKNAME

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_NICKNAME) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_NICKNAME(struct zx_ctx* c, struct zx_cdm_NICKNAME_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:NICKNAME")-1 + 1 + sizeof("</cdm:NICKNAME>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:NICKNAME", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_NICKNAME) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_NICKNAME(struct zx_ctx* c, struct zx_cdm_NICKNAME_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:NICKNAME");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:NICKNAME>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:NICKNAME", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_NICKNAME) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_NICKNAME(struct zx_ctx* c, struct zx_cdm_NICKNAME_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_NICKNAME(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_NICKNAME(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_NOTE
#define EL_STRUCT zx_cdm_NOTE_s
#define EL_NS     cdm
#define EL_TAG    NOTE

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_NOTE) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_NOTE(struct zx_ctx* c, struct zx_cdm_NOTE_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:NOTE")-1 + 1 + sizeof("</cdm:NOTE>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:NOTE", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_NOTE) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_NOTE(struct zx_ctx* c, struct zx_cdm_NOTE_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:NOTE");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:NOTE>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:NOTE", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_NOTE) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_NOTE(struct zx_ctx* c, struct zx_cdm_NOTE_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_NOTE(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_NOTE(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_NUMBER
#define EL_STRUCT zx_cdm_NUMBER_s
#define EL_NS     cdm
#define EL_TAG    NUMBER

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_NUMBER) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_NUMBER(struct zx_ctx* c, struct zx_cdm_NUMBER_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:NUMBER")-1 + 1 + sizeof("</cdm:NUMBER>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:NUMBER", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_NUMBER) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_NUMBER(struct zx_ctx* c, struct zx_cdm_NUMBER_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:NUMBER");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:NUMBER>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:NUMBER", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_NUMBER) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_NUMBER(struct zx_ctx* c, struct zx_cdm_NUMBER_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_NUMBER(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_NUMBER(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_ORG
#define EL_STRUCT zx_cdm_ORG_s
#define EL_NS     cdm
#define EL_TAG    ORG

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_ORG) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_ORG(struct zx_ctx* c, struct zx_cdm_ORG_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:ORG")-1 + 1 + sizeof("</cdm:ORG>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->ORGNAME->gg;
       se && se->g.tok == zx_cdm_ORGNAME_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_ORGNAME(c, (struct zx_cdm_ORGNAME_s*)se);
  for (se = &x->ORGUNIT->gg;
       se && se->g.tok == zx_cdm_ORGUNIT_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_ORGUNIT(c, (struct zx_cdm_ORGUNIT_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:ORG", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_ORG) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_ORG(struct zx_ctx* c, struct zx_cdm_ORG_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:ORG");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->ORGNAME->gg;
       se && se->g.tok == zx_cdm_ORGNAME_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_ORGNAME(c, (struct zx_cdm_ORGNAME_s*)se, p);
  for (se = &x->ORGUNIT->gg;
       se && se->g.tok == zx_cdm_ORGUNIT_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_ORGUNIT(c, (struct zx_cdm_ORGUNIT_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:ORG>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:ORG", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_ORG) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_ORG(struct zx_ctx* c, struct zx_cdm_ORG_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_ORG(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_ORG(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_ORGNAME
#define EL_STRUCT zx_cdm_ORGNAME_s
#define EL_NS     cdm
#define EL_TAG    ORGNAME

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_ORGNAME) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_ORGNAME(struct zx_ctx* c, struct zx_cdm_ORGNAME_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:ORGNAME")-1 + 1 + sizeof("</cdm:ORGNAME>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:ORGNAME", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_ORGNAME) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_ORGNAME(struct zx_ctx* c, struct zx_cdm_ORGNAME_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:ORGNAME");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:ORGNAME>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:ORGNAME", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_ORGNAME) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_ORGNAME(struct zx_ctx* c, struct zx_cdm_ORGNAME_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_ORGNAME(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_ORGNAME(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_ORGUNIT
#define EL_STRUCT zx_cdm_ORGUNIT_s
#define EL_NS     cdm
#define EL_TAG    ORGUNIT

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_ORGUNIT) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_ORGUNIT(struct zx_ctx* c, struct zx_cdm_ORGUNIT_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:ORGUNIT")-1 + 1 + sizeof("</cdm:ORGUNIT>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:ORGUNIT", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_ORGUNIT) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_ORGUNIT(struct zx_ctx* c, struct zx_cdm_ORGUNIT_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:ORGUNIT");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:ORGUNIT>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:ORGUNIT", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_ORGUNIT) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_ORGUNIT(struct zx_ctx* c, struct zx_cdm_ORGUNIT_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_ORGUNIT(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_ORGUNIT(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_PCODE
#define EL_STRUCT zx_cdm_PCODE_s
#define EL_NS     cdm
#define EL_TAG    PCODE

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_PCODE) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_PCODE(struct zx_ctx* c, struct zx_cdm_PCODE_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:PCODE")-1 + 1 + sizeof("</cdm:PCODE>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:PCODE", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_PCODE) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_PCODE(struct zx_ctx* c, struct zx_cdm_PCODE_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:PCODE");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:PCODE>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:PCODE", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_PCODE) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_PCODE(struct zx_ctx* c, struct zx_cdm_PCODE_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_PCODE(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_PCODE(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_PHONETIC
#define EL_STRUCT zx_cdm_PHONETIC_s
#define EL_NS     cdm
#define EL_TAG    PHONETIC

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_PHONETIC) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_PHONETIC(struct zx_ctx* c, struct zx_cdm_PHONETIC_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:PHONETIC")-1 + 1 + sizeof("</cdm:PHONETIC>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:PHONETIC", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_PHONETIC) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_PHONETIC(struct zx_ctx* c, struct zx_cdm_PHONETIC_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:PHONETIC");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:PHONETIC>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:PHONETIC", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_PHONETIC) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_PHONETIC(struct zx_ctx* c, struct zx_cdm_PHONETIC_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_PHONETIC(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_PHONETIC(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_PHOTO
#define EL_STRUCT zx_cdm_PHOTO_s
#define EL_NS     cdm
#define EL_TAG    PHOTO

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_PHOTO) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_PHOTO(struct zx_ctx* c, struct zx_cdm_PHOTO_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:PHOTO")-1 + 1 + sizeof("</cdm:PHOTO>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->TYPE->gg;
       se && se->g.tok == zx_cdm_TYPE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_TYPE(c, (struct zx_cdm_TYPE_s*)se);
  for (se = &x->BINVAL->gg;
       se && se->g.tok == zx_cdm_BINVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_BINVAL(c, (struct zx_cdm_BINVAL_s*)se);
  for (se = &x->EXTVAL->gg;
       se && se->g.tok == zx_cdm_EXTVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_EXTVAL(c, (struct zx_cdm_EXTVAL_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:PHOTO", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_PHOTO) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_PHOTO(struct zx_ctx* c, struct zx_cdm_PHOTO_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:PHOTO");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->TYPE->gg;
       se && se->g.tok == zx_cdm_TYPE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_TYPE(c, (struct zx_cdm_TYPE_s*)se, p);
  for (se = &x->BINVAL->gg;
       se && se->g.tok == zx_cdm_BINVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_BINVAL(c, (struct zx_cdm_BINVAL_s*)se, p);
  for (se = &x->EXTVAL->gg;
       se && se->g.tok == zx_cdm_EXTVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_EXTVAL(c, (struct zx_cdm_EXTVAL_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:PHOTO>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:PHOTO", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_PHOTO) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_PHOTO(struct zx_ctx* c, struct zx_cdm_PHOTO_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_PHOTO(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_PHOTO(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_PHYSICALACCESS
#define EL_STRUCT zx_cdm_PHYSICALACCESS_s
#define EL_NS     cdm
#define EL_TAG    PHYSICALACCESS

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_PHYSICALACCESS) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_PHYSICALACCESS(struct zx_ctx* c, struct zx_cdm_PHYSICALACCESS_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:PHYSICALACCESS")-1 + 1 + sizeof("</cdm:PHYSICALACCESS>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:PHYSICALACCESS", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_PHYSICALACCESS) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_PHYSICALACCESS(struct zx_ctx* c, struct zx_cdm_PHYSICALACCESS_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:PHYSICALACCESS");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:PHYSICALACCESS>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:PHYSICALACCESS", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_PHYSICALACCESS) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_PHYSICALACCESS(struct zx_ctx* c, struct zx_cdm_PHYSICALACCESS_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_PHYSICALACCESS(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_PHYSICALACCESS(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_POBOX
#define EL_STRUCT zx_cdm_POBOX_s
#define EL_NS     cdm
#define EL_TAG    POBOX

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_POBOX) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_POBOX(struct zx_ctx* c, struct zx_cdm_POBOX_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:POBOX")-1 + 1 + sizeof("</cdm:POBOX>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:POBOX", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_POBOX) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_POBOX(struct zx_ctx* c, struct zx_cdm_POBOX_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:POBOX");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:POBOX>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:POBOX", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_POBOX) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_POBOX(struct zx_ctx* c, struct zx_cdm_POBOX_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_POBOX(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_POBOX(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_PREFIX
#define EL_STRUCT zx_cdm_PREFIX_s
#define EL_NS     cdm
#define EL_TAG    PREFIX

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_PREFIX) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_PREFIX(struct zx_ctx* c, struct zx_cdm_PREFIX_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:PREFIX")-1 + 1 + sizeof("</cdm:PREFIX>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:PREFIX", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_PREFIX) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_PREFIX(struct zx_ctx* c, struct zx_cdm_PREFIX_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:PREFIX");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:PREFIX>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:PREFIX", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_PREFIX) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_PREFIX(struct zx_ctx* c, struct zx_cdm_PREFIX_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_PREFIX(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_PREFIX(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_PRODID
#define EL_STRUCT zx_cdm_PRODID_s
#define EL_NS     cdm
#define EL_TAG    PRODID

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_PRODID) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_PRODID(struct zx_ctx* c, struct zx_cdm_PRODID_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:PRODID")-1 + 1 + sizeof("</cdm:PRODID>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:PRODID", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_PRODID) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_PRODID(struct zx_ctx* c, struct zx_cdm_PRODID_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:PRODID");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:PRODID>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:PRODID", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_PRODID) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_PRODID(struct zx_ctx* c, struct zx_cdm_PRODID_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_PRODID(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_PRODID(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_REGION
#define EL_STRUCT zx_cdm_REGION_s
#define EL_NS     cdm
#define EL_TAG    REGION

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_REGION) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_REGION(struct zx_ctx* c, struct zx_cdm_REGION_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:REGION")-1 + 1 + sizeof("</cdm:REGION>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:REGION", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_REGION) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_REGION(struct zx_ctx* c, struct zx_cdm_REGION_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:REGION");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:REGION>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:REGION", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_REGION) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_REGION(struct zx_ctx* c, struct zx_cdm_REGION_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_REGION(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_REGION(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_REV
#define EL_STRUCT zx_cdm_REV_s
#define EL_NS     cdm
#define EL_TAG    REV

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_REV) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_REV(struct zx_ctx* c, struct zx_cdm_REV_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:REV")-1 + 1 + sizeof("</cdm:REV>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:REV", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_REV) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_REV(struct zx_ctx* c, struct zx_cdm_REV_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:REV");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:REV>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:REV", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_REV) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_REV(struct zx_ctx* c, struct zx_cdm_REV_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_REV(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_REV(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_ROLE
#define EL_STRUCT zx_cdm_ROLE_s
#define EL_NS     cdm
#define EL_TAG    ROLE

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_ROLE) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_ROLE(struct zx_ctx* c, struct zx_cdm_ROLE_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:ROLE")-1 + 1 + sizeof("</cdm:ROLE>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:ROLE", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_ROLE) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_ROLE(struct zx_ctx* c, struct zx_cdm_ROLE_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:ROLE");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:ROLE>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:ROLE", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_ROLE) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_ROLE(struct zx_ctx* c, struct zx_cdm_ROLE_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_ROLE(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_ROLE(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_SORT_STRING
#define EL_STRUCT zx_cdm_SORT_STRING_s
#define EL_NS     cdm
#define EL_TAG    SORT_STRING

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_SORT_STRING) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_SORT_STRING(struct zx_ctx* c, struct zx_cdm_SORT_STRING_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:SORT_STRING")-1 + 1 + sizeof("</cdm:SORT_STRING>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:SORT_STRING", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_SORT_STRING) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_SORT_STRING(struct zx_ctx* c, struct zx_cdm_SORT_STRING_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:SORT_STRING");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:SORT_STRING>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:SORT_STRING", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_SORT_STRING) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_SORT_STRING(struct zx_ctx* c, struct zx_cdm_SORT_STRING_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_SORT_STRING(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_SORT_STRING(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_SOUND
#define EL_STRUCT zx_cdm_SOUND_s
#define EL_NS     cdm
#define EL_TAG    SOUND

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_SOUND) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_SOUND(struct zx_ctx* c, struct zx_cdm_SOUND_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:SOUND")-1 + 1 + sizeof("</cdm:SOUND>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->PHONETIC->gg;
       se && se->g.tok == zx_cdm_PHONETIC_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_PHONETIC(c, (struct zx_cdm_PHONETIC_s*)se);
  for (se = &x->BINVAL->gg;
       se && se->g.tok == zx_cdm_BINVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_BINVAL(c, (struct zx_cdm_BINVAL_s*)se);
  for (se = &x->EXTVAL->gg;
       se && se->g.tok == zx_cdm_EXTVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_EXTVAL(c, (struct zx_cdm_EXTVAL_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:SOUND", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_SOUND) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_SOUND(struct zx_ctx* c, struct zx_cdm_SOUND_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:SOUND");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->PHONETIC->gg;
       se && se->g.tok == zx_cdm_PHONETIC_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_PHONETIC(c, (struct zx_cdm_PHONETIC_s*)se, p);
  for (se = &x->BINVAL->gg;
       se && se->g.tok == zx_cdm_BINVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_BINVAL(c, (struct zx_cdm_BINVAL_s*)se, p);
  for (se = &x->EXTVAL->gg;
       se && se->g.tok == zx_cdm_EXTVAL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_EXTVAL(c, (struct zx_cdm_EXTVAL_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:SOUND>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:SOUND", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_SOUND) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_SOUND(struct zx_ctx* c, struct zx_cdm_SOUND_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_SOUND(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_SOUND(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_STREET
#define EL_STRUCT zx_cdm_STREET_s
#define EL_NS     cdm
#define EL_TAG    STREET

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_STREET) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_STREET(struct zx_ctx* c, struct zx_cdm_STREET_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:STREET")-1 + 1 + sizeof("</cdm:STREET>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:STREET", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_STREET) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_STREET(struct zx_ctx* c, struct zx_cdm_STREET_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:STREET");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:STREET>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:STREET", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_STREET) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_STREET(struct zx_ctx* c, struct zx_cdm_STREET_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_STREET(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_STREET(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_SUFFIX
#define EL_STRUCT zx_cdm_SUFFIX_s
#define EL_NS     cdm
#define EL_TAG    SUFFIX

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_SUFFIX) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_SUFFIX(struct zx_ctx* c, struct zx_cdm_SUFFIX_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:SUFFIX")-1 + 1 + sizeof("</cdm:SUFFIX>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:SUFFIX", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_SUFFIX) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_SUFFIX(struct zx_ctx* c, struct zx_cdm_SUFFIX_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:SUFFIX");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:SUFFIX>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:SUFFIX", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_SUFFIX) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_SUFFIX(struct zx_ctx* c, struct zx_cdm_SUFFIX_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_SUFFIX(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_SUFFIX(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_TEL
#define EL_STRUCT zx_cdm_TEL_s
#define EL_NS     cdm
#define EL_TAG    TEL

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_TEL) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_TEL(struct zx_ctx* c, struct zx_cdm_TEL_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:TEL")-1 + 1 + sizeof("</cdm:TEL>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->HOME;
    se && se->g.tok == zx_cdm_HOME_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:HOME")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->WORK;
    se && se->g.tok == zx_cdm_WORK_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:WORK")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->VOICE;
    se && se->g.tok == zx_cdm_VOICE_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:VOICE")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->FAX;
    se && se->g.tok == zx_cdm_FAX_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:FAX")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PAGER;
    se && se->g.tok == zx_cdm_PAGER_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PAGER")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->MSG;
    se && se->g.tok == zx_cdm_MSG_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:MSG")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->CELL;
    se && se->g.tok == zx_cdm_CELL_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:CELL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->VIDEO;
    se && se->g.tok == zx_cdm_VIDEO_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:VIDEO")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->BBS;
    se && se->g.tok == zx_cdm_BBS_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:BBS")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->MODEM;
    se && se->g.tok == zx_cdm_MODEM_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:MODEM")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->ISDN;
    se && se->g.tok == zx_cdm_ISDN_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:ISDN")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PCS;
    se && se->g.tok == zx_cdm_PCS_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PCS")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PREF;
    se && se->g.tok == zx_cdm_PREF_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->NUMBER->gg;
       se && se->g.tok == zx_cdm_NUMBER_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_NUMBER(c, (struct zx_cdm_NUMBER_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:TEL", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_TEL) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_TEL(struct zx_ctx* c, struct zx_cdm_TEL_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:TEL");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->HOME;
       se && se->g.tok == zx_cdm_HOME_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:HOME", sizeof("cdm:HOME")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->WORK;
       se && se->g.tok == zx_cdm_WORK_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:WORK", sizeof("cdm:WORK")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->VOICE;
       se && se->g.tok == zx_cdm_VOICE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:VOICE", sizeof("cdm:VOICE")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->FAX;
       se && se->g.tok == zx_cdm_FAX_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:FAX", sizeof("cdm:FAX")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PAGER;
       se && se->g.tok == zx_cdm_PAGER_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PAGER", sizeof("cdm:PAGER")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->MSG;
       se && se->g.tok == zx_cdm_MSG_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:MSG", sizeof("cdm:MSG")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->CELL;
       se && se->g.tok == zx_cdm_CELL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:CELL", sizeof("cdm:CELL")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->VIDEO;
       se && se->g.tok == zx_cdm_VIDEO_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:VIDEO", sizeof("cdm:VIDEO")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->BBS;
       se && se->g.tok == zx_cdm_BBS_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:BBS", sizeof("cdm:BBS")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->MODEM;
       se && se->g.tok == zx_cdm_MODEM_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:MODEM", sizeof("cdm:MODEM")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->ISDN;
       se && se->g.tok == zx_cdm_ISDN_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:ISDN", sizeof("cdm:ISDN")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PCS;
       se && se->g.tok == zx_cdm_PCS_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PCS", sizeof("cdm:PCS")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->PREF;
       se && se->g.tok == zx_cdm_PREF_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:PREF", sizeof("cdm:PREF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->NUMBER->gg;
       se && se->g.tok == zx_cdm_NUMBER_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_NUMBER(c, (struct zx_cdm_NUMBER_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:TEL>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:TEL", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_TEL) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_TEL(struct zx_ctx* c, struct zx_cdm_TEL_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_TEL(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_TEL(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_TITLE
#define EL_STRUCT zx_cdm_TITLE_s
#define EL_NS     cdm
#define EL_TAG    TITLE

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_TITLE) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_TITLE(struct zx_ctx* c, struct zx_cdm_TITLE_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:TITLE")-1 + 1 + sizeof("</cdm:TITLE>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->group)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->group, sizeof("cb:group")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:TITLE", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_TITLE) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_TITLE(struct zx_ctx* c, struct zx_cdm_TITLE_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:TITLE");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->group)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->group, " cb:group=\"", sizeof(" cb:group=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:TITLE>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:TITLE", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_TITLE) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_TITLE(struct zx_ctx* c, struct zx_cdm_TITLE_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_TITLE(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_TITLE(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_TYPE
#define EL_STRUCT zx_cdm_TYPE_s
#define EL_NS     cdm
#define EL_TAG    TYPE

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_TYPE) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_TYPE(struct zx_ctx* c, struct zx_cdm_TYPE_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:TYPE")-1 + 1 + sizeof("</cdm:TYPE>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:TYPE", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_TYPE) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_TYPE(struct zx_ctx* c, struct zx_cdm_TYPE_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:TYPE");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:TYPE>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:TYPE", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_TYPE) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_TYPE(struct zx_ctx* c, struct zx_cdm_TYPE_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_TYPE(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_TYPE(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_TZ
#define EL_STRUCT zx_cdm_TZ_s
#define EL_NS     cdm
#define EL_TAG    TZ

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_TZ) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_TZ(struct zx_ctx* c, struct zx_cdm_TZ_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:TZ")-1 + 1 + sizeof("</cdm:TZ>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:TZ", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_TZ) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_TZ(struct zx_ctx* c, struct zx_cdm_TZ_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:TZ");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:TZ>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:TZ", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_TZ) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_TZ(struct zx_ctx* c, struct zx_cdm_TZ_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_TZ(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_TZ(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_UID
#define EL_STRUCT zx_cdm_UID_s
#define EL_NS     cdm
#define EL_TAG    UID

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_UID) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_UID(struct zx_ctx* c, struct zx_cdm_UID_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:UID")-1 + 1 + sizeof("</cdm:UID>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:UID", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_UID) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_UID(struct zx_ctx* c, struct zx_cdm_UID_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:UID");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:UID>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:UID", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_UID) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_UID(struct zx_ctx* c, struct zx_cdm_UID_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_UID(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_UID(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_URI
#define EL_STRUCT zx_cdm_URI_s
#define EL_NS     cdm
#define EL_TAG    URI

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_URI) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_URI(struct zx_ctx* c, struct zx_cdm_URI_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:URI")-1 + 1 + sizeof("</cdm:URI>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:URI", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_URI) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_URI(struct zx_ctx* c, struct zx_cdm_URI_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:URI");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:URI>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:URI", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_URI) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_URI(struct zx_ctx* c, struct zx_cdm_URI_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_URI(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_URI(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_URL
#define EL_STRUCT zx_cdm_URL_s
#define EL_NS     cdm
#define EL_TAG    URL

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_URL) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_URL(struct zx_ctx* c, struct zx_cdm_URL_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:URL")-1 + 1 + sizeof("</cdm:URL>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:URL", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_URL) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_URL(struct zx_ctx* c, struct zx_cdm_URL_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:URL");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:URL>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:URL", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_URL) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_URL(struct zx_ctx* c, struct zx_cdm_URL_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_URL(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_URL(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_USERID
#define EL_STRUCT zx_cdm_USERID_s
#define EL_NS     cdm
#define EL_TAG    USERID

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_USERID) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_USERID(struct zx_ctx* c, struct zx_cdm_USERID_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:USERID")-1 + 1 + sizeof("</cdm:USERID>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:USERID", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_USERID) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_USERID(struct zx_ctx* c, struct zx_cdm_USERID_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:USERID");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:USERID>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:USERID", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_USERID) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_USERID(struct zx_ctx* c, struct zx_cdm_USERID_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_USERID(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_USERID(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_VERSION
#define EL_STRUCT zx_cdm_VERSION_s
#define EL_NS     cdm
#define EL_TAG    VERSION

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_VERSION) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_VERSION(struct zx_ctx* c, struct zx_cdm_VERSION_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:VERSION")-1 + 1 + sizeof("</cdm:VERSION>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->ACC, sizeof("cb:ACC")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ACCTime, sizeof("cb:ACCTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modifier, sizeof("cb:modifier")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:VERSION", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_VERSION) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_VERSION(struct zx_ctx* c, struct zx_cdm_VERSION_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:VERSION");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->ACC || x->ACCTime || x->id || x->modificationTime || x->modifier)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->ACC, " cb:ACC=\"", sizeof(" cb:ACC=\"")-1);
  p = zx_attr_so_enc(p, x->ACCTime, " cb:ACCTime=\"", sizeof(" cb:ACCTime=\"")-1);
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);
  p = zx_attr_so_enc(p, x->modifier, " cb:modifier=\"", sizeof(" cb:modifier=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:VERSION>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:VERSION", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_VERSION) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_VERSION(struct zx_ctx* c, struct zx_cdm_VERSION_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_VERSION(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_VERSION(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   cdm_vCard
#define EL_STRUCT zx_cdm_vCard_s
#define EL_NS     cdm
#define EL_TAG    vCard

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_cdm_vCard) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_cdm_vCard(struct zx_ctx* c, struct zx_cdm_vCard_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<cdm:vCard")-1 + 1 + sizeof("</cdm:vCard>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >>  ZX_TOK_NS_SHIFT), &pop_seen);

  len += zx_attr_so_len(c, x->id, sizeof("cb:id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->modificationTime, sizeof("cb:modificationTime")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->VERSION_is_Perl_MakeMaker_gobbled->gg;
       se && se->g.tok == zx_cdm_VERSION_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_VERSION(c, (struct zx_cdm_VERSION_s*)se);
  for (se = x->CARDID;
    se && se->g.tok == zx_cdm_CARDID_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:CARDID")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->DISTRIBUTIONLIST;
    se && se->g.tok == zx_cdm_DISTRIBUTIONLIST_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:DISTRIBUTIONLIST")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->SELF;
    se && se->g.tok == zx_cdm_SELF_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:SELF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->FAVORITE;
    se && se->g.tok == zx_cdm_FAVORITE_ELEM;
    se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("cdm:FAVORITE")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->FN->gg;
       se && se->g.tok == zx_cdm_FN_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_FN(c, (struct zx_cdm_FN_s*)se);
  for (se = &x->N->gg;
       se && se->g.tok == zx_cdm_N_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_N(c, (struct zx_cdm_N_s*)se);
  for (se = &x->LISTMEMBER->gg;
       se && se->g.tok == zx_cdm_LISTMEMBER_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_LISTMEMBER(c, (struct zx_cdm_LISTMEMBER_s*)se);
  for (se = &x->NICKNAME->gg;
       se && se->g.tok == zx_cdm_NICKNAME_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_NICKNAME(c, (struct zx_cdm_NICKNAME_s*)se);
  for (se = &x->PHOTO->gg;
       se && se->g.tok == zx_cdm_PHOTO_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_PHOTO(c, (struct zx_cdm_PHOTO_s*)se);
  for (se = &x->BDAY->gg;
       se && se->g.tok == zx_cdm_BDAY_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_BDAY(c, (struct zx_cdm_BDAY_s*)se);
  for (se = &x->ADR->gg;
       se && se->g.tok == zx_cdm_ADR_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_ADR(c, (struct zx_cdm_ADR_s*)se);
  for (se = &x->LABEL->gg;
       se && se->g.tok == zx_cdm_LABEL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_LABEL(c, (struct zx_cdm_LABEL_s*)se);
  for (se = &x->TEL->gg;
       se && se->g.tok == zx_cdm_TEL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_TEL(c, (struct zx_cdm_TEL_s*)se);
  for (se = &x->EMAIL->gg;
       se && se->g.tok == zx_cdm_EMAIL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_EMAIL(c, (struct zx_cdm_EMAIL_s*)se);
  for (se = &x->JABBERID->gg;
       se && se->g.tok == zx_cdm_JABBERID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_JABBERID(c, (struct zx_cdm_JABBERID_s*)se);
  for (se = &x->MAILER->gg;
       se && se->g.tok == zx_cdm_MAILER_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_MAILER(c, (struct zx_cdm_MAILER_s*)se);
  for (se = &x->TZ->gg;
       se && se->g.tok == zx_cdm_TZ_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_TZ(c, (struct zx_cdm_TZ_s*)se);
  for (se = &x->GEO->gg;
       se && se->g.tok == zx_cdm_GEO_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_GEO(c, (struct zx_cdm_GEO_s*)se);
  for (se = &x->TITLE->gg;
       se && se->g.tok == zx_cdm_TITLE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_TITLE(c, (struct zx_cdm_TITLE_s*)se);
  for (se = &x->ROLE->gg;
       se && se->g.tok == zx_cdm_ROLE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_ROLE(c, (struct zx_cdm_ROLE_s*)se);
  for (se = &x->LOGO->gg;
       se && se->g.tok == zx_cdm_LOGO_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_LOGO(c, (struct zx_cdm_LOGO_s*)se);
  for (se = &x->AGENT->gg;
       se && se->g.tok == zx_cdm_AGENT_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_AGENT(c, (struct zx_cdm_AGENT_s*)se);
  for (se = &x->ORG->gg;
       se && se->g.tok == zx_cdm_ORG_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_ORG(c, (struct zx_cdm_ORG_s*)se);
  for (se = &x->CATEGORIES->gg;
       se && se->g.tok == zx_cdm_CATEGORIES_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_CATEGORIES(c, (struct zx_cdm_CATEGORIES_s*)se);
  for (se = &x->NOTE->gg;
       se && se->g.tok == zx_cdm_NOTE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_NOTE(c, (struct zx_cdm_NOTE_s*)se);
  for (se = &x->PRODID->gg;
       se && se->g.tok == zx_cdm_PRODID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_PRODID(c, (struct zx_cdm_PRODID_s*)se);
  for (se = &x->REV->gg;
       se && se->g.tok == zx_cdm_REV_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_REV(c, (struct zx_cdm_REV_s*)se);
  for (se = &x->SORT_STRING->gg;
       se && se->g.tok == zx_cdm_SORT_STRING_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_SORT_STRING(c, (struct zx_cdm_SORT_STRING_s*)se);
  for (se = &x->SOUND->gg;
       se && se->g.tok == zx_cdm_SOUND_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_SOUND(c, (struct zx_cdm_SOUND_s*)se);
  for (se = &x->UID->gg;
       se && se->g.tok == zx_cdm_UID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_UID(c, (struct zx_cdm_UID_s*)se);
  for (se = &x->URL->gg;
       se && se->g.tok == zx_cdm_URL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_URL(c, (struct zx_cdm_URL_s*)se);
  for (se = &x->CLASS->gg;
       se && se->g.tok == zx_cdm_CLASS_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_CLASS(c, (struct zx_cdm_CLASS_s*)se);
  for (se = &x->KEY->gg;
       se && se->g.tok == zx_cdm_KEY_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_KEY(c, (struct zx_cdm_KEY_s*)se);
  for (se = &x->DESC->gg;
       se && se->g.tok == zx_cdm_DESC_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_DESC(c, (struct zx_cdm_DESC_s*)se);
  for (se = &x->PHYSICALACCESS->gg;
       se && se->g.tok == zx_cdm_PHYSICALACCESS_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_PHYSICALACCESS(c, (struct zx_cdm_PHYSICALACCESS_s*)se);
  for (se = &x->CALURI->gg;
       se && se->g.tok == zx_cdm_CALURI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_CALURI(c, (struct zx_cdm_CALURI_s*)se);
  for (se = &x->CAPURI->gg;
       se && se->g.tok == zx_cdm_CAPURI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_CAPURI(c, (struct zx_cdm_CAPURI_s*)se);
  for (se = &x->CALADRURI->gg;
       se && se->g.tok == zx_cdm_CALADRURI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_CALADRURI(c, (struct zx_cdm_CALADRURI_s*)se);
  for (se = &x->FBURL->gg;
       se && se->g.tok == zx_cdm_FBURL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cdm_FBURL(c, (struct zx_cdm_FBURL_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_cb_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_cb_Extension(c, (struct zx_cb_Extension_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "cdm:vCard", len);
  return len;
}

/* FUNC(zx_ENC_SO_cdm_vCard) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_cdm_vCard(struct zx_ctx* c, struct zx_cdm_vCard_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<cdm:vCard");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  if (x->id || x->modificationTime)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cb_NS >> ZX_TOK_NS_SHIFT), &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT), &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->id, " cb:id=\"", sizeof(" cb:id=\"")-1);
  p = zx_attr_so_enc(p, x->modificationTime, " cb:modificationTime=\"", sizeof(" cb:modificationTime=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->VERSION_is_Perl_MakeMaker_gobbled->gg;
       se && se->g.tok == zx_cdm_VERSION_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_VERSION(c, (struct zx_cdm_VERSION_s*)se, p);
  for (se = x->CARDID;
       se && se->g.tok == zx_cdm_CARDID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:CARDID", sizeof("cdm:CARDID")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->DISTRIBUTIONLIST;
       se && se->g.tok == zx_cdm_DISTRIBUTIONLIST_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:DISTRIBUTIONLIST", sizeof("cdm:DISTRIBUTIONLIST")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->SELF;
       se && se->g.tok == zx_cdm_SELF_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:SELF", sizeof("cdm:SELF")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = x->FAVORITE;
       se && se->g.tok == zx_cdm_FAVORITE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "cdm:FAVORITE", sizeof("cdm:FAVORITE")-1, zx_ns_tab+(zx_cdm_NS >> ZX_TOK_NS_SHIFT));
  for (se = &x->FN->gg;
       se && se->g.tok == zx_cdm_FN_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_FN(c, (struct zx_cdm_FN_s*)se, p);
  for (se = &x->N->gg;
       se && se->g.tok == zx_cdm_N_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_N(c, (struct zx_cdm_N_s*)se, p);
  for (se = &x->LISTMEMBER->gg;
       se && se->g.tok == zx_cdm_LISTMEMBER_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_LISTMEMBER(c, (struct zx_cdm_LISTMEMBER_s*)se, p);
  for (se = &x->NICKNAME->gg;
       se && se->g.tok == zx_cdm_NICKNAME_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_NICKNAME(c, (struct zx_cdm_NICKNAME_s*)se, p);
  for (se = &x->PHOTO->gg;
       se && se->g.tok == zx_cdm_PHOTO_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_PHOTO(c, (struct zx_cdm_PHOTO_s*)se, p);
  for (se = &x->BDAY->gg;
       se && se->g.tok == zx_cdm_BDAY_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_BDAY(c, (struct zx_cdm_BDAY_s*)se, p);
  for (se = &x->ADR->gg;
       se && se->g.tok == zx_cdm_ADR_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_ADR(c, (struct zx_cdm_ADR_s*)se, p);
  for (se = &x->LABEL->gg;
       se && se->g.tok == zx_cdm_LABEL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_LABEL(c, (struct zx_cdm_LABEL_s*)se, p);
  for (se = &x->TEL->gg;
       se && se->g.tok == zx_cdm_TEL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_TEL(c, (struct zx_cdm_TEL_s*)se, p);
  for (se = &x->EMAIL->gg;
       se && se->g.tok == zx_cdm_EMAIL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_EMAIL(c, (struct zx_cdm_EMAIL_s*)se, p);
  for (se = &x->JABBERID->gg;
       se && se->g.tok == zx_cdm_JABBERID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_JABBERID(c, (struct zx_cdm_JABBERID_s*)se, p);
  for (se = &x->MAILER->gg;
       se && se->g.tok == zx_cdm_MAILER_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_MAILER(c, (struct zx_cdm_MAILER_s*)se, p);
  for (se = &x->TZ->gg;
       se && se->g.tok == zx_cdm_TZ_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_TZ(c, (struct zx_cdm_TZ_s*)se, p);
  for (se = &x->GEO->gg;
       se && se->g.tok == zx_cdm_GEO_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_GEO(c, (struct zx_cdm_GEO_s*)se, p);
  for (se = &x->TITLE->gg;
       se && se->g.tok == zx_cdm_TITLE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_TITLE(c, (struct zx_cdm_TITLE_s*)se, p);
  for (se = &x->ROLE->gg;
       se && se->g.tok == zx_cdm_ROLE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_ROLE(c, (struct zx_cdm_ROLE_s*)se, p);
  for (se = &x->LOGO->gg;
       se && se->g.tok == zx_cdm_LOGO_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_LOGO(c, (struct zx_cdm_LOGO_s*)se, p);
  for (se = &x->AGENT->gg;
       se && se->g.tok == zx_cdm_AGENT_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_AGENT(c, (struct zx_cdm_AGENT_s*)se, p);
  for (se = &x->ORG->gg;
       se && se->g.tok == zx_cdm_ORG_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_ORG(c, (struct zx_cdm_ORG_s*)se, p);
  for (se = &x->CATEGORIES->gg;
       se && se->g.tok == zx_cdm_CATEGORIES_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_CATEGORIES(c, (struct zx_cdm_CATEGORIES_s*)se, p);
  for (se = &x->NOTE->gg;
       se && se->g.tok == zx_cdm_NOTE_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_NOTE(c, (struct zx_cdm_NOTE_s*)se, p);
  for (se = &x->PRODID->gg;
       se && se->g.tok == zx_cdm_PRODID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_PRODID(c, (struct zx_cdm_PRODID_s*)se, p);
  for (se = &x->REV->gg;
       se && se->g.tok == zx_cdm_REV_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_REV(c, (struct zx_cdm_REV_s*)se, p);
  for (se = &x->SORT_STRING->gg;
       se && se->g.tok == zx_cdm_SORT_STRING_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_SORT_STRING(c, (struct zx_cdm_SORT_STRING_s*)se, p);
  for (se = &x->SOUND->gg;
       se && se->g.tok == zx_cdm_SOUND_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_SOUND(c, (struct zx_cdm_SOUND_s*)se, p);
  for (se = &x->UID->gg;
       se && se->g.tok == zx_cdm_UID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_UID(c, (struct zx_cdm_UID_s*)se, p);
  for (se = &x->URL->gg;
       se && se->g.tok == zx_cdm_URL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_URL(c, (struct zx_cdm_URL_s*)se, p);
  for (se = &x->CLASS->gg;
       se && se->g.tok == zx_cdm_CLASS_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_CLASS(c, (struct zx_cdm_CLASS_s*)se, p);
  for (se = &x->KEY->gg;
       se && se->g.tok == zx_cdm_KEY_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_KEY(c, (struct zx_cdm_KEY_s*)se, p);
  for (se = &x->DESC->gg;
       se && se->g.tok == zx_cdm_DESC_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_DESC(c, (struct zx_cdm_DESC_s*)se, p);
  for (se = &x->PHYSICALACCESS->gg;
       se && se->g.tok == zx_cdm_PHYSICALACCESS_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_PHYSICALACCESS(c, (struct zx_cdm_PHYSICALACCESS_s*)se, p);
  for (se = &x->CALURI->gg;
       se && se->g.tok == zx_cdm_CALURI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_CALURI(c, (struct zx_cdm_CALURI_s*)se, p);
  for (se = &x->CAPURI->gg;
       se && se->g.tok == zx_cdm_CAPURI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_CAPURI(c, (struct zx_cdm_CAPURI_s*)se, p);
  for (se = &x->CALADRURI->gg;
       se && se->g.tok == zx_cdm_CALADRURI_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_CALADRURI(c, (struct zx_cdm_CALADRURI_s*)se, p);
  for (se = &x->FBURL->gg;
       se && se->g.tok == zx_cdm_FBURL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cdm_FBURL(c, (struct zx_cdm_FBURL_s*)se, p);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_cb_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_cb_Extension(c, (struct zx_cb_Extension_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</cdm:vCard>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "cdm:vCard", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_cdm_vCard) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_cdm_vCard(struct zx_ctx* c, struct zx_cdm_vCard_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_cdm_vCard(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_cdm_vCard(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif


/* EOF -- c/zx-cdm-enc.c */
