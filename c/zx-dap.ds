/* c/zx-dap.ds - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** ds-templ.c  -  DirectoryScript template, used in code generation
 ** Copyright (c) 2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: ds-templ.c,v 1.1 2007-08-10 17:44:49 sampo Exp $
 **
 ** 6.6.2007, created, Sampo Kellomaki (sampo@iki.fi)
 **
 ** N.B: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/



function parse_dap_Create(data, x) {
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);

  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'Subscription', i); ++i) {
    h =  hash [];
    parse_dap_Subscription(h, tag);
    push data{'Subscription'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'CreateItem', i); ++i) {
    h =  hash [];
    parse_dap_CreateItem(h, tag);
    push data{'CreateItem'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'ResultQuery', i); ++i) {
    h =  hash [];
    parse_dap_ResultQuery(h, tag);
    push data{'ResultQuery'}, h;
  }

}

function build_dap_Create(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);

  for d(data{'Extension'}) push body,build_lu_Extension(d);
  for d(data{'Subscription'}) push body,build_dap_Subscription(d);
  for d(data{'CreateItem'}) push body,build_dap_CreateItem(d);
  for d(data{'ResultQuery'}) push body,build_dap_ResultQuery(d);

  return TAG('dap:Create', attr, body);
}




function parse_dap_CreateItem(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);
  POPATTR(x[1], 'dst_objectType', data.dst_objectType);

  tag = find_xml_local(x[2], 'NewData', 1);
  h =  hash [];
  parse_dap_NewData(h, aux1);
  data{'NewData'} = h;

}

function build_dap_CreateItem(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);
  PUSHATTR(attr, 'dst_objectType', data.dst_objectType);

  push body, build_dap_NewData(data{'NewData'});

  return TAG('dap:CreateItem', attr, body);
}




function parse_dap_CreateResponse(data, x) {
  POPATTR(x[1], 'timeStamp', data.timeStamp);
  POPATTR(x[1], 'dst_itemIDRef', data.dst_itemIDRef);

  tag = find_xml_local(x[2], 'Status', 1);
  h =  hash [];
  parse_lu_Status(h, aux1);
  data{'Status'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'ItemData', i); ++i) {
    h =  hash [];
    parse_dap_ItemData(h, tag);
    push data{'ItemData'}, h;
  }

}

function build_dap_CreateResponse(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'timeStamp', data.timeStamp);
  PUSHATTR(attr, 'dst_itemIDRef', data.dst_itemIDRef);

  push body, build_lu_Status(data{'Status'});
  for d(data{'Extension'}) push body,build_lu_Extension(d);
  for d(data{'ItemData'}) push body,build_dap_ItemData(d);

  return TAG('dap:CreateResponse', attr, body);
}




function parse_dap_Data(data, x) {
  POPATTR(x[1], 'nextOffset', data.nextOffset);
  POPATTR(x[1], 'notSorted', data.notSorted);
  POPATTR(x[1], 'remaining', data.remaining);
  POPATTR(x[1], 'setID', data.setID);
  POPATTR(x[1], 'dst_changeFormat', data.dst_changeFormat);
  POPATTR(x[1], 'dst_itemIDRef', data.dst_itemIDRef);

  tag = find_xml_local(x[2], 'LDIF', 1);
  h =  hash [];
  parse_dap_LDIF(h, aux1);
  data{'LDIF'} = h;
  tag = find_xml_local(x[2], 'Subscription', 1);
  h =  hash [];
  parse_dap_Subscription(h, aux1);
  data{'Subscription'} = h;

}

function build_dap_Data(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'nextOffset', data.nextOffset);
  PUSHATTR(attr, 'notSorted', data.notSorted);
  PUSHATTR(attr, 'remaining', data.remaining);
  PUSHATTR(attr, 'setID', data.setID);
  PUSHATTR(attr, 'dst_changeFormat', data.dst_changeFormat);
  PUSHATTR(attr, 'dst_itemIDRef', data.dst_itemIDRef);

  push body, build_dap_LDIF(data{'LDIF'});
  push body, build_dap_Subscription(data{'Subscription'});

  return TAG('dap:Data', attr, body);
}




function parse_dap_Delete(data, x) {
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);

  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'DeleteItem', i); ++i) {
    h =  hash [];
    parse_dap_DeleteItem(h, tag);
    push data{'DeleteItem'}, h;
  }

}

function build_dap_Delete(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);

  for d(data{'Extension'}) push body,build_lu_Extension(d);
  for d(data{'DeleteItem'}) push body,build_dap_DeleteItem(d);

  return TAG('dap:Delete', attr, body);
}




function parse_dap_DeleteItem(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'notChangedSince', data.notChangedSince);
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);
  POPATTR(x[1], 'dst_objectType', data.dst_objectType);
  POPATTR(x[1], 'dst_predefined', data.dst_predefined);

  tag = find_xml_local(x[2], 'Select', 1);
  h =  hash [];
  parse_dap_Select(h, aux1);
  data{'Select'} = h;

}

function build_dap_DeleteItem(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'notChangedSince', data.notChangedSince);
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);
  PUSHATTR(attr, 'dst_objectType', data.dst_objectType);
  PUSHATTR(attr, 'dst_predefined', data.dst_predefined);

  push body, build_dap_Select(data{'Select'});

  return TAG('dap:DeleteItem', attr, body);
}




function parse_dap_DeleteResponse(data, x) {
  POPATTR(x[1], 'itemIDRef', data.itemIDRef);

  tag = find_xml_local(x[2], 'Status', 1);
  h =  hash [];
  parse_lu_Status(h, aux1);
  data{'Status'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }

}

function build_dap_DeleteResponse(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'itemIDRef', data.itemIDRef);

  push body, build_lu_Status(data{'Status'});
  for d(data{'Extension'}) push body,build_lu_Extension(d);

  return TAG('dap:DeleteResponse', attr, body);
}




function parse_dap_ItemData(data, x) {
  POPATTR(x[1], 'notSorted', data.notSorted);
  POPATTR(x[1], 'dst_changeFormat', data.dst_changeFormat);
  POPATTR(x[1], 'dst_itemIDRef', data.dst_itemIDRef);

  tag = find_xml_local(x[2], 'LDIF', 1);
  h =  hash [];
  parse_dap_LDIF(h, aux1);
  data{'LDIF'} = h;
  tag = find_xml_local(x[2], 'Subscription', 1);
  h =  hash [];
  parse_dap_Subscription(h, aux1);
  data{'Subscription'} = h;

}

function build_dap_ItemData(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'notSorted', data.notSorted);
  PUSHATTR(attr, 'dst_changeFormat', data.dst_changeFormat);
  PUSHATTR(attr, 'dst_itemIDRef', data.dst_itemIDRef);

  push body, build_dap_LDIF(data{'LDIF'});
  push body, build_dap_Subscription(data{'Subscription'});

  return TAG('dap:ItemData', attr, body);
}




function parse_dap_LDIF(data, x) {
  POPATTR(x[1], 'xml_lang', data.xml_lang);
  POPATTR(x[1], 'dst_ACC', data.dst_ACC);
  POPATTR(x[1], 'dst_ACCTime', data.dst_ACCTime);
  POPATTR(x[1], 'dst_id', data.dst_id);
  POPATTR(x[1], 'dst_modificationTime', data.dst_modificationTime);
  POPATTR(x[1], 'dst_modifier', data.dst_modifier);
  POPATTR(x[1], 'dst_script', data.dst_script);


}

function build_dap_LDIF(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'xml_lang', data.xml_lang);
  PUSHATTR(attr, 'dst_ACC', data.dst_ACC);
  PUSHATTR(attr, 'dst_ACCTime', data.dst_ACCTime);
  PUSHATTR(attr, 'dst_id', data.dst_id);
  PUSHATTR(attr, 'dst_modificationTime', data.dst_modificationTime);
  PUSHATTR(attr, 'dst_modifier', data.dst_modifier);
  PUSHATTR(attr, 'dst_script', data.dst_script);


  return TAG('dap:LDIF', attr, body);
}




function parse_dap_Modify(data, x) {
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);

  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'Subscription', i); ++i) {
    h =  hash [];
    parse_dap_Subscription(h, tag);
    push data{'Subscription'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'ModifyItem', i); ++i) {
    h =  hash [];
    parse_dap_ModifyItem(h, tag);
    push data{'ModifyItem'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'ResultQuery', i); ++i) {
    h =  hash [];
    parse_dap_ResultQuery(h, tag);
    push data{'ResultQuery'}, h;
  }

}

function build_dap_Modify(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);

  for d(data{'Extension'}) push body,build_lu_Extension(d);
  for d(data{'Subscription'}) push body,build_dap_Subscription(d);
  for d(data{'ModifyItem'}) push body,build_dap_ModifyItem(d);
  for d(data{'ResultQuery'}) push body,build_dap_ResultQuery(d);

  return TAG('dap:Modify', attr, body);
}




function parse_dap_ModifyItem(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'notChangedSince', data.notChangedSince);
  POPATTR(x[1], 'overrideAllowed', data.overrideAllowed);
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);
  POPATTR(x[1], 'dst_objectType', data.dst_objectType);
  POPATTR(x[1], 'dst_predefined', data.dst_predefined);

  tag = find_xml_local(x[2], 'Select', 1);
  h =  hash [];
  parse_dap_Select(h, aux1);
  data{'Select'} = h;
  tag = find_xml_local(x[2], 'NewData', 1);
  h =  hash [];
  parse_dap_NewData(h, aux1);
  data{'NewData'} = h;

}

function build_dap_ModifyItem(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'notChangedSince', data.notChangedSince);
  PUSHATTR(attr, 'overrideAllowed', data.overrideAllowed);
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);
  PUSHATTR(attr, 'dst_objectType', data.dst_objectType);
  PUSHATTR(attr, 'dst_predefined', data.dst_predefined);

  push body, build_dap_Select(data{'Select'});
  push body, build_dap_NewData(data{'NewData'});

  return TAG('dap:ModifyItem', attr, body);
}




function parse_dap_ModifyResponse(data, x) {
  POPATTR(x[1], 'timeStamp', data.timeStamp);
  POPATTR(x[1], 'dst_itemIDRef', data.dst_itemIDRef);

  tag = find_xml_local(x[2], 'Status', 1);
  h =  hash [];
  parse_lu_Status(h, aux1);
  data{'Status'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'ItemData', i); ++i) {
    h =  hash [];
    parse_dap_ItemData(h, tag);
    push data{'ItemData'}, h;
  }

}

function build_dap_ModifyResponse(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'timeStamp', data.timeStamp);
  PUSHATTR(attr, 'dst_itemIDRef', data.dst_itemIDRef);

  push body, build_lu_Status(data{'Status'});
  for d(data{'Extension'}) push body,build_lu_Extension(d);
  for d(data{'ItemData'}) push body,build_dap_ItemData(d);

  return TAG('dap:ModifyResponse', attr, body);
}




function parse_dap_NewData(data, x) {

  tag = find_xml_local(x[2], 'LDIF', 1);
  h =  hash [];
  parse_dap_LDIF(h, aux1);
  data{'LDIF'} = h;
  tag = find_xml_local(x[2], 'Subscription', 1);
  h =  hash [];
  parse_dap_Subscription(h, aux1);
  data{'Subscription'} = h;

}

function build_dap_NewData(data) {
  attr = [];
  body = [];

  push body, build_dap_LDIF(data{'LDIF'});
  push body, build_dap_Subscription(data{'Subscription'});

  return TAG('dap:NewData', attr, body);
}




function parse_dap_Notification(data, x) {
  POPATTR(x[1], 'endReason', data.endReason);
  POPATTR(x[1], 'expires', data.expires);
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'subscriptionID', data.subscriptionID);

  for (i=1; tag = find_xml_local(x[2], 'TestResult', i); ++i) {
    h =  hash [];
    parse_lu_TestResult(h, tag);
    push data{'TestResult'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'ItemData', i); ++i) {
    h =  hash [];
    parse_dap_ItemData(h, tag);
    push data{'ItemData'}, h;
  }

}

function build_dap_Notification(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'endReason', data.endReason);
  PUSHATTR(attr, 'expires', data.expires);
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'subscriptionID', data.subscriptionID);

  for d(data{'TestResult'}) push body,build_lu_TestResult(d);
  for d(data{'ItemData'}) push body,build_dap_ItemData(d);

  return TAG('dap:Notification', attr, body);
}




function parse_dap_Notify(data, x) {
  POPATTR(x[1], 'timeStamp', data.timeStamp);
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);

  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'Notification', i); ++i) {
    h =  hash [];
    parse_dap_Notification(h, tag);
    push data{'Notification'}, h;
  }

}

function build_dap_Notify(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'timeStamp', data.timeStamp);
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);

  for d(data{'Extension'}) push body,build_lu_Extension(d);
  for d(data{'Notification'}) push body,build_dap_Notification(d);

  return TAG('dap:Notify', attr, body);
}




function parse_dap_NotifyResponse(data, x) {
  POPATTR(x[1], 'itemIDRef', data.itemIDRef);

  tag = find_xml_local(x[2], 'Status', 1);
  h =  hash [];
  parse_lu_Status(h, aux1);
  data{'Status'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }

}

function build_dap_NotifyResponse(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'itemIDRef', data.itemIDRef);

  push body, build_lu_Status(data{'Status'});
  for d(data{'Extension'}) push body,build_lu_Extension(d);

  return TAG('dap:NotifyResponse', attr, body);
}




function parse_dap_Query(data, x) {
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);

  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'TestItem', i); ++i) {
    h =  hash [];
    parse_dap_TestItem(h, tag);
    push data{'TestItem'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'QueryItem', i); ++i) {
    h =  hash [];
    parse_dap_QueryItem(h, tag);
    push data{'QueryItem'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'Subscription', i); ++i) {
    h =  hash [];
    parse_dap_Subscription(h, tag);
    push data{'Subscription'}, h;
  }

}

function build_dap_Query(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);

  for d(data{'Extension'}) push body,build_lu_Extension(d);
  for d(data{'TestItem'}) push body,build_dap_TestItem(d);
  for d(data{'QueryItem'}) push body,build_dap_QueryItem(d);
  for d(data{'Subscription'}) push body,build_dap_Subscription(d);

  return TAG('dap:Query', attr, body);
}




function parse_dap_QueryItem(data, x) {
  POPATTR(x[1], 'changedSince', data.changedSince);
  POPATTR(x[1], 'contingency', data.contingency);
  POPATTR(x[1], 'count', data.count);
  POPATTR(x[1], 'includeCommonAttributes', data.includeCommonAttributes);
  POPATTR(x[1], 'offset', data.offset);
  POPATTR(x[1], 'setID', data.setID);
  POPATTR(x[1], 'setReq', data.setReq);
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);
  POPATTR(x[1], 'dst_itemIDRef', data.dst_itemIDRef);
  POPATTR(x[1], 'dst_objectType', data.dst_objectType);
  POPATTR(x[1], 'dst_predefined', data.dst_predefined);

  for (i=1; tag = find_xml_local(x[2], 'ChangeFormat', i); ++i)
    push data{'ChangeFormat'}, tag[2];
  tag = find_xml_local(x[2], 'Select', 1);
  h =  hash [];
  parse_dap_Select(h, aux1);
  data{'Select'} = h;
  POPTAG_RAW(x[2],  'Sort', data.Sort);

}

function build_dap_QueryItem(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'changedSince', data.changedSince);
  PUSHATTR(attr, 'contingency', data.contingency);
  PUSHATTR(attr, 'count', data.count);
  PUSHATTR(attr, 'includeCommonAttributes', data.includeCommonAttributes);
  PUSHATTR(attr, 'offset', data.offset);
  PUSHATTR(attr, 'setID', data.setID);
  PUSHATTR(attr, 'setReq', data.setReq);
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);
  PUSHATTR(attr, 'dst_itemIDRef', data.dst_itemIDRef);
  PUSHATTR(attr, 'dst_objectType', data.dst_objectType);
  PUSHATTR(attr, 'dst_predefined', data.dst_predefined);

  for d(data{'ChangeFormat'})PUSHTAG_RAW(body,'ChangeFormat',d);
  push body, build_dap_Select(data{'Select'});
  PUSHTAG_RAW(body, 'Sort', data.Sort);

  return TAG('dap:QueryItem', attr, body);
}




function parse_dap_QueryResponse(data, x) {
  POPATTR(x[1], 'timeStamp', data.timeStamp);
  POPATTR(x[1], 'dst_itemIDRef', data.dst_itemIDRef);

  tag = find_xml_local(x[2], 'Status', 1);
  h =  hash [];
  parse_lu_Status(h, aux1);
  data{'Status'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'TestResult', i); ++i) {
    h =  hash [];
    parse_dst_TestResult(h, tag);
    push data{'TestResult'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'Data', i); ++i) {
    h =  hash [];
    parse_dap_Data(h, tag);
    push data{'Data'}, h;
  }

}

function build_dap_QueryResponse(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'timeStamp', data.timeStamp);
  PUSHATTR(attr, 'dst_itemIDRef', data.dst_itemIDRef);

  push body, build_lu_Status(data{'Status'});
  for d(data{'Extension'}) push body,build_lu_Extension(d);
  for d(data{'TestResult'}) push body,build_dst_TestResult(d);
  for d(data{'Data'}) push body,build_dap_Data(d);

  return TAG('dap:QueryResponse', attr, body);
}




function parse_dap_ResultQuery(data, x) {
  POPATTR(x[1], 'changedSince', data.changedSince);
  POPATTR(x[1], 'contingency', data.contingency);
  POPATTR(x[1], 'includeCommonAttributes', data.includeCommonAttributes);
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);
  POPATTR(x[1], 'dst_itemIDRef', data.dst_itemIDRef);
  POPATTR(x[1], 'dst_objectType', data.dst_objectType);
  POPATTR(x[1], 'dst_predefined', data.dst_predefined);

  for (i=1; tag = find_xml_local(x[2], 'ChangeFormat', i); ++i)
    push data{'ChangeFormat'}, tag[2];
  tag = find_xml_local(x[2], 'Select', 1);
  h =  hash [];
  parse_dap_Select(h, aux1);
  data{'Select'} = h;
  POPTAG_RAW(x[2],  'Sort', data.Sort);

}

function build_dap_ResultQuery(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'changedSince', data.changedSince);
  PUSHATTR(attr, 'contingency', data.contingency);
  PUSHATTR(attr, 'includeCommonAttributes', data.includeCommonAttributes);
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);
  PUSHATTR(attr, 'dst_itemIDRef', data.dst_itemIDRef);
  PUSHATTR(attr, 'dst_objectType', data.dst_objectType);
  PUSHATTR(attr, 'dst_predefined', data.dst_predefined);

  for d(data{'ChangeFormat'})PUSHTAG_RAW(body,'ChangeFormat',d);
  push body, build_dap_Select(data{'Select'});
  PUSHTAG_RAW(body, 'Sort', data.Sort);

  return TAG('dap:ResultQuery', attr, body);
}




function parse_dap_Select(data, x) {
  POPATTR(x[1], 'attributes', data.attributes);
  POPATTR(x[1], 'derefaliases', data.derefaliases);
  POPATTR(x[1], 'scope', data.scope);
  POPATTR(x[1], 'sizelimit', data.sizelimit);
  POPATTR(x[1], 'timelimit', data.timelimit);
  POPATTR(x[1], 'typesonly', data.typesonly);

  POPTAG_RAW(x[2],  'dn', data.dn);
  POPTAG_RAW(x[2],  'filter', data.filter);

}

function build_dap_Select(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'attributes', data.attributes);
  PUSHATTR(attr, 'derefaliases', data.derefaliases);
  PUSHATTR(attr, 'scope', data.scope);
  PUSHATTR(attr, 'sizelimit', data.sizelimit);
  PUSHATTR(attr, 'timelimit', data.timelimit);
  PUSHATTR(attr, 'typesonly', data.typesonly);

  PUSHTAG_RAW(body, 'dn', data.dn);
  PUSHTAG_RAW(body, 'filter', data.filter);

  return TAG('dap:Select', attr, body);
}




function parse_dap_Subscription(data, x) {
  POPATTR(x[1], 'adminNotifyToRef', data.adminNotifyToRef);
  POPATTR(x[1], 'expires', data.expires);
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'includeData', data.includeData);
  POPATTR(x[1], 'notifyToRef', data.notifyToRef);
  POPATTR(x[1], 'starts', data.starts);
  POPATTR(x[1], 'subscriptionID', data.subscriptionID);

  for (i=1; tag = find_xml_local(x[2], 'RefItem', i); ++i) {
    h =  hash [];
    parse_subs_RefItem(h, tag);
    push data{'RefItem'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'Extension', i); ++i) {
    h =  hash [];
    parse_lu_Extension(h, tag);
    push data{'Extension'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'ResultQuery', i); ++i) {
    h =  hash [];
    parse_dap_ResultQuery(h, tag);
    push data{'ResultQuery'}, h;
  }
  POPTAG_RAW(x[2],  'Aggregation', data.Aggregation);
  POPTAG_RAW(x[2],  'Trigger', data.Trigger);

}

function build_dap_Subscription(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'adminNotifyToRef', data.adminNotifyToRef);
  PUSHATTR(attr, 'expires', data.expires);
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'includeData', data.includeData);
  PUSHATTR(attr, 'notifyToRef', data.notifyToRef);
  PUSHATTR(attr, 'starts', data.starts);
  PUSHATTR(attr, 'subscriptionID', data.subscriptionID);

  for d(data{'RefItem'}) push body,build_subs_RefItem(d);
  for d(data{'Extension'}) push body,build_lu_Extension(d);
  for d(data{'ResultQuery'}) push body,build_dap_ResultQuery(d);
  PUSHTAG_RAW(body, 'Aggregation', data.Aggregation);
  PUSHTAG_RAW(body, 'Trigger', data.Trigger);

  return TAG('dap:Subscription', attr, body);
}




function parse_dap_TestItem(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'dst_itemID', data.dst_itemID);
  POPATTR(x[1], 'dst_objectType', data.dst_objectType);
  POPATTR(x[1], 'dst_predefined', data.dst_predefined);

  tag = find_xml_local(x[2], 'TestOp', 1);
  h =  hash [];
  parse_dap_TestOp(h, aux1);
  data{'TestOp'} = h;

}

function build_dap_TestItem(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'dst_itemID', data.dst_itemID);
  PUSHATTR(attr, 'dst_objectType', data.dst_objectType);
  PUSHATTR(attr, 'dst_predefined', data.dst_predefined);

  push body, build_dap_TestOp(data{'TestOp'});

  return TAG('dap:TestItem', attr, body);
}




function parse_dap_TestOp(data, x) {
  POPATTR(x[1], 'attributes', data.attributes);
  POPATTR(x[1], 'derefaliases', data.derefaliases);
  POPATTR(x[1], 'scope', data.scope);
  POPATTR(x[1], 'sizelimit', data.sizelimit);
  POPATTR(x[1], 'timelimit', data.timelimit);
  POPATTR(x[1], 'typesonly', data.typesonly);

  POPTAG_RAW(x[2],  'dn', data.dn);
  POPTAG_RAW(x[2],  'filter', data.filter);

}

function build_dap_TestOp(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'attributes', data.attributes);
  PUSHATTR(attr, 'derefaliases', data.derefaliases);
  PUSHATTR(attr, 'scope', data.scope);
  PUSHATTR(attr, 'sizelimit', data.sizelimit);
  PUSHATTR(attr, 'timelimit', data.timelimit);
  PUSHATTR(attr, 'typesonly', data.typesonly);

  PUSHTAG_RAW(body, 'dn', data.dn);
  PUSHTAG_RAW(body, 'filter', data.filter);

  return TAG('dap:TestOp', attr, body);
}


/* EOF -- c/zx-dap.ds */
