/* c/zx-prov-aux.c - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** aux-templ.c  -  Auxiliary functions template: cloning, freeing, walking data
 ** Copyright (c) 2006 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: aux-templ.c,v 1.12 2008-10-04 23:42:14 sampo Exp $
 **
 ** 30.5.2006, created, Sampo Kellomaki (sampo@iki.fi)
 ** 6.8.2006, factored from enc-templ.c to separate file --Sampo
 **
 ** N.B: wo=wire order (needed for exc-c14n), so=schema order
 **/

#include <memory.h>
#include "errmac.h"
#include "zx.h"
#include "c/zx-const.h"
#include "c/zx-data.h"
#include "c/zx-prov-data.h"



#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_CallbackEPR
#define EL_STRUCT zx_prov_CallbackEPR_s
#define EL_NS     prov
#define EL_TAG    CallbackEPR

/* FUNC(zx_FREE_prov_CallbackEPR) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_CallbackEPR(struct zx_ctx* c, struct zx_prov_CallbackEPR_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->ID, free_strs);
  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->notOnOrAfter, free_strs);
  zx_free_attr(c, x->Id, free_strs);
  zx_free_attr(c, x->actor, free_strs);
  zx_free_attr(c, x->mustUnderstand, free_strs);

  for (e = &x->Address->gg;
       e && e->g.tok == zx_a_Address_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_a_Address(c, (struct zx_a_Address_s*)e, free_strs);
  }
  for (e = &x->ReferenceParameters->gg;
       e && e->g.tok == zx_a_ReferenceParameters_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_a_ReferenceParameters(c, (struct zx_a_ReferenceParameters_s*)e, free_strs);
  }
  for (e = &x->Metadata->gg;
       e && e->g.tok == zx_a_Metadata_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_a_Metadata(c, (struct zx_a_Metadata_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_CallbackEPR) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_CallbackEPR_s* zx_NEW_prov_CallbackEPR(struct zx_ctx* c)
{
  struct zx_prov_CallbackEPR_s* x = ZX_ZALLOC(c, struct zx_prov_CallbackEPR_s);
  x->gg.g.tok = zx_prov_CallbackEPR_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_CallbackEPR) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_CallbackEPR(struct zx_ctx* c, struct zx_prov_CallbackEPR_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->ID);
  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->notOnOrAfter);
  zx_dup_attr(c, x->Id);
  zx_dup_attr(c, x->actor);
  zx_dup_attr(c, x->mustUnderstand);

  for (se = &x->Address->gg;
       se && se->g.tok == zx_a_Address_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_a_Address(c, (struct zx_a_Address_s*)se);
  for (se = &x->ReferenceParameters->gg;
       se && se->g.tok == zx_a_ReferenceParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_a_ReferenceParameters(c, (struct zx_a_ReferenceParameters_s*)se);
  for (se = &x->Metadata->gg;
       se && se->g.tok == zx_a_Metadata_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_a_Metadata(c, (struct zx_a_Metadata_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_CallbackEPR) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_CallbackEPR_s* zx_DEEP_CLONE_prov_CallbackEPR(struct zx_ctx* c, struct zx_prov_CallbackEPR_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_CallbackEPR_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_CallbackEPR_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->ID = zx_clone_attr(c, x->ID);
  x->id = zx_clone_attr(c, x->id);
  x->notOnOrAfter = zx_clone_attr(c, x->notOnOrAfter);
  x->Id = zx_clone_attr(c, x->Id);
  x->actor = zx_clone_attr(c, x->actor);
  x->mustUnderstand = zx_clone_attr(c, x->mustUnderstand);

  for (enn = 0, e = &x->Address->gg;
       e && e->g.tok == zx_a_Address_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_a_Address(c,(struct zx_a_Address_s*)e,dup_strs);
  	  if (!enn)
  	      x->Address = (struct zx_a_Address_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ReferenceParameters->gg;
       e && e->g.tok == zx_a_ReferenceParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_a_ReferenceParameters(c,(struct zx_a_ReferenceParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->ReferenceParameters = (struct zx_a_ReferenceParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Metadata->gg;
       e && e->g.tok == zx_a_Metadata_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_a_Metadata(c,(struct zx_a_Metadata_s*)e,dup_strs);
  	  if (!enn)
  	      x->Metadata = (struct zx_a_Metadata_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_CallbackEPR) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_CallbackEPR(struct zx_ctx* c, struct zx_prov_CallbackEPR_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Address->gg;
       e && e->g.tok == zx_a_Address_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_a_Address(c, (struct zx_a_Address_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ReferenceParameters->gg;
       e && e->g.tok == zx_a_ReferenceParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_a_ReferenceParameters(c, (struct zx_a_ReferenceParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Metadata->gg;
       e && e->g.tok == zx_a_Metadata_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_a_Metadata(c, (struct zx_a_Metadata_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_CallbackEPR) */

int zx_WALK_WO_prov_CallbackEPR(struct zx_ctx* c, struct zx_prov_CallbackEPR_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMActivate
#define EL_STRUCT zx_prov_PMActivate_s
#define EL_NS     prov
#define EL_TAG    PMActivate

/* FUNC(zx_FREE_prov_PMActivate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMActivate(struct zx_ctx* c, struct zx_prov_PMActivate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PMActivateItem->gg;
       e && e->g.tok == zx_prov_PMActivateItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMActivateItem(c, (struct zx_prov_PMActivateItem_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->NotifyTo, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMActivate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMActivate_s* zx_NEW_prov_PMActivate(struct zx_ctx* c)
{
  struct zx_prov_PMActivate_s* x = ZX_ZALLOC(c, struct zx_prov_PMActivate_s);
  x->gg.g.tok = zx_prov_PMActivate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMActivate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMActivate(struct zx_ctx* c, struct zx_prov_PMActivate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PMActivateItem->gg;
       se && se->g.tok == zx_prov_PMActivateItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMActivateItem(c, (struct zx_prov_PMActivateItem_s*)se);
  zx_dup_strs_simple_elems(c, x->NotifyTo);

}

/* FUNC(zx_DEEP_CLONE_prov_PMActivate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMActivate_s* zx_DEEP_CLONE_prov_PMActivate(struct zx_ctx* c, struct zx_prov_PMActivate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMActivate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMActivate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PMActivateItem->gg;
       e && e->g.tok == zx_prov_PMActivateItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMActivateItem(c,(struct zx_prov_PMActivateItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMActivateItem = (struct zx_prov_PMActivateItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->NotifyTo = zx_deep_clone_simple_elems(c,x->NotifyTo, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMActivate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMActivate(struct zx_ctx* c, struct zx_prov_PMActivate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMActivateItem->gg;
       e && e->g.tok == zx_prov_PMActivateItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMActivateItem(c, (struct zx_prov_PMActivateItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->NotifyTo, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMActivate) */

int zx_WALK_WO_prov_PMActivate(struct zx_ctx* c, struct zx_prov_PMActivate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMActivateItem
#define EL_STRUCT zx_prov_PMActivateItem_s
#define EL_NS     prov
#define EL_TAG    PMActivateItem

/* FUNC(zx_FREE_prov_PMActivateItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMActivateItem(struct zx_ctx* c, struct zx_prov_PMActivateItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->at, free_strs);
  zx_free_attr(c, x->itemID, free_strs);

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMID(c, (struct zx_prov_PMID_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMActivateItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMActivateItem_s* zx_NEW_prov_PMActivateItem(struct zx_ctx* c)
{
  struct zx_prov_PMActivateItem_s* x = ZX_ZALLOC(c, struct zx_prov_PMActivateItem_s);
  x->gg.g.tok = zx_prov_PMActivateItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMActivateItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMActivateItem(struct zx_ctx* c, struct zx_prov_PMActivateItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->at);
  zx_dup_attr(c, x->itemID);

  for (se = &x->PMID->gg;
       se && se->g.tok == zx_prov_PMID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMID(c, (struct zx_prov_PMID_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMActivateItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMActivateItem_s* zx_DEEP_CLONE_prov_PMActivateItem(struct zx_ctx* c, struct zx_prov_PMActivateItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMActivateItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMActivateItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->at = zx_clone_attr(c, x->at);
  x->itemID = zx_clone_attr(c, x->itemID);

  for (enn = 0, e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMID(c,(struct zx_prov_PMID_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMID = (struct zx_prov_PMID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMActivateItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMActivateItem(struct zx_ctx* c, struct zx_prov_PMActivateItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMID(c, (struct zx_prov_PMID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMActivateItem) */

int zx_WALK_WO_prov_PMActivateItem(struct zx_ctx* c, struct zx_prov_PMActivateItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMActivateResponse
#define EL_STRUCT zx_prov_PMActivateResponse_s
#define EL_NS     prov
#define EL_TAG    PMActivateResponse

/* FUNC(zx_FREE_prov_PMActivateResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMActivateResponse(struct zx_ctx* c, struct zx_prov_PMActivateResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMActivateResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMActivateResponse_s* zx_NEW_prov_PMActivateResponse(struct zx_ctx* c)
{
  struct zx_prov_PMActivateResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMActivateResponse_s);
  x->gg.g.tok = zx_prov_PMActivateResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMActivateResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMActivateResponse(struct zx_ctx* c, struct zx_prov_PMActivateResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMActivateResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMActivateResponse_s* zx_DEEP_CLONE_prov_PMActivateResponse(struct zx_ctx* c, struct zx_prov_PMActivateResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMActivateResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMActivateResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMActivateResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMActivateResponse(struct zx_ctx* c, struct zx_prov_PMActivateResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMActivateResponse) */

int zx_WALK_WO_prov_PMActivateResponse(struct zx_ctx* c, struct zx_prov_PMActivateResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMDeactivate
#define EL_STRUCT zx_prov_PMDeactivate_s
#define EL_NS     prov
#define EL_TAG    PMDeactivate

/* FUNC(zx_FREE_prov_PMDeactivate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMDeactivate(struct zx_ctx* c, struct zx_prov_PMDeactivate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PMDeactivateItem->gg;
       e && e->g.tok == zx_prov_PMDeactivateItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMDeactivateItem(c, (struct zx_prov_PMDeactivateItem_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->NotifyTo, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMDeactivate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMDeactivate_s* zx_NEW_prov_PMDeactivate(struct zx_ctx* c)
{
  struct zx_prov_PMDeactivate_s* x = ZX_ZALLOC(c, struct zx_prov_PMDeactivate_s);
  x->gg.g.tok = zx_prov_PMDeactivate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMDeactivate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMDeactivate(struct zx_ctx* c, struct zx_prov_PMDeactivate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PMDeactivateItem->gg;
       se && se->g.tok == zx_prov_PMDeactivateItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMDeactivateItem(c, (struct zx_prov_PMDeactivateItem_s*)se);
  zx_dup_strs_simple_elems(c, x->NotifyTo);

}

/* FUNC(zx_DEEP_CLONE_prov_PMDeactivate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMDeactivate_s* zx_DEEP_CLONE_prov_PMDeactivate(struct zx_ctx* c, struct zx_prov_PMDeactivate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMDeactivate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMDeactivate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PMDeactivateItem->gg;
       e && e->g.tok == zx_prov_PMDeactivateItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMDeactivateItem(c,(struct zx_prov_PMDeactivateItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMDeactivateItem = (struct zx_prov_PMDeactivateItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->NotifyTo = zx_deep_clone_simple_elems(c,x->NotifyTo, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMDeactivate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMDeactivate(struct zx_ctx* c, struct zx_prov_PMDeactivate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMDeactivateItem->gg;
       e && e->g.tok == zx_prov_PMDeactivateItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMDeactivateItem(c, (struct zx_prov_PMDeactivateItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->NotifyTo, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMDeactivate) */

int zx_WALK_WO_prov_PMDeactivate(struct zx_ctx* c, struct zx_prov_PMDeactivate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMDeactivateItem
#define EL_STRUCT zx_prov_PMDeactivateItem_s
#define EL_NS     prov
#define EL_TAG    PMDeactivateItem

/* FUNC(zx_FREE_prov_PMDeactivateItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMDeactivateItem(struct zx_ctx* c, struct zx_prov_PMDeactivateItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->at, free_strs);
  zx_free_attr(c, x->itemID, free_strs);

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMID(c, (struct zx_prov_PMID_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMDeactivateItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMDeactivateItem_s* zx_NEW_prov_PMDeactivateItem(struct zx_ctx* c)
{
  struct zx_prov_PMDeactivateItem_s* x = ZX_ZALLOC(c, struct zx_prov_PMDeactivateItem_s);
  x->gg.g.tok = zx_prov_PMDeactivateItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMDeactivateItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMDeactivateItem(struct zx_ctx* c, struct zx_prov_PMDeactivateItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->at);
  zx_dup_attr(c, x->itemID);

  for (se = &x->PMID->gg;
       se && se->g.tok == zx_prov_PMID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMID(c, (struct zx_prov_PMID_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMDeactivateItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMDeactivateItem_s* zx_DEEP_CLONE_prov_PMDeactivateItem(struct zx_ctx* c, struct zx_prov_PMDeactivateItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMDeactivateItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMDeactivateItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->at = zx_clone_attr(c, x->at);
  x->itemID = zx_clone_attr(c, x->itemID);

  for (enn = 0, e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMID(c,(struct zx_prov_PMID_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMID = (struct zx_prov_PMID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMDeactivateItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMDeactivateItem(struct zx_ctx* c, struct zx_prov_PMDeactivateItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMID(c, (struct zx_prov_PMID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMDeactivateItem) */

int zx_WALK_WO_prov_PMDeactivateItem(struct zx_ctx* c, struct zx_prov_PMDeactivateItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMDeactivateResponse
#define EL_STRUCT zx_prov_PMDeactivateResponse_s
#define EL_NS     prov
#define EL_TAG    PMDeactivateResponse

/* FUNC(zx_FREE_prov_PMDeactivateResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMDeactivateResponse(struct zx_ctx* c, struct zx_prov_PMDeactivateResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMDeactivateResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMDeactivateResponse_s* zx_NEW_prov_PMDeactivateResponse(struct zx_ctx* c)
{
  struct zx_prov_PMDeactivateResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMDeactivateResponse_s);
  x->gg.g.tok = zx_prov_PMDeactivateResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMDeactivateResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMDeactivateResponse(struct zx_ctx* c, struct zx_prov_PMDeactivateResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMDeactivateResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMDeactivateResponse_s* zx_DEEP_CLONE_prov_PMDeactivateResponse(struct zx_ctx* c, struct zx_prov_PMDeactivateResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMDeactivateResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMDeactivateResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMDeactivateResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMDeactivateResponse(struct zx_ctx* c, struct zx_prov_PMDeactivateResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMDeactivateResponse) */

int zx_WALK_WO_prov_PMDeactivateResponse(struct zx_ctx* c, struct zx_prov_PMDeactivateResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMDelete
#define EL_STRUCT zx_prov_PMDelete_s
#define EL_NS     prov
#define EL_TAG    PMDelete

/* FUNC(zx_FREE_prov_PMDelete) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMDelete(struct zx_ctx* c, struct zx_prov_PMDelete_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PMDeleteItem->gg;
       e && e->g.tok == zx_prov_PMDeleteItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMDeleteItem(c, (struct zx_prov_PMDeleteItem_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->NotifyTo, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMDelete) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMDelete_s* zx_NEW_prov_PMDelete(struct zx_ctx* c)
{
  struct zx_prov_PMDelete_s* x = ZX_ZALLOC(c, struct zx_prov_PMDelete_s);
  x->gg.g.tok = zx_prov_PMDelete_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMDelete) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMDelete(struct zx_ctx* c, struct zx_prov_PMDelete_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PMDeleteItem->gg;
       se && se->g.tok == zx_prov_PMDeleteItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMDeleteItem(c, (struct zx_prov_PMDeleteItem_s*)se);
  zx_dup_strs_simple_elems(c, x->NotifyTo);

}

/* FUNC(zx_DEEP_CLONE_prov_PMDelete) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMDelete_s* zx_DEEP_CLONE_prov_PMDelete(struct zx_ctx* c, struct zx_prov_PMDelete_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMDelete_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMDelete_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PMDeleteItem->gg;
       e && e->g.tok == zx_prov_PMDeleteItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMDeleteItem(c,(struct zx_prov_PMDeleteItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMDeleteItem = (struct zx_prov_PMDeleteItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->NotifyTo = zx_deep_clone_simple_elems(c,x->NotifyTo, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMDelete) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMDelete(struct zx_ctx* c, struct zx_prov_PMDelete_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMDeleteItem->gg;
       e && e->g.tok == zx_prov_PMDeleteItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMDeleteItem(c, (struct zx_prov_PMDeleteItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->NotifyTo, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMDelete) */

int zx_WALK_WO_prov_PMDelete(struct zx_ctx* c, struct zx_prov_PMDelete_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMDeleteItem
#define EL_STRUCT zx_prov_PMDeleteItem_s
#define EL_NS     prov
#define EL_TAG    PMDeleteItem

/* FUNC(zx_FREE_prov_PMDeleteItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMDeleteItem(struct zx_ctx* c, struct zx_prov_PMDeleteItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->itemID, free_strs);

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMID(c, (struct zx_prov_PMID_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMDeleteItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMDeleteItem_s* zx_NEW_prov_PMDeleteItem(struct zx_ctx* c)
{
  struct zx_prov_PMDeleteItem_s* x = ZX_ZALLOC(c, struct zx_prov_PMDeleteItem_s);
  x->gg.g.tok = zx_prov_PMDeleteItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMDeleteItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMDeleteItem(struct zx_ctx* c, struct zx_prov_PMDeleteItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->itemID);

  for (se = &x->PMID->gg;
       se && se->g.tok == zx_prov_PMID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMID(c, (struct zx_prov_PMID_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMDeleteItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMDeleteItem_s* zx_DEEP_CLONE_prov_PMDeleteItem(struct zx_ctx* c, struct zx_prov_PMDeleteItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMDeleteItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMDeleteItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->itemID = zx_clone_attr(c, x->itemID);

  for (enn = 0, e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMID(c,(struct zx_prov_PMID_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMID = (struct zx_prov_PMID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMDeleteItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMDeleteItem(struct zx_ctx* c, struct zx_prov_PMDeleteItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMID(c, (struct zx_prov_PMID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMDeleteItem) */

int zx_WALK_WO_prov_PMDeleteItem(struct zx_ctx* c, struct zx_prov_PMDeleteItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMDeleteResponse
#define EL_STRUCT zx_prov_PMDeleteResponse_s
#define EL_NS     prov
#define EL_TAG    PMDeleteResponse

/* FUNC(zx_FREE_prov_PMDeleteResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMDeleteResponse(struct zx_ctx* c, struct zx_prov_PMDeleteResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMDeleteResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMDeleteResponse_s* zx_NEW_prov_PMDeleteResponse(struct zx_ctx* c)
{
  struct zx_prov_PMDeleteResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMDeleteResponse_s);
  x->gg.g.tok = zx_prov_PMDeleteResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMDeleteResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMDeleteResponse(struct zx_ctx* c, struct zx_prov_PMDeleteResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMDeleteResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMDeleteResponse_s* zx_DEEP_CLONE_prov_PMDeleteResponse(struct zx_ctx* c, struct zx_prov_PMDeleteResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMDeleteResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMDeleteResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMDeleteResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMDeleteResponse(struct zx_ctx* c, struct zx_prov_PMDeleteResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMDeleteResponse) */

int zx_WALK_WO_prov_PMDeleteResponse(struct zx_ctx* c, struct zx_prov_PMDeleteResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMDescriptor
#define EL_STRUCT zx_prov_PMDescriptor_s
#define EL_NS     prov
#define EL_TAG    PMDescriptor

/* FUNC(zx_FREE_prov_PMDescriptor) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMDescriptor(struct zx_ctx* c, struct zx_prov_PMDescriptor_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->activate, free_strs);
  zx_free_attr(c, x->activateAt, free_strs);
  zx_free_attr(c, x->deactivateAt, free_strs);

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMID(c, (struct zx_prov_PMID_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->PMEngineRef, free_strs);
  zx_free_simple_elems(c, x->PMInitData, free_strs);
  zx_free_simple_elems(c, x->PMRTData, free_strs);
  for (e = &x->Signature->gg;
       e && e->g.tok == zx_ds_Signature_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_ds_Signature(c, (struct zx_ds_Signature_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMDescriptor) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMDescriptor_s* zx_NEW_prov_PMDescriptor(struct zx_ctx* c)
{
  struct zx_prov_PMDescriptor_s* x = ZX_ZALLOC(c, struct zx_prov_PMDescriptor_s);
  x->gg.g.tok = zx_prov_PMDescriptor_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMDescriptor) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMDescriptor(struct zx_ctx* c, struct zx_prov_PMDescriptor_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->activate);
  zx_dup_attr(c, x->activateAt);
  zx_dup_attr(c, x->deactivateAt);

  for (se = &x->PMID->gg;
       se && se->g.tok == zx_prov_PMID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMID(c, (struct zx_prov_PMID_s*)se);
  zx_dup_strs_simple_elems(c, x->PMEngineRef);
  zx_dup_strs_simple_elems(c, x->PMInitData);
  zx_dup_strs_simple_elems(c, x->PMRTData);
  for (se = &x->Signature->gg;
       se && se->g.tok == zx_ds_Signature_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ds_Signature(c, (struct zx_ds_Signature_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMDescriptor) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMDescriptor_s* zx_DEEP_CLONE_prov_PMDescriptor(struct zx_ctx* c, struct zx_prov_PMDescriptor_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMDescriptor_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMDescriptor_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->activate = zx_clone_attr(c, x->activate);
  x->activateAt = zx_clone_attr(c, x->activateAt);
  x->deactivateAt = zx_clone_attr(c, x->deactivateAt);

  for (enn = 0, e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMID(c,(struct zx_prov_PMID_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMID = (struct zx_prov_PMID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->PMEngineRef = zx_deep_clone_simple_elems(c,x->PMEngineRef, dup_strs);
  x->PMInitData = zx_deep_clone_simple_elems(c,x->PMInitData, dup_strs);
  x->PMRTData = zx_deep_clone_simple_elems(c,x->PMRTData, dup_strs);
  for (enn = 0, e = &x->Signature->gg;
       e && e->g.tok == zx_ds_Signature_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ds_Signature(c,(struct zx_ds_Signature_s*)e,dup_strs);
  	  if (!enn)
  	      x->Signature = (struct zx_ds_Signature_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMDescriptor) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMDescriptor(struct zx_ctx* c, struct zx_prov_PMDescriptor_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMID(c, (struct zx_prov_PMID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->PMEngineRef, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PMInitData, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PMRTData, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Signature->gg;
       e && e->g.tok == zx_ds_Signature_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ds_Signature(c, (struct zx_ds_Signature_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMDescriptor) */

int zx_WALK_WO_prov_PMDescriptor(struct zx_ctx* c, struct zx_prov_PMDescriptor_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEDelete
#define EL_STRUCT zx_prov_PMEDelete_s
#define EL_NS     prov
#define EL_TAG    PMEDelete

/* FUNC(zx_FREE_prov_PMEDelete) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEDelete(struct zx_ctx* c, struct zx_prov_PMEDelete_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->PMEngineRef, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEDelete) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEDelete_s* zx_NEW_prov_PMEDelete(struct zx_ctx* c)
{
  struct zx_prov_PMEDelete_s* x = ZX_ZALLOC(c, struct zx_prov_PMEDelete_s);
  x->gg.g.tok = zx_prov_PMEDelete_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEDelete) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEDelete(struct zx_ctx* c, struct zx_prov_PMEDelete_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->PMEngineRef);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEDelete) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEDelete_s* zx_DEEP_CLONE_prov_PMEDelete(struct zx_ctx* c, struct zx_prov_PMEDelete_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEDelete_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEDelete_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->PMEngineRef = zx_deep_clone_simple_elems(c,x->PMEngineRef, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEDelete) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEDelete(struct zx_ctx* c, struct zx_prov_PMEDelete_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PMEngineRef, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEDelete) */

int zx_WALK_WO_prov_PMEDelete(struct zx_ctx* c, struct zx_prov_PMEDelete_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEDeleteResponse
#define EL_STRUCT zx_prov_PMEDeleteResponse_s
#define EL_NS     prov
#define EL_TAG    PMEDeleteResponse

/* FUNC(zx_FREE_prov_PMEDeleteResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEDeleteResponse(struct zx_ctx* c, struct zx_prov_PMEDeleteResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEDeleteResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEDeleteResponse_s* zx_NEW_prov_PMEDeleteResponse(struct zx_ctx* c)
{
  struct zx_prov_PMEDeleteResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMEDeleteResponse_s);
  x->gg.g.tok = zx_prov_PMEDeleteResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEDeleteResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEDeleteResponse(struct zx_ctx* c, struct zx_prov_PMEDeleteResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEDeleteResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEDeleteResponse_s* zx_DEEP_CLONE_prov_PMEDeleteResponse(struct zx_ctx* c, struct zx_prov_PMEDeleteResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEDeleteResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEDeleteResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEDeleteResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEDeleteResponse(struct zx_ctx* c, struct zx_prov_PMEDeleteResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEDeleteResponse) */

int zx_WALK_WO_prov_PMEDeleteResponse(struct zx_ctx* c, struct zx_prov_PMEDeleteResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEDisable
#define EL_STRUCT zx_prov_PMEDisable_s
#define EL_NS     prov
#define EL_TAG    PMEDisable

/* FUNC(zx_FREE_prov_PMEDisable) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEDisable(struct zx_ctx* c, struct zx_prov_PMEDisable_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->PMEngineRef, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEDisable) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEDisable_s* zx_NEW_prov_PMEDisable(struct zx_ctx* c)
{
  struct zx_prov_PMEDisable_s* x = ZX_ZALLOC(c, struct zx_prov_PMEDisable_s);
  x->gg.g.tok = zx_prov_PMEDisable_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEDisable) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEDisable(struct zx_ctx* c, struct zx_prov_PMEDisable_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->PMEngineRef);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEDisable) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEDisable_s* zx_DEEP_CLONE_prov_PMEDisable(struct zx_ctx* c, struct zx_prov_PMEDisable_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEDisable_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEDisable_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->PMEngineRef = zx_deep_clone_simple_elems(c,x->PMEngineRef, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEDisable) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEDisable(struct zx_ctx* c, struct zx_prov_PMEDisable_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PMEngineRef, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEDisable) */

int zx_WALK_WO_prov_PMEDisable(struct zx_ctx* c, struct zx_prov_PMEDisable_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEDisableResponse
#define EL_STRUCT zx_prov_PMEDisableResponse_s
#define EL_NS     prov
#define EL_TAG    PMEDisableResponse

/* FUNC(zx_FREE_prov_PMEDisableResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEDisableResponse(struct zx_ctx* c, struct zx_prov_PMEDisableResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEDisableResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEDisableResponse_s* zx_NEW_prov_PMEDisableResponse(struct zx_ctx* c)
{
  struct zx_prov_PMEDisableResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMEDisableResponse_s);
  x->gg.g.tok = zx_prov_PMEDisableResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEDisableResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEDisableResponse(struct zx_ctx* c, struct zx_prov_PMEDisableResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEDisableResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEDisableResponse_s* zx_DEEP_CLONE_prov_PMEDisableResponse(struct zx_ctx* c, struct zx_prov_PMEDisableResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEDisableResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEDisableResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEDisableResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEDisableResponse(struct zx_ctx* c, struct zx_prov_PMEDisableResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEDisableResponse) */

int zx_WALK_WO_prov_PMEDisableResponse(struct zx_ctx* c, struct zx_prov_PMEDisableResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEDownload
#define EL_STRUCT zx_prov_PMEDownload_s
#define EL_NS     prov
#define EL_TAG    PMEDownload

/* FUNC(zx_FREE_prov_PMEDownload) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEDownload(struct zx_ctx* c, struct zx_prov_PMEDownload_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->PMEngineRef, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEDownload) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEDownload_s* zx_NEW_prov_PMEDownload(struct zx_ctx* c)
{
  struct zx_prov_PMEDownload_s* x = ZX_ZALLOC(c, struct zx_prov_PMEDownload_s);
  x->gg.g.tok = zx_prov_PMEDownload_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEDownload) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEDownload(struct zx_ctx* c, struct zx_prov_PMEDownload_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->PMEngineRef);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEDownload) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEDownload_s* zx_DEEP_CLONE_prov_PMEDownload(struct zx_ctx* c, struct zx_prov_PMEDownload_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEDownload_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEDownload_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->PMEngineRef = zx_deep_clone_simple_elems(c,x->PMEngineRef, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEDownload) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEDownload(struct zx_ctx* c, struct zx_prov_PMEDownload_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PMEngineRef, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEDownload) */

int zx_WALK_WO_prov_PMEDownload(struct zx_ctx* c, struct zx_prov_PMEDownload_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEDownloadResponse
#define EL_STRUCT zx_prov_PMEDownloadResponse_s
#define EL_NS     prov
#define EL_TAG    PMEDownloadResponse

/* FUNC(zx_FREE_prov_PMEDownloadResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEDownloadResponse(struct zx_ctx* c, struct zx_prov_PMEDownloadResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->EngineData, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEDownloadResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEDownloadResponse_s* zx_NEW_prov_PMEDownloadResponse(struct zx_ctx* c)
{
  struct zx_prov_PMEDownloadResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMEDownloadResponse_s);
  x->gg.g.tok = zx_prov_PMEDownloadResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEDownloadResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEDownloadResponse(struct zx_ctx* c, struct zx_prov_PMEDownloadResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);
  zx_dup_strs_simple_elems(c, x->EngineData);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEDownloadResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEDownloadResponse_s* zx_DEEP_CLONE_prov_PMEDownloadResponse(struct zx_ctx* c, struct zx_prov_PMEDownloadResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEDownloadResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEDownloadResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->EngineData = zx_deep_clone_simple_elems(c,x->EngineData, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEDownloadResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEDownloadResponse(struct zx_ctx* c, struct zx_prov_PMEDownloadResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->EngineData, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEDownloadResponse) */

int zx_WALK_WO_prov_PMEDownloadResponse(struct zx_ctx* c, struct zx_prov_PMEDownloadResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEEnable
#define EL_STRUCT zx_prov_PMEEnable_s
#define EL_NS     prov
#define EL_TAG    PMEEnable

/* FUNC(zx_FREE_prov_PMEEnable) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEEnable(struct zx_ctx* c, struct zx_prov_PMEEnable_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->PMEngineRef, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEEnable) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEEnable_s* zx_NEW_prov_PMEEnable(struct zx_ctx* c)
{
  struct zx_prov_PMEEnable_s* x = ZX_ZALLOC(c, struct zx_prov_PMEEnable_s);
  x->gg.g.tok = zx_prov_PMEEnable_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEEnable) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEEnable(struct zx_ctx* c, struct zx_prov_PMEEnable_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->PMEngineRef);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEEnable) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEEnable_s* zx_DEEP_CLONE_prov_PMEEnable(struct zx_ctx* c, struct zx_prov_PMEEnable_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEEnable_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEEnable_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->PMEngineRef = zx_deep_clone_simple_elems(c,x->PMEngineRef, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEEnable) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEEnable(struct zx_ctx* c, struct zx_prov_PMEEnable_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PMEngineRef, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEEnable) */

int zx_WALK_WO_prov_PMEEnable(struct zx_ctx* c, struct zx_prov_PMEEnable_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEEnableResponse
#define EL_STRUCT zx_prov_PMEEnableResponse_s
#define EL_NS     prov
#define EL_TAG    PMEEnableResponse

/* FUNC(zx_FREE_prov_PMEEnableResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEEnableResponse(struct zx_ctx* c, struct zx_prov_PMEEnableResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEEnableResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEEnableResponse_s* zx_NEW_prov_PMEEnableResponse(struct zx_ctx* c)
{
  struct zx_prov_PMEEnableResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMEEnableResponse_s);
  x->gg.g.tok = zx_prov_PMEEnableResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEEnableResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEEnableResponse(struct zx_ctx* c, struct zx_prov_PMEEnableResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEEnableResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEEnableResponse_s* zx_DEEP_CLONE_prov_PMEEnableResponse(struct zx_ctx* c, struct zx_prov_PMEEnableResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEEnableResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEEnableResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEEnableResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEEnableResponse(struct zx_ctx* c, struct zx_prov_PMEEnableResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEEnableResponse) */

int zx_WALK_WO_prov_PMEEnableResponse(struct zx_ctx* c, struct zx_prov_PMEEnableResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEGetInfo
#define EL_STRUCT zx_prov_PMEGetInfo_s
#define EL_NS     prov
#define EL_TAG    PMEGetInfo

/* FUNC(zx_FREE_prov_PMEGetInfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEGetInfo(struct zx_ctx* c, struct zx_prov_PMEGetInfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->PMEngineRef, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEGetInfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEGetInfo_s* zx_NEW_prov_PMEGetInfo(struct zx_ctx* c)
{
  struct zx_prov_PMEGetInfo_s* x = ZX_ZALLOC(c, struct zx_prov_PMEGetInfo_s);
  x->gg.g.tok = zx_prov_PMEGetInfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEGetInfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEGetInfo(struct zx_ctx* c, struct zx_prov_PMEGetInfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->PMEngineRef);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEGetInfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEGetInfo_s* zx_DEEP_CLONE_prov_PMEGetInfo(struct zx_ctx* c, struct zx_prov_PMEGetInfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEGetInfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEGetInfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->PMEngineRef = zx_deep_clone_simple_elems(c,x->PMEngineRef, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEGetInfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEGetInfo(struct zx_ctx* c, struct zx_prov_PMEGetInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PMEngineRef, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEGetInfo) */

int zx_WALK_WO_prov_PMEGetInfo(struct zx_ctx* c, struct zx_prov_PMEGetInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEGetInfoResponse
#define EL_STRUCT zx_prov_PMEGetInfoResponse_s
#define EL_NS     prov
#define EL_TAG    PMEGetInfoResponse

/* FUNC(zx_FREE_prov_PMEGetInfoResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEGetInfoResponse(struct zx_ctx* c, struct zx_prov_PMEGetInfoResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }
  for (e = &x->PMEInfo->gg;
       e && e->g.tok == zx_prov_PMEInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMEInfo(c, (struct zx_prov_PMEInfo_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEGetInfoResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEGetInfoResponse_s* zx_NEW_prov_PMEGetInfoResponse(struct zx_ctx* c)
{
  struct zx_prov_PMEGetInfoResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMEGetInfoResponse_s);
  x->gg.g.tok = zx_prov_PMEGetInfoResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEGetInfoResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEGetInfoResponse(struct zx_ctx* c, struct zx_prov_PMEGetInfoResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);
  for (se = &x->PMEInfo->gg;
       se && se->g.tok == zx_prov_PMEInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMEInfo(c, (struct zx_prov_PMEInfo_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEGetInfoResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEGetInfoResponse_s* zx_DEEP_CLONE_prov_PMEGetInfoResponse(struct zx_ctx* c, struct zx_prov_PMEGetInfoResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEGetInfoResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEGetInfoResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PMEInfo->gg;
       e && e->g.tok == zx_prov_PMEInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMEInfo(c,(struct zx_prov_PMEInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMEInfo = (struct zx_prov_PMEInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEGetInfoResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEGetInfoResponse(struct zx_ctx* c, struct zx_prov_PMEGetInfoResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PMEInfo->gg;
       e && e->g.tok == zx_prov_PMEInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMEInfo(c, (struct zx_prov_PMEInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEGetInfoResponse) */

int zx_WALK_WO_prov_PMEGetInfoResponse(struct zx_ctx* c, struct zx_prov_PMEGetInfoResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEHash
#define EL_STRUCT zx_prov_PMEHash_s
#define EL_NS     prov
#define EL_TAG    PMEHash

/* FUNC(zx_FREE_prov_PMEHash) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEHash(struct zx_ctx* c, struct zx_prov_PMEHash_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->method, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEHash) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEHash_s* zx_NEW_prov_PMEHash(struct zx_ctx* c)
{
  struct zx_prov_PMEHash_s* x = ZX_ZALLOC(c, struct zx_prov_PMEHash_s);
  x->gg.g.tok = zx_prov_PMEHash_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEHash) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEHash(struct zx_ctx* c, struct zx_prov_PMEHash_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->method);


}

/* FUNC(zx_DEEP_CLONE_prov_PMEHash) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEHash_s* zx_DEEP_CLONE_prov_PMEHash(struct zx_ctx* c, struct zx_prov_PMEHash_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEHash_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEHash_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->method = zx_clone_attr(c, x->method);


  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEHash) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEHash(struct zx_ctx* c, struct zx_prov_PMEHash_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEHash) */

int zx_WALK_WO_prov_PMEHash(struct zx_ctx* c, struct zx_prov_PMEHash_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEInfo
#define EL_STRUCT zx_prov_PMEInfo_s
#define EL_NS     prov
#define EL_TAG    PMEInfo

/* FUNC(zx_FREE_prov_PMEInfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEInfo(struct zx_ctx* c, struct zx_prov_PMEInfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->PMEngineRef, free_strs);
  zx_free_simple_elems(c, x->PMECreatorID, free_strs);
  zx_free_simple_elems(c, x->PMEWhenCreated, free_strs);
  zx_free_simple_elems(c, x->PMEEnabled, free_strs);
  zx_free_simple_elems(c, x->PMEWhenEnabled, free_strs);
  zx_free_simple_elems(c, x->PMESize, free_strs);
  for (e = &x->PMEHash->gg;
       e && e->g.tok == zx_prov_PMEHash_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMEHash(c, (struct zx_prov_PMEHash_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEInfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEInfo_s* zx_NEW_prov_PMEInfo(struct zx_ctx* c)
{
  struct zx_prov_PMEInfo_s* x = ZX_ZALLOC(c, struct zx_prov_PMEInfo_s);
  x->gg.g.tok = zx_prov_PMEInfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEInfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEInfo(struct zx_ctx* c, struct zx_prov_PMEInfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->PMEngineRef);
  zx_dup_strs_simple_elems(c, x->PMECreatorID);
  zx_dup_strs_simple_elems(c, x->PMEWhenCreated);
  zx_dup_strs_simple_elems(c, x->PMEEnabled);
  zx_dup_strs_simple_elems(c, x->PMEWhenEnabled);
  zx_dup_strs_simple_elems(c, x->PMESize);
  for (se = &x->PMEHash->gg;
       se && se->g.tok == zx_prov_PMEHash_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMEHash(c, (struct zx_prov_PMEHash_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEInfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEInfo_s* zx_DEEP_CLONE_prov_PMEInfo(struct zx_ctx* c, struct zx_prov_PMEInfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEInfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEInfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->PMEngineRef = zx_deep_clone_simple_elems(c,x->PMEngineRef, dup_strs);
  x->PMECreatorID = zx_deep_clone_simple_elems(c,x->PMECreatorID, dup_strs);
  x->PMEWhenCreated = zx_deep_clone_simple_elems(c,x->PMEWhenCreated, dup_strs);
  x->PMEEnabled = zx_deep_clone_simple_elems(c,x->PMEEnabled, dup_strs);
  x->PMEWhenEnabled = zx_deep_clone_simple_elems(c,x->PMEWhenEnabled, dup_strs);
  x->PMESize = zx_deep_clone_simple_elems(c,x->PMESize, dup_strs);
  for (enn = 0, e = &x->PMEHash->gg;
       e && e->g.tok == zx_prov_PMEHash_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMEHash(c,(struct zx_prov_PMEHash_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMEHash = (struct zx_prov_PMEHash_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEInfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEInfo(struct zx_ctx* c, struct zx_prov_PMEInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PMEngineRef, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PMECreatorID, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PMEWhenCreated, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PMEEnabled, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PMEWhenEnabled, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PMESize, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PMEHash->gg;
       e && e->g.tok == zx_prov_PMEHash_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMEHash(c, (struct zx_prov_PMEHash_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEInfo) */

int zx_WALK_WO_prov_PMEInfo(struct zx_ctx* c, struct zx_prov_PMEInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMERegister
#define EL_STRUCT zx_prov_PMERegister_s
#define EL_NS     prov
#define EL_TAG    PMERegister

/* FUNC(zx_FREE_prov_PMERegister) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMERegister(struct zx_ctx* c, struct zx_prov_PMERegister_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->PMEngineRef, free_strs);
  zx_free_simple_elems(c, x->PMESize, free_strs);
  for (e = &x->PMEHash->gg;
       e && e->g.tok == zx_prov_PMEHash_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMEHash(c, (struct zx_prov_PMEHash_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMERegister) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMERegister_s* zx_NEW_prov_PMERegister(struct zx_ctx* c)
{
  struct zx_prov_PMERegister_s* x = ZX_ZALLOC(c, struct zx_prov_PMERegister_s);
  x->gg.g.tok = zx_prov_PMERegister_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMERegister) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMERegister(struct zx_ctx* c, struct zx_prov_PMERegister_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->PMEngineRef);
  zx_dup_strs_simple_elems(c, x->PMESize);
  for (se = &x->PMEHash->gg;
       se && se->g.tok == zx_prov_PMEHash_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMEHash(c, (struct zx_prov_PMEHash_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMERegister) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMERegister_s* zx_DEEP_CLONE_prov_PMERegister(struct zx_ctx* c, struct zx_prov_PMERegister_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMERegister_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMERegister_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->PMEngineRef = zx_deep_clone_simple_elems(c,x->PMEngineRef, dup_strs);
  x->PMESize = zx_deep_clone_simple_elems(c,x->PMESize, dup_strs);
  for (enn = 0, e = &x->PMEHash->gg;
       e && e->g.tok == zx_prov_PMEHash_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMEHash(c,(struct zx_prov_PMEHash_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMEHash = (struct zx_prov_PMEHash_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMERegister) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMERegister(struct zx_ctx* c, struct zx_prov_PMERegister_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PMEngineRef, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PMESize, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PMEHash->gg;
       e && e->g.tok == zx_prov_PMEHash_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMEHash(c, (struct zx_prov_PMEHash_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMERegister) */

int zx_WALK_WO_prov_PMERegister(struct zx_ctx* c, struct zx_prov_PMERegister_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMERegisterResponse
#define EL_STRUCT zx_prov_PMERegisterResponse_s
#define EL_NS     prov
#define EL_TAG    PMERegisterResponse

/* FUNC(zx_FREE_prov_PMERegisterResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMERegisterResponse(struct zx_ctx* c, struct zx_prov_PMERegisterResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->PMEUploadMax, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMERegisterResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMERegisterResponse_s* zx_NEW_prov_PMERegisterResponse(struct zx_ctx* c)
{
  struct zx_prov_PMERegisterResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMERegisterResponse_s);
  x->gg.g.tok = zx_prov_PMERegisterResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMERegisterResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMERegisterResponse(struct zx_ctx* c, struct zx_prov_PMERegisterResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);
  zx_dup_strs_simple_elems(c, x->PMEUploadMax);

}

/* FUNC(zx_DEEP_CLONE_prov_PMERegisterResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMERegisterResponse_s* zx_DEEP_CLONE_prov_PMERegisterResponse(struct zx_ctx* c, struct zx_prov_PMERegisterResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMERegisterResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMERegisterResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->PMEUploadMax = zx_deep_clone_simple_elems(c,x->PMEUploadMax, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMERegisterResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMERegisterResponse(struct zx_ctx* c, struct zx_prov_PMERegisterResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->PMEUploadMax, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMERegisterResponse) */

int zx_WALK_WO_prov_PMERegisterResponse(struct zx_ctx* c, struct zx_prov_PMERegisterResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEUpload
#define EL_STRUCT zx_prov_PMEUpload_s
#define EL_NS     prov
#define EL_TAG    PMEUpload

/* FUNC(zx_FREE_prov_PMEUpload) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEUpload(struct zx_ctx* c, struct zx_prov_PMEUpload_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->offset, free_strs);
  zx_free_attr(c, x->remaining, free_strs);

  zx_free_simple_elems(c, x->PMEngineRef, free_strs);
  zx_free_simple_elems(c, x->EngineData, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEUpload) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEUpload_s* zx_NEW_prov_PMEUpload(struct zx_ctx* c)
{
  struct zx_prov_PMEUpload_s* x = ZX_ZALLOC(c, struct zx_prov_PMEUpload_s);
  x->gg.g.tok = zx_prov_PMEUpload_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEUpload) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEUpload(struct zx_ctx* c, struct zx_prov_PMEUpload_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->offset);
  zx_dup_attr(c, x->remaining);

  zx_dup_strs_simple_elems(c, x->PMEngineRef);
  zx_dup_strs_simple_elems(c, x->EngineData);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEUpload) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEUpload_s* zx_DEEP_CLONE_prov_PMEUpload(struct zx_ctx* c, struct zx_prov_PMEUpload_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEUpload_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEUpload_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->offset = zx_clone_attr(c, x->offset);
  x->remaining = zx_clone_attr(c, x->remaining);

  x->PMEngineRef = zx_deep_clone_simple_elems(c,x->PMEngineRef, dup_strs);
  x->EngineData = zx_deep_clone_simple_elems(c,x->EngineData, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEUpload) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEUpload(struct zx_ctx* c, struct zx_prov_PMEUpload_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PMEngineRef, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->EngineData, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEUpload) */

int zx_WALK_WO_prov_PMEUpload(struct zx_ctx* c, struct zx_prov_PMEUpload_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMEUploadResponse
#define EL_STRUCT zx_prov_PMEUploadResponse_s
#define EL_NS     prov
#define EL_TAG    PMEUploadResponse

/* FUNC(zx_FREE_prov_PMEUploadResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMEUploadResponse(struct zx_ctx* c, struct zx_prov_PMEUploadResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMEUploadResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMEUploadResponse_s* zx_NEW_prov_PMEUploadResponse(struct zx_ctx* c)
{
  struct zx_prov_PMEUploadResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMEUploadResponse_s);
  x->gg.g.tok = zx_prov_PMEUploadResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMEUploadResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMEUploadResponse(struct zx_ctx* c, struct zx_prov_PMEUploadResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMEUploadResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMEUploadResponse_s* zx_DEEP_CLONE_prov_PMEUploadResponse(struct zx_ctx* c, struct zx_prov_PMEUploadResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMEUploadResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMEUploadResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMEUploadResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMEUploadResponse(struct zx_ctx* c, struct zx_prov_PMEUploadResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMEUploadResponse) */

int zx_WALK_WO_prov_PMEUploadResponse(struct zx_ctx* c, struct zx_prov_PMEUploadResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMGetDescriptor
#define EL_STRUCT zx_prov_PMGetDescriptor_s
#define EL_NS     prov
#define EL_TAG    PMGetDescriptor

/* FUNC(zx_FREE_prov_PMGetDescriptor) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMGetDescriptor(struct zx_ctx* c, struct zx_prov_PMGetDescriptor_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->PMDArtifact, free_strs);
  for (e = &x->CallbackEPR->gg;
       e && e->g.tok == zx_prov_CallbackEPR_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_CallbackEPR(c, (struct zx_prov_CallbackEPR_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMGetDescriptor) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMGetDescriptor_s* zx_NEW_prov_PMGetDescriptor(struct zx_ctx* c)
{
  struct zx_prov_PMGetDescriptor_s* x = ZX_ZALLOC(c, struct zx_prov_PMGetDescriptor_s);
  x->gg.g.tok = zx_prov_PMGetDescriptor_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMGetDescriptor) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMGetDescriptor(struct zx_ctx* c, struct zx_prov_PMGetDescriptor_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->PMDArtifact);
  for (se = &x->CallbackEPR->gg;
       se && se->g.tok == zx_prov_CallbackEPR_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_CallbackEPR(c, (struct zx_prov_CallbackEPR_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMGetDescriptor) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMGetDescriptor_s* zx_DEEP_CLONE_prov_PMGetDescriptor(struct zx_ctx* c, struct zx_prov_PMGetDescriptor_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMGetDescriptor_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMGetDescriptor_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->PMDArtifact = zx_deep_clone_simple_elems(c,x->PMDArtifact, dup_strs);
  for (enn = 0, e = &x->CallbackEPR->gg;
       e && e->g.tok == zx_prov_CallbackEPR_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_CallbackEPR(c,(struct zx_prov_CallbackEPR_s*)e,dup_strs);
  	  if (!enn)
  	      x->CallbackEPR = (struct zx_prov_CallbackEPR_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMGetDescriptor) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMGetDescriptor(struct zx_ctx* c, struct zx_prov_PMGetDescriptor_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PMDArtifact, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->CallbackEPR->gg;
       e && e->g.tok == zx_prov_CallbackEPR_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_CallbackEPR(c, (struct zx_prov_CallbackEPR_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMGetDescriptor) */

int zx_WALK_WO_prov_PMGetDescriptor(struct zx_ctx* c, struct zx_prov_PMGetDescriptor_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMGetDescriptorResponse
#define EL_STRUCT zx_prov_PMGetDescriptorResponse_s
#define EL_NS     prov
#define EL_TAG    PMGetDescriptorResponse

/* FUNC(zx_FREE_prov_PMGetDescriptorResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMGetDescriptorResponse(struct zx_ctx* c, struct zx_prov_PMGetDescriptorResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }
  for (e = &x->PMDescriptor->gg;
       e && e->g.tok == zx_prov_PMDescriptor_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMDescriptor(c, (struct zx_prov_PMDescriptor_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMGetDescriptorResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMGetDescriptorResponse_s* zx_NEW_prov_PMGetDescriptorResponse(struct zx_ctx* c)
{
  struct zx_prov_PMGetDescriptorResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMGetDescriptorResponse_s);
  x->gg.g.tok = zx_prov_PMGetDescriptorResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMGetDescriptorResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMGetDescriptorResponse(struct zx_ctx* c, struct zx_prov_PMGetDescriptorResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);
  for (se = &x->PMDescriptor->gg;
       se && se->g.tok == zx_prov_PMDescriptor_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMDescriptor(c, (struct zx_prov_PMDescriptor_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMGetDescriptorResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMGetDescriptorResponse_s* zx_DEEP_CLONE_prov_PMGetDescriptorResponse(struct zx_ctx* c, struct zx_prov_PMGetDescriptorResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMGetDescriptorResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMGetDescriptorResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PMDescriptor->gg;
       e && e->g.tok == zx_prov_PMDescriptor_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMDescriptor(c,(struct zx_prov_PMDescriptor_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMDescriptor = (struct zx_prov_PMDescriptor_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMGetDescriptorResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMGetDescriptorResponse(struct zx_ctx* c, struct zx_prov_PMGetDescriptorResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PMDescriptor->gg;
       e && e->g.tok == zx_prov_PMDescriptor_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMDescriptor(c, (struct zx_prov_PMDescriptor_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMGetDescriptorResponse) */

int zx_WALK_WO_prov_PMGetDescriptorResponse(struct zx_ctx* c, struct zx_prov_PMGetDescriptorResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMGetStatus
#define EL_STRUCT zx_prov_PMGetStatus_s
#define EL_NS     prov
#define EL_TAG    PMGetStatus

/* FUNC(zx_FREE_prov_PMGetStatus) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMGetStatus(struct zx_ctx* c, struct zx_prov_PMGetStatus_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMID(c, (struct zx_prov_PMID_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMGetStatus) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMGetStatus_s* zx_NEW_prov_PMGetStatus(struct zx_ctx* c)
{
  struct zx_prov_PMGetStatus_s* x = ZX_ZALLOC(c, struct zx_prov_PMGetStatus_s);
  x->gg.g.tok = zx_prov_PMGetStatus_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMGetStatus) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMGetStatus(struct zx_ctx* c, struct zx_prov_PMGetStatus_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PMID->gg;
       se && se->g.tok == zx_prov_PMID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMID(c, (struct zx_prov_PMID_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMGetStatus) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMGetStatus_s* zx_DEEP_CLONE_prov_PMGetStatus(struct zx_ctx* c, struct zx_prov_PMGetStatus_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMGetStatus_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMGetStatus_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMID(c,(struct zx_prov_PMID_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMID = (struct zx_prov_PMID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMGetStatus) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMGetStatus(struct zx_ctx* c, struct zx_prov_PMGetStatus_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMID(c, (struct zx_prov_PMID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMGetStatus) */

int zx_WALK_WO_prov_PMGetStatus(struct zx_ctx* c, struct zx_prov_PMGetStatus_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMGetStatusResponse
#define EL_STRUCT zx_prov_PMGetStatusResponse_s
#define EL_NS     prov
#define EL_TAG    PMGetStatusResponse

/* FUNC(zx_FREE_prov_PMGetStatusResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMGetStatusResponse(struct zx_ctx* c, struct zx_prov_PMGetStatusResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }
  for (e = &x->PMStatus->gg;
       e && e->g.tok == zx_prov_PMStatus_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMStatus(c, (struct zx_prov_PMStatus_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMGetStatusResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMGetStatusResponse_s* zx_NEW_prov_PMGetStatusResponse(struct zx_ctx* c)
{
  struct zx_prov_PMGetStatusResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMGetStatusResponse_s);
  x->gg.g.tok = zx_prov_PMGetStatusResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMGetStatusResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMGetStatusResponse(struct zx_ctx* c, struct zx_prov_PMGetStatusResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);
  for (se = &x->PMStatus->gg;
       se && se->g.tok == zx_prov_PMStatus_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMStatus(c, (struct zx_prov_PMStatus_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMGetStatusResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMGetStatusResponse_s* zx_DEEP_CLONE_prov_PMGetStatusResponse(struct zx_ctx* c, struct zx_prov_PMGetStatusResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMGetStatusResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMGetStatusResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PMStatus->gg;
       e && e->g.tok == zx_prov_PMStatus_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMStatus(c,(struct zx_prov_PMStatus_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMStatus = (struct zx_prov_PMStatus_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMGetStatusResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMGetStatusResponse(struct zx_ctx* c, struct zx_prov_PMGetStatusResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PMStatus->gg;
       e && e->g.tok == zx_prov_PMStatus_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMStatus(c, (struct zx_prov_PMStatus_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMGetStatusResponse) */

int zx_WALK_WO_prov_PMGetStatusResponse(struct zx_ctx* c, struct zx_prov_PMGetStatusResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMID
#define EL_STRUCT zx_prov_PMID_s
#define EL_NS     prov
#define EL_TAG    PMID

/* FUNC(zx_FREE_prov_PMID) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMID(struct zx_ctx* c, struct zx_prov_PMID_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->issuer, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMID) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMID_s* zx_NEW_prov_PMID(struct zx_ctx* c)
{
  struct zx_prov_PMID_s* x = ZX_ZALLOC(c, struct zx_prov_PMID_s);
  x->gg.g.tok = zx_prov_PMID_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMID) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMID(struct zx_ctx* c, struct zx_prov_PMID_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->issuer);


}

/* FUNC(zx_DEEP_CLONE_prov_PMID) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMID_s* zx_DEEP_CLONE_prov_PMID(struct zx_ctx* c, struct zx_prov_PMID_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMID_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMID_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->issuer = zx_clone_attr(c, x->issuer);


  return x;
}

/* FUNC(zx_WALK_SO_prov_PMID) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMID(struct zx_ctx* c, struct zx_prov_PMID_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMID) */

int zx_WALK_WO_prov_PMID(struct zx_ctx* c, struct zx_prov_PMID_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMRegisterDescriptor
#define EL_STRUCT zx_prov_PMRegisterDescriptor_s
#define EL_NS     prov
#define EL_TAG    PMRegisterDescriptor

/* FUNC(zx_FREE_prov_PMRegisterDescriptor) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMRegisterDescriptor(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptor_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PMRegisterDescriptorItem->gg;
       e && e->g.tok == zx_prov_PMRegisterDescriptorItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMRegisterDescriptorItem(c, (struct zx_prov_PMRegisterDescriptorItem_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMRegisterDescriptor) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMRegisterDescriptor_s* zx_NEW_prov_PMRegisterDescriptor(struct zx_ctx* c)
{
  struct zx_prov_PMRegisterDescriptor_s* x = ZX_ZALLOC(c, struct zx_prov_PMRegisterDescriptor_s);
  x->gg.g.tok = zx_prov_PMRegisterDescriptor_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMRegisterDescriptor) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMRegisterDescriptor(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptor_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PMRegisterDescriptorItem->gg;
       se && se->g.tok == zx_prov_PMRegisterDescriptorItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMRegisterDescriptorItem(c, (struct zx_prov_PMRegisterDescriptorItem_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMRegisterDescriptor) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMRegisterDescriptor_s* zx_DEEP_CLONE_prov_PMRegisterDescriptor(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptor_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMRegisterDescriptor_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMRegisterDescriptor_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PMRegisterDescriptorItem->gg;
       e && e->g.tok == zx_prov_PMRegisterDescriptorItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMRegisterDescriptorItem(c,(struct zx_prov_PMRegisterDescriptorItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMRegisterDescriptorItem = (struct zx_prov_PMRegisterDescriptorItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMRegisterDescriptor) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMRegisterDescriptor(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptor_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMRegisterDescriptorItem->gg;
       e && e->g.tok == zx_prov_PMRegisterDescriptorItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMRegisterDescriptorItem(c, (struct zx_prov_PMRegisterDescriptorItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMRegisterDescriptor) */

int zx_WALK_WO_prov_PMRegisterDescriptor(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptor_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMRegisterDescriptorItem
#define EL_STRUCT zx_prov_PMRegisterDescriptorItem_s
#define EL_NS     prov
#define EL_TAG    PMRegisterDescriptorItem

/* FUNC(zx_FREE_prov_PMRegisterDescriptorItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMRegisterDescriptorItem(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->itemID, free_strs);

  for (e = &x->PMDescriptor->gg;
       e && e->g.tok == zx_prov_PMDescriptor_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMDescriptor(c, (struct zx_prov_PMDescriptor_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMRegisterDescriptorItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMRegisterDescriptorItem_s* zx_NEW_prov_PMRegisterDescriptorItem(struct zx_ctx* c)
{
  struct zx_prov_PMRegisterDescriptorItem_s* x = ZX_ZALLOC(c, struct zx_prov_PMRegisterDescriptorItem_s);
  x->gg.g.tok = zx_prov_PMRegisterDescriptorItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMRegisterDescriptorItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMRegisterDescriptorItem(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->itemID);

  for (se = &x->PMDescriptor->gg;
       se && se->g.tok == zx_prov_PMDescriptor_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMDescriptor(c, (struct zx_prov_PMDescriptor_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMRegisterDescriptorItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMRegisterDescriptorItem_s* zx_DEEP_CLONE_prov_PMRegisterDescriptorItem(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMRegisterDescriptorItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMRegisterDescriptorItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->itemID = zx_clone_attr(c, x->itemID);

  for (enn = 0, e = &x->PMDescriptor->gg;
       e && e->g.tok == zx_prov_PMDescriptor_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMDescriptor(c,(struct zx_prov_PMDescriptor_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMDescriptor = (struct zx_prov_PMDescriptor_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMRegisterDescriptorItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMRegisterDescriptorItem(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMDescriptor->gg;
       e && e->g.tok == zx_prov_PMDescriptor_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMDescriptor(c, (struct zx_prov_PMDescriptor_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMRegisterDescriptorItem) */

int zx_WALK_WO_prov_PMRegisterDescriptorItem(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMRegisterDescriptorResponse
#define EL_STRUCT zx_prov_PMRegisterDescriptorResponse_s
#define EL_NS     prov
#define EL_TAG    PMRegisterDescriptorResponse

/* FUNC(zx_FREE_prov_PMRegisterDescriptorResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMRegisterDescriptorResponse(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }
  for (e = &x->PMRegisterDescriptorResponseItem->gg;
       e && e->g.tok == zx_prov_PMRegisterDescriptorResponseItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMRegisterDescriptorResponseItem(c, (struct zx_prov_PMRegisterDescriptorResponseItem_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMRegisterDescriptorResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMRegisterDescriptorResponse_s* zx_NEW_prov_PMRegisterDescriptorResponse(struct zx_ctx* c)
{
  struct zx_prov_PMRegisterDescriptorResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMRegisterDescriptorResponse_s);
  x->gg.g.tok = zx_prov_PMRegisterDescriptorResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMRegisterDescriptorResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMRegisterDescriptorResponse(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);
  for (se = &x->PMRegisterDescriptorResponseItem->gg;
       se && se->g.tok == zx_prov_PMRegisterDescriptorResponseItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMRegisterDescriptorResponseItem(c, (struct zx_prov_PMRegisterDescriptorResponseItem_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMRegisterDescriptorResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMRegisterDescriptorResponse_s* zx_DEEP_CLONE_prov_PMRegisterDescriptorResponse(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMRegisterDescriptorResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMRegisterDescriptorResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PMRegisterDescriptorResponseItem->gg;
       e && e->g.tok == zx_prov_PMRegisterDescriptorResponseItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMRegisterDescriptorResponseItem(c,(struct zx_prov_PMRegisterDescriptorResponseItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMRegisterDescriptorResponseItem = (struct zx_prov_PMRegisterDescriptorResponseItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMRegisterDescriptorResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMRegisterDescriptorResponse(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PMRegisterDescriptorResponseItem->gg;
       e && e->g.tok == zx_prov_PMRegisterDescriptorResponseItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMRegisterDescriptorResponseItem(c, (struct zx_prov_PMRegisterDescriptorResponseItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMRegisterDescriptorResponse) */

int zx_WALK_WO_prov_PMRegisterDescriptorResponse(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMRegisterDescriptorResponseItem
#define EL_STRUCT zx_prov_PMRegisterDescriptorResponseItem_s
#define EL_NS     prov
#define EL_TAG    PMRegisterDescriptorResponseItem

/* FUNC(zx_FREE_prov_PMRegisterDescriptorResponseItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMRegisterDescriptorResponseItem(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorResponseItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->ref, free_strs);

  for (e = &x->ProvisioningHandle->gg;
       e && e->g.tok == zx_prov_ProvisioningHandle_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_ProvisioningHandle(c, (struct zx_prov_ProvisioningHandle_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMRegisterDescriptorResponseItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMRegisterDescriptorResponseItem_s* zx_NEW_prov_PMRegisterDescriptorResponseItem(struct zx_ctx* c)
{
  struct zx_prov_PMRegisterDescriptorResponseItem_s* x = ZX_ZALLOC(c, struct zx_prov_PMRegisterDescriptorResponseItem_s);
  x->gg.g.tok = zx_prov_PMRegisterDescriptorResponseItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMRegisterDescriptorResponseItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMRegisterDescriptorResponseItem(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorResponseItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->ref);

  for (se = &x->ProvisioningHandle->gg;
       se && se->g.tok == zx_prov_ProvisioningHandle_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_ProvisioningHandle(c, (struct zx_prov_ProvisioningHandle_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMRegisterDescriptorResponseItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMRegisterDescriptorResponseItem_s* zx_DEEP_CLONE_prov_PMRegisterDescriptorResponseItem(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorResponseItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMRegisterDescriptorResponseItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMRegisterDescriptorResponseItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->ref = zx_clone_attr(c, x->ref);

  for (enn = 0, e = &x->ProvisioningHandle->gg;
       e && e->g.tok == zx_prov_ProvisioningHandle_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_ProvisioningHandle(c,(struct zx_prov_ProvisioningHandle_s*)e,dup_strs);
  	  if (!enn)
  	      x->ProvisioningHandle = (struct zx_prov_ProvisioningHandle_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMRegisterDescriptorResponseItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMRegisterDescriptorResponseItem(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorResponseItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ProvisioningHandle->gg;
       e && e->g.tok == zx_prov_ProvisioningHandle_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_ProvisioningHandle(c, (struct zx_prov_ProvisioningHandle_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMRegisterDescriptorResponseItem) */

int zx_WALK_WO_prov_PMRegisterDescriptorResponseItem(struct zx_ctx* c, struct zx_prov_PMRegisterDescriptorResponseItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMSetStatus
#define EL_STRUCT zx_prov_PMSetStatus_s
#define EL_NS     prov
#define EL_TAG    PMSetStatus

/* FUNC(zx_FREE_prov_PMSetStatus) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMSetStatus(struct zx_ctx* c, struct zx_prov_PMSetStatus_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PMStatus->gg;
       e && e->g.tok == zx_prov_PMStatus_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMStatus(c, (struct zx_prov_PMStatus_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMSetStatus) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMSetStatus_s* zx_NEW_prov_PMSetStatus(struct zx_ctx* c)
{
  struct zx_prov_PMSetStatus_s* x = ZX_ZALLOC(c, struct zx_prov_PMSetStatus_s);
  x->gg.g.tok = zx_prov_PMSetStatus_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMSetStatus) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMSetStatus(struct zx_ctx* c, struct zx_prov_PMSetStatus_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PMStatus->gg;
       se && se->g.tok == zx_prov_PMStatus_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMStatus(c, (struct zx_prov_PMStatus_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMSetStatus) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMSetStatus_s* zx_DEEP_CLONE_prov_PMSetStatus(struct zx_ctx* c, struct zx_prov_PMSetStatus_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMSetStatus_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMSetStatus_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PMStatus->gg;
       e && e->g.tok == zx_prov_PMStatus_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMStatus(c,(struct zx_prov_PMStatus_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMStatus = (struct zx_prov_PMStatus_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMSetStatus) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMSetStatus(struct zx_ctx* c, struct zx_prov_PMSetStatus_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMStatus->gg;
       e && e->g.tok == zx_prov_PMStatus_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMStatus(c, (struct zx_prov_PMStatus_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMSetStatus) */

int zx_WALK_WO_prov_PMSetStatus(struct zx_ctx* c, struct zx_prov_PMSetStatus_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMSetStatusResponse
#define EL_STRUCT zx_prov_PMSetStatusResponse_s
#define EL_NS     prov
#define EL_TAG    PMSetStatusResponse

/* FUNC(zx_FREE_prov_PMSetStatusResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMSetStatusResponse(struct zx_ctx* c, struct zx_prov_PMSetStatusResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMSetStatusResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMSetStatusResponse_s* zx_NEW_prov_PMSetStatusResponse(struct zx_ctx* c)
{
  struct zx_prov_PMSetStatusResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMSetStatusResponse_s);
  x->gg.g.tok = zx_prov_PMSetStatusResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMSetStatusResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMSetStatusResponse(struct zx_ctx* c, struct zx_prov_PMSetStatusResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMSetStatusResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMSetStatusResponse_s* zx_DEEP_CLONE_prov_PMSetStatusResponse(struct zx_ctx* c, struct zx_prov_PMSetStatusResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMSetStatusResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMSetStatusResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMSetStatusResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMSetStatusResponse(struct zx_ctx* c, struct zx_prov_PMSetStatusResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMSetStatusResponse) */

int zx_WALK_WO_prov_PMSetStatusResponse(struct zx_ctx* c, struct zx_prov_PMSetStatusResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMStatus
#define EL_STRUCT zx_prov_PMStatus_s
#define EL_NS     prov
#define EL_TAG    PMStatus

/* FUNC(zx_FREE_prov_PMStatus) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMStatus(struct zx_ctx* c, struct zx_prov_PMStatus_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMID(c, (struct zx_prov_PMID_s*)e, free_strs);
  }
  for (e = &x->State->gg;
       e && e->g.tok == zx_prov_State_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_State(c, (struct zx_prov_State_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMStatus) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMStatus_s* zx_NEW_prov_PMStatus(struct zx_ctx* c)
{
  struct zx_prov_PMStatus_s* x = ZX_ZALLOC(c, struct zx_prov_PMStatus_s);
  x->gg.g.tok = zx_prov_PMStatus_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMStatus) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMStatus(struct zx_ctx* c, struct zx_prov_PMStatus_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PMID->gg;
       se && se->g.tok == zx_prov_PMID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMID(c, (struct zx_prov_PMID_s*)se);
  for (se = &x->State->gg;
       se && se->g.tok == zx_prov_State_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_State(c, (struct zx_prov_State_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMStatus) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMStatus_s* zx_DEEP_CLONE_prov_PMStatus(struct zx_ctx* c, struct zx_prov_PMStatus_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMStatus_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMStatus_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMID(c,(struct zx_prov_PMID_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMID = (struct zx_prov_PMID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->State->gg;
       e && e->g.tok == zx_prov_State_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_State(c,(struct zx_prov_State_s*)e,dup_strs);
  	  if (!enn)
  	      x->State = (struct zx_prov_State_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMStatus) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMStatus(struct zx_ctx* c, struct zx_prov_PMStatus_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMID(c, (struct zx_prov_PMID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->State->gg;
       e && e->g.tok == zx_prov_State_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_State(c, (struct zx_prov_State_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMStatus) */

int zx_WALK_WO_prov_PMStatus(struct zx_ctx* c, struct zx_prov_PMStatus_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMUpdate
#define EL_STRUCT zx_prov_PMUpdate_s
#define EL_NS     prov
#define EL_TAG    PMUpdate

/* FUNC(zx_FREE_prov_PMUpdate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMUpdate(struct zx_ctx* c, struct zx_prov_PMUpdate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PMUpdateItem->gg;
       e && e->g.tok == zx_prov_PMUpdateItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMUpdateItem(c, (struct zx_prov_PMUpdateItem_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->NotifyTo, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMUpdate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMUpdate_s* zx_NEW_prov_PMUpdate(struct zx_ctx* c)
{
  struct zx_prov_PMUpdate_s* x = ZX_ZALLOC(c, struct zx_prov_PMUpdate_s);
  x->gg.g.tok = zx_prov_PMUpdate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMUpdate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMUpdate(struct zx_ctx* c, struct zx_prov_PMUpdate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PMUpdateItem->gg;
       se && se->g.tok == zx_prov_PMUpdateItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMUpdateItem(c, (struct zx_prov_PMUpdateItem_s*)se);
  zx_dup_strs_simple_elems(c, x->NotifyTo);

}

/* FUNC(zx_DEEP_CLONE_prov_PMUpdate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMUpdate_s* zx_DEEP_CLONE_prov_PMUpdate(struct zx_ctx* c, struct zx_prov_PMUpdate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMUpdate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMUpdate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PMUpdateItem->gg;
       e && e->g.tok == zx_prov_PMUpdateItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMUpdateItem(c,(struct zx_prov_PMUpdateItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMUpdateItem = (struct zx_prov_PMUpdateItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->NotifyTo = zx_deep_clone_simple_elems(c,x->NotifyTo, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMUpdate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMUpdate(struct zx_ctx* c, struct zx_prov_PMUpdate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMUpdateItem->gg;
       e && e->g.tok == zx_prov_PMUpdateItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMUpdateItem(c, (struct zx_prov_PMUpdateItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->NotifyTo, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMUpdate) */

int zx_WALK_WO_prov_PMUpdate(struct zx_ctx* c, struct zx_prov_PMUpdate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMUpdateItem
#define EL_STRUCT zx_prov_PMUpdateItem_s
#define EL_NS     prov
#define EL_TAG    PMUpdateItem

/* FUNC(zx_FREE_prov_PMUpdateItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMUpdateItem(struct zx_ctx* c, struct zx_prov_PMUpdateItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->at, free_strs);
  zx_free_attr(c, x->itemID, free_strs);
  zx_free_attr(c, x->type, free_strs);

  for (e = &x->PMDescriptor->gg;
       e && e->g.tok == zx_prov_PMDescriptor_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMDescriptor(c, (struct zx_prov_PMDescriptor_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMUpdateItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMUpdateItem_s* zx_NEW_prov_PMUpdateItem(struct zx_ctx* c)
{
  struct zx_prov_PMUpdateItem_s* x = ZX_ZALLOC(c, struct zx_prov_PMUpdateItem_s);
  x->gg.g.tok = zx_prov_PMUpdateItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMUpdateItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMUpdateItem(struct zx_ctx* c, struct zx_prov_PMUpdateItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->at);
  zx_dup_attr(c, x->itemID);
  zx_dup_attr(c, x->type);

  for (se = &x->PMDescriptor->gg;
       se && se->g.tok == zx_prov_PMDescriptor_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMDescriptor(c, (struct zx_prov_PMDescriptor_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMUpdateItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMUpdateItem_s* zx_DEEP_CLONE_prov_PMUpdateItem(struct zx_ctx* c, struct zx_prov_PMUpdateItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMUpdateItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMUpdateItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->at = zx_clone_attr(c, x->at);
  x->itemID = zx_clone_attr(c, x->itemID);
  x->type = zx_clone_attr(c, x->type);

  for (enn = 0, e = &x->PMDescriptor->gg;
       e && e->g.tok == zx_prov_PMDescriptor_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMDescriptor(c,(struct zx_prov_PMDescriptor_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMDescriptor = (struct zx_prov_PMDescriptor_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMUpdateItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMUpdateItem(struct zx_ctx* c, struct zx_prov_PMUpdateItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMDescriptor->gg;
       e && e->g.tok == zx_prov_PMDescriptor_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMDescriptor(c, (struct zx_prov_PMDescriptor_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMUpdateItem) */

int zx_WALK_WO_prov_PMUpdateItem(struct zx_ctx* c, struct zx_prov_PMUpdateItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PMUpdateResponse
#define EL_STRUCT zx_prov_PMUpdateResponse_s
#define EL_NS     prov
#define EL_TAG    PMUpdateResponse

/* FUNC(zx_FREE_prov_PMUpdateResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PMUpdateResponse(struct zx_ctx* c, struct zx_prov_PMUpdateResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PMUpdateResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PMUpdateResponse_s* zx_NEW_prov_PMUpdateResponse(struct zx_ctx* c)
{
  struct zx_prov_PMUpdateResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PMUpdateResponse_s);
  x->gg.g.tok = zx_prov_PMUpdateResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PMUpdateResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PMUpdateResponse(struct zx_ctx* c, struct zx_prov_PMUpdateResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PMUpdateResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PMUpdateResponse_s* zx_DEEP_CLONE_prov_PMUpdateResponse(struct zx_ctx* c, struct zx_prov_PMUpdateResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PMUpdateResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PMUpdateResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PMUpdateResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PMUpdateResponse(struct zx_ctx* c, struct zx_prov_PMUpdateResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PMUpdateResponse) */

int zx_WALK_WO_prov_PMUpdateResponse(struct zx_ctx* c, struct zx_prov_PMUpdateResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_Poll
#define EL_STRUCT zx_prov_Poll_s
#define EL_NS     prov
#define EL_TAG    Poll

/* FUNC(zx_FREE_prov_Poll) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_Poll(struct zx_ctx* c, struct zx_prov_Poll_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->wait, free_strs);

  for (e = &x->Action->gg;
       e && e->g.tok == zx_a_Action_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_a_Action(c, (struct zx_a_Action_s*)e, free_strs);
  }
  for (e = &x->Response->gg;
       e && e->g.tok == zx_dp_Response_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_dp_Response(c, (struct zx_dp_Response_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_Poll) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_Poll_s* zx_NEW_prov_Poll(struct zx_ctx* c)
{
  struct zx_prov_Poll_s* x = ZX_ZALLOC(c, struct zx_prov_Poll_s);
  x->gg.g.tok = zx_prov_Poll_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_Poll) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_Poll(struct zx_ctx* c, struct zx_prov_Poll_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->wait);

  for (se = &x->Action->gg;
       se && se->g.tok == zx_a_Action_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_a_Action(c, (struct zx_a_Action_s*)se);
  for (se = &x->Response->gg;
       se && se->g.tok == zx_dp_Response_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_dp_Response(c, (struct zx_dp_Response_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_Poll) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_Poll_s* zx_DEEP_CLONE_prov_Poll(struct zx_ctx* c, struct zx_prov_Poll_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_Poll_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_Poll_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->wait = zx_clone_attr(c, x->wait);

  for (enn = 0, e = &x->Action->gg;
       e && e->g.tok == zx_a_Action_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_a_Action(c,(struct zx_a_Action_s*)e,dup_strs);
  	  if (!enn)
  	      x->Action = (struct zx_a_Action_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Response->gg;
       e && e->g.tok == zx_dp_Response_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_dp_Response(c,(struct zx_dp_Response_s*)e,dup_strs);
  	  if (!enn)
  	      x->Response = (struct zx_dp_Response_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_Poll) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_Poll(struct zx_ctx* c, struct zx_prov_Poll_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Action->gg;
       e && e->g.tok == zx_a_Action_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_a_Action(c, (struct zx_a_Action_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Response->gg;
       e && e->g.tok == zx_dp_Response_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_dp_Response(c, (struct zx_dp_Response_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_Poll) */

int zx_WALK_WO_prov_Poll(struct zx_ctx* c, struct zx_prov_Poll_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_PollResponse
#define EL_STRUCT zx_prov_PollResponse_s
#define EL_NS     prov
#define EL_TAG    PollResponse

/* FUNC(zx_FREE_prov_PollResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_PollResponse(struct zx_ctx* c, struct zx_prov_PollResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->nextPoll, free_strs);

  for (e = &x->Request->gg;
       e && e->g.tok == zx_dp_Request_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_dp_Request(c, (struct zx_dp_Request_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_PollResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_PollResponse_s* zx_NEW_prov_PollResponse(struct zx_ctx* c)
{
  struct zx_prov_PollResponse_s* x = ZX_ZALLOC(c, struct zx_prov_PollResponse_s);
  x->gg.g.tok = zx_prov_PollResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_PollResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_PollResponse(struct zx_ctx* c, struct zx_prov_PollResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->nextPoll);

  for (se = &x->Request->gg;
       se && se->g.tok == zx_dp_Request_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_dp_Request(c, (struct zx_dp_Request_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_PollResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_PollResponse_s* zx_DEEP_CLONE_prov_PollResponse(struct zx_ctx* c, struct zx_prov_PollResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_PollResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_PollResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->nextPoll = zx_clone_attr(c, x->nextPoll);

  for (enn = 0, e = &x->Request->gg;
       e && e->g.tok == zx_dp_Request_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_dp_Request(c,(struct zx_dp_Request_s*)e,dup_strs);
  	  if (!enn)
  	      x->Request = (struct zx_dp_Request_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_PollResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_PollResponse(struct zx_ctx* c, struct zx_prov_PollResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Request->gg;
       e && e->g.tok == zx_dp_Request_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_dp_Request(c, (struct zx_dp_Request_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_PollResponse) */

int zx_WALK_WO_prov_PollResponse(struct zx_ctx* c, struct zx_prov_PollResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_ProvisioningHandle
#define EL_STRUCT zx_prov_ProvisioningHandle_s
#define EL_NS     prov
#define EL_TAG    ProvisioningHandle

/* FUNC(zx_FREE_prov_ProvisioningHandle) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_ProvisioningHandle(struct zx_ctx* c, struct zx_prov_ProvisioningHandle_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->expires, free_strs);

  zx_free_simple_elems(c, x->PMDArtifact, free_strs);
  for (e = &x->ProvisioningServiceEPR->gg;
       e && e->g.tok == zx_prov_ProvisioningServiceEPR_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_ProvisioningServiceEPR(c, (struct zx_prov_ProvisioningServiceEPR_s*)e, free_strs);
  }
  for (e = &x->Signature->gg;
       e && e->g.tok == zx_ds_Signature_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_ds_Signature(c, (struct zx_ds_Signature_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_ProvisioningHandle) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_ProvisioningHandle_s* zx_NEW_prov_ProvisioningHandle(struct zx_ctx* c)
{
  struct zx_prov_ProvisioningHandle_s* x = ZX_ZALLOC(c, struct zx_prov_ProvisioningHandle_s);
  x->gg.g.tok = zx_prov_ProvisioningHandle_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_ProvisioningHandle) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_ProvisioningHandle(struct zx_ctx* c, struct zx_prov_ProvisioningHandle_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->expires);

  zx_dup_strs_simple_elems(c, x->PMDArtifact);
  for (se = &x->ProvisioningServiceEPR->gg;
       se && se->g.tok == zx_prov_ProvisioningServiceEPR_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_ProvisioningServiceEPR(c, (struct zx_prov_ProvisioningServiceEPR_s*)se);
  for (se = &x->Signature->gg;
       se && se->g.tok == zx_ds_Signature_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ds_Signature(c, (struct zx_ds_Signature_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_ProvisioningHandle) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_ProvisioningHandle_s* zx_DEEP_CLONE_prov_ProvisioningHandle(struct zx_ctx* c, struct zx_prov_ProvisioningHandle_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_ProvisioningHandle_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_ProvisioningHandle_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->expires = zx_clone_attr(c, x->expires);

  x->PMDArtifact = zx_deep_clone_simple_elems(c,x->PMDArtifact, dup_strs);
  for (enn = 0, e = &x->ProvisioningServiceEPR->gg;
       e && e->g.tok == zx_prov_ProvisioningServiceEPR_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_ProvisioningServiceEPR(c,(struct zx_prov_ProvisioningServiceEPR_s*)e,dup_strs);
  	  if (!enn)
  	      x->ProvisioningServiceEPR = (struct zx_prov_ProvisioningServiceEPR_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Signature->gg;
       e && e->g.tok == zx_ds_Signature_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ds_Signature(c,(struct zx_ds_Signature_s*)e,dup_strs);
  	  if (!enn)
  	      x->Signature = (struct zx_ds_Signature_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_ProvisioningHandle) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_ProvisioningHandle(struct zx_ctx* c, struct zx_prov_ProvisioningHandle_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PMDArtifact, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->ProvisioningServiceEPR->gg;
       e && e->g.tok == zx_prov_ProvisioningServiceEPR_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_ProvisioningServiceEPR(c, (struct zx_prov_ProvisioningServiceEPR_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Signature->gg;
       e && e->g.tok == zx_ds_Signature_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ds_Signature(c, (struct zx_ds_Signature_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_ProvisioningHandle) */

int zx_WALK_WO_prov_ProvisioningHandle(struct zx_ctx* c, struct zx_prov_ProvisioningHandle_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_ProvisioningServiceEPR
#define EL_STRUCT zx_prov_ProvisioningServiceEPR_s
#define EL_NS     prov
#define EL_TAG    ProvisioningServiceEPR

/* FUNC(zx_FREE_prov_ProvisioningServiceEPR) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_ProvisioningServiceEPR(struct zx_ctx* c, struct zx_prov_ProvisioningServiceEPR_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->ID, free_strs);
  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->notOnOrAfter, free_strs);
  zx_free_attr(c, x->Id, free_strs);
  zx_free_attr(c, x->actor, free_strs);
  zx_free_attr(c, x->mustUnderstand, free_strs);

  for (e = &x->Address->gg;
       e && e->g.tok == zx_a_Address_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_a_Address(c, (struct zx_a_Address_s*)e, free_strs);
  }
  for (e = &x->ReferenceParameters->gg;
       e && e->g.tok == zx_a_ReferenceParameters_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_a_ReferenceParameters(c, (struct zx_a_ReferenceParameters_s*)e, free_strs);
  }
  for (e = &x->Metadata->gg;
       e && e->g.tok == zx_a_Metadata_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_a_Metadata(c, (struct zx_a_Metadata_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_ProvisioningServiceEPR) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_ProvisioningServiceEPR_s* zx_NEW_prov_ProvisioningServiceEPR(struct zx_ctx* c)
{
  struct zx_prov_ProvisioningServiceEPR_s* x = ZX_ZALLOC(c, struct zx_prov_ProvisioningServiceEPR_s);
  x->gg.g.tok = zx_prov_ProvisioningServiceEPR_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_ProvisioningServiceEPR) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_ProvisioningServiceEPR(struct zx_ctx* c, struct zx_prov_ProvisioningServiceEPR_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->ID);
  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->notOnOrAfter);
  zx_dup_attr(c, x->Id);
  zx_dup_attr(c, x->actor);
  zx_dup_attr(c, x->mustUnderstand);

  for (se = &x->Address->gg;
       se && se->g.tok == zx_a_Address_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_a_Address(c, (struct zx_a_Address_s*)se);
  for (se = &x->ReferenceParameters->gg;
       se && se->g.tok == zx_a_ReferenceParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_a_ReferenceParameters(c, (struct zx_a_ReferenceParameters_s*)se);
  for (se = &x->Metadata->gg;
       se && se->g.tok == zx_a_Metadata_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_a_Metadata(c, (struct zx_a_Metadata_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_ProvisioningServiceEPR) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_ProvisioningServiceEPR_s* zx_DEEP_CLONE_prov_ProvisioningServiceEPR(struct zx_ctx* c, struct zx_prov_ProvisioningServiceEPR_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_ProvisioningServiceEPR_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_ProvisioningServiceEPR_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->ID = zx_clone_attr(c, x->ID);
  x->id = zx_clone_attr(c, x->id);
  x->notOnOrAfter = zx_clone_attr(c, x->notOnOrAfter);
  x->Id = zx_clone_attr(c, x->Id);
  x->actor = zx_clone_attr(c, x->actor);
  x->mustUnderstand = zx_clone_attr(c, x->mustUnderstand);

  for (enn = 0, e = &x->Address->gg;
       e && e->g.tok == zx_a_Address_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_a_Address(c,(struct zx_a_Address_s*)e,dup_strs);
  	  if (!enn)
  	      x->Address = (struct zx_a_Address_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ReferenceParameters->gg;
       e && e->g.tok == zx_a_ReferenceParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_a_ReferenceParameters(c,(struct zx_a_ReferenceParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->ReferenceParameters = (struct zx_a_ReferenceParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Metadata->gg;
       e && e->g.tok == zx_a_Metadata_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_a_Metadata(c,(struct zx_a_Metadata_s*)e,dup_strs);
  	  if (!enn)
  	      x->Metadata = (struct zx_a_Metadata_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_ProvisioningServiceEPR) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_ProvisioningServiceEPR(struct zx_ctx* c, struct zx_prov_ProvisioningServiceEPR_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Address->gg;
       e && e->g.tok == zx_a_Address_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_a_Address(c, (struct zx_a_Address_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ReferenceParameters->gg;
       e && e->g.tok == zx_a_ReferenceParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_a_ReferenceParameters(c, (struct zx_a_ReferenceParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Metadata->gg;
       e && e->g.tok == zx_a_Metadata_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_a_Metadata(c, (struct zx_a_Metadata_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_ProvisioningServiceEPR) */

int zx_WALK_WO_prov_ProvisioningServiceEPR(struct zx_ctx* c, struct zx_prov_ProvisioningServiceEPR_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_State
#define EL_STRUCT zx_prov_State_s
#define EL_NS     prov
#define EL_TAG    State

/* FUNC(zx_FREE_prov_State) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_State(struct zx_ctx* c, struct zx_prov_State_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->asof, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_State) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_State_s* zx_NEW_prov_State(struct zx_ctx* c)
{
  struct zx_prov_State_s* x = ZX_ZALLOC(c, struct zx_prov_State_s);
  x->gg.g.tok = zx_prov_State_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_State) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_State(struct zx_ctx* c, struct zx_prov_State_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->asof);


}

/* FUNC(zx_DEEP_CLONE_prov_State) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_State_s* zx_DEEP_CLONE_prov_State(struct zx_ctx* c, struct zx_prov_State_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_State_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_State_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->asof = zx_clone_attr(c, x->asof);


  return x;
}

/* FUNC(zx_WALK_SO_prov_State) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_State(struct zx_ctx* c, struct zx_prov_State_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_State) */

int zx_WALK_WO_prov_State(struct zx_ctx* c, struct zx_prov_State_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_UpdateEPR
#define EL_STRUCT zx_prov_UpdateEPR_s
#define EL_NS     prov
#define EL_TAG    UpdateEPR

/* FUNC(zx_FREE_prov_UpdateEPR) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_UpdateEPR(struct zx_ctx* c, struct zx_prov_UpdateEPR_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->UpdateEPRItem->gg;
       e && e->g.tok == zx_prov_UpdateEPRItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_UpdateEPRItem(c, (struct zx_prov_UpdateEPRItem_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_UpdateEPR) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_UpdateEPR_s* zx_NEW_prov_UpdateEPR(struct zx_ctx* c)
{
  struct zx_prov_UpdateEPR_s* x = ZX_ZALLOC(c, struct zx_prov_UpdateEPR_s);
  x->gg.g.tok = zx_prov_UpdateEPR_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_UpdateEPR) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_UpdateEPR(struct zx_ctx* c, struct zx_prov_UpdateEPR_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->UpdateEPRItem->gg;
       se && se->g.tok == zx_prov_UpdateEPRItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_UpdateEPRItem(c, (struct zx_prov_UpdateEPRItem_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_UpdateEPR) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_UpdateEPR_s* zx_DEEP_CLONE_prov_UpdateEPR(struct zx_ctx* c, struct zx_prov_UpdateEPR_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_UpdateEPR_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_UpdateEPR_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->UpdateEPRItem->gg;
       e && e->g.tok == zx_prov_UpdateEPRItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_UpdateEPRItem(c,(struct zx_prov_UpdateEPRItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->UpdateEPRItem = (struct zx_prov_UpdateEPRItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_UpdateEPR) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_UpdateEPR(struct zx_ctx* c, struct zx_prov_UpdateEPR_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->UpdateEPRItem->gg;
       e && e->g.tok == zx_prov_UpdateEPRItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_UpdateEPRItem(c, (struct zx_prov_UpdateEPRItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_UpdateEPR) */

int zx_WALK_WO_prov_UpdateEPR(struct zx_ctx* c, struct zx_prov_UpdateEPR_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_UpdateEPRItem
#define EL_STRUCT zx_prov_UpdateEPRItem_s
#define EL_NS     prov
#define EL_TAG    UpdateEPRItem

/* FUNC(zx_FREE_prov_UpdateEPRItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_UpdateEPRItem(struct zx_ctx* c, struct zx_prov_UpdateEPRItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->itemID, free_strs);

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_PMID(c, (struct zx_prov_PMID_s*)e, free_strs);
  }
  for (e = &x->CallbackEPR->gg;
       e && e->g.tok == zx_prov_CallbackEPR_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_prov_CallbackEPR(c, (struct zx_prov_CallbackEPR_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_UpdateEPRItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_UpdateEPRItem_s* zx_NEW_prov_UpdateEPRItem(struct zx_ctx* c)
{
  struct zx_prov_UpdateEPRItem_s* x = ZX_ZALLOC(c, struct zx_prov_UpdateEPRItem_s);
  x->gg.g.tok = zx_prov_UpdateEPRItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_UpdateEPRItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_UpdateEPRItem(struct zx_ctx* c, struct zx_prov_UpdateEPRItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->itemID);

  for (se = &x->PMID->gg;
       se && se->g.tok == zx_prov_PMID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_PMID(c, (struct zx_prov_PMID_s*)se);
  for (se = &x->CallbackEPR->gg;
       se && se->g.tok == zx_prov_CallbackEPR_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_prov_CallbackEPR(c, (struct zx_prov_CallbackEPR_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_UpdateEPRItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_UpdateEPRItem_s* zx_DEEP_CLONE_prov_UpdateEPRItem(struct zx_ctx* c, struct zx_prov_UpdateEPRItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_UpdateEPRItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_UpdateEPRItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->itemID = zx_clone_attr(c, x->itemID);

  for (enn = 0, e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_PMID(c,(struct zx_prov_PMID_s*)e,dup_strs);
  	  if (!enn)
  	      x->PMID = (struct zx_prov_PMID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CallbackEPR->gg;
       e && e->g.tok == zx_prov_CallbackEPR_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_prov_CallbackEPR(c,(struct zx_prov_CallbackEPR_s*)e,dup_strs);
  	  if (!enn)
  	      x->CallbackEPR = (struct zx_prov_CallbackEPR_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_UpdateEPRItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_UpdateEPRItem(struct zx_ctx* c, struct zx_prov_UpdateEPRItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PMID->gg;
       e && e->g.tok == zx_prov_PMID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_PMID(c, (struct zx_prov_PMID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CallbackEPR->gg;
       e && e->g.tok == zx_prov_CallbackEPR_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_prov_CallbackEPR(c, (struct zx_prov_CallbackEPR_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_UpdateEPRItem) */

int zx_WALK_WO_prov_UpdateEPRItem(struct zx_ctx* c, struct zx_prov_UpdateEPRItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   prov_UpdateEPRResponse
#define EL_STRUCT zx_prov_UpdateEPRResponse_s
#define EL_NS     prov
#define EL_TAG    UpdateEPRResponse

/* FUNC(zx_FREE_prov_UpdateEPRResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_prov_UpdateEPRResponse(struct zx_ctx* c, struct zx_prov_UpdateEPRResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_lu_Status(c, (struct zx_lu_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_prov_UpdateEPRResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_prov_UpdateEPRResponse_s* zx_NEW_prov_UpdateEPRResponse(struct zx_ctx* c)
{
  struct zx_prov_UpdateEPRResponse_s* x = ZX_ZALLOC(c, struct zx_prov_UpdateEPRResponse_s);
  x->gg.g.tok = zx_prov_UpdateEPRResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_prov_UpdateEPRResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_prov_UpdateEPRResponse(struct zx_ctx* c, struct zx_prov_UpdateEPRResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Status->gg;
       se && se->g.tok == zx_lu_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_lu_Status(c, (struct zx_lu_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_prov_UpdateEPRResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_prov_UpdateEPRResponse_s* zx_DEEP_CLONE_prov_UpdateEPRResponse(struct zx_ctx* c, struct zx_prov_UpdateEPRResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_prov_UpdateEPRResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_prov_UpdateEPRResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_lu_Status(c,(struct zx_lu_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_lu_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_prov_UpdateEPRResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_prov_UpdateEPRResponse(struct zx_ctx* c, struct zx_prov_UpdateEPRResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_lu_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_lu_Status(c, (struct zx_lu_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_prov_UpdateEPRResponse) */

int zx_WALK_WO_prov_UpdateEPRResponse(struct zx_ctx* c, struct zx_prov_UpdateEPRResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif


/* EOF -- c/zx-prov-aux.c */
