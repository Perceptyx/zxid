/* c/zx-gl-aux.c - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** aux-templ.c  -  Auxiliary functions template: cloning, freeing, walking data
 ** Copyright (c) 2006 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: aux-templ.c,v 1.12 2008-10-04 23:42:14 sampo Exp $
 **
 ** 30.5.2006, created, Sampo Kellomaki (sampo@iki.fi)
 ** 6.8.2006, factored from enc-templ.c to separate file --Sampo
 **
 ** N.B: wo=wire order (needed for exc-c14n), so=schema order
 **/

#include <memory.h>
#include "errmac.h"
#include "zx.h"
#include "c/zx-const.h"
#include "c/zx-data.h"
#include "c/zx-gl-data.h"



#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_AreaComparison
#define EL_STRUCT zx_gl_AreaComparison_s
#define EL_NS     gl
#define EL_TAG    AreaComparison

/* FUNC(zx_FREE_gl_AreaComparison) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_AreaComparison(struct zx_ctx* c, struct zx_gl_AreaComparison_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->itemID, free_strs);
  zx_free_attr(c, x->returnLocation, free_strs);

  for (e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_CivilData(c, (struct zx_gl_CivilData_s*)e, free_strs);
  }
  for (e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_shape(c, (struct zx_gl_shape_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_AreaComparison) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_AreaComparison_s* zx_NEW_gl_AreaComparison(struct zx_ctx* c)
{
  struct zx_gl_AreaComparison_s* x = ZX_ZALLOC(c, struct zx_gl_AreaComparison_s);
  x->gg.g.tok = zx_gl_AreaComparison_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_AreaComparison) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_AreaComparison(struct zx_ctx* c, struct zx_gl_AreaComparison_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->itemID);
  zx_dup_attr(c, x->returnLocation);

  for (se = &x->CivilData->gg;
       se && se->g.tok == zx_gl_CivilData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_CivilData(c, (struct zx_gl_CivilData_s*)se);
  for (se = &x->shape->gg;
       se && se->g.tok == zx_gl_shape_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_shape(c, (struct zx_gl_shape_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_AreaComparison) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_AreaComparison_s* zx_DEEP_CLONE_gl_AreaComparison(struct zx_ctx* c, struct zx_gl_AreaComparison_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_AreaComparison_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_AreaComparison_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->itemID = zx_clone_attr(c, x->itemID);
  x->returnLocation = zx_clone_attr(c, x->returnLocation);

  for (enn = 0, e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_CivilData(c,(struct zx_gl_CivilData_s*)e,dup_strs);
  	  if (!enn)
  	      x->CivilData = (struct zx_gl_CivilData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_shape(c,(struct zx_gl_shape_s*)e,dup_strs);
  	  if (!enn)
  	      x->shape = (struct zx_gl_shape_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_AreaComparison) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_AreaComparison(struct zx_ctx* c, struct zx_gl_AreaComparison_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_CivilData(c, (struct zx_gl_CivilData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_shape(c, (struct zx_gl_shape_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_AreaComparison) */

int zx_WALK_WO_gl_AreaComparison(struct zx_ctx* c, struct zx_gl_AreaComparison_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Box
#define EL_STRUCT zx_gl_Box_s
#define EL_NS     gl
#define EL_TAG    Box

/* FUNC(zx_FREE_gl_Box) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Box(struct zx_ctx* c, struct zx_gl_Box_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_coord(c, (struct zx_gl_coord_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Box) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Box_s* zx_NEW_gl_Box(struct zx_ctx* c)
{
  struct zx_gl_Box_s* x = ZX_ZALLOC(c, struct zx_gl_Box_s);
  x->gg.g.tok = zx_gl_Box_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Box) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Box(struct zx_ctx* c, struct zx_gl_Box_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->coord->gg;
       se && se->g.tok == zx_gl_coord_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_coord(c, (struct zx_gl_coord_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Box) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Box_s* zx_DEEP_CLONE_gl_Box(struct zx_ctx* c, struct zx_gl_Box_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Box_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Box_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_coord(c,(struct zx_gl_coord_s*)e,dup_strs);
  	  if (!enn)
  	      x->coord = (struct zx_gl_coord_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Box) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Box(struct zx_ctx* c, struct zx_gl_Box_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_coord(c, (struct zx_gl_coord_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Box) */

int zx_WALK_WO_gl_Box(struct zx_ctx* c, struct zx_gl_Box_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_ChangeArea
#define EL_STRUCT zx_gl_ChangeArea_s
#define EL_NS     gl
#define EL_TAG    ChangeArea

/* FUNC(zx_FREE_gl_ChangeArea) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_ChangeArea(struct zx_ctx* c, struct zx_gl_ChangeArea_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->event, free_strs);

  for (e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_CivilData(c, (struct zx_gl_CivilData_s*)e, free_strs);
  }
  for (e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_shape(c, (struct zx_gl_shape_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_ChangeArea) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_ChangeArea_s* zx_NEW_gl_ChangeArea(struct zx_ctx* c)
{
  struct zx_gl_ChangeArea_s* x = ZX_ZALLOC(c, struct zx_gl_ChangeArea_s);
  x->gg.g.tok = zx_gl_ChangeArea_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_ChangeArea) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_ChangeArea(struct zx_ctx* c, struct zx_gl_ChangeArea_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->event);

  for (se = &x->CivilData->gg;
       se && se->g.tok == zx_gl_CivilData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_CivilData(c, (struct zx_gl_CivilData_s*)se);
  for (se = &x->shape->gg;
       se && se->g.tok == zx_gl_shape_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_shape(c, (struct zx_gl_shape_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_ChangeArea) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_ChangeArea_s* zx_DEEP_CLONE_gl_ChangeArea(struct zx_ctx* c, struct zx_gl_ChangeArea_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_ChangeArea_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_ChangeArea_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->event = zx_clone_attr(c, x->event);

  for (enn = 0, e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_CivilData(c,(struct zx_gl_CivilData_s*)e,dup_strs);
  	  if (!enn)
  	      x->CivilData = (struct zx_gl_CivilData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_shape(c,(struct zx_gl_shape_s*)e,dup_strs);
  	  if (!enn)
  	      x->shape = (struct zx_gl_shape_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_ChangeArea) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_ChangeArea(struct zx_ctx* c, struct zx_gl_ChangeArea_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_CivilData(c, (struct zx_gl_CivilData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_shape(c, (struct zx_gl_shape_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_ChangeArea) */

int zx_WALK_WO_gl_ChangeArea(struct zx_ctx* c, struct zx_gl_ChangeArea_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_CircularArcArea
#define EL_STRUCT zx_gl_CircularArcArea_s
#define EL_NS     gl
#define EL_TAG    CircularArcArea

/* FUNC(zx_FREE_gl_CircularArcArea) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_CircularArcArea(struct zx_ctx* c, struct zx_gl_CircularArcArea_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_coord(c, (struct zx_gl_coord_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->inRadius, free_strs);
  zx_free_simple_elems(c, x->outRadius, free_strs);
  zx_free_simple_elems(c, x->startAngle, free_strs);
  zx_free_simple_elems(c, x->stopAngle, free_strs);
  zx_free_simple_elems(c, x->angularUnit, free_strs);
  zx_free_simple_elems(c, x->distanceUnit, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_CircularArcArea) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_CircularArcArea_s* zx_NEW_gl_CircularArcArea(struct zx_ctx* c)
{
  struct zx_gl_CircularArcArea_s* x = ZX_ZALLOC(c, struct zx_gl_CircularArcArea_s);
  x->gg.g.tok = zx_gl_CircularArcArea_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_CircularArcArea) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_CircularArcArea(struct zx_ctx* c, struct zx_gl_CircularArcArea_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->coord->gg;
       se && se->g.tok == zx_gl_coord_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_coord(c, (struct zx_gl_coord_s*)se);
  zx_dup_strs_simple_elems(c, x->inRadius);
  zx_dup_strs_simple_elems(c, x->outRadius);
  zx_dup_strs_simple_elems(c, x->startAngle);
  zx_dup_strs_simple_elems(c, x->stopAngle);
  zx_dup_strs_simple_elems(c, x->angularUnit);
  zx_dup_strs_simple_elems(c, x->distanceUnit);

}

/* FUNC(zx_DEEP_CLONE_gl_CircularArcArea) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_CircularArcArea_s* zx_DEEP_CLONE_gl_CircularArcArea(struct zx_ctx* c, struct zx_gl_CircularArcArea_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_CircularArcArea_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_CircularArcArea_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_coord(c,(struct zx_gl_coord_s*)e,dup_strs);
  	  if (!enn)
  	      x->coord = (struct zx_gl_coord_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->inRadius = zx_deep_clone_simple_elems(c,x->inRadius, dup_strs);
  x->outRadius = zx_deep_clone_simple_elems(c,x->outRadius, dup_strs);
  x->startAngle = zx_deep_clone_simple_elems(c,x->startAngle, dup_strs);
  x->stopAngle = zx_deep_clone_simple_elems(c,x->stopAngle, dup_strs);
  x->angularUnit = zx_deep_clone_simple_elems(c,x->angularUnit, dup_strs);
  x->distanceUnit = zx_deep_clone_simple_elems(c,x->distanceUnit, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_gl_CircularArcArea) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_CircularArcArea(struct zx_ctx* c, struct zx_gl_CircularArcArea_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_coord(c, (struct zx_gl_coord_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->inRadius, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->outRadius, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->startAngle, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->stopAngle, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->angularUnit, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->distanceUnit, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_CircularArcArea) */

int zx_WALK_WO_gl_CircularArcArea(struct zx_ctx* c, struct zx_gl_CircularArcArea_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_CircularArea
#define EL_STRUCT zx_gl_CircularArea_s
#define EL_NS     gl
#define EL_TAG    CircularArea

/* FUNC(zx_FREE_gl_CircularArea) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_CircularArea(struct zx_ctx* c, struct zx_gl_CircularArea_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_coord(c, (struct zx_gl_coord_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->radius, free_strs);
  zx_free_simple_elems(c, x->distanceUnit, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_CircularArea) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_CircularArea_s* zx_NEW_gl_CircularArea(struct zx_ctx* c)
{
  struct zx_gl_CircularArea_s* x = ZX_ZALLOC(c, struct zx_gl_CircularArea_s);
  x->gg.g.tok = zx_gl_CircularArea_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_CircularArea) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_CircularArea(struct zx_ctx* c, struct zx_gl_CircularArea_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->coord->gg;
       se && se->g.tok == zx_gl_coord_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_coord(c, (struct zx_gl_coord_s*)se);
  zx_dup_strs_simple_elems(c, x->radius);
  zx_dup_strs_simple_elems(c, x->distanceUnit);

}

/* FUNC(zx_DEEP_CLONE_gl_CircularArea) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_CircularArea_s* zx_DEEP_CLONE_gl_CircularArea(struct zx_ctx* c, struct zx_gl_CircularArea_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_CircularArea_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_CircularArea_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_coord(c,(struct zx_gl_coord_s*)e,dup_strs);
  	  if (!enn)
  	      x->coord = (struct zx_gl_coord_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->radius = zx_deep_clone_simple_elems(c,x->radius, dup_strs);
  x->distanceUnit = zx_deep_clone_simple_elems(c,x->distanceUnit, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_gl_CircularArea) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_CircularArea(struct zx_ctx* c, struct zx_gl_CircularArea_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_coord(c, (struct zx_gl_coord_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->radius, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->distanceUnit, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_CircularArea) */

int zx_WALK_WO_gl_CircularArea(struct zx_ctx* c, struct zx_gl_CircularArea_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_CivilData
#define EL_STRUCT zx_gl_CivilData_s
#define EL_NS     gl
#define EL_TAG    CivilData

/* FUNC(zx_FREE_gl_CivilData) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_CivilData(struct zx_ctx* c, struct zx_gl_CivilData_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->PostalAddress, free_strs);
  for (e = &x->LPostalAddress->gg;
       e && e->g.tok == zx_gl_LPostalAddress_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_LPostalAddress(c, (struct zx_gl_LPostalAddress_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->PostalCode, free_strs);
  zx_free_simple_elems(c, x->L, free_strs);
  for (e = &x->LL->gg;
       e && e->g.tok == zx_gl_LL_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_LL(c, (struct zx_gl_LL_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->St, free_strs);
  for (e = &x->LSt->gg;
       e && e->g.tok == zx_gl_LSt_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_LSt(c, (struct zx_gl_LSt_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->C, free_strs);
  zx_free_simple_elems(c, x->MNC, free_strs);
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_CivilData) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_CivilData_s* zx_NEW_gl_CivilData(struct zx_ctx* c)
{
  struct zx_gl_CivilData_s* x = ZX_ZALLOC(c, struct zx_gl_CivilData_s);
  x->gg.g.tok = zx_gl_CivilData_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_CivilData) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_CivilData(struct zx_ctx* c, struct zx_gl_CivilData_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->PostalAddress);
  for (se = &x->LPostalAddress->gg;
       se && se->g.tok == zx_gl_LPostalAddress_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_LPostalAddress(c, (struct zx_gl_LPostalAddress_s*)se);
  zx_dup_strs_simple_elems(c, x->PostalCode);
  zx_dup_strs_simple_elems(c, x->L);
  for (se = &x->LL->gg;
       se && se->g.tok == zx_gl_LL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_LL(c, (struct zx_gl_LL_s*)se);
  zx_dup_strs_simple_elems(c, x->St);
  for (se = &x->LSt->gg;
       se && se->g.tok == zx_gl_LSt_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_LSt(c, (struct zx_gl_LSt_s*)se);
  zx_dup_strs_simple_elems(c, x->C);
  zx_dup_strs_simple_elems(c, x->MNC);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_CivilData) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_CivilData_s* zx_DEEP_CLONE_gl_CivilData(struct zx_ctx* c, struct zx_gl_CivilData_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_CivilData_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_CivilData_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->PostalAddress = zx_deep_clone_simple_elems(c,x->PostalAddress, dup_strs);
  for (enn = 0, e = &x->LPostalAddress->gg;
       e && e->g.tok == zx_gl_LPostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_LPostalAddress(c,(struct zx_gl_LPostalAddress_s*)e,dup_strs);
  	  if (!enn)
  	      x->LPostalAddress = (struct zx_gl_LPostalAddress_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->PostalCode = zx_deep_clone_simple_elems(c,x->PostalCode, dup_strs);
  x->L = zx_deep_clone_simple_elems(c,x->L, dup_strs);
  for (enn = 0, e = &x->LL->gg;
       e && e->g.tok == zx_gl_LL_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_LL(c,(struct zx_gl_LL_s*)e,dup_strs);
  	  if (!enn)
  	      x->LL = (struct zx_gl_LL_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->St = zx_deep_clone_simple_elems(c,x->St, dup_strs);
  for (enn = 0, e = &x->LSt->gg;
       e && e->g.tok == zx_gl_LSt_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_LSt(c,(struct zx_gl_LSt_s*)e,dup_strs);
  	  if (!enn)
  	      x->LSt = (struct zx_gl_LSt_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->C = zx_deep_clone_simple_elems(c,x->C, dup_strs);
  x->MNC = zx_deep_clone_simple_elems(c,x->MNC, dup_strs);
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_CivilData) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_CivilData(struct zx_ctx* c, struct zx_gl_CivilData_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PostalAddress, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->LPostalAddress->gg;
       e && e->g.tok == zx_gl_LPostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_LPostalAddress(c, (struct zx_gl_LPostalAddress_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->PostalCode, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->L, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->LL->gg;
       e && e->g.tok == zx_gl_LL_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_LL(c, (struct zx_gl_LL_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->St, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->LSt->gg;
       e && e->g.tok == zx_gl_LSt_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_LSt(c, (struct zx_gl_LSt_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->C, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MNC, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_CivilData) */

int zx_WALK_WO_gl_CivilData(struct zx_ctx* c, struct zx_gl_CivilData_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_ComparisonResult
#define EL_STRUCT zx_gl_ComparisonResult_s
#define EL_NS     gl
#define EL_TAG    ComparisonResult

/* FUNC(zx_FREE_gl_ComparisonResult) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_ComparisonResult(struct zx_ctx* c, struct zx_gl_ComparisonResult_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->ItemIDRef, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_ComparisonResult) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_ComparisonResult_s* zx_NEW_gl_ComparisonResult(struct zx_ctx* c)
{
  struct zx_gl_ComparisonResult_s* x = ZX_ZALLOC(c, struct zx_gl_ComparisonResult_s);
  x->gg.g.tok = zx_gl_ComparisonResult_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_ComparisonResult) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_ComparisonResult(struct zx_ctx* c, struct zx_gl_ComparisonResult_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->ItemIDRef);


}

/* FUNC(zx_DEEP_CLONE_gl_ComparisonResult) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_ComparisonResult_s* zx_DEEP_CLONE_gl_ComparisonResult(struct zx_ctx* c, struct zx_gl_ComparisonResult_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_ComparisonResult_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_ComparisonResult_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->ItemIDRef = zx_clone_attr(c, x->ItemIDRef);


  return x;
}

/* FUNC(zx_WALK_SO_gl_ComparisonResult) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_ComparisonResult(struct zx_ctx* c, struct zx_gl_ComparisonResult_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_ComparisonResult) */

int zx_WALK_WO_gl_ComparisonResult(struct zx_ctx* c, struct zx_gl_ComparisonResult_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_CoordinateReferenceSystem
#define EL_STRUCT zx_gl_CoordinateReferenceSystem_s
#define EL_NS     gl
#define EL_TAG    CoordinateReferenceSystem

/* FUNC(zx_FREE_gl_CoordinateReferenceSystem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_CoordinateReferenceSystem(struct zx_ctx* c, struct zx_gl_CoordinateReferenceSystem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Identifier->gg;
       e && e->g.tok == zx_gl_Identifier_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Identifier(c, (struct zx_gl_Identifier_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_CoordinateReferenceSystem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_CoordinateReferenceSystem_s* zx_NEW_gl_CoordinateReferenceSystem(struct zx_ctx* c)
{
  struct zx_gl_CoordinateReferenceSystem_s* x = ZX_ZALLOC(c, struct zx_gl_CoordinateReferenceSystem_s);
  x->gg.g.tok = zx_gl_CoordinateReferenceSystem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_CoordinateReferenceSystem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_CoordinateReferenceSystem(struct zx_ctx* c, struct zx_gl_CoordinateReferenceSystem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Identifier->gg;
       se && se->g.tok == zx_gl_Identifier_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Identifier(c, (struct zx_gl_Identifier_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_CoordinateReferenceSystem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_CoordinateReferenceSystem_s* zx_DEEP_CLONE_gl_CoordinateReferenceSystem(struct zx_ctx* c, struct zx_gl_CoordinateReferenceSystem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_CoordinateReferenceSystem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_CoordinateReferenceSystem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Identifier->gg;
       e && e->g.tok == zx_gl_Identifier_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Identifier(c,(struct zx_gl_Identifier_s*)e,dup_strs);
  	  if (!enn)
  	      x->Identifier = (struct zx_gl_Identifier_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_CoordinateReferenceSystem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_CoordinateReferenceSystem(struct zx_ctx* c, struct zx_gl_CoordinateReferenceSystem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Identifier->gg;
       e && e->g.tok == zx_gl_Identifier_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Identifier(c, (struct zx_gl_Identifier_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_CoordinateReferenceSystem) */

int zx_WALK_WO_gl_CoordinateReferenceSystem(struct zx_ctx* c, struct zx_gl_CoordinateReferenceSystem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Create
#define EL_STRUCT zx_gl_Create_s
#define EL_NS     gl
#define EL_TAG    Create

/* FUNC(zx_FREE_gl_Create) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Create(struct zx_ctx* c, struct zx_gl_Create_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);

  for (e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)e, free_strs);
  }
  for (e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)e, free_strs);
  }
  for (e = &x->Subscription->gg;
       e && e->g.tok == zx_gl_Subscription_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Subscription(c, (struct zx_gl_Subscription_s*)e, free_strs);
  }
  for (e = &x->CreateItem->gg;
       e && e->g.tok == zx_gl_CreateItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_CreateItem(c, (struct zx_gl_CreateItem_s*)e, free_strs);
  }
  for (e = &x->ItemSelection->gg;
       e && e->g.tok == zx_gl_ItemSelection_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ItemSelection(c, (struct zx_gl_ItemSelection_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Create) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Create_s* zx_NEW_gl_Create(struct zx_ctx* c)
{
  struct zx_gl_Create_s* x = ZX_ZALLOC(c, struct zx_gl_Create_s);
  x->gg.g.tok = zx_gl_Create_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Create) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Create(struct zx_ctx* c, struct zx_gl_Create_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);

  for (se = &x->ResourceID->gg;
       se && se->g.tok == zx_gl_ResourceID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)se);
  for (se = &x->EncryptedResourceID->gg;
       se && se->g.tok == zx_gl_EncryptedResourceID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)se);
  for (se = &x->Subscription->gg;
       se && se->g.tok == zx_gl_Subscription_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Subscription(c, (struct zx_gl_Subscription_s*)se);
  for (se = &x->CreateItem->gg;
       se && se->g.tok == zx_gl_CreateItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_CreateItem(c, (struct zx_gl_CreateItem_s*)se);
  for (se = &x->ItemSelection->gg;
       se && se->g.tok == zx_gl_ItemSelection_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ItemSelection(c, (struct zx_gl_ItemSelection_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Create) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Create_s* zx_DEEP_CLONE_gl_Create(struct zx_ctx* c, struct zx_gl_Create_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Create_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Create_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);

  for (enn = 0, e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ResourceID(c,(struct zx_gl_ResourceID_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResourceID = (struct zx_gl_ResourceID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_EncryptedResourceID(c,(struct zx_gl_EncryptedResourceID_s*)e,dup_strs);
  	  if (!enn)
  	      x->EncryptedResourceID = (struct zx_gl_EncryptedResourceID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Subscription->gg;
       e && e->g.tok == zx_gl_Subscription_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Subscription(c,(struct zx_gl_Subscription_s*)e,dup_strs);
  	  if (!enn)
  	      x->Subscription = (struct zx_gl_Subscription_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CreateItem->gg;
       e && e->g.tok == zx_gl_CreateItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_CreateItem(c,(struct zx_gl_CreateItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->CreateItem = (struct zx_gl_CreateItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ItemSelection->gg;
       e && e->g.tok == zx_gl_ItemSelection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ItemSelection(c,(struct zx_gl_ItemSelection_s*)e,dup_strs);
  	  if (!enn)
  	      x->ItemSelection = (struct zx_gl_ItemSelection_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Create) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Create(struct zx_ctx* c, struct zx_gl_Create_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Subscription->gg;
       e && e->g.tok == zx_gl_Subscription_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Subscription(c, (struct zx_gl_Subscription_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CreateItem->gg;
       e && e->g.tok == zx_gl_CreateItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_CreateItem(c, (struct zx_gl_CreateItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ItemSelection->gg;
       e && e->g.tok == zx_gl_ItemSelection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ItemSelection(c, (struct zx_gl_ItemSelection_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Create) */

int zx_WALK_WO_gl_Create(struct zx_ctx* c, struct zx_gl_Create_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_CreateItem
#define EL_STRUCT zx_gl_CreateItem_s
#define EL_NS     gl
#define EL_TAG    CreateItem

/* FUNC(zx_FREE_gl_CreateItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_CreateItem(struct zx_ctx* c, struct zx_gl_CreateItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->itemID, free_strs);
  zx_free_attr(c, x->objectType, free_strs);

  for (e = &x->NewData->gg;
       e && e->g.tok == zx_gl_NewData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_NewData(c, (struct zx_gl_NewData_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_CreateItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_CreateItem_s* zx_NEW_gl_CreateItem(struct zx_ctx* c)
{
  struct zx_gl_CreateItem_s* x = ZX_ZALLOC(c, struct zx_gl_CreateItem_s);
  x->gg.g.tok = zx_gl_CreateItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_CreateItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_CreateItem(struct zx_ctx* c, struct zx_gl_CreateItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->itemID);
  zx_dup_attr(c, x->objectType);

  for (se = &x->NewData->gg;
       se && se->g.tok == zx_gl_NewData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_NewData(c, (struct zx_gl_NewData_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_CreateItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_CreateItem_s* zx_DEEP_CLONE_gl_CreateItem(struct zx_ctx* c, struct zx_gl_CreateItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_CreateItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_CreateItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);
  x->itemID = zx_clone_attr(c, x->itemID);
  x->objectType = zx_clone_attr(c, x->objectType);

  for (enn = 0, e = &x->NewData->gg;
       e && e->g.tok == zx_gl_NewData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_NewData(c,(struct zx_gl_NewData_s*)e,dup_strs);
  	  if (!enn)
  	      x->NewData = (struct zx_gl_NewData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_CreateItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_CreateItem(struct zx_ctx* c, struct zx_gl_CreateItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->NewData->gg;
       e && e->g.tok == zx_gl_NewData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_NewData(c, (struct zx_gl_NewData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_CreateItem) */

int zx_WALK_WO_gl_CreateItem(struct zx_ctx* c, struct zx_gl_CreateItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_CreateResponse
#define EL_STRUCT zx_gl_CreateResponse_s
#define EL_NS     gl
#define EL_TAG    CreateResponse

/* FUNC(zx_FREE_gl_CreateResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_CreateResponse(struct zx_ctx* c, struct zx_gl_CreateResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->timeStamp, free_strs);

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Status(c, (struct zx_gl_Status_s*)e, free_strs);
  }
  for (e = &x->ItemData->gg;
       e && e->g.tok == zx_gl_ItemData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ItemData(c, (struct zx_gl_ItemData_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_CreateResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_CreateResponse_s* zx_NEW_gl_CreateResponse(struct zx_ctx* c)
{
  struct zx_gl_CreateResponse_s* x = ZX_ZALLOC(c, struct zx_gl_CreateResponse_s);
  x->gg.g.tok = zx_gl_CreateResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_CreateResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_CreateResponse(struct zx_ctx* c, struct zx_gl_CreateResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->timeStamp);

  for (se = &x->Status->gg;
       se && se->g.tok == zx_gl_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Status(c, (struct zx_gl_Status_s*)se);
  for (se = &x->ItemData->gg;
       se && se->g.tok == zx_gl_ItemData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ItemData(c, (struct zx_gl_ItemData_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_CreateResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_CreateResponse_s* zx_DEEP_CLONE_gl_CreateResponse(struct zx_ctx* c, struct zx_gl_CreateResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_CreateResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_CreateResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);
  x->timeStamp = zx_clone_attr(c, x->timeStamp);

  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Status(c,(struct zx_gl_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_gl_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ItemData->gg;
       e && e->g.tok == zx_gl_ItemData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ItemData(c,(struct zx_gl_ItemData_s*)e,dup_strs);
  	  if (!enn)
  	      x->ItemData = (struct zx_gl_ItemData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_CreateResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_CreateResponse(struct zx_ctx* c, struct zx_gl_CreateResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Status(c, (struct zx_gl_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ItemData->gg;
       e && e->g.tok == zx_gl_ItemData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ItemData(c, (struct zx_gl_ItemData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_CreateResponse) */

int zx_WALK_WO_gl_CreateResponse(struct zx_ctx* c, struct zx_gl_CreateResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Credential
#define EL_STRUCT zx_gl_Credential_s
#define EL_NS     gl
#define EL_TAG    Credential

/* FUNC(zx_FREE_gl_Credential) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Credential(struct zx_ctx* c, struct zx_gl_Credential_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->notOnOrAfter, free_strs);

  for (e = &x->Assertion->gg;
       e && e->g.tok == zx_sa_Assertion_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_sa_Assertion(c, (struct zx_sa_Assertion_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Credential) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Credential_s* zx_NEW_gl_Credential(struct zx_ctx* c)
{
  struct zx_gl_Credential_s* x = ZX_ZALLOC(c, struct zx_gl_Credential_s);
  x->gg.g.tok = zx_gl_Credential_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Credential) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Credential(struct zx_ctx* c, struct zx_gl_Credential_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->notOnOrAfter);

  for (se = &x->Assertion->gg;
       se && se->g.tok == zx_sa_Assertion_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_sa_Assertion(c, (struct zx_sa_Assertion_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Credential) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Credential_s* zx_DEEP_CLONE_gl_Credential(struct zx_ctx* c, struct zx_gl_Credential_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Credential_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Credential_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->notOnOrAfter = zx_clone_attr(c, x->notOnOrAfter);

  for (enn = 0, e = &x->Assertion->gg;
       e && e->g.tok == zx_sa_Assertion_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_sa_Assertion(c,(struct zx_sa_Assertion_s*)e,dup_strs);
  	  if (!enn)
  	      x->Assertion = (struct zx_sa_Assertion_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Credential) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Credential(struct zx_ctx* c, struct zx_gl_Credential_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Assertion->gg;
       e && e->g.tok == zx_sa_Assertion_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_sa_Assertion(c, (struct zx_sa_Assertion_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Credential) */

int zx_WALK_WO_gl_Credential(struct zx_ctx* c, struct zx_gl_Credential_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Data
#define EL_STRUCT zx_gl_Data_s
#define EL_NS     gl
#define EL_TAG    Data

/* FUNC(zx_FREE_gl_Data) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Data(struct zx_ctx* c, struct zx_gl_Data_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->itemIDRef, free_strs);
  zx_free_attr(c, x->nextOffset, free_strs);
  zx_free_attr(c, x->notSorted, free_strs);
  zx_free_attr(c, x->remaining, free_strs);
  zx_free_attr(c, x->setID, free_strs);
  zx_free_attr(c, x->changeFormat, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Data) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Data_s* zx_NEW_gl_Data(struct zx_ctx* c)
{
  struct zx_gl_Data_s* x = ZX_ZALLOC(c, struct zx_gl_Data_s);
  x->gg.g.tok = zx_gl_Data_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Data) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Data(struct zx_ctx* c, struct zx_gl_Data_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->itemIDRef);
  zx_dup_attr(c, x->nextOffset);
  zx_dup_attr(c, x->notSorted);
  zx_dup_attr(c, x->remaining);
  zx_dup_attr(c, x->setID);
  zx_dup_attr(c, x->changeFormat);


}

/* FUNC(zx_DEEP_CLONE_gl_Data) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Data_s* zx_DEEP_CLONE_gl_Data(struct zx_ctx* c, struct zx_gl_Data_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Data_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Data_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);
  x->itemIDRef = zx_clone_attr(c, x->itemIDRef);
  x->nextOffset = zx_clone_attr(c, x->nextOffset);
  x->notSorted = zx_clone_attr(c, x->notSorted);
  x->remaining = zx_clone_attr(c, x->remaining);
  x->setID = zx_clone_attr(c, x->setID);
  x->changeFormat = zx_clone_attr(c, x->changeFormat);


  return x;
}

/* FUNC(zx_WALK_SO_gl_Data) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Data(struct zx_ctx* c, struct zx_gl_Data_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Data) */

int zx_WALK_WO_gl_Data(struct zx_ctx* c, struct zx_gl_Data_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Delete
#define EL_STRUCT zx_gl_Delete_s
#define EL_NS     gl
#define EL_TAG    Delete

/* FUNC(zx_FREE_gl_Delete) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Delete(struct zx_ctx* c, struct zx_gl_Delete_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);

  for (e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)e, free_strs);
  }
  for (e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)e, free_strs);
  }
  for (e = &x->DeleteItem->gg;
       e && e->g.tok == zx_gl_DeleteItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_DeleteItem(c, (struct zx_gl_DeleteItem_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Delete) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Delete_s* zx_NEW_gl_Delete(struct zx_ctx* c)
{
  struct zx_gl_Delete_s* x = ZX_ZALLOC(c, struct zx_gl_Delete_s);
  x->gg.g.tok = zx_gl_Delete_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Delete) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Delete(struct zx_ctx* c, struct zx_gl_Delete_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);

  for (se = &x->ResourceID->gg;
       se && se->g.tok == zx_gl_ResourceID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)se);
  for (se = &x->EncryptedResourceID->gg;
       se && se->g.tok == zx_gl_EncryptedResourceID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)se);
  for (se = &x->DeleteItem->gg;
       se && se->g.tok == zx_gl_DeleteItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_DeleteItem(c, (struct zx_gl_DeleteItem_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Delete) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Delete_s* zx_DEEP_CLONE_gl_Delete(struct zx_ctx* c, struct zx_gl_Delete_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Delete_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Delete_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);

  for (enn = 0, e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ResourceID(c,(struct zx_gl_ResourceID_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResourceID = (struct zx_gl_ResourceID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_EncryptedResourceID(c,(struct zx_gl_EncryptedResourceID_s*)e,dup_strs);
  	  if (!enn)
  	      x->EncryptedResourceID = (struct zx_gl_EncryptedResourceID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DeleteItem->gg;
       e && e->g.tok == zx_gl_DeleteItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_DeleteItem(c,(struct zx_gl_DeleteItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->DeleteItem = (struct zx_gl_DeleteItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Delete) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Delete(struct zx_ctx* c, struct zx_gl_Delete_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DeleteItem->gg;
       e && e->g.tok == zx_gl_DeleteItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_DeleteItem(c, (struct zx_gl_DeleteItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Delete) */

int zx_WALK_WO_gl_Delete(struct zx_ctx* c, struct zx_gl_Delete_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_DeleteItem
#define EL_STRUCT zx_gl_DeleteItem_s
#define EL_NS     gl
#define EL_TAG    DeleteItem

/* FUNC(zx_FREE_gl_DeleteItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_DeleteItem(struct zx_ctx* c, struct zx_gl_DeleteItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->itemID, free_strs);
  zx_free_attr(c, x->notChangedSince, free_strs);
  zx_free_attr(c, x->objectType, free_strs);
  zx_free_attr(c, x->predefined, free_strs);

  zx_free_simple_elems(c, x->Select, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_DeleteItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_DeleteItem_s* zx_NEW_gl_DeleteItem(struct zx_ctx* c)
{
  struct zx_gl_DeleteItem_s* x = ZX_ZALLOC(c, struct zx_gl_DeleteItem_s);
  x->gg.g.tok = zx_gl_DeleteItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_DeleteItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_DeleteItem(struct zx_ctx* c, struct zx_gl_DeleteItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->itemID);
  zx_dup_attr(c, x->notChangedSince);
  zx_dup_attr(c, x->objectType);
  zx_dup_attr(c, x->predefined);

  zx_dup_strs_simple_elems(c, x->Select);

}

/* FUNC(zx_DEEP_CLONE_gl_DeleteItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_DeleteItem_s* zx_DEEP_CLONE_gl_DeleteItem(struct zx_ctx* c, struct zx_gl_DeleteItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_DeleteItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_DeleteItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);
  x->itemID = zx_clone_attr(c, x->itemID);
  x->notChangedSince = zx_clone_attr(c, x->notChangedSince);
  x->objectType = zx_clone_attr(c, x->objectType);
  x->predefined = zx_clone_attr(c, x->predefined);

  x->Select = zx_deep_clone_simple_elems(c,x->Select, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_gl_DeleteItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_DeleteItem(struct zx_ctx* c, struct zx_gl_DeleteItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Select, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_DeleteItem) */

int zx_WALK_WO_gl_DeleteItem(struct zx_ctx* c, struct zx_gl_DeleteItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_DeleteResponse
#define EL_STRUCT zx_gl_DeleteResponse_s
#define EL_NS     gl
#define EL_TAG    DeleteResponse

/* FUNC(zx_FREE_gl_DeleteResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_DeleteResponse(struct zx_ctx* c, struct zx_gl_DeleteResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Status(c, (struct zx_gl_Status_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_DeleteResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_DeleteResponse_s* zx_NEW_gl_DeleteResponse(struct zx_ctx* c)
{
  struct zx_gl_DeleteResponse_s* x = ZX_ZALLOC(c, struct zx_gl_DeleteResponse_s);
  x->gg.g.tok = zx_gl_DeleteResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_DeleteResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_DeleteResponse(struct zx_ctx* c, struct zx_gl_DeleteResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);

  for (se = &x->Status->gg;
       se && se->g.tok == zx_gl_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Status(c, (struct zx_gl_Status_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_DeleteResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_DeleteResponse_s* zx_DEEP_CLONE_gl_DeleteResponse(struct zx_ctx* c, struct zx_gl_DeleteResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_DeleteResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_DeleteResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);

  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Status(c,(struct zx_gl_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_gl_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_DeleteResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_DeleteResponse(struct zx_ctx* c, struct zx_gl_DeleteResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Status(c, (struct zx_gl_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_DeleteResponse) */

int zx_WALK_WO_gl_DeleteResponse(struct zx_ctx* c, struct zx_gl_DeleteResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_EllipticalArea
#define EL_STRUCT zx_gl_EllipticalArea_s
#define EL_NS     gl
#define EL_TAG    EllipticalArea

/* FUNC(zx_FREE_gl_EllipticalArea) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_EllipticalArea(struct zx_ctx* c, struct zx_gl_EllipticalArea_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_coord(c, (struct zx_gl_coord_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->angle, free_strs);
  zx_free_simple_elems(c, x->semiMajor, free_strs);
  zx_free_simple_elems(c, x->semiMinor, free_strs);
  zx_free_simple_elems(c, x->angularUnit, free_strs);
  zx_free_simple_elems(c, x->distanceUnit, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_EllipticalArea) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_EllipticalArea_s* zx_NEW_gl_EllipticalArea(struct zx_ctx* c)
{
  struct zx_gl_EllipticalArea_s* x = ZX_ZALLOC(c, struct zx_gl_EllipticalArea_s);
  x->gg.g.tok = zx_gl_EllipticalArea_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_EllipticalArea) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_EllipticalArea(struct zx_ctx* c, struct zx_gl_EllipticalArea_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->coord->gg;
       se && se->g.tok == zx_gl_coord_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_coord(c, (struct zx_gl_coord_s*)se);
  zx_dup_strs_simple_elems(c, x->angle);
  zx_dup_strs_simple_elems(c, x->semiMajor);
  zx_dup_strs_simple_elems(c, x->semiMinor);
  zx_dup_strs_simple_elems(c, x->angularUnit);
  zx_dup_strs_simple_elems(c, x->distanceUnit);

}

/* FUNC(zx_DEEP_CLONE_gl_EllipticalArea) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_EllipticalArea_s* zx_DEEP_CLONE_gl_EllipticalArea(struct zx_ctx* c, struct zx_gl_EllipticalArea_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_EllipticalArea_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_EllipticalArea_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_coord(c,(struct zx_gl_coord_s*)e,dup_strs);
  	  if (!enn)
  	      x->coord = (struct zx_gl_coord_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->angle = zx_deep_clone_simple_elems(c,x->angle, dup_strs);
  x->semiMajor = zx_deep_clone_simple_elems(c,x->semiMajor, dup_strs);
  x->semiMinor = zx_deep_clone_simple_elems(c,x->semiMinor, dup_strs);
  x->angularUnit = zx_deep_clone_simple_elems(c,x->angularUnit, dup_strs);
  x->distanceUnit = zx_deep_clone_simple_elems(c,x->distanceUnit, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_gl_EllipticalArea) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_EllipticalArea(struct zx_ctx* c, struct zx_gl_EllipticalArea_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_coord(c, (struct zx_gl_coord_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->angle, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->semiMajor, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->semiMinor, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->angularUnit, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->distanceUnit, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_EllipticalArea) */

int zx_WALK_WO_gl_EllipticalArea(struct zx_ctx* c, struct zx_gl_EllipticalArea_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_EncryptedResourceID
#define EL_STRUCT zx_gl_EncryptedResourceID_s
#define EL_NS     gl
#define EL_TAG    EncryptedResourceID

/* FUNC(zx_FREE_gl_EncryptedResourceID) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_EncryptedResourceID(struct zx_ctx* c, struct zx_gl_EncryptedResourceID_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->EncryptedData->gg;
       e && e->g.tok == zx_xenc_EncryptedData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xenc_EncryptedData(c, (struct zx_xenc_EncryptedData_s*)e, free_strs);
  }
  for (e = &x->EncryptedKey->gg;
       e && e->g.tok == zx_xenc_EncryptedKey_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xenc_EncryptedKey(c, (struct zx_xenc_EncryptedKey_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_EncryptedResourceID) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_EncryptedResourceID_s* zx_NEW_gl_EncryptedResourceID(struct zx_ctx* c)
{
  struct zx_gl_EncryptedResourceID_s* x = ZX_ZALLOC(c, struct zx_gl_EncryptedResourceID_s);
  x->gg.g.tok = zx_gl_EncryptedResourceID_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_EncryptedResourceID) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_EncryptedResourceID(struct zx_ctx* c, struct zx_gl_EncryptedResourceID_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->EncryptedData->gg;
       se && se->g.tok == zx_xenc_EncryptedData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xenc_EncryptedData(c, (struct zx_xenc_EncryptedData_s*)se);
  for (se = &x->EncryptedKey->gg;
       se && se->g.tok == zx_xenc_EncryptedKey_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xenc_EncryptedKey(c, (struct zx_xenc_EncryptedKey_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_EncryptedResourceID) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_EncryptedResourceID_s* zx_DEEP_CLONE_gl_EncryptedResourceID(struct zx_ctx* c, struct zx_gl_EncryptedResourceID_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_EncryptedResourceID_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_EncryptedResourceID_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->EncryptedData->gg;
       e && e->g.tok == zx_xenc_EncryptedData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xenc_EncryptedData(c,(struct zx_xenc_EncryptedData_s*)e,dup_strs);
  	  if (!enn)
  	      x->EncryptedData = (struct zx_xenc_EncryptedData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EncryptedKey->gg;
       e && e->g.tok == zx_xenc_EncryptedKey_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xenc_EncryptedKey(c,(struct zx_xenc_EncryptedKey_s*)e,dup_strs);
  	  if (!enn)
  	      x->EncryptedKey = (struct zx_xenc_EncryptedKey_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_EncryptedResourceID) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_EncryptedResourceID(struct zx_ctx* c, struct zx_gl_EncryptedResourceID_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->EncryptedData->gg;
       e && e->g.tok == zx_xenc_EncryptedData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xenc_EncryptedData(c, (struct zx_xenc_EncryptedData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EncryptedKey->gg;
       e && e->g.tok == zx_xenc_EncryptedKey_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xenc_EncryptedKey(c, (struct zx_xenc_EncryptedKey_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_EncryptedResourceID) */

int zx_WALK_WO_gl_EncryptedResourceID(struct zx_ctx* c, struct zx_gl_EncryptedResourceID_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Extension
#define EL_STRUCT zx_gl_Extension_s
#define EL_NS     gl
#define EL_TAG    Extension

/* FUNC(zx_FREE_gl_Extension) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Extension(struct zx_ctx* c, struct zx_gl_Extension_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Extension) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Extension_s* zx_NEW_gl_Extension(struct zx_ctx* c)
{
  struct zx_gl_Extension_s* x = ZX_ZALLOC(c, struct zx_gl_Extension_s);
  x->gg.g.tok = zx_gl_Extension_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Extension) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Extension(struct zx_ctx* c, struct zx_gl_Extension_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_gl_Extension) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Extension_s* zx_DEEP_CLONE_gl_Extension(struct zx_ctx* c, struct zx_gl_Extension_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Extension_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Extension_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_gl_Extension) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Extension(struct zx_ctx* c, struct zx_gl_Extension_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Extension) */

int zx_WALK_WO_gl_Extension(struct zx_ctx* c, struct zx_gl_Extension_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_GeometryCollection
#define EL_STRUCT zx_gl_GeometryCollection_s
#define EL_NS     gl
#define EL_TAG    GeometryCollection

/* FUNC(zx_FREE_gl_GeometryCollection) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_GeometryCollection(struct zx_ctx* c, struct zx_gl_GeometryCollection_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_shape(c, (struct zx_gl_shape_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_GeometryCollection) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_GeometryCollection_s* zx_NEW_gl_GeometryCollection(struct zx_ctx* c)
{
  struct zx_gl_GeometryCollection_s* x = ZX_ZALLOC(c, struct zx_gl_GeometryCollection_s);
  x->gg.g.tok = zx_gl_GeometryCollection_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_GeometryCollection) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_GeometryCollection(struct zx_ctx* c, struct zx_gl_GeometryCollection_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->shape->gg;
       se && se->g.tok == zx_gl_shape_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_shape(c, (struct zx_gl_shape_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_GeometryCollection) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_GeometryCollection_s* zx_DEEP_CLONE_gl_GeometryCollection(struct zx_ctx* c, struct zx_gl_GeometryCollection_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_GeometryCollection_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_GeometryCollection_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_shape(c,(struct zx_gl_shape_s*)e,dup_strs);
  	  if (!enn)
  	      x->shape = (struct zx_gl_shape_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_GeometryCollection) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_GeometryCollection(struct zx_ctx* c, struct zx_gl_GeometryCollection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_shape(c, (struct zx_gl_shape_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_GeometryCollection) */

int zx_WALK_WO_gl_GeometryCollection(struct zx_ctx* c, struct zx_gl_GeometryCollection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Identifier
#define EL_STRUCT zx_gl_Identifier_s
#define EL_NS     gl
#define EL_TAG    Identifier

/* FUNC(zx_FREE_gl_Identifier) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Identifier(struct zx_ctx* c, struct zx_gl_Identifier_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->code, free_strs);
  zx_free_simple_elems(c, x->codeSpace, free_strs);
  zx_free_simple_elems(c, x->edition, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Identifier) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Identifier_s* zx_NEW_gl_Identifier(struct zx_ctx* c)
{
  struct zx_gl_Identifier_s* x = ZX_ZALLOC(c, struct zx_gl_Identifier_s);
  x->gg.g.tok = zx_gl_Identifier_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Identifier) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Identifier(struct zx_ctx* c, struct zx_gl_Identifier_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->code);
  zx_dup_strs_simple_elems(c, x->codeSpace);
  zx_dup_strs_simple_elems(c, x->edition);

}

/* FUNC(zx_DEEP_CLONE_gl_Identifier) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Identifier_s* zx_DEEP_CLONE_gl_Identifier(struct zx_ctx* c, struct zx_gl_Identifier_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Identifier_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Identifier_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->code = zx_deep_clone_simple_elems(c,x->code, dup_strs);
  x->codeSpace = zx_deep_clone_simple_elems(c,x->codeSpace, dup_strs);
  x->edition = zx_deep_clone_simple_elems(c,x->edition, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_gl_Identifier) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Identifier(struct zx_ctx* c, struct zx_gl_Identifier_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->code, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->codeSpace, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->edition, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Identifier) */

int zx_WALK_WO_gl_Identifier(struct zx_ctx* c, struct zx_gl_Identifier_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_ItemData
#define EL_STRUCT zx_gl_ItemData_s
#define EL_NS     gl
#define EL_TAG    ItemData

/* FUNC(zx_FREE_gl_ItemData) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_ItemData(struct zx_ctx* c, struct zx_gl_ItemData_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->itemIDRef, free_strs);
  zx_free_attr(c, x->notSorted, free_strs);
  zx_free_attr(c, x->changeFormat, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_ItemData) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_ItemData_s* zx_NEW_gl_ItemData(struct zx_ctx* c)
{
  struct zx_gl_ItemData_s* x = ZX_ZALLOC(c, struct zx_gl_ItemData_s);
  x->gg.g.tok = zx_gl_ItemData_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_ItemData) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_ItemData(struct zx_ctx* c, struct zx_gl_ItemData_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->itemIDRef);
  zx_dup_attr(c, x->notSorted);
  zx_dup_attr(c, x->changeFormat);


}

/* FUNC(zx_DEEP_CLONE_gl_ItemData) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_ItemData_s* zx_DEEP_CLONE_gl_ItemData(struct zx_ctx* c, struct zx_gl_ItemData_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_ItemData_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_ItemData_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);
  x->itemIDRef = zx_clone_attr(c, x->itemIDRef);
  x->notSorted = zx_clone_attr(c, x->notSorted);
  x->changeFormat = zx_clone_attr(c, x->changeFormat);


  return x;
}

/* FUNC(zx_WALK_SO_gl_ItemData) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_ItemData(struct zx_ctx* c, struct zx_gl_ItemData_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_ItemData) */

int zx_WALK_WO_gl_ItemData(struct zx_ctx* c, struct zx_gl_ItemData_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_ItemSelection
#define EL_STRUCT zx_gl_ItemSelection_s
#define EL_NS     gl
#define EL_TAG    ItemSelection

/* FUNC(zx_FREE_gl_ItemSelection) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_ItemSelection(struct zx_ctx* c, struct zx_gl_ItemSelection_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->AreaComparison->gg;
       e && e->g.tok == zx_gl_AreaComparison_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_AreaComparison(c, (struct zx_gl_AreaComparison_s*)e, free_strs);
  }
  for (e = &x->eqop->gg;
       e && e->g.tok == zx_gl_eqop_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_eqop(c, (struct zx_gl_eqop_s*)e, free_strs);
  }
  for (e = &x->geoinfo->gg;
       e && e->g.tok == zx_gl_geoinfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_geoinfo(c, (struct zx_gl_geoinfo_s*)e, free_strs);
  }
  for (e = &x->loc_type->gg;
       e && e->g.tok == zx_gl_loc_type_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_loc_type(c, (struct zx_gl_loc_type_s*)e, free_strs);
  }
  for (e = &x->prio->gg;
       e && e->g.tok == zx_gl_prio_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_prio(c, (struct zx_gl_prio_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_ItemSelection) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_ItemSelection_s* zx_NEW_gl_ItemSelection(struct zx_ctx* c)
{
  struct zx_gl_ItemSelection_s* x = ZX_ZALLOC(c, struct zx_gl_ItemSelection_s);
  x->gg.g.tok = zx_gl_ItemSelection_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_ItemSelection) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_ItemSelection(struct zx_ctx* c, struct zx_gl_ItemSelection_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->AreaComparison->gg;
       se && se->g.tok == zx_gl_AreaComparison_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_AreaComparison(c, (struct zx_gl_AreaComparison_s*)se);
  for (se = &x->eqop->gg;
       se && se->g.tok == zx_gl_eqop_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_eqop(c, (struct zx_gl_eqop_s*)se);
  for (se = &x->geoinfo->gg;
       se && se->g.tok == zx_gl_geoinfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_geoinfo(c, (struct zx_gl_geoinfo_s*)se);
  for (se = &x->loc_type->gg;
       se && se->g.tok == zx_gl_loc_type_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_loc_type(c, (struct zx_gl_loc_type_s*)se);
  for (se = &x->prio->gg;
       se && se->g.tok == zx_gl_prio_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_prio(c, (struct zx_gl_prio_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_ItemSelection) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_ItemSelection_s* zx_DEEP_CLONE_gl_ItemSelection(struct zx_ctx* c, struct zx_gl_ItemSelection_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_ItemSelection_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_ItemSelection_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->AreaComparison->gg;
       e && e->g.tok == zx_gl_AreaComparison_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_AreaComparison(c,(struct zx_gl_AreaComparison_s*)e,dup_strs);
  	  if (!enn)
  	      x->AreaComparison = (struct zx_gl_AreaComparison_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->eqop->gg;
       e && e->g.tok == zx_gl_eqop_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_eqop(c,(struct zx_gl_eqop_s*)e,dup_strs);
  	  if (!enn)
  	      x->eqop = (struct zx_gl_eqop_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->geoinfo->gg;
       e && e->g.tok == zx_gl_geoinfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_geoinfo(c,(struct zx_gl_geoinfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->geoinfo = (struct zx_gl_geoinfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->loc_type->gg;
       e && e->g.tok == zx_gl_loc_type_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_loc_type(c,(struct zx_gl_loc_type_s*)e,dup_strs);
  	  if (!enn)
  	      x->loc_type = (struct zx_gl_loc_type_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->prio->gg;
       e && e->g.tok == zx_gl_prio_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_prio(c,(struct zx_gl_prio_s*)e,dup_strs);
  	  if (!enn)
  	      x->prio = (struct zx_gl_prio_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_ItemSelection) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_ItemSelection(struct zx_ctx* c, struct zx_gl_ItemSelection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AreaComparison->gg;
       e && e->g.tok == zx_gl_AreaComparison_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_AreaComparison(c, (struct zx_gl_AreaComparison_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->eqop->gg;
       e && e->g.tok == zx_gl_eqop_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_eqop(c, (struct zx_gl_eqop_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->geoinfo->gg;
       e && e->g.tok == zx_gl_geoinfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_geoinfo(c, (struct zx_gl_geoinfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->loc_type->gg;
       e && e->g.tok == zx_gl_loc_type_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_loc_type(c, (struct zx_gl_loc_type_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->prio->gg;
       e && e->g.tok == zx_gl_prio_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_prio(c, (struct zx_gl_prio_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_ItemSelection) */

int zx_WALK_WO_gl_ItemSelection(struct zx_ctx* c, struct zx_gl_ItemSelection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_LL
#define EL_STRUCT zx_gl_LL_s
#define EL_NS     gl
#define EL_TAG    LL

/* FUNC(zx_FREE_gl_LL) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_LL(struct zx_ctx* c, struct zx_gl_LL_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);
  zx_free_attr(c, x->script, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_LL) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_LL_s* zx_NEW_gl_LL(struct zx_ctx* c)
{
  struct zx_gl_LL_s* x = ZX_ZALLOC(c, struct zx_gl_LL_s);
  x->gg.g.tok = zx_gl_LL_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_LL) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_LL(struct zx_ctx* c, struct zx_gl_LL_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);
  zx_dup_attr(c, x->script);


}

/* FUNC(zx_DEEP_CLONE_gl_LL) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_LL_s* zx_DEEP_CLONE_gl_LL(struct zx_ctx* c, struct zx_gl_LL_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_LL_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_LL_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);
  x->script = zx_clone_attr(c, x->script);


  return x;
}

/* FUNC(zx_WALK_SO_gl_LL) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_LL(struct zx_ctx* c, struct zx_gl_LL_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_LL) */

int zx_WALK_WO_gl_LL(struct zx_ctx* c, struct zx_gl_LL_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_LPostalAddress
#define EL_STRUCT zx_gl_LPostalAddress_s
#define EL_NS     gl
#define EL_TAG    LPostalAddress

/* FUNC(zx_FREE_gl_LPostalAddress) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_LPostalAddress(struct zx_ctx* c, struct zx_gl_LPostalAddress_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);
  zx_free_attr(c, x->script, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_LPostalAddress) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_LPostalAddress_s* zx_NEW_gl_LPostalAddress(struct zx_ctx* c)
{
  struct zx_gl_LPostalAddress_s* x = ZX_ZALLOC(c, struct zx_gl_LPostalAddress_s);
  x->gg.g.tok = zx_gl_LPostalAddress_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_LPostalAddress) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_LPostalAddress(struct zx_ctx* c, struct zx_gl_LPostalAddress_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);
  zx_dup_attr(c, x->script);


}

/* FUNC(zx_DEEP_CLONE_gl_LPostalAddress) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_LPostalAddress_s* zx_DEEP_CLONE_gl_LPostalAddress(struct zx_ctx* c, struct zx_gl_LPostalAddress_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_LPostalAddress_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_LPostalAddress_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);
  x->script = zx_clone_attr(c, x->script);


  return x;
}

/* FUNC(zx_WALK_SO_gl_LPostalAddress) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_LPostalAddress(struct zx_ctx* c, struct zx_gl_LPostalAddress_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_LPostalAddress) */

int zx_WALK_WO_gl_LPostalAddress(struct zx_ctx* c, struct zx_gl_LPostalAddress_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_LSt
#define EL_STRUCT zx_gl_LSt_s
#define EL_NS     gl
#define EL_TAG    LSt

/* FUNC(zx_FREE_gl_LSt) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_LSt(struct zx_ctx* c, struct zx_gl_LSt_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);
  zx_free_attr(c, x->script, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_LSt) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_LSt_s* zx_NEW_gl_LSt(struct zx_ctx* c)
{
  struct zx_gl_LSt_s* x = ZX_ZALLOC(c, struct zx_gl_LSt_s);
  x->gg.g.tok = zx_gl_LSt_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_LSt) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_LSt(struct zx_ctx* c, struct zx_gl_LSt_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);
  zx_dup_attr(c, x->script);


}

/* FUNC(zx_DEEP_CLONE_gl_LSt) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_LSt_s* zx_DEEP_CLONE_gl_LSt(struct zx_ctx* c, struct zx_gl_LSt_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_LSt_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_LSt_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);
  x->script = zx_clone_attr(c, x->script);


  return x;
}

/* FUNC(zx_WALK_SO_gl_LSt) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_LSt(struct zx_ctx* c, struct zx_gl_LSt_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_LSt) */

int zx_WALK_WO_gl_LSt(struct zx_ctx* c, struct zx_gl_LSt_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_LineString
#define EL_STRUCT zx_gl_LineString_s
#define EL_NS     gl
#define EL_TAG    LineString

/* FUNC(zx_FREE_gl_LineString) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_LineString(struct zx_ctx* c, struct zx_gl_LineString_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_coord(c, (struct zx_gl_coord_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_LineString) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_LineString_s* zx_NEW_gl_LineString(struct zx_ctx* c)
{
  struct zx_gl_LineString_s* x = ZX_ZALLOC(c, struct zx_gl_LineString_s);
  x->gg.g.tok = zx_gl_LineString_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_LineString) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_LineString(struct zx_ctx* c, struct zx_gl_LineString_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->coord->gg;
       se && se->g.tok == zx_gl_coord_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_coord(c, (struct zx_gl_coord_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_LineString) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_LineString_s* zx_DEEP_CLONE_gl_LineString(struct zx_ctx* c, struct zx_gl_LineString_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_LineString_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_LineString_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_coord(c,(struct zx_gl_coord_s*)e,dup_strs);
  	  if (!enn)
  	      x->coord = (struct zx_gl_coord_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_LineString) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_LineString(struct zx_ctx* c, struct zx_gl_LineString_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_coord(c, (struct zx_gl_coord_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_LineString) */

int zx_WALK_WO_gl_LineString(struct zx_ctx* c, struct zx_gl_LineString_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_LinearRing
#define EL_STRUCT zx_gl_LinearRing_s
#define EL_NS     gl
#define EL_TAG    LinearRing

/* FUNC(zx_FREE_gl_LinearRing) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_LinearRing(struct zx_ctx* c, struct zx_gl_LinearRing_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_coord(c, (struct zx_gl_coord_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_LinearRing) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_LinearRing_s* zx_NEW_gl_LinearRing(struct zx_ctx* c)
{
  struct zx_gl_LinearRing_s* x = ZX_ZALLOC(c, struct zx_gl_LinearRing_s);
  x->gg.g.tok = zx_gl_LinearRing_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_LinearRing) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_LinearRing(struct zx_ctx* c, struct zx_gl_LinearRing_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->coord->gg;
       se && se->g.tok == zx_gl_coord_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_coord(c, (struct zx_gl_coord_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_LinearRing) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_LinearRing_s* zx_DEEP_CLONE_gl_LinearRing(struct zx_ctx* c, struct zx_gl_LinearRing_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_LinearRing_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_LinearRing_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_coord(c,(struct zx_gl_coord_s*)e,dup_strs);
  	  if (!enn)
  	      x->coord = (struct zx_gl_coord_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_LinearRing) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_LinearRing(struct zx_ctx* c, struct zx_gl_LinearRing_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_coord(c, (struct zx_gl_coord_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_LinearRing) */

int zx_WALK_WO_gl_LinearRing(struct zx_ctx* c, struct zx_gl_LinearRing_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Modification
#define EL_STRUCT zx_gl_Modification_s
#define EL_NS     gl
#define EL_TAG    Modification

/* FUNC(zx_FREE_gl_Modification) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Modification(struct zx_ctx* c, struct zx_gl_Modification_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->itemID, free_strs);
  zx_free_attr(c, x->notChangedSince, free_strs);
  zx_free_attr(c, x->objectType, free_strs);
  zx_free_attr(c, x->overrideAllowed, free_strs);

  zx_free_simple_elems(c, x->Select, free_strs);
  for (e = &x->NewData->gg;
       e && e->g.tok == zx_gl_NewData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_NewData(c, (struct zx_gl_NewData_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Modification) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Modification_s* zx_NEW_gl_Modification(struct zx_ctx* c)
{
  struct zx_gl_Modification_s* x = ZX_ZALLOC(c, struct zx_gl_Modification_s);
  x->gg.g.tok = zx_gl_Modification_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Modification) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Modification(struct zx_ctx* c, struct zx_gl_Modification_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->itemID);
  zx_dup_attr(c, x->notChangedSince);
  zx_dup_attr(c, x->objectType);
  zx_dup_attr(c, x->overrideAllowed);

  zx_dup_strs_simple_elems(c, x->Select);
  for (se = &x->NewData->gg;
       se && se->g.tok == zx_gl_NewData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_NewData(c, (struct zx_gl_NewData_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Modification) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Modification_s* zx_DEEP_CLONE_gl_Modification(struct zx_ctx* c, struct zx_gl_Modification_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Modification_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Modification_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);
  x->itemID = zx_clone_attr(c, x->itemID);
  x->notChangedSince = zx_clone_attr(c, x->notChangedSince);
  x->objectType = zx_clone_attr(c, x->objectType);
  x->overrideAllowed = zx_clone_attr(c, x->overrideAllowed);

  x->Select = zx_deep_clone_simple_elems(c,x->Select, dup_strs);
  for (enn = 0, e = &x->NewData->gg;
       e && e->g.tok == zx_gl_NewData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_NewData(c,(struct zx_gl_NewData_s*)e,dup_strs);
  	  if (!enn)
  	      x->NewData = (struct zx_gl_NewData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Modification) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Modification(struct zx_ctx* c, struct zx_gl_Modification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Select, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->NewData->gg;
       e && e->g.tok == zx_gl_NewData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_NewData(c, (struct zx_gl_NewData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Modification) */

int zx_WALK_WO_gl_Modification(struct zx_ctx* c, struct zx_gl_Modification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Modify
#define EL_STRUCT zx_gl_Modify_s
#define EL_NS     gl
#define EL_TAG    Modify

/* FUNC(zx_FREE_gl_Modify) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Modify(struct zx_ctx* c, struct zx_gl_Modify_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);

  for (e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)e, free_strs);
  }
  for (e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)e, free_strs);
  }
  for (e = &x->Subscription->gg;
       e && e->g.tok == zx_gl_Subscription_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Subscription(c, (struct zx_gl_Subscription_s*)e, free_strs);
  }
  for (e = &x->Modification->gg;
       e && e->g.tok == zx_gl_Modification_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Modification(c, (struct zx_gl_Modification_s*)e, free_strs);
  }
  for (e = &x->ItemSelection->gg;
       e && e->g.tok == zx_gl_ItemSelection_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ItemSelection(c, (struct zx_gl_ItemSelection_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Modify) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Modify_s* zx_NEW_gl_Modify(struct zx_ctx* c)
{
  struct zx_gl_Modify_s* x = ZX_ZALLOC(c, struct zx_gl_Modify_s);
  x->gg.g.tok = zx_gl_Modify_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Modify) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Modify(struct zx_ctx* c, struct zx_gl_Modify_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);

  for (se = &x->ResourceID->gg;
       se && se->g.tok == zx_gl_ResourceID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)se);
  for (se = &x->EncryptedResourceID->gg;
       se && se->g.tok == zx_gl_EncryptedResourceID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)se);
  for (se = &x->Subscription->gg;
       se && se->g.tok == zx_gl_Subscription_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Subscription(c, (struct zx_gl_Subscription_s*)se);
  for (se = &x->Modification->gg;
       se && se->g.tok == zx_gl_Modification_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Modification(c, (struct zx_gl_Modification_s*)se);
  for (se = &x->ItemSelection->gg;
       se && se->g.tok == zx_gl_ItemSelection_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ItemSelection(c, (struct zx_gl_ItemSelection_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Modify) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Modify_s* zx_DEEP_CLONE_gl_Modify(struct zx_ctx* c, struct zx_gl_Modify_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Modify_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Modify_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);

  for (enn = 0, e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ResourceID(c,(struct zx_gl_ResourceID_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResourceID = (struct zx_gl_ResourceID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_EncryptedResourceID(c,(struct zx_gl_EncryptedResourceID_s*)e,dup_strs);
  	  if (!enn)
  	      x->EncryptedResourceID = (struct zx_gl_EncryptedResourceID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Subscription->gg;
       e && e->g.tok == zx_gl_Subscription_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Subscription(c,(struct zx_gl_Subscription_s*)e,dup_strs);
  	  if (!enn)
  	      x->Subscription = (struct zx_gl_Subscription_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Modification->gg;
       e && e->g.tok == zx_gl_Modification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Modification(c,(struct zx_gl_Modification_s*)e,dup_strs);
  	  if (!enn)
  	      x->Modification = (struct zx_gl_Modification_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ItemSelection->gg;
       e && e->g.tok == zx_gl_ItemSelection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ItemSelection(c,(struct zx_gl_ItemSelection_s*)e,dup_strs);
  	  if (!enn)
  	      x->ItemSelection = (struct zx_gl_ItemSelection_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Modify) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Modify(struct zx_ctx* c, struct zx_gl_Modify_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Subscription->gg;
       e && e->g.tok == zx_gl_Subscription_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Subscription(c, (struct zx_gl_Subscription_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Modification->gg;
       e && e->g.tok == zx_gl_Modification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Modification(c, (struct zx_gl_Modification_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ItemSelection->gg;
       e && e->g.tok == zx_gl_ItemSelection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ItemSelection(c, (struct zx_gl_ItemSelection_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Modify) */

int zx_WALK_WO_gl_Modify(struct zx_ctx* c, struct zx_gl_Modify_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_ModifyResponse
#define EL_STRUCT zx_gl_ModifyResponse_s
#define EL_NS     gl
#define EL_TAG    ModifyResponse

/* FUNC(zx_FREE_gl_ModifyResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_ModifyResponse(struct zx_ctx* c, struct zx_gl_ModifyResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->timeStamp, free_strs);

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Status(c, (struct zx_gl_Status_s*)e, free_strs);
  }
  for (e = &x->ItemData->gg;
       e && e->g.tok == zx_gl_ItemData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ItemData(c, (struct zx_gl_ItemData_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_ModifyResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_ModifyResponse_s* zx_NEW_gl_ModifyResponse(struct zx_ctx* c)
{
  struct zx_gl_ModifyResponse_s* x = ZX_ZALLOC(c, struct zx_gl_ModifyResponse_s);
  x->gg.g.tok = zx_gl_ModifyResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_ModifyResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_ModifyResponse(struct zx_ctx* c, struct zx_gl_ModifyResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->timeStamp);

  for (se = &x->Status->gg;
       se && se->g.tok == zx_gl_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Status(c, (struct zx_gl_Status_s*)se);
  for (se = &x->ItemData->gg;
       se && se->g.tok == zx_gl_ItemData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ItemData(c, (struct zx_gl_ItemData_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_ModifyResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_ModifyResponse_s* zx_DEEP_CLONE_gl_ModifyResponse(struct zx_ctx* c, struct zx_gl_ModifyResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_ModifyResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_ModifyResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);
  x->timeStamp = zx_clone_attr(c, x->timeStamp);

  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Status(c,(struct zx_gl_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_gl_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ItemData->gg;
       e && e->g.tok == zx_gl_ItemData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ItemData(c,(struct zx_gl_ItemData_s*)e,dup_strs);
  	  if (!enn)
  	      x->ItemData = (struct zx_gl_ItemData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_ModifyResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_ModifyResponse(struct zx_ctx* c, struct zx_gl_ModifyResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Status(c, (struct zx_gl_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ItemData->gg;
       e && e->g.tok == zx_gl_ItemData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ItemData(c, (struct zx_gl_ItemData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_ModifyResponse) */

int zx_WALK_WO_gl_ModifyResponse(struct zx_ctx* c, struct zx_gl_ModifyResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_MultiLineString
#define EL_STRUCT zx_gl_MultiLineString_s
#define EL_NS     gl
#define EL_TAG    MultiLineString

/* FUNC(zx_FREE_gl_MultiLineString) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_MultiLineString(struct zx_ctx* c, struct zx_gl_MultiLineString_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->LineString->gg;
       e && e->g.tok == zx_gl_LineString_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_LineString(c, (struct zx_gl_LineString_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_MultiLineString) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_MultiLineString_s* zx_NEW_gl_MultiLineString(struct zx_ctx* c)
{
  struct zx_gl_MultiLineString_s* x = ZX_ZALLOC(c, struct zx_gl_MultiLineString_s);
  x->gg.g.tok = zx_gl_MultiLineString_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_MultiLineString) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_MultiLineString(struct zx_ctx* c, struct zx_gl_MultiLineString_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->LineString->gg;
       se && se->g.tok == zx_gl_LineString_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_LineString(c, (struct zx_gl_LineString_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_MultiLineString) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_MultiLineString_s* zx_DEEP_CLONE_gl_MultiLineString(struct zx_ctx* c, struct zx_gl_MultiLineString_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_MultiLineString_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_MultiLineString_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->LineString->gg;
       e && e->g.tok == zx_gl_LineString_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_LineString(c,(struct zx_gl_LineString_s*)e,dup_strs);
  	  if (!enn)
  	      x->LineString = (struct zx_gl_LineString_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_MultiLineString) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_MultiLineString(struct zx_ctx* c, struct zx_gl_MultiLineString_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->LineString->gg;
       e && e->g.tok == zx_gl_LineString_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_LineString(c, (struct zx_gl_LineString_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_MultiLineString) */

int zx_WALK_WO_gl_MultiLineString(struct zx_ctx* c, struct zx_gl_MultiLineString_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_MultiPoint
#define EL_STRUCT zx_gl_MultiPoint_s
#define EL_NS     gl
#define EL_TAG    MultiPoint

/* FUNC(zx_FREE_gl_MultiPoint) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_MultiPoint(struct zx_ctx* c, struct zx_gl_MultiPoint_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->Point->gg;
       e && e->g.tok == zx_gl_Point_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Point(c, (struct zx_gl_Point_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_MultiPoint) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_MultiPoint_s* zx_NEW_gl_MultiPoint(struct zx_ctx* c)
{
  struct zx_gl_MultiPoint_s* x = ZX_ZALLOC(c, struct zx_gl_MultiPoint_s);
  x->gg.g.tok = zx_gl_MultiPoint_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_MultiPoint) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_MultiPoint(struct zx_ctx* c, struct zx_gl_MultiPoint_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->Point->gg;
       se && se->g.tok == zx_gl_Point_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Point(c, (struct zx_gl_Point_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_MultiPoint) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_MultiPoint_s* zx_DEEP_CLONE_gl_MultiPoint(struct zx_ctx* c, struct zx_gl_MultiPoint_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_MultiPoint_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_MultiPoint_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->Point->gg;
       e && e->g.tok == zx_gl_Point_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Point(c,(struct zx_gl_Point_s*)e,dup_strs);
  	  if (!enn)
  	      x->Point = (struct zx_gl_Point_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_MultiPoint) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_MultiPoint(struct zx_ctx* c, struct zx_gl_MultiPoint_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Point->gg;
       e && e->g.tok == zx_gl_Point_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Point(c, (struct zx_gl_Point_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_MultiPoint) */

int zx_WALK_WO_gl_MultiPoint(struct zx_ctx* c, struct zx_gl_MultiPoint_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_MultiPolygon
#define EL_STRUCT zx_gl_MultiPolygon_s
#define EL_NS     gl
#define EL_TAG    MultiPolygon

/* FUNC(zx_FREE_gl_MultiPolygon) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_MultiPolygon(struct zx_ctx* c, struct zx_gl_MultiPolygon_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->Polygon->gg;
       e && e->g.tok == zx_gl_Polygon_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Polygon(c, (struct zx_gl_Polygon_s*)e, free_strs);
  }
  for (e = &x->Box->gg;
       e && e->g.tok == zx_gl_Box_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Box(c, (struct zx_gl_Box_s*)e, free_strs);
  }
  for (e = &x->CircularArea->gg;
       e && e->g.tok == zx_gl_CircularArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_CircularArea(c, (struct zx_gl_CircularArea_s*)e, free_strs);
  }
  for (e = &x->CircularArcArea->gg;
       e && e->g.tok == zx_gl_CircularArcArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_CircularArcArea(c, (struct zx_gl_CircularArcArea_s*)e, free_strs);
  }
  for (e = &x->EllipticalArea->gg;
       e && e->g.tok == zx_gl_EllipticalArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_EllipticalArea(c, (struct zx_gl_EllipticalArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_MultiPolygon) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_MultiPolygon_s* zx_NEW_gl_MultiPolygon(struct zx_ctx* c)
{
  struct zx_gl_MultiPolygon_s* x = ZX_ZALLOC(c, struct zx_gl_MultiPolygon_s);
  x->gg.g.tok = zx_gl_MultiPolygon_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_MultiPolygon) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_MultiPolygon(struct zx_ctx* c, struct zx_gl_MultiPolygon_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->Polygon->gg;
       se && se->g.tok == zx_gl_Polygon_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Polygon(c, (struct zx_gl_Polygon_s*)se);
  for (se = &x->Box->gg;
       se && se->g.tok == zx_gl_Box_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Box(c, (struct zx_gl_Box_s*)se);
  for (se = &x->CircularArea->gg;
       se && se->g.tok == zx_gl_CircularArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_CircularArea(c, (struct zx_gl_CircularArea_s*)se);
  for (se = &x->CircularArcArea->gg;
       se && se->g.tok == zx_gl_CircularArcArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_CircularArcArea(c, (struct zx_gl_CircularArcArea_s*)se);
  for (se = &x->EllipticalArea->gg;
       se && se->g.tok == zx_gl_EllipticalArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_EllipticalArea(c, (struct zx_gl_EllipticalArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_MultiPolygon) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_MultiPolygon_s* zx_DEEP_CLONE_gl_MultiPolygon(struct zx_ctx* c, struct zx_gl_MultiPolygon_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_MultiPolygon_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_MultiPolygon_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->Polygon->gg;
       e && e->g.tok == zx_gl_Polygon_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Polygon(c,(struct zx_gl_Polygon_s*)e,dup_strs);
  	  if (!enn)
  	      x->Polygon = (struct zx_gl_Polygon_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Box->gg;
       e && e->g.tok == zx_gl_Box_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Box(c,(struct zx_gl_Box_s*)e,dup_strs);
  	  if (!enn)
  	      x->Box = (struct zx_gl_Box_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CircularArea->gg;
       e && e->g.tok == zx_gl_CircularArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_CircularArea(c,(struct zx_gl_CircularArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->CircularArea = (struct zx_gl_CircularArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CircularArcArea->gg;
       e && e->g.tok == zx_gl_CircularArcArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_CircularArcArea(c,(struct zx_gl_CircularArcArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->CircularArcArea = (struct zx_gl_CircularArcArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EllipticalArea->gg;
       e && e->g.tok == zx_gl_EllipticalArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_EllipticalArea(c,(struct zx_gl_EllipticalArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->EllipticalArea = (struct zx_gl_EllipticalArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_MultiPolygon) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_MultiPolygon(struct zx_ctx* c, struct zx_gl_MultiPolygon_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Polygon->gg;
       e && e->g.tok == zx_gl_Polygon_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Polygon(c, (struct zx_gl_Polygon_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Box->gg;
       e && e->g.tok == zx_gl_Box_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Box(c, (struct zx_gl_Box_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CircularArea->gg;
       e && e->g.tok == zx_gl_CircularArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_CircularArea(c, (struct zx_gl_CircularArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CircularArcArea->gg;
       e && e->g.tok == zx_gl_CircularArcArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_CircularArcArea(c, (struct zx_gl_CircularArcArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EllipticalArea->gg;
       e && e->g.tok == zx_gl_EllipticalArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_EllipticalArea(c, (struct zx_gl_EllipticalArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_MultiPolygon) */

int zx_WALK_WO_gl_MultiPolygon(struct zx_ctx* c, struct zx_gl_MultiPolygon_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_NewData
#define EL_STRUCT zx_gl_NewData_s
#define EL_NS     gl
#define EL_TAG    NewData

/* FUNC(zx_FREE_gl_NewData) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_NewData(struct zx_ctx* c, struct zx_gl_NewData_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_NewData) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_NewData_s* zx_NEW_gl_NewData(struct zx_ctx* c)
{
  struct zx_gl_NewData_s* x = ZX_ZALLOC(c, struct zx_gl_NewData_s);
  x->gg.g.tok = zx_gl_NewData_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_NewData) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_NewData(struct zx_ctx* c, struct zx_gl_NewData_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_gl_NewData) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_NewData_s* zx_DEEP_CLONE_gl_NewData(struct zx_ctx* c, struct zx_gl_NewData_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_NewData_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_NewData_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_gl_NewData) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_NewData(struct zx_ctx* c, struct zx_gl_NewData_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_NewData) */

int zx_WALK_WO_gl_NewData(struct zx_ctx* c, struct zx_gl_NewData_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Notification
#define EL_STRUCT zx_gl_Notification_s
#define EL_NS     gl
#define EL_TAG    Notification

/* FUNC(zx_FREE_gl_Notification) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Notification(struct zx_ctx* c, struct zx_gl_Notification_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->endReason, free_strs);
  zx_free_attr(c, x->expires, free_strs);
  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->subscriptionID, free_strs);

  for (e = &x->ItemData->gg;
       e && e->g.tok == zx_gl_ItemData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ItemData(c, (struct zx_gl_ItemData_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Notification) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Notification_s* zx_NEW_gl_Notification(struct zx_ctx* c)
{
  struct zx_gl_Notification_s* x = ZX_ZALLOC(c, struct zx_gl_Notification_s);
  x->gg.g.tok = zx_gl_Notification_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Notification) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Notification(struct zx_ctx* c, struct zx_gl_Notification_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->endReason);
  zx_dup_attr(c, x->expires);
  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->subscriptionID);

  for (se = &x->ItemData->gg;
       se && se->g.tok == zx_gl_ItemData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ItemData(c, (struct zx_gl_ItemData_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Notification) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Notification_s* zx_DEEP_CLONE_gl_Notification(struct zx_ctx* c, struct zx_gl_Notification_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Notification_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Notification_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->endReason = zx_clone_attr(c, x->endReason);
  x->expires = zx_clone_attr(c, x->expires);
  x->id = zx_clone_attr(c, x->id);
  x->subscriptionID = zx_clone_attr(c, x->subscriptionID);

  for (enn = 0, e = &x->ItemData->gg;
       e && e->g.tok == zx_gl_ItemData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ItemData(c,(struct zx_gl_ItemData_s*)e,dup_strs);
  	  if (!enn)
  	      x->ItemData = (struct zx_gl_ItemData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Notification) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Notification(struct zx_ctx* c, struct zx_gl_Notification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ItemData->gg;
       e && e->g.tok == zx_gl_ItemData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ItemData(c, (struct zx_gl_ItemData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Notification) */

int zx_WALK_WO_gl_Notification(struct zx_ctx* c, struct zx_gl_Notification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Notify
#define EL_STRUCT zx_gl_Notify_s
#define EL_NS     gl
#define EL_TAG    Notify

/* FUNC(zx_FREE_gl_Notify) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Notify(struct zx_ctx* c, struct zx_gl_Notify_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->timeStamp, free_strs);

  for (e = &x->Notification->gg;
       e && e->g.tok == zx_gl_Notification_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Notification(c, (struct zx_gl_Notification_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Notify) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Notify_s* zx_NEW_gl_Notify(struct zx_ctx* c)
{
  struct zx_gl_Notify_s* x = ZX_ZALLOC(c, struct zx_gl_Notify_s);
  x->gg.g.tok = zx_gl_Notify_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Notify) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Notify(struct zx_ctx* c, struct zx_gl_Notify_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->timeStamp);

  for (se = &x->Notification->gg;
       se && se->g.tok == zx_gl_Notification_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Notification(c, (struct zx_gl_Notification_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Notify) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Notify_s* zx_DEEP_CLONE_gl_Notify(struct zx_ctx* c, struct zx_gl_Notify_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Notify_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Notify_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);
  x->timeStamp = zx_clone_attr(c, x->timeStamp);

  for (enn = 0, e = &x->Notification->gg;
       e && e->g.tok == zx_gl_Notification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Notification(c,(struct zx_gl_Notification_s*)e,dup_strs);
  	  if (!enn)
  	      x->Notification = (struct zx_gl_Notification_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Notify) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Notify(struct zx_ctx* c, struct zx_gl_Notify_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Notification->gg;
       e && e->g.tok == zx_gl_Notification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Notification(c, (struct zx_gl_Notification_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Notify) */

int zx_WALK_WO_gl_Notify(struct zx_ctx* c, struct zx_gl_Notify_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_NotifyAdminTo
#define EL_STRUCT zx_gl_NotifyAdminTo_s
#define EL_NS     gl
#define EL_TAG    NotifyAdminTo

/* FUNC(zx_FREE_gl_NotifyAdminTo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_NotifyAdminTo(struct zx_ctx* c, struct zx_gl_NotifyAdminTo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);

  zx_free_simple_elems(c, x->SecurityMechID, free_strs);
  for (e = &x->Credential->gg;
       e && e->g.tok == zx_gl_Credential_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Credential(c, (struct zx_gl_Credential_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Endpoint, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_NotifyAdminTo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_NotifyAdminTo_s* zx_NEW_gl_NotifyAdminTo(struct zx_ctx* c)
{
  struct zx_gl_NotifyAdminTo_s* x = ZX_ZALLOC(c, struct zx_gl_NotifyAdminTo_s);
  x->gg.g.tok = zx_gl_NotifyAdminTo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_NotifyAdminTo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_NotifyAdminTo(struct zx_ctx* c, struct zx_gl_NotifyAdminTo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);

  zx_dup_strs_simple_elems(c, x->SecurityMechID);
  for (se = &x->Credential->gg;
       se && se->g.tok == zx_gl_Credential_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Credential(c, (struct zx_gl_Credential_s*)se);
  zx_dup_strs_simple_elems(c, x->Endpoint);

}

/* FUNC(zx_DEEP_CLONE_gl_NotifyAdminTo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_NotifyAdminTo_s* zx_DEEP_CLONE_gl_NotifyAdminTo(struct zx_ctx* c, struct zx_gl_NotifyAdminTo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_NotifyAdminTo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_NotifyAdminTo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);

  x->SecurityMechID = zx_deep_clone_simple_elems(c,x->SecurityMechID, dup_strs);
  for (enn = 0, e = &x->Credential->gg;
       e && e->g.tok == zx_gl_Credential_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Credential(c,(struct zx_gl_Credential_s*)e,dup_strs);
  	  if (!enn)
  	      x->Credential = (struct zx_gl_Credential_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Endpoint = zx_deep_clone_simple_elems(c,x->Endpoint, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_gl_NotifyAdminTo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_NotifyAdminTo(struct zx_ctx* c, struct zx_gl_NotifyAdminTo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->SecurityMechID, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Credential->gg;
       e && e->g.tok == zx_gl_Credential_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Credential(c, (struct zx_gl_Credential_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Endpoint, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_NotifyAdminTo) */

int zx_WALK_WO_gl_NotifyAdminTo(struct zx_ctx* c, struct zx_gl_NotifyAdminTo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_NotifyResponse
#define EL_STRUCT zx_gl_NotifyResponse_s
#define EL_NS     gl
#define EL_TAG    NotifyResponse

/* FUNC(zx_FREE_gl_NotifyResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_NotifyResponse(struct zx_ctx* c, struct zx_gl_NotifyResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Status(c, (struct zx_gl_Status_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_NotifyResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_NotifyResponse_s* zx_NEW_gl_NotifyResponse(struct zx_ctx* c)
{
  struct zx_gl_NotifyResponse_s* x = ZX_ZALLOC(c, struct zx_gl_NotifyResponse_s);
  x->gg.g.tok = zx_gl_NotifyResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_NotifyResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_NotifyResponse(struct zx_ctx* c, struct zx_gl_NotifyResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);

  for (se = &x->Status->gg;
       se && se->g.tok == zx_gl_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Status(c, (struct zx_gl_Status_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_NotifyResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_NotifyResponse_s* zx_DEEP_CLONE_gl_NotifyResponse(struct zx_ctx* c, struct zx_gl_NotifyResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_NotifyResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_NotifyResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);

  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Status(c,(struct zx_gl_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_gl_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_NotifyResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_NotifyResponse(struct zx_ctx* c, struct zx_gl_NotifyResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Status(c, (struct zx_gl_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_NotifyResponse) */

int zx_WALK_WO_gl_NotifyResponse(struct zx_ctx* c, struct zx_gl_NotifyResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_NotifyTo
#define EL_STRUCT zx_gl_NotifyTo_s
#define EL_NS     gl
#define EL_TAG    NotifyTo

/* FUNC(zx_FREE_gl_NotifyTo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_NotifyTo(struct zx_ctx* c, struct zx_gl_NotifyTo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);

  zx_free_simple_elems(c, x->SecurityMechID, free_strs);
  for (e = &x->Credential->gg;
       e && e->g.tok == zx_gl_Credential_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Credential(c, (struct zx_gl_Credential_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Endpoint, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_NotifyTo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_NotifyTo_s* zx_NEW_gl_NotifyTo(struct zx_ctx* c)
{
  struct zx_gl_NotifyTo_s* x = ZX_ZALLOC(c, struct zx_gl_NotifyTo_s);
  x->gg.g.tok = zx_gl_NotifyTo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_NotifyTo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_NotifyTo(struct zx_ctx* c, struct zx_gl_NotifyTo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);

  zx_dup_strs_simple_elems(c, x->SecurityMechID);
  for (se = &x->Credential->gg;
       se && se->g.tok == zx_gl_Credential_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Credential(c, (struct zx_gl_Credential_s*)se);
  zx_dup_strs_simple_elems(c, x->Endpoint);

}

/* FUNC(zx_DEEP_CLONE_gl_NotifyTo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_NotifyTo_s* zx_DEEP_CLONE_gl_NotifyTo(struct zx_ctx* c, struct zx_gl_NotifyTo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_NotifyTo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_NotifyTo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);

  x->SecurityMechID = zx_deep_clone_simple_elems(c,x->SecurityMechID, dup_strs);
  for (enn = 0, e = &x->Credential->gg;
       e && e->g.tok == zx_gl_Credential_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Credential(c,(struct zx_gl_Credential_s*)e,dup_strs);
  	  if (!enn)
  	      x->Credential = (struct zx_gl_Credential_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Endpoint = zx_deep_clone_simple_elems(c,x->Endpoint, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_gl_NotifyTo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_NotifyTo(struct zx_ctx* c, struct zx_gl_NotifyTo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->SecurityMechID, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Credential->gg;
       e && e->g.tok == zx_gl_Credential_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Credential(c, (struct zx_gl_Credential_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Endpoint, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_NotifyTo) */

int zx_WALK_WO_gl_NotifyTo(struct zx_ctx* c, struct zx_gl_NotifyTo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Point
#define EL_STRUCT zx_gl_Point_s
#define EL_NS     gl
#define EL_TAG    Point

/* FUNC(zx_FREE_gl_Point) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Point(struct zx_ctx* c, struct zx_gl_Point_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_coord(c, (struct zx_gl_coord_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Point) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Point_s* zx_NEW_gl_Point(struct zx_ctx* c)
{
  struct zx_gl_Point_s* x = ZX_ZALLOC(c, struct zx_gl_Point_s);
  x->gg.g.tok = zx_gl_Point_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Point) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Point(struct zx_ctx* c, struct zx_gl_Point_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->coord->gg;
       se && se->g.tok == zx_gl_coord_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_coord(c, (struct zx_gl_coord_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Point) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Point_s* zx_DEEP_CLONE_gl_Point(struct zx_ctx* c, struct zx_gl_Point_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Point_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Point_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_coord(c,(struct zx_gl_coord_s*)e,dup_strs);
  	  if (!enn)
  	      x->coord = (struct zx_gl_coord_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Point) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Point(struct zx_ctx* c, struct zx_gl_Point_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->coord->gg;
       e && e->g.tok == zx_gl_coord_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_coord(c, (struct zx_gl_coord_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Point) */

int zx_WALK_WO_gl_Point(struct zx_ctx* c, struct zx_gl_Point_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Polygon
#define EL_STRUCT zx_gl_Polygon_s
#define EL_NS     gl
#define EL_TAG    Polygon

/* FUNC(zx_FREE_gl_Polygon) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Polygon(struct zx_ctx* c, struct zx_gl_Polygon_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->gid, free_strs);
  zx_free_attr(c, x->srsName, free_strs);

  for (e = &x->outerBoundaryIs->gg;
       e && e->g.tok == zx_gl_outerBoundaryIs_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_outerBoundaryIs(c, (struct zx_gl_outerBoundaryIs_s*)e, free_strs);
  }
  for (e = &x->innerBoundaryIs->gg;
       e && e->g.tok == zx_gl_innerBoundaryIs_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_innerBoundaryIs(c, (struct zx_gl_innerBoundaryIs_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Polygon) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Polygon_s* zx_NEW_gl_Polygon(struct zx_ctx* c)
{
  struct zx_gl_Polygon_s* x = ZX_ZALLOC(c, struct zx_gl_Polygon_s);
  x->gg.g.tok = zx_gl_Polygon_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Polygon) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Polygon(struct zx_ctx* c, struct zx_gl_Polygon_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->gid);
  zx_dup_attr(c, x->srsName);

  for (se = &x->outerBoundaryIs->gg;
       se && se->g.tok == zx_gl_outerBoundaryIs_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_outerBoundaryIs(c, (struct zx_gl_outerBoundaryIs_s*)se);
  for (se = &x->innerBoundaryIs->gg;
       se && se->g.tok == zx_gl_innerBoundaryIs_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_innerBoundaryIs(c, (struct zx_gl_innerBoundaryIs_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Polygon) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Polygon_s* zx_DEEP_CLONE_gl_Polygon(struct zx_ctx* c, struct zx_gl_Polygon_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Polygon_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Polygon_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->gid = zx_clone_attr(c, x->gid);
  x->srsName = zx_clone_attr(c, x->srsName);

  for (enn = 0, e = &x->outerBoundaryIs->gg;
       e && e->g.tok == zx_gl_outerBoundaryIs_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_outerBoundaryIs(c,(struct zx_gl_outerBoundaryIs_s*)e,dup_strs);
  	  if (!enn)
  	      x->outerBoundaryIs = (struct zx_gl_outerBoundaryIs_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->innerBoundaryIs->gg;
       e && e->g.tok == zx_gl_innerBoundaryIs_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_innerBoundaryIs(c,(struct zx_gl_innerBoundaryIs_s*)e,dup_strs);
  	  if (!enn)
  	      x->innerBoundaryIs = (struct zx_gl_innerBoundaryIs_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Polygon) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Polygon(struct zx_ctx* c, struct zx_gl_Polygon_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->outerBoundaryIs->gg;
       e && e->g.tok == zx_gl_outerBoundaryIs_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_outerBoundaryIs(c, (struct zx_gl_outerBoundaryIs_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->innerBoundaryIs->gg;
       e && e->g.tok == zx_gl_innerBoundaryIs_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_innerBoundaryIs(c, (struct zx_gl_innerBoundaryIs_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Polygon) */

int zx_WALK_WO_gl_Polygon(struct zx_ctx* c, struct zx_gl_Polygon_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Query
#define EL_STRUCT zx_gl_Query_s
#define EL_NS     gl
#define EL_TAG    Query

/* FUNC(zx_FREE_gl_Query) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Query(struct zx_ctx* c, struct zx_gl_Query_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);

  for (e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)e, free_strs);
  }
  for (e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)e, free_strs);
  }
  for (e = &x->Subscription->gg;
       e && e->g.tok == zx_gl_Subscription_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Subscription(c, (struct zx_gl_Subscription_s*)e, free_strs);
  }
  for (e = &x->QueryItem->gg;
       e && e->g.tok == zx_gl_QueryItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_QueryItem(c, (struct zx_gl_QueryItem_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Query) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Query_s* zx_NEW_gl_Query(struct zx_ctx* c)
{
  struct zx_gl_Query_s* x = ZX_ZALLOC(c, struct zx_gl_Query_s);
  x->gg.g.tok = zx_gl_Query_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Query) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Query(struct zx_ctx* c, struct zx_gl_Query_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);

  for (se = &x->ResourceID->gg;
       se && se->g.tok == zx_gl_ResourceID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)se);
  for (se = &x->EncryptedResourceID->gg;
       se && se->g.tok == zx_gl_EncryptedResourceID_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)se);
  for (se = &x->Subscription->gg;
       se && se->g.tok == zx_gl_Subscription_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Subscription(c, (struct zx_gl_Subscription_s*)se);
  for (se = &x->QueryItem->gg;
       se && se->g.tok == zx_gl_QueryItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_QueryItem(c, (struct zx_gl_QueryItem_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Query) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Query_s* zx_DEEP_CLONE_gl_Query(struct zx_ctx* c, struct zx_gl_Query_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Query_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Query_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);

  for (enn = 0, e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ResourceID(c,(struct zx_gl_ResourceID_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResourceID = (struct zx_gl_ResourceID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_EncryptedResourceID(c,(struct zx_gl_EncryptedResourceID_s*)e,dup_strs);
  	  if (!enn)
  	      x->EncryptedResourceID = (struct zx_gl_EncryptedResourceID_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Subscription->gg;
       e && e->g.tok == zx_gl_Subscription_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Subscription(c,(struct zx_gl_Subscription_s*)e,dup_strs);
  	  if (!enn)
  	      x->Subscription = (struct zx_gl_Subscription_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->QueryItem->gg;
       e && e->g.tok == zx_gl_QueryItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_QueryItem(c,(struct zx_gl_QueryItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->QueryItem = (struct zx_gl_QueryItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Query) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Query(struct zx_ctx* c, struct zx_gl_Query_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ResourceID->gg;
       e && e->g.tok == zx_gl_ResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ResourceID(c, (struct zx_gl_ResourceID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EncryptedResourceID->gg;
       e && e->g.tok == zx_gl_EncryptedResourceID_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_EncryptedResourceID(c, (struct zx_gl_EncryptedResourceID_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Subscription->gg;
       e && e->g.tok == zx_gl_Subscription_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Subscription(c, (struct zx_gl_Subscription_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->QueryItem->gg;
       e && e->g.tok == zx_gl_QueryItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_QueryItem(c, (struct zx_gl_QueryItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Query) */

int zx_WALK_WO_gl_Query(struct zx_ctx* c, struct zx_gl_Query_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_QueryItem
#define EL_STRUCT zx_gl_QueryItem_s
#define EL_NS     gl
#define EL_TAG    QueryItem

/* FUNC(zx_FREE_gl_QueryItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_QueryItem(struct zx_ctx* c, struct zx_gl_QueryItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->count, free_strs);
  zx_free_attr(c, x->offset, free_strs);
  zx_free_attr(c, x->setID, free_strs);
  zx_free_attr(c, x->setReq, free_strs);

  for (e = &x->AreaComparison->gg;
       e && e->g.tok == zx_gl_AreaComparison_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_AreaComparison(c, (struct zx_gl_AreaComparison_s*)e, free_strs);
  }
  for (e = &x->eqop->gg;
       e && e->g.tok == zx_gl_eqop_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_eqop(c, (struct zx_gl_eqop_s*)e, free_strs);
  }
  for (e = &x->geoinfo->gg;
       e && e->g.tok == zx_gl_geoinfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_geoinfo(c, (struct zx_gl_geoinfo_s*)e, free_strs);
  }
  for (e = &x->loc_type->gg;
       e && e->g.tok == zx_gl_loc_type_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_loc_type(c, (struct zx_gl_loc_type_s*)e, free_strs);
  }
  for (e = &x->prio->gg;
       e && e->g.tok == zx_gl_prio_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_prio(c, (struct zx_gl_prio_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_QueryItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_QueryItem_s* zx_NEW_gl_QueryItem(struct zx_ctx* c)
{
  struct zx_gl_QueryItem_s* x = ZX_ZALLOC(c, struct zx_gl_QueryItem_s);
  x->gg.g.tok = zx_gl_QueryItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_QueryItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_QueryItem(struct zx_ctx* c, struct zx_gl_QueryItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->count);
  zx_dup_attr(c, x->offset);
  zx_dup_attr(c, x->setID);
  zx_dup_attr(c, x->setReq);

  for (se = &x->AreaComparison->gg;
       se && se->g.tok == zx_gl_AreaComparison_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_AreaComparison(c, (struct zx_gl_AreaComparison_s*)se);
  for (se = &x->eqop->gg;
       se && se->g.tok == zx_gl_eqop_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_eqop(c, (struct zx_gl_eqop_s*)se);
  for (se = &x->geoinfo->gg;
       se && se->g.tok == zx_gl_geoinfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_geoinfo(c, (struct zx_gl_geoinfo_s*)se);
  for (se = &x->loc_type->gg;
       se && se->g.tok == zx_gl_loc_type_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_loc_type(c, (struct zx_gl_loc_type_s*)se);
  for (se = &x->prio->gg;
       se && se->g.tok == zx_gl_prio_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_prio(c, (struct zx_gl_prio_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_QueryItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_QueryItem_s* zx_DEEP_CLONE_gl_QueryItem(struct zx_ctx* c, struct zx_gl_QueryItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_QueryItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_QueryItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->count = zx_clone_attr(c, x->count);
  x->offset = zx_clone_attr(c, x->offset);
  x->setID = zx_clone_attr(c, x->setID);
  x->setReq = zx_clone_attr(c, x->setReq);

  for (enn = 0, e = &x->AreaComparison->gg;
       e && e->g.tok == zx_gl_AreaComparison_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_AreaComparison(c,(struct zx_gl_AreaComparison_s*)e,dup_strs);
  	  if (!enn)
  	      x->AreaComparison = (struct zx_gl_AreaComparison_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->eqop->gg;
       e && e->g.tok == zx_gl_eqop_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_eqop(c,(struct zx_gl_eqop_s*)e,dup_strs);
  	  if (!enn)
  	      x->eqop = (struct zx_gl_eqop_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->geoinfo->gg;
       e && e->g.tok == zx_gl_geoinfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_geoinfo(c,(struct zx_gl_geoinfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->geoinfo = (struct zx_gl_geoinfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->loc_type->gg;
       e && e->g.tok == zx_gl_loc_type_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_loc_type(c,(struct zx_gl_loc_type_s*)e,dup_strs);
  	  if (!enn)
  	      x->loc_type = (struct zx_gl_loc_type_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->prio->gg;
       e && e->g.tok == zx_gl_prio_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_prio(c,(struct zx_gl_prio_s*)e,dup_strs);
  	  if (!enn)
  	      x->prio = (struct zx_gl_prio_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_QueryItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_QueryItem(struct zx_ctx* c, struct zx_gl_QueryItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AreaComparison->gg;
       e && e->g.tok == zx_gl_AreaComparison_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_AreaComparison(c, (struct zx_gl_AreaComparison_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->eqop->gg;
       e && e->g.tok == zx_gl_eqop_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_eqop(c, (struct zx_gl_eqop_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->geoinfo->gg;
       e && e->g.tok == zx_gl_geoinfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_geoinfo(c, (struct zx_gl_geoinfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->loc_type->gg;
       e && e->g.tok == zx_gl_loc_type_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_loc_type(c, (struct zx_gl_loc_type_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->prio->gg;
       e && e->g.tok == zx_gl_prio_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_prio(c, (struct zx_gl_prio_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_QueryItem) */

int zx_WALK_WO_gl_QueryItem(struct zx_ctx* c, struct zx_gl_QueryItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_QueryResponse
#define EL_STRUCT zx_gl_QueryResponse_s
#define EL_NS     gl
#define EL_TAG    QueryResponse

/* FUNC(zx_FREE_gl_QueryResponse) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_QueryResponse(struct zx_ctx* c, struct zx_gl_QueryResponse_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->itemIDRef, free_strs);
  zx_free_attr(c, x->timeStamp, free_strs);

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Status(c, (struct zx_gl_Status_s*)e, free_strs);
  }
  for (e = &x->Data->gg;
       e && e->g.tok == zx_gl_Data_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Data(c, (struct zx_gl_Data_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_QueryResponse) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_QueryResponse_s* zx_NEW_gl_QueryResponse(struct zx_ctx* c)
{
  struct zx_gl_QueryResponse_s* x = ZX_ZALLOC(c, struct zx_gl_QueryResponse_s);
  x->gg.g.tok = zx_gl_QueryResponse_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_QueryResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_QueryResponse(struct zx_ctx* c, struct zx_gl_QueryResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->itemIDRef);
  zx_dup_attr(c, x->timeStamp);

  for (se = &x->Status->gg;
       se && se->g.tok == zx_gl_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Status(c, (struct zx_gl_Status_s*)se);
  for (se = &x->Data->gg;
       se && se->g.tok == zx_gl_Data_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Data(c, (struct zx_gl_Data_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_QueryResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_QueryResponse_s* zx_DEEP_CLONE_gl_QueryResponse(struct zx_ctx* c, struct zx_gl_QueryResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_QueryResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_QueryResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);
  x->itemIDRef = zx_clone_attr(c, x->itemIDRef);
  x->timeStamp = zx_clone_attr(c, x->timeStamp);

  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Status(c,(struct zx_gl_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_gl_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Data->gg;
       e && e->g.tok == zx_gl_Data_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Data(c,(struct zx_gl_Data_s*)e,dup_strs);
  	  if (!enn)
  	      x->Data = (struct zx_gl_Data_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_QueryResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_QueryResponse(struct zx_ctx* c, struct zx_gl_QueryResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Status(c, (struct zx_gl_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Data->gg;
       e && e->g.tok == zx_gl_Data_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Data(c, (struct zx_gl_Data_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_QueryResponse) */

int zx_WALK_WO_gl_QueryResponse(struct zx_ctx* c, struct zx_gl_QueryResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_RefItem
#define EL_STRUCT zx_gl_RefItem_s
#define EL_NS     gl
#define EL_TAG    RefItem

/* FUNC(zx_FREE_gl_RefItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_RefItem(struct zx_ctx* c, struct zx_gl_RefItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->ItemIDRef, free_strs);
  zx_free_attr(c, x->subscriptionID, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_RefItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_RefItem_s* zx_NEW_gl_RefItem(struct zx_ctx* c)
{
  struct zx_gl_RefItem_s* x = ZX_ZALLOC(c, struct zx_gl_RefItem_s);
  x->gg.g.tok = zx_gl_RefItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_RefItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_RefItem(struct zx_ctx* c, struct zx_gl_RefItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->ItemIDRef);
  zx_dup_attr(c, x->subscriptionID);


}

/* FUNC(zx_DEEP_CLONE_gl_RefItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_RefItem_s* zx_DEEP_CLONE_gl_RefItem(struct zx_ctx* c, struct zx_gl_RefItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_RefItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_RefItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->ItemIDRef = zx_clone_attr(c, x->ItemIDRef);
  x->subscriptionID = zx_clone_attr(c, x->subscriptionID);


  return x;
}

/* FUNC(zx_WALK_SO_gl_RefItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_RefItem(struct zx_ctx* c, struct zx_gl_RefItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_RefItem) */

int zx_WALK_WO_gl_RefItem(struct zx_ctx* c, struct zx_gl_RefItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_ResourceID
#define EL_STRUCT zx_gl_ResourceID_s
#define EL_NS     gl
#define EL_TAG    ResourceID

/* FUNC(zx_FREE_gl_ResourceID) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_ResourceID(struct zx_ctx* c, struct zx_gl_ResourceID_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->id, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_ResourceID) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_ResourceID_s* zx_NEW_gl_ResourceID(struct zx_ctx* c)
{
  struct zx_gl_ResourceID_s* x = ZX_ZALLOC(c, struct zx_gl_ResourceID_s);
  x->gg.g.tok = zx_gl_ResourceID_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_ResourceID) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_ResourceID(struct zx_ctx* c, struct zx_gl_ResourceID_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->id);


}

/* FUNC(zx_DEEP_CLONE_gl_ResourceID) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_ResourceID_s* zx_DEEP_CLONE_gl_ResourceID(struct zx_ctx* c, struct zx_gl_ResourceID_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_ResourceID_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_ResourceID_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->id = zx_clone_attr(c, x->id);


  return x;
}

/* FUNC(zx_WALK_SO_gl_ResourceID) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_ResourceID(struct zx_ctx* c, struct zx_gl_ResourceID_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_ResourceID) */

int zx_WALK_WO_gl_ResourceID(struct zx_ctx* c, struct zx_gl_ResourceID_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Status
#define EL_STRUCT zx_gl_Status_s
#define EL_NS     gl
#define EL_TAG    Status

/* FUNC(zx_FREE_gl_Status) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Status(struct zx_ctx* c, struct zx_gl_Status_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->code, free_strs);
  zx_free_attr(c, x->comment, free_strs);
  zx_free_attr(c, x->ref, free_strs);

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Status(c, (struct zx_gl_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Status) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Status_s* zx_NEW_gl_Status(struct zx_ctx* c)
{
  struct zx_gl_Status_s* x = ZX_ZALLOC(c, struct zx_gl_Status_s);
  x->gg.g.tok = zx_gl_Status_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Status) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Status(struct zx_ctx* c, struct zx_gl_Status_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->code);
  zx_dup_attr(c, x->comment);
  zx_dup_attr(c, x->ref);

  for (se = &x->Status->gg;
       se && se->g.tok == zx_gl_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Status(c, (struct zx_gl_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Status) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Status_s* zx_DEEP_CLONE_gl_Status(struct zx_ctx* c, struct zx_gl_Status_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Status_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Status_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->code = zx_clone_attr(c, x->code);
  x->comment = zx_clone_attr(c, x->comment);
  x->ref = zx_clone_attr(c, x->ref);

  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Status(c,(struct zx_gl_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_gl_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Status) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Status(struct zx_ctx* c, struct zx_gl_Status_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Status->gg;
       e && e->g.tok == zx_gl_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Status(c, (struct zx_gl_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Status) */

int zx_WALK_WO_gl_Status(struct zx_ctx* c, struct zx_gl_Status_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Subscription
#define EL_STRUCT zx_gl_Subscription_s
#define EL_NS     gl
#define EL_TAG    Subscription

/* FUNC(zx_FREE_gl_Subscription) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Subscription(struct zx_ctx* c, struct zx_gl_Subscription_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->expires, free_strs);
  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->includeData, free_strs);
  zx_free_attr(c, x->starts, free_strs);
  zx_free_attr(c, x->subscriptionID, free_strs);

  for (e = &x->ItemSelection->gg;
       e && e->g.tok == zx_gl_ItemSelection_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ItemSelection(c, (struct zx_gl_ItemSelection_s*)e, free_strs);
  }
  for (e = &x->RefItem->gg;
       e && e->g.tok == zx_gl_RefItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_RefItem(c, (struct zx_gl_RefItem_s*)e, free_strs);
  }
  for (e = &x->NotifyTo->gg;
       e && e->g.tok == zx_gl_NotifyTo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_NotifyTo(c, (struct zx_gl_NotifyTo_s*)e, free_strs);
  }
  for (e = &x->NotifyAdminTo->gg;
       e && e->g.tok == zx_gl_NotifyAdminTo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_NotifyAdminTo(c, (struct zx_gl_NotifyAdminTo_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Aggregation, free_strs);
  for (e = &x->Trigger->gg;
       e && e->g.tok == zx_gl_Trigger_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Trigger(c, (struct zx_gl_Trigger_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Subscription) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Subscription_s* zx_NEW_gl_Subscription(struct zx_ctx* c)
{
  struct zx_gl_Subscription_s* x = ZX_ZALLOC(c, struct zx_gl_Subscription_s);
  x->gg.g.tok = zx_gl_Subscription_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Subscription) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Subscription(struct zx_ctx* c, struct zx_gl_Subscription_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->expires);
  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->includeData);
  zx_dup_attr(c, x->starts);
  zx_dup_attr(c, x->subscriptionID);

  for (se = &x->ItemSelection->gg;
       se && se->g.tok == zx_gl_ItemSelection_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ItemSelection(c, (struct zx_gl_ItemSelection_s*)se);
  for (se = &x->RefItem->gg;
       se && se->g.tok == zx_gl_RefItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_RefItem(c, (struct zx_gl_RefItem_s*)se);
  for (se = &x->NotifyTo->gg;
       se && se->g.tok == zx_gl_NotifyTo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_NotifyTo(c, (struct zx_gl_NotifyTo_s*)se);
  for (se = &x->NotifyAdminTo->gg;
       se && se->g.tok == zx_gl_NotifyAdminTo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_NotifyAdminTo(c, (struct zx_gl_NotifyAdminTo_s*)se);
  zx_dup_strs_simple_elems(c, x->Aggregation);
  for (se = &x->Trigger->gg;
       se && se->g.tok == zx_gl_Trigger_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Trigger(c, (struct zx_gl_Trigger_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Subscription) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Subscription_s* zx_DEEP_CLONE_gl_Subscription(struct zx_ctx* c, struct zx_gl_Subscription_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Subscription_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Subscription_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->expires = zx_clone_attr(c, x->expires);
  x->id = zx_clone_attr(c, x->id);
  x->includeData = zx_clone_attr(c, x->includeData);
  x->starts = zx_clone_attr(c, x->starts);
  x->subscriptionID = zx_clone_attr(c, x->subscriptionID);

  for (enn = 0, e = &x->ItemSelection->gg;
       e && e->g.tok == zx_gl_ItemSelection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ItemSelection(c,(struct zx_gl_ItemSelection_s*)e,dup_strs);
  	  if (!enn)
  	      x->ItemSelection = (struct zx_gl_ItemSelection_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RefItem->gg;
       e && e->g.tok == zx_gl_RefItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_RefItem(c,(struct zx_gl_RefItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->RefItem = (struct zx_gl_RefItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->NotifyTo->gg;
       e && e->g.tok == zx_gl_NotifyTo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_NotifyTo(c,(struct zx_gl_NotifyTo_s*)e,dup_strs);
  	  if (!enn)
  	      x->NotifyTo = (struct zx_gl_NotifyTo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->NotifyAdminTo->gg;
       e && e->g.tok == zx_gl_NotifyAdminTo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_NotifyAdminTo(c,(struct zx_gl_NotifyAdminTo_s*)e,dup_strs);
  	  if (!enn)
  	      x->NotifyAdminTo = (struct zx_gl_NotifyAdminTo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Aggregation = zx_deep_clone_simple_elems(c,x->Aggregation, dup_strs);
  for (enn = 0, e = &x->Trigger->gg;
       e && e->g.tok == zx_gl_Trigger_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Trigger(c,(struct zx_gl_Trigger_s*)e,dup_strs);
  	  if (!enn)
  	      x->Trigger = (struct zx_gl_Trigger_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Subscription) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Subscription(struct zx_ctx* c, struct zx_gl_Subscription_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ItemSelection->gg;
       e && e->g.tok == zx_gl_ItemSelection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ItemSelection(c, (struct zx_gl_ItemSelection_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RefItem->gg;
       e && e->g.tok == zx_gl_RefItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_RefItem(c, (struct zx_gl_RefItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->NotifyTo->gg;
       e && e->g.tok == zx_gl_NotifyTo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_NotifyTo(c, (struct zx_gl_NotifyTo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->NotifyAdminTo->gg;
       e && e->g.tok == zx_gl_NotifyAdminTo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_NotifyAdminTo(c, (struct zx_gl_NotifyAdminTo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Aggregation, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Trigger->gg;
       e && e->g.tok == zx_gl_Trigger_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Trigger(c, (struct zx_gl_Trigger_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Subscription) */

int zx_WALK_WO_gl_Subscription(struct zx_ctx* c, struct zx_gl_Subscription_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_Trigger
#define EL_STRUCT zx_gl_Trigger_s
#define EL_NS     gl
#define EL_TAG    Trigger

/* FUNC(zx_FREE_gl_Trigger) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_Trigger(struct zx_ctx* c, struct zx_gl_Trigger_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Granularity, free_strs);
  zx_free_simple_elems(c, x->Interval, free_strs);
  for (e = &x->ms_action->gg;
       e && e->g.tok == zx_gl_ms_action_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ms_action(c, (struct zx_gl_ms_action_s*)e, free_strs);
  }
  for (e = &x->ChangeArea->gg;
       e && e->g.tok == zx_gl_ChangeArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_ChangeArea(c, (struct zx_gl_ChangeArea_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_Trigger) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_Trigger_s* zx_NEW_gl_Trigger(struct zx_ctx* c)
{
  struct zx_gl_Trigger_s* x = ZX_ZALLOC(c, struct zx_gl_Trigger_s);
  x->gg.g.tok = zx_gl_Trigger_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_Trigger) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_Trigger(struct zx_ctx* c, struct zx_gl_Trigger_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Granularity);
  zx_dup_strs_simple_elems(c, x->Interval);
  for (se = &x->ms_action->gg;
       se && se->g.tok == zx_gl_ms_action_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ms_action(c, (struct zx_gl_ms_action_s*)se);
  for (se = &x->ChangeArea->gg;
       se && se->g.tok == zx_gl_ChangeArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_ChangeArea(c, (struct zx_gl_ChangeArea_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_Trigger) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_Trigger_s* zx_DEEP_CLONE_gl_Trigger(struct zx_ctx* c, struct zx_gl_Trigger_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_Trigger_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_Trigger_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Granularity = zx_deep_clone_simple_elems(c,x->Granularity, dup_strs);
  x->Interval = zx_deep_clone_simple_elems(c,x->Interval, dup_strs);
  for (enn = 0, e = &x->ms_action->gg;
       e && e->g.tok == zx_gl_ms_action_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ms_action(c,(struct zx_gl_ms_action_s*)e,dup_strs);
  	  if (!enn)
  	      x->ms_action = (struct zx_gl_ms_action_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ChangeArea->gg;
       e && e->g.tok == zx_gl_ChangeArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_ChangeArea(c,(struct zx_gl_ChangeArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->ChangeArea = (struct zx_gl_ChangeArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_Trigger) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_Trigger(struct zx_ctx* c, struct zx_gl_Trigger_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Granularity, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Interval, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->ms_action->gg;
       e && e->g.tok == zx_gl_ms_action_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ms_action(c, (struct zx_gl_ms_action_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ChangeArea->gg;
       e && e->g.tok == zx_gl_ChangeArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_ChangeArea(c, (struct zx_gl_ChangeArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_Trigger) */

int zx_WALK_WO_gl_Trigger(struct zx_ctx* c, struct zx_gl_Trigger_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_coord
#define EL_STRUCT zx_gl_coord_s
#define EL_NS     gl
#define EL_TAG    coord

/* FUNC(zx_FREE_gl_coord) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_coord(struct zx_ctx* c, struct zx_gl_coord_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->X, free_strs);
  zx_free_simple_elems(c, x->Y, free_strs);
  zx_free_simple_elems(c, x->Z, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_coord) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_coord_s* zx_NEW_gl_coord(struct zx_ctx* c)
{
  struct zx_gl_coord_s* x = ZX_ZALLOC(c, struct zx_gl_coord_s);
  x->gg.g.tok = zx_gl_coord_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_coord) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_coord(struct zx_ctx* c, struct zx_gl_coord_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->X);
  zx_dup_strs_simple_elems(c, x->Y);
  zx_dup_strs_simple_elems(c, x->Z);

}

/* FUNC(zx_DEEP_CLONE_gl_coord) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_coord_s* zx_DEEP_CLONE_gl_coord(struct zx_ctx* c, struct zx_gl_coord_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_coord_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_coord_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->X = zx_deep_clone_simple_elems(c,x->X, dup_strs);
  x->Y = zx_deep_clone_simple_elems(c,x->Y, dup_strs);
  x->Z = zx_deep_clone_simple_elems(c,x->Z, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_gl_coord) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_coord(struct zx_ctx* c, struct zx_gl_coord_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->X, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Y, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Z, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_coord) */

int zx_WALK_WO_gl_coord(struct zx_ctx* c, struct zx_gl_coord_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_eqop
#define EL_STRUCT zx_gl_eqop_s
#define EL_NS     gl
#define EL_TAG    eqop

/* FUNC(zx_FREE_gl_eqop) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_eqop(struct zx_ctx* c, struct zx_gl_eqop_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->resp_req->gg;
       e && e->g.tok == zx_gl_resp_req_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_resp_req(c, (struct zx_gl_resp_req_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->ll_acc, free_strs);
  zx_free_simple_elems(c, x->hor_acc, free_strs);
  zx_free_simple_elems(c, x->alt_acc, free_strs);
  zx_free_simple_elems(c, x->max_loc_age, free_strs);
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_eqop) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_eqop_s* zx_NEW_gl_eqop(struct zx_ctx* c)
{
  struct zx_gl_eqop_s* x = ZX_ZALLOC(c, struct zx_gl_eqop_s);
  x->gg.g.tok = zx_gl_eqop_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_eqop) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_eqop(struct zx_ctx* c, struct zx_gl_eqop_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->resp_req->gg;
       se && se->g.tok == zx_gl_resp_req_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_resp_req(c, (struct zx_gl_resp_req_s*)se);
  zx_dup_strs_simple_elems(c, x->ll_acc);
  zx_dup_strs_simple_elems(c, x->hor_acc);
  zx_dup_strs_simple_elems(c, x->alt_acc);
  zx_dup_strs_simple_elems(c, x->max_loc_age);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_eqop) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_eqop_s* zx_DEEP_CLONE_gl_eqop(struct zx_ctx* c, struct zx_gl_eqop_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_eqop_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_eqop_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->resp_req->gg;
       e && e->g.tok == zx_gl_resp_req_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_resp_req(c,(struct zx_gl_resp_req_s*)e,dup_strs);
  	  if (!enn)
  	      x->resp_req = (struct zx_gl_resp_req_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->ll_acc = zx_deep_clone_simple_elems(c,x->ll_acc, dup_strs);
  x->hor_acc = zx_deep_clone_simple_elems(c,x->hor_acc, dup_strs);
  x->alt_acc = zx_deep_clone_simple_elems(c,x->alt_acc, dup_strs);
  x->max_loc_age = zx_deep_clone_simple_elems(c,x->max_loc_age, dup_strs);
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_eqop) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_eqop(struct zx_ctx* c, struct zx_gl_eqop_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->resp_req->gg;
       e && e->g.tok == zx_gl_resp_req_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_resp_req(c, (struct zx_gl_resp_req_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->ll_acc, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->hor_acc, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->alt_acc, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->max_loc_age, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_eqop) */

int zx_WALK_WO_gl_eqop(struct zx_ctx* c, struct zx_gl_eqop_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_esrd
#define EL_STRUCT zx_gl_esrd_s
#define EL_NS     gl
#define EL_TAG    esrd

/* FUNC(zx_FREE_gl_esrd) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_esrd(struct zx_ctx* c, struct zx_gl_esrd_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_esrd) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_esrd_s* zx_NEW_gl_esrd(struct zx_ctx* c)
{
  struct zx_gl_esrd_s* x = ZX_ZALLOC(c, struct zx_gl_esrd_s);
  x->gg.g.tok = zx_gl_esrd_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_esrd) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_esrd(struct zx_ctx* c, struct zx_gl_esrd_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_gl_esrd) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_esrd_s* zx_DEEP_CLONE_gl_esrd(struct zx_ctx* c, struct zx_gl_esrd_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_esrd_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_esrd_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_gl_esrd) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_esrd(struct zx_ctx* c, struct zx_gl_esrd_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_esrd) */

int zx_WALK_WO_gl_esrd(struct zx_ctx* c, struct zx_gl_esrd_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_esrk
#define EL_STRUCT zx_gl_esrk_s
#define EL_NS     gl
#define EL_TAG    esrk

/* FUNC(zx_FREE_gl_esrk) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_esrk(struct zx_ctx* c, struct zx_gl_esrk_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_esrk) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_esrk_s* zx_NEW_gl_esrk(struct zx_ctx* c)
{
  struct zx_gl_esrk_s* x = ZX_ZALLOC(c, struct zx_gl_esrk_s);
  x->gg.g.tok = zx_gl_esrk_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_esrk) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_esrk(struct zx_ctx* c, struct zx_gl_esrk_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_gl_esrk) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_esrk_s* zx_DEEP_CLONE_gl_esrk(struct zx_ctx* c, struct zx_gl_esrk_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_esrk_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_esrk_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_gl_esrk) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_esrk(struct zx_ctx* c, struct zx_gl_esrk_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_esrk) */

int zx_WALK_WO_gl_esrk(struct zx_ctx* c, struct zx_gl_esrk_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_geoinfo
#define EL_STRUCT zx_gl_geoinfo_s
#define EL_NS     gl
#define EL_TAG    geoinfo

/* FUNC(zx_FREE_gl_geoinfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_geoinfo(struct zx_ctx* c, struct zx_gl_geoinfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->CoordinateReferenceSystem->gg;
       e && e->g.tok == zx_gl_CoordinateReferenceSystem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_CoordinateReferenceSystem(c, (struct zx_gl_CoordinateReferenceSystem_s*)e, free_strs);
  }
  for (e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_CivilData(c, (struct zx_gl_CivilData_s*)e, free_strs);
  }
  for (e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_shape(c, (struct zx_gl_shape_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->speed, free_strs);
  zx_free_simple_elems(c, x->alt, free_strs);
  zx_free_simple_elems(c, x->direction, free_strs);
  zx_free_simple_elems(c, x->Heading, free_strs);
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_geoinfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_geoinfo_s* zx_NEW_gl_geoinfo(struct zx_ctx* c)
{
  struct zx_gl_geoinfo_s* x = ZX_ZALLOC(c, struct zx_gl_geoinfo_s);
  x->gg.g.tok = zx_gl_geoinfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_geoinfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_geoinfo(struct zx_ctx* c, struct zx_gl_geoinfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->CoordinateReferenceSystem->gg;
       se && se->g.tok == zx_gl_CoordinateReferenceSystem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_CoordinateReferenceSystem(c, (struct zx_gl_CoordinateReferenceSystem_s*)se);
  for (se = &x->CivilData->gg;
       se && se->g.tok == zx_gl_CivilData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_CivilData(c, (struct zx_gl_CivilData_s*)se);
  for (se = &x->shape->gg;
       se && se->g.tok == zx_gl_shape_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_shape(c, (struct zx_gl_shape_s*)se);
  zx_dup_strs_simple_elems(c, x->speed);
  zx_dup_strs_simple_elems(c, x->alt);
  zx_dup_strs_simple_elems(c, x->direction);
  zx_dup_strs_simple_elems(c, x->Heading);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_geoinfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_geoinfo_s* zx_DEEP_CLONE_gl_geoinfo(struct zx_ctx* c, struct zx_gl_geoinfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_geoinfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_geoinfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->CoordinateReferenceSystem->gg;
       e && e->g.tok == zx_gl_CoordinateReferenceSystem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_CoordinateReferenceSystem(c,(struct zx_gl_CoordinateReferenceSystem_s*)e,dup_strs);
  	  if (!enn)
  	      x->CoordinateReferenceSystem = (struct zx_gl_CoordinateReferenceSystem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_CivilData(c,(struct zx_gl_CivilData_s*)e,dup_strs);
  	  if (!enn)
  	      x->CivilData = (struct zx_gl_CivilData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_shape(c,(struct zx_gl_shape_s*)e,dup_strs);
  	  if (!enn)
  	      x->shape = (struct zx_gl_shape_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->speed = zx_deep_clone_simple_elems(c,x->speed, dup_strs);
  x->alt = zx_deep_clone_simple_elems(c,x->alt, dup_strs);
  x->direction = zx_deep_clone_simple_elems(c,x->direction, dup_strs);
  x->Heading = zx_deep_clone_simple_elems(c,x->Heading, dup_strs);
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_geoinfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_geoinfo(struct zx_ctx* c, struct zx_gl_geoinfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CoordinateReferenceSystem->gg;
       e && e->g.tok == zx_gl_CoordinateReferenceSystem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_CoordinateReferenceSystem(c, (struct zx_gl_CoordinateReferenceSystem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_CivilData(c, (struct zx_gl_CivilData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_shape(c, (struct zx_gl_shape_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->speed, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->alt, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->direction, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Heading, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_geoinfo) */

int zx_WALK_WO_gl_geoinfo(struct zx_ctx* c, struct zx_gl_geoinfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_innerBoundaryIs
#define EL_STRUCT zx_gl_innerBoundaryIs_s
#define EL_NS     gl
#define EL_TAG    innerBoundaryIs

/* FUNC(zx_FREE_gl_innerBoundaryIs) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_innerBoundaryIs(struct zx_ctx* c, struct zx_gl_innerBoundaryIs_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->LinearRing->gg;
       e && e->g.tok == zx_gl_LinearRing_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_LinearRing(c, (struct zx_gl_LinearRing_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_innerBoundaryIs) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_innerBoundaryIs_s* zx_NEW_gl_innerBoundaryIs(struct zx_ctx* c)
{
  struct zx_gl_innerBoundaryIs_s* x = ZX_ZALLOC(c, struct zx_gl_innerBoundaryIs_s);
  x->gg.g.tok = zx_gl_innerBoundaryIs_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_innerBoundaryIs) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_innerBoundaryIs(struct zx_ctx* c, struct zx_gl_innerBoundaryIs_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->LinearRing->gg;
       se && se->g.tok == zx_gl_LinearRing_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_LinearRing(c, (struct zx_gl_LinearRing_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_innerBoundaryIs) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_innerBoundaryIs_s* zx_DEEP_CLONE_gl_innerBoundaryIs(struct zx_ctx* c, struct zx_gl_innerBoundaryIs_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_innerBoundaryIs_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_innerBoundaryIs_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->LinearRing->gg;
       e && e->g.tok == zx_gl_LinearRing_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_LinearRing(c,(struct zx_gl_LinearRing_s*)e,dup_strs);
  	  if (!enn)
  	      x->LinearRing = (struct zx_gl_LinearRing_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_innerBoundaryIs) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_innerBoundaryIs(struct zx_ctx* c, struct zx_gl_innerBoundaryIs_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->LinearRing->gg;
       e && e->g.tok == zx_gl_LinearRing_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_LinearRing(c, (struct zx_gl_LinearRing_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_innerBoundaryIs) */

int zx_WALK_WO_gl_innerBoundaryIs(struct zx_ctx* c, struct zx_gl_innerBoundaryIs_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_loc_type
#define EL_STRUCT zx_gl_loc_type_s
#define EL_NS     gl
#define EL_TAG    loc_type

/* FUNC(zx_FREE_gl_loc_type) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_loc_type(struct zx_ctx* c, struct zx_gl_loc_type_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_loc_type) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_loc_type_s* zx_NEW_gl_loc_type(struct zx_ctx* c)
{
  struct zx_gl_loc_type_s* x = ZX_ZALLOC(c, struct zx_gl_loc_type_s);
  x->gg.g.tok = zx_gl_loc_type_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_loc_type) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_loc_type(struct zx_ctx* c, struct zx_gl_loc_type_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_gl_loc_type) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_loc_type_s* zx_DEEP_CLONE_gl_loc_type(struct zx_ctx* c, struct zx_gl_loc_type_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_loc_type_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_loc_type_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_gl_loc_type) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_loc_type(struct zx_ctx* c, struct zx_gl_loc_type_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_loc_type) */

int zx_WALK_WO_gl_loc_type(struct zx_ctx* c, struct zx_gl_loc_type_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_ms_action
#define EL_STRUCT zx_gl_ms_action_s
#define EL_NS     gl
#define EL_TAG    ms_action

/* FUNC(zx_FREE_gl_ms_action) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_ms_action(struct zx_ctx* c, struct zx_gl_ms_action_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_ms_action) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_ms_action_s* zx_NEW_gl_ms_action(struct zx_ctx* c)
{
  struct zx_gl_ms_action_s* x = ZX_ZALLOC(c, struct zx_gl_ms_action_s);
  x->gg.g.tok = zx_gl_ms_action_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_ms_action) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_ms_action(struct zx_ctx* c, struct zx_gl_ms_action_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_gl_ms_action) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_ms_action_s* zx_DEEP_CLONE_gl_ms_action(struct zx_ctx* c, struct zx_gl_ms_action_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_ms_action_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_ms_action_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_gl_ms_action) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_ms_action(struct zx_ctx* c, struct zx_gl_ms_action_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_ms_action) */

int zx_WALK_WO_gl_ms_action(struct zx_ctx* c, struct zx_gl_ms_action_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_outerBoundaryIs
#define EL_STRUCT zx_gl_outerBoundaryIs_s
#define EL_NS     gl
#define EL_TAG    outerBoundaryIs

/* FUNC(zx_FREE_gl_outerBoundaryIs) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_outerBoundaryIs(struct zx_ctx* c, struct zx_gl_outerBoundaryIs_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->LinearRing->gg;
       e && e->g.tok == zx_gl_LinearRing_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_LinearRing(c, (struct zx_gl_LinearRing_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_outerBoundaryIs) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_outerBoundaryIs_s* zx_NEW_gl_outerBoundaryIs(struct zx_ctx* c)
{
  struct zx_gl_outerBoundaryIs_s* x = ZX_ZALLOC(c, struct zx_gl_outerBoundaryIs_s);
  x->gg.g.tok = zx_gl_outerBoundaryIs_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_outerBoundaryIs) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_outerBoundaryIs(struct zx_ctx* c, struct zx_gl_outerBoundaryIs_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->LinearRing->gg;
       se && se->g.tok == zx_gl_LinearRing_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_LinearRing(c, (struct zx_gl_LinearRing_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_outerBoundaryIs) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_outerBoundaryIs_s* zx_DEEP_CLONE_gl_outerBoundaryIs(struct zx_ctx* c, struct zx_gl_outerBoundaryIs_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_outerBoundaryIs_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_outerBoundaryIs_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->LinearRing->gg;
       e && e->g.tok == zx_gl_LinearRing_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_LinearRing(c,(struct zx_gl_LinearRing_s*)e,dup_strs);
  	  if (!enn)
  	      x->LinearRing = (struct zx_gl_LinearRing_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_outerBoundaryIs) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_outerBoundaryIs(struct zx_ctx* c, struct zx_gl_outerBoundaryIs_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->LinearRing->gg;
       e && e->g.tok == zx_gl_LinearRing_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_LinearRing(c, (struct zx_gl_LinearRing_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_outerBoundaryIs) */

int zx_WALK_WO_gl_outerBoundaryIs(struct zx_ctx* c, struct zx_gl_outerBoundaryIs_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_pd
#define EL_STRUCT zx_gl_pd_s
#define EL_NS     gl
#define EL_TAG    pd

/* FUNC(zx_FREE_gl_pd) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_pd(struct zx_ctx* c, struct zx_gl_pd_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->ACC, free_strs);

  zx_free_simple_elems(c, x->time, free_strs);
  for (e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_CivilData(c, (struct zx_gl_CivilData_s*)e, free_strs);
  }
  for (e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_shape(c, (struct zx_gl_shape_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->alt, free_strs);
  zx_free_simple_elems(c, x->alt_acc, free_strs);
  zx_free_simple_elems(c, x->speed, free_strs);
  zx_free_simple_elems(c, x->direction, free_strs);
  zx_free_simple_elems(c, x->Heading, free_strs);
  zx_free_simple_elems(c, x->lev_conf, free_strs);
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_pd) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_pd_s* zx_NEW_gl_pd(struct zx_ctx* c)
{
  struct zx_gl_pd_s* x = ZX_ZALLOC(c, struct zx_gl_pd_s);
  x->gg.g.tok = zx_gl_pd_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_pd) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_pd(struct zx_ctx* c, struct zx_gl_pd_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->ACC);

  zx_dup_strs_simple_elems(c, x->time);
  for (se = &x->CivilData->gg;
       se && se->g.tok == zx_gl_CivilData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_CivilData(c, (struct zx_gl_CivilData_s*)se);
  for (se = &x->shape->gg;
       se && se->g.tok == zx_gl_shape_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_shape(c, (struct zx_gl_shape_s*)se);
  zx_dup_strs_simple_elems(c, x->alt);
  zx_dup_strs_simple_elems(c, x->alt_acc);
  zx_dup_strs_simple_elems(c, x->speed);
  zx_dup_strs_simple_elems(c, x->direction);
  zx_dup_strs_simple_elems(c, x->Heading);
  zx_dup_strs_simple_elems(c, x->lev_conf);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_pd) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_pd_s* zx_DEEP_CLONE_gl_pd(struct zx_ctx* c, struct zx_gl_pd_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_pd_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_pd_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->ACC = zx_clone_attr(c, x->ACC);

  x->time = zx_deep_clone_simple_elems(c,x->time, dup_strs);
  for (enn = 0, e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_CivilData(c,(struct zx_gl_CivilData_s*)e,dup_strs);
  	  if (!enn)
  	      x->CivilData = (struct zx_gl_CivilData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_shape(c,(struct zx_gl_shape_s*)e,dup_strs);
  	  if (!enn)
  	      x->shape = (struct zx_gl_shape_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->alt = zx_deep_clone_simple_elems(c,x->alt, dup_strs);
  x->alt_acc = zx_deep_clone_simple_elems(c,x->alt_acc, dup_strs);
  x->speed = zx_deep_clone_simple_elems(c,x->speed, dup_strs);
  x->direction = zx_deep_clone_simple_elems(c,x->direction, dup_strs);
  x->Heading = zx_deep_clone_simple_elems(c,x->Heading, dup_strs);
  x->lev_conf = zx_deep_clone_simple_elems(c,x->lev_conf, dup_strs);
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_pd) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_pd(struct zx_ctx* c, struct zx_gl_pd_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->time, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->CivilData->gg;
       e && e->g.tok == zx_gl_CivilData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_CivilData(c, (struct zx_gl_CivilData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->shape->gg;
       e && e->g.tok == zx_gl_shape_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_shape(c, (struct zx_gl_shape_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->alt, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->alt_acc, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->speed, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->direction, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Heading, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->lev_conf, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_pd) */

int zx_WALK_WO_gl_pd(struct zx_ctx* c, struct zx_gl_pd_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_prio
#define EL_STRUCT zx_gl_prio_s
#define EL_NS     gl
#define EL_TAG    prio

/* FUNC(zx_FREE_gl_prio) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_prio(struct zx_ctx* c, struct zx_gl_prio_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_prio) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_prio_s* zx_NEW_gl_prio(struct zx_ctx* c)
{
  struct zx_gl_prio_s* x = ZX_ZALLOC(c, struct zx_gl_prio_s);
  x->gg.g.tok = zx_gl_prio_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_prio) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_prio(struct zx_ctx* c, struct zx_gl_prio_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_gl_prio) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_prio_s* zx_DEEP_CLONE_gl_prio(struct zx_ctx* c, struct zx_gl_prio_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_prio_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_prio_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_gl_prio) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_prio(struct zx_ctx* c, struct zx_gl_prio_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_prio) */

int zx_WALK_WO_gl_prio(struct zx_ctx* c, struct zx_gl_prio_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_resp_req
#define EL_STRUCT zx_gl_resp_req_s
#define EL_NS     gl
#define EL_TAG    resp_req

/* FUNC(zx_FREE_gl_resp_req) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_resp_req(struct zx_ctx* c, struct zx_gl_resp_req_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_resp_req) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_resp_req_s* zx_NEW_gl_resp_req(struct zx_ctx* c)
{
  struct zx_gl_resp_req_s* x = ZX_ZALLOC(c, struct zx_gl_resp_req_s);
  x->gg.g.tok = zx_gl_resp_req_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_resp_req) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_resp_req(struct zx_ctx* c, struct zx_gl_resp_req_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_gl_resp_req) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_resp_req_s* zx_DEEP_CLONE_gl_resp_req(struct zx_ctx* c, struct zx_gl_resp_req_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_resp_req_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_resp_req_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_gl_resp_req) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_resp_req(struct zx_ctx* c, struct zx_gl_resp_req_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_resp_req) */

int zx_WALK_WO_gl_resp_req(struct zx_ctx* c, struct zx_gl_resp_req_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   gl_shape
#define EL_STRUCT zx_gl_shape_s
#define EL_NS     gl
#define EL_TAG    shape

/* FUNC(zx_FREE_gl_shape) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_gl_shape(struct zx_ctx* c, struct zx_gl_shape_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Point->gg;
       e && e->g.tok == zx_gl_Point_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Point(c, (struct zx_gl_Point_s*)e, free_strs);
  }
  for (e = &x->LineString->gg;
       e && e->g.tok == zx_gl_LineString_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_LineString(c, (struct zx_gl_LineString_s*)e, free_strs);
  }
  for (e = &x->Polygon->gg;
       e && e->g.tok == zx_gl_Polygon_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Polygon(c, (struct zx_gl_Polygon_s*)e, free_strs);
  }
  for (e = &x->Box->gg;
       e && e->g.tok == zx_gl_Box_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Box(c, (struct zx_gl_Box_s*)e, free_strs);
  }
  for (e = &x->CircularArea->gg;
       e && e->g.tok == zx_gl_CircularArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_CircularArea(c, (struct zx_gl_CircularArea_s*)e, free_strs);
  }
  for (e = &x->CircularArcArea->gg;
       e && e->g.tok == zx_gl_CircularArcArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_CircularArcArea(c, (struct zx_gl_CircularArcArea_s*)e, free_strs);
  }
  for (e = &x->EllipticalArea->gg;
       e && e->g.tok == zx_gl_EllipticalArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_EllipticalArea(c, (struct zx_gl_EllipticalArea_s*)e, free_strs);
  }
  for (e = &x->GeometryCollection->gg;
       e && e->g.tok == zx_gl_GeometryCollection_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_GeometryCollection(c, (struct zx_gl_GeometryCollection_s*)e, free_strs);
  }
  for (e = &x->MultiLineString->gg;
       e && e->g.tok == zx_gl_MultiLineString_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_MultiLineString(c, (struct zx_gl_MultiLineString_s*)e, free_strs);
  }
  for (e = &x->MultiPoint->gg;
       e && e->g.tok == zx_gl_MultiPoint_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_MultiPoint(c, (struct zx_gl_MultiPoint_s*)e, free_strs);
  }
  for (e = &x->MultiPolygon->gg;
       e && e->g.tok == zx_gl_MultiPolygon_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_MultiPolygon(c, (struct zx_gl_MultiPolygon_s*)e, free_strs);
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_gl_Extension(c, (struct zx_gl_Extension_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_gl_shape) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_gl_shape_s* zx_NEW_gl_shape(struct zx_ctx* c)
{
  struct zx_gl_shape_s* x = ZX_ZALLOC(c, struct zx_gl_shape_s);
  x->gg.g.tok = zx_gl_shape_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_gl_shape) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_gl_shape(struct zx_ctx* c, struct zx_gl_shape_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Point->gg;
       se && se->g.tok == zx_gl_Point_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Point(c, (struct zx_gl_Point_s*)se);
  for (se = &x->LineString->gg;
       se && se->g.tok == zx_gl_LineString_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_LineString(c, (struct zx_gl_LineString_s*)se);
  for (se = &x->Polygon->gg;
       se && se->g.tok == zx_gl_Polygon_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Polygon(c, (struct zx_gl_Polygon_s*)se);
  for (se = &x->Box->gg;
       se && se->g.tok == zx_gl_Box_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Box(c, (struct zx_gl_Box_s*)se);
  for (se = &x->CircularArea->gg;
       se && se->g.tok == zx_gl_CircularArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_CircularArea(c, (struct zx_gl_CircularArea_s*)se);
  for (se = &x->CircularArcArea->gg;
       se && se->g.tok == zx_gl_CircularArcArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_CircularArcArea(c, (struct zx_gl_CircularArcArea_s*)se);
  for (se = &x->EllipticalArea->gg;
       se && se->g.tok == zx_gl_EllipticalArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_EllipticalArea(c, (struct zx_gl_EllipticalArea_s*)se);
  for (se = &x->GeometryCollection->gg;
       se && se->g.tok == zx_gl_GeometryCollection_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_GeometryCollection(c, (struct zx_gl_GeometryCollection_s*)se);
  for (se = &x->MultiLineString->gg;
       se && se->g.tok == zx_gl_MultiLineString_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_MultiLineString(c, (struct zx_gl_MultiLineString_s*)se);
  for (se = &x->MultiPoint->gg;
       se && se->g.tok == zx_gl_MultiPoint_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_MultiPoint(c, (struct zx_gl_MultiPoint_s*)se);
  for (se = &x->MultiPolygon->gg;
       se && se->g.tok == zx_gl_MultiPolygon_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_MultiPolygon(c, (struct zx_gl_MultiPolygon_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_gl_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_gl_Extension(c, (struct zx_gl_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_gl_shape) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_gl_shape_s* zx_DEEP_CLONE_gl_shape(struct zx_ctx* c, struct zx_gl_shape_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_gl_shape_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_gl_shape_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Point->gg;
       e && e->g.tok == zx_gl_Point_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Point(c,(struct zx_gl_Point_s*)e,dup_strs);
  	  if (!enn)
  	      x->Point = (struct zx_gl_Point_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->LineString->gg;
       e && e->g.tok == zx_gl_LineString_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_LineString(c,(struct zx_gl_LineString_s*)e,dup_strs);
  	  if (!enn)
  	      x->LineString = (struct zx_gl_LineString_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Polygon->gg;
       e && e->g.tok == zx_gl_Polygon_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Polygon(c,(struct zx_gl_Polygon_s*)e,dup_strs);
  	  if (!enn)
  	      x->Polygon = (struct zx_gl_Polygon_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Box->gg;
       e && e->g.tok == zx_gl_Box_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Box(c,(struct zx_gl_Box_s*)e,dup_strs);
  	  if (!enn)
  	      x->Box = (struct zx_gl_Box_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CircularArea->gg;
       e && e->g.tok == zx_gl_CircularArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_CircularArea(c,(struct zx_gl_CircularArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->CircularArea = (struct zx_gl_CircularArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CircularArcArea->gg;
       e && e->g.tok == zx_gl_CircularArcArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_CircularArcArea(c,(struct zx_gl_CircularArcArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->CircularArcArea = (struct zx_gl_CircularArcArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EllipticalArea->gg;
       e && e->g.tok == zx_gl_EllipticalArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_EllipticalArea(c,(struct zx_gl_EllipticalArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->EllipticalArea = (struct zx_gl_EllipticalArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->GeometryCollection->gg;
       e && e->g.tok == zx_gl_GeometryCollection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_GeometryCollection(c,(struct zx_gl_GeometryCollection_s*)e,dup_strs);
  	  if (!enn)
  	      x->GeometryCollection = (struct zx_gl_GeometryCollection_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->MultiLineString->gg;
       e && e->g.tok == zx_gl_MultiLineString_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_MultiLineString(c,(struct zx_gl_MultiLineString_s*)e,dup_strs);
  	  if (!enn)
  	      x->MultiLineString = (struct zx_gl_MultiLineString_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->MultiPoint->gg;
       e && e->g.tok == zx_gl_MultiPoint_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_MultiPoint(c,(struct zx_gl_MultiPoint_s*)e,dup_strs);
  	  if (!enn)
  	      x->MultiPoint = (struct zx_gl_MultiPoint_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->MultiPolygon->gg;
       e && e->g.tok == zx_gl_MultiPolygon_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_MultiPolygon(c,(struct zx_gl_MultiPolygon_s*)e,dup_strs);
  	  if (!enn)
  	      x->MultiPolygon = (struct zx_gl_MultiPolygon_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_gl_Extension(c,(struct zx_gl_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_gl_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_gl_shape) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_gl_shape(struct zx_ctx* c, struct zx_gl_shape_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Point->gg;
       e && e->g.tok == zx_gl_Point_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Point(c, (struct zx_gl_Point_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->LineString->gg;
       e && e->g.tok == zx_gl_LineString_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_LineString(c, (struct zx_gl_LineString_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Polygon->gg;
       e && e->g.tok == zx_gl_Polygon_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Polygon(c, (struct zx_gl_Polygon_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Box->gg;
       e && e->g.tok == zx_gl_Box_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Box(c, (struct zx_gl_Box_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CircularArea->gg;
       e && e->g.tok == zx_gl_CircularArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_CircularArea(c, (struct zx_gl_CircularArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CircularArcArea->gg;
       e && e->g.tok == zx_gl_CircularArcArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_CircularArcArea(c, (struct zx_gl_CircularArcArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EllipticalArea->gg;
       e && e->g.tok == zx_gl_EllipticalArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_EllipticalArea(c, (struct zx_gl_EllipticalArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->GeometryCollection->gg;
       e && e->g.tok == zx_gl_GeometryCollection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_GeometryCollection(c, (struct zx_gl_GeometryCollection_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->MultiLineString->gg;
       e && e->g.tok == zx_gl_MultiLineString_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_MultiLineString(c, (struct zx_gl_MultiLineString_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->MultiPoint->gg;
       e && e->g.tok == zx_gl_MultiPoint_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_MultiPoint(c, (struct zx_gl_MultiPoint_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->MultiPolygon->gg;
       e && e->g.tok == zx_gl_MultiPolygon_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_MultiPolygon(c, (struct zx_gl_MultiPolygon_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_gl_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_gl_Extension(c, (struct zx_gl_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_gl_shape) */

int zx_WALK_WO_gl_shape(struct zx_ctx* c, struct zx_gl_shape_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif


/* EOF -- c/zx-gl-aux.c */
