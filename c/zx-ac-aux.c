/* c/zx-ac-aux.c - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** aux-templ.c  -  Auxiliary functions template: cloning, freeing, walking data
 ** Copyright (c) 2010 Sampo Kellomaki (sampo@iki.fi), All Rights Reserved.
 ** Copyright (c) 2006 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: aux-templ.c,v 1.12 2008-10-04 23:42:14 sampo Exp $
 **
 ** 30.5.2006, created, Sampo Kellomaki (sampo@iki.fi)
 ** 6.8.2006, factored from enc-templ.c to separate file --Sampo
 **
 ** N.B: wo=wire order (needed for exc-c14n), so=schema order
 **/

#include <memory.h>
#include "errmac.h"
#include "zx.h"
#include "c/zx-const.h"
#include "c/zx-data.h"
#include "c/zx-ac-data.h"



#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_ActivationLimit
#define EL_STRUCT zx_ac_ActivationLimit_s
#define EL_NS     ac
#define EL_TAG    ActivationLimit

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_ActivationLimit) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_ActivationLimit(struct zx_ctx* c, struct zx_ac_ActivationLimit_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ActivationLimitDuration->gg;
       se && se->g.tok == zx_ac_ActivationLimitDuration_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_ActivationLimitDuration(c, (struct zx_ac_ActivationLimitDuration_s*)se);
  for (se = &x->ActivationLimitUsages->gg;
       se && se->g.tok == zx_ac_ActivationLimitUsages_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_ActivationLimitUsages(c, (struct zx_ac_ActivationLimitUsages_s*)se);
  zx_dup_strs_simple_elems(c, x->ActivationLimitSession);

}

/* FUNC(zx_DEEP_CLONE_ac_ActivationLimit) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_ActivationLimit_s* zx_DEEP_CLONE_ac_ActivationLimit(struct zx_ctx* c, struct zx_ac_ActivationLimit_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_ActivationLimit_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_ActivationLimit_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ActivationLimitDuration->gg;
       e && e->g.tok == zx_ac_ActivationLimitDuration_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_ActivationLimitDuration(c,(struct zx_ac_ActivationLimitDuration_s*)e,dup_strs);
  	  if (!enn)
  	      x->ActivationLimitDuration = (struct zx_ac_ActivationLimitDuration_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ActivationLimitUsages->gg;
       e && e->g.tok == zx_ac_ActivationLimitUsages_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_ActivationLimitUsages(c,(struct zx_ac_ActivationLimitUsages_s*)e,dup_strs);
  	  if (!enn)
  	      x->ActivationLimitUsages = (struct zx_ac_ActivationLimitUsages_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->ActivationLimitSession = zx_deep_clone_simple_elems(c,x->ActivationLimitSession, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_ac_ActivationLimit) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_ActivationLimit(struct zx_ctx* c, struct zx_ac_ActivationLimit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ActivationLimitDuration->gg;
       e && e->g.tok == zx_ac_ActivationLimitDuration_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_ActivationLimitDuration(c, (struct zx_ac_ActivationLimitDuration_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ActivationLimitUsages->gg;
       e && e->g.tok == zx_ac_ActivationLimitUsages_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_ActivationLimitUsages(c, (struct zx_ac_ActivationLimitUsages_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->ActivationLimitSession, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_ActivationLimit) */

int zx_WALK_WO_ac_ActivationLimit(struct zx_ctx* c, struct zx_ac_ActivationLimit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_ActivationLimitDuration
#define EL_STRUCT zx_ac_ActivationLimitDuration_s
#define EL_NS     ac
#define EL_TAG    ActivationLimitDuration

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_ActivationLimitDuration) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_ActivationLimitDuration(struct zx_ctx* c, struct zx_ac_ActivationLimitDuration_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->duration);


}

/* FUNC(zx_DEEP_CLONE_ac_ActivationLimitDuration) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_ActivationLimitDuration_s* zx_DEEP_CLONE_ac_ActivationLimitDuration(struct zx_ctx* c, struct zx_ac_ActivationLimitDuration_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_ActivationLimitDuration_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_ActivationLimitDuration_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->duration = zx_clone_attr(c, x->duration);


  return x;
}

/* FUNC(zx_WALK_SO_ac_ActivationLimitDuration) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_ActivationLimitDuration(struct zx_ctx* c, struct zx_ac_ActivationLimitDuration_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_ActivationLimitDuration) */

int zx_WALK_WO_ac_ActivationLimitDuration(struct zx_ctx* c, struct zx_ac_ActivationLimitDuration_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_ActivationLimitUsages
#define EL_STRUCT zx_ac_ActivationLimitUsages_s
#define EL_NS     ac
#define EL_TAG    ActivationLimitUsages

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_ActivationLimitUsages) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_ActivationLimitUsages(struct zx_ctx* c, struct zx_ac_ActivationLimitUsages_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->number);


}

/* FUNC(zx_DEEP_CLONE_ac_ActivationLimitUsages) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_ActivationLimitUsages_s* zx_DEEP_CLONE_ac_ActivationLimitUsages(struct zx_ctx* c, struct zx_ac_ActivationLimitUsages_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_ActivationLimitUsages_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_ActivationLimitUsages_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->number = zx_clone_attr(c, x->number);


  return x;
}

/* FUNC(zx_WALK_SO_ac_ActivationLimitUsages) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_ActivationLimitUsages(struct zx_ctx* c, struct zx_ac_ActivationLimitUsages_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_ActivationLimitUsages) */

int zx_WALK_WO_ac_ActivationLimitUsages(struct zx_ctx* c, struct zx_ac_ActivationLimitUsages_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_ActivationPin
#define EL_STRUCT zx_ac_ActivationPin_s
#define EL_NS     ac
#define EL_TAG    ActivationPin

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_ActivationPin) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_ActivationPin(struct zx_ctx* c, struct zx_ac_ActivationPin_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Length->gg;
       se && se->g.tok == zx_ac_Length_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Length(c, (struct zx_ac_Length_s*)se);
  for (se = &x->Alphabet->gg;
       se && se->g.tok == zx_ac_Alphabet_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Alphabet(c, (struct zx_ac_Alphabet_s*)se);
  for (se = &x->Generation->gg;
       se && se->g.tok == zx_ac_Generation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Generation(c, (struct zx_ac_Generation_s*)se);
  for (se = &x->ActivationLimit->gg;
       se && se->g.tok == zx_ac_ActivationLimit_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_ActivationLimit(c, (struct zx_ac_ActivationLimit_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_ActivationPin) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_ActivationPin_s* zx_DEEP_CLONE_ac_ActivationPin(struct zx_ctx* c, struct zx_ac_ActivationPin_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_ActivationPin_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_ActivationPin_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Length->gg;
       e && e->g.tok == zx_ac_Length_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Length(c,(struct zx_ac_Length_s*)e,dup_strs);
  	  if (!enn)
  	      x->Length = (struct zx_ac_Length_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Alphabet->gg;
       e && e->g.tok == zx_ac_Alphabet_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Alphabet(c,(struct zx_ac_Alphabet_s*)e,dup_strs);
  	  if (!enn)
  	      x->Alphabet = (struct zx_ac_Alphabet_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Generation->gg;
       e && e->g.tok == zx_ac_Generation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Generation(c,(struct zx_ac_Generation_s*)e,dup_strs);
  	  if (!enn)
  	      x->Generation = (struct zx_ac_Generation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ActivationLimit->gg;
       e && e->g.tok == zx_ac_ActivationLimit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_ActivationLimit(c,(struct zx_ac_ActivationLimit_s*)e,dup_strs);
  	  if (!enn)
  	      x->ActivationLimit = (struct zx_ac_ActivationLimit_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_ActivationPin) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_ActivationPin(struct zx_ctx* c, struct zx_ac_ActivationPin_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Length->gg;
       e && e->g.tok == zx_ac_Length_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Length(c, (struct zx_ac_Length_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Alphabet->gg;
       e && e->g.tok == zx_ac_Alphabet_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Alphabet(c, (struct zx_ac_Alphabet_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Generation->gg;
       e && e->g.tok == zx_ac_Generation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Generation(c, (struct zx_ac_Generation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ActivationLimit->gg;
       e && e->g.tok == zx_ac_ActivationLimit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_ActivationLimit(c, (struct zx_ac_ActivationLimit_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_ActivationPin) */

int zx_WALK_WO_ac_ActivationPin(struct zx_ctx* c, struct zx_ac_ActivationPin_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_Alphabet
#define EL_STRUCT zx_ac_Alphabet_s
#define EL_NS     ac
#define EL_TAG    Alphabet

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_Alphabet) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_Alphabet(struct zx_ctx* c, struct zx_ac_Alphabet_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->case_is_c_keyword);
  zx_dup_attr(c, x->excludedChars);
  zx_dup_attr(c, x->requiredChars);


}

/* FUNC(zx_DEEP_CLONE_ac_Alphabet) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_Alphabet_s* zx_DEEP_CLONE_ac_Alphabet(struct zx_ctx* c, struct zx_ac_Alphabet_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_Alphabet_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_Alphabet_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->case_is_c_keyword = zx_clone_attr(c, x->case_is_c_keyword);
  x->excludedChars = zx_clone_attr(c, x->excludedChars);
  x->requiredChars = zx_clone_attr(c, x->requiredChars);


  return x;
}

/* FUNC(zx_WALK_SO_ac_Alphabet) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_Alphabet(struct zx_ctx* c, struct zx_ac_Alphabet_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_Alphabet) */

int zx_WALK_WO_ac_Alphabet(struct zx_ctx* c, struct zx_ac_Alphabet_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_AsymmetricDecryption
#define EL_STRUCT zx_ac_AsymmetricDecryption_s
#define EL_NS     ac
#define EL_TAG    AsymmetricDecryption

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_AsymmetricDecryption) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_AsymmetricDecryption(struct zx_ctx* c, struct zx_ac_AsymmetricDecryption_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_AsymmetricDecryption) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_AsymmetricDecryption_s* zx_DEEP_CLONE_ac_AsymmetricDecryption(struct zx_ctx* c, struct zx_ac_AsymmetricDecryption_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_AsymmetricDecryption_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_AsymmetricDecryption_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_AsymmetricDecryption) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_AsymmetricDecryption(struct zx_ctx* c, struct zx_ac_AsymmetricDecryption_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_AsymmetricDecryption) */

int zx_WALK_WO_ac_AsymmetricDecryption(struct zx_ctx* c, struct zx_ac_AsymmetricDecryption_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_AsymmetricKeyAgreement
#define EL_STRUCT zx_ac_AsymmetricKeyAgreement_s
#define EL_NS     ac
#define EL_TAG    AsymmetricKeyAgreement

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_AsymmetricKeyAgreement) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_AsymmetricKeyAgreement(struct zx_ctx* c, struct zx_ac_AsymmetricKeyAgreement_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_AsymmetricKeyAgreement) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_AsymmetricKeyAgreement_s* zx_DEEP_CLONE_ac_AsymmetricKeyAgreement(struct zx_ctx* c, struct zx_ac_AsymmetricKeyAgreement_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_AsymmetricKeyAgreement_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_AsymmetricKeyAgreement_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_AsymmetricKeyAgreement) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_AsymmetricKeyAgreement(struct zx_ctx* c, struct zx_ac_AsymmetricKeyAgreement_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_AsymmetricKeyAgreement) */

int zx_WALK_WO_ac_AsymmetricKeyAgreement(struct zx_ctx* c, struct zx_ac_AsymmetricKeyAgreement_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_AuthenticatingAuthority
#define EL_STRUCT zx_ac_AuthenticatingAuthority_s
#define EL_NS     ac
#define EL_TAG    AuthenticatingAuthority

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_AuthenticatingAuthority) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_AuthenticatingAuthority(struct zx_ctx* c, struct zx_ac_AuthenticatingAuthority_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->ID);

  for (se = &x->GoverningAgreements->gg;
       se && se->g.tok == zx_ac_GoverningAgreements_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_GoverningAgreements(c, (struct zx_ac_GoverningAgreements_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_AuthenticatingAuthority) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_AuthenticatingAuthority_s* zx_DEEP_CLONE_ac_AuthenticatingAuthority(struct zx_ctx* c, struct zx_ac_AuthenticatingAuthority_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_AuthenticatingAuthority_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_AuthenticatingAuthority_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->ID = zx_clone_attr(c, x->ID);

  for (enn = 0, e = &x->GoverningAgreements->gg;
       e && e->g.tok == zx_ac_GoverningAgreements_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_GoverningAgreements(c,(struct zx_ac_GoverningAgreements_s*)e,dup_strs);
  	  if (!enn)
  	      x->GoverningAgreements = (struct zx_ac_GoverningAgreements_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_AuthenticatingAuthority) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_AuthenticatingAuthority(struct zx_ctx* c, struct zx_ac_AuthenticatingAuthority_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->GoverningAgreements->gg;
       e && e->g.tok == zx_ac_GoverningAgreements_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_GoverningAgreements(c, (struct zx_ac_GoverningAgreements_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_AuthenticatingAuthority) */

int zx_WALK_WO_ac_AuthenticatingAuthority(struct zx_ctx* c, struct zx_ac_AuthenticatingAuthority_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_AuthenticationContextStatement
#define EL_STRUCT zx_ac_AuthenticationContextStatement_s
#define EL_NS     ac
#define EL_TAG    AuthenticationContextStatement

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_AuthenticationContextStatement) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_AuthenticationContextStatement(struct zx_ctx* c, struct zx_ac_AuthenticationContextStatement_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->ID);

  for (se = &x->Identification->gg;
       se && se->g.tok == zx_ac_Identification_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Identification(c, (struct zx_ac_Identification_s*)se);
  for (se = &x->TechnicalProtection->gg;
       se && se->g.tok == zx_ac_TechnicalProtection_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_TechnicalProtection(c, (struct zx_ac_TechnicalProtection_s*)se);
  for (se = &x->OperationalProtection->gg;
       se && se->g.tok == zx_ac_OperationalProtection_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_OperationalProtection(c, (struct zx_ac_OperationalProtection_s*)se);
  for (se = &x->AuthenticationMethod->gg;
       se && se->g.tok == zx_ac_AuthenticationMethod_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_AuthenticationMethod(c, (struct zx_ac_AuthenticationMethod_s*)se);
  for (se = &x->GoverningAgreements->gg;
       se && se->g.tok == zx_ac_GoverningAgreements_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_GoverningAgreements(c, (struct zx_ac_GoverningAgreements_s*)se);
  for (se = &x->AuthenticatingAuthority->gg;
       se && se->g.tok == zx_ac_AuthenticatingAuthority_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_AuthenticatingAuthority(c, (struct zx_ac_AuthenticatingAuthority_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_AuthenticationContextStatement) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_AuthenticationContextStatement_s* zx_DEEP_CLONE_ac_AuthenticationContextStatement(struct zx_ctx* c, struct zx_ac_AuthenticationContextStatement_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_AuthenticationContextStatement_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_AuthenticationContextStatement_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->ID = zx_clone_attr(c, x->ID);

  for (enn = 0, e = &x->Identification->gg;
       e && e->g.tok == zx_ac_Identification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Identification(c,(struct zx_ac_Identification_s*)e,dup_strs);
  	  if (!enn)
  	      x->Identification = (struct zx_ac_Identification_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->TechnicalProtection->gg;
       e && e->g.tok == zx_ac_TechnicalProtection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_TechnicalProtection(c,(struct zx_ac_TechnicalProtection_s*)e,dup_strs);
  	  if (!enn)
  	      x->TechnicalProtection = (struct zx_ac_TechnicalProtection_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OperationalProtection->gg;
       e && e->g.tok == zx_ac_OperationalProtection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_OperationalProtection(c,(struct zx_ac_OperationalProtection_s*)e,dup_strs);
  	  if (!enn)
  	      x->OperationalProtection = (struct zx_ac_OperationalProtection_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AuthenticationMethod->gg;
       e && e->g.tok == zx_ac_AuthenticationMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_AuthenticationMethod(c,(struct zx_ac_AuthenticationMethod_s*)e,dup_strs);
  	  if (!enn)
  	      x->AuthenticationMethod = (struct zx_ac_AuthenticationMethod_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->GoverningAgreements->gg;
       e && e->g.tok == zx_ac_GoverningAgreements_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_GoverningAgreements(c,(struct zx_ac_GoverningAgreements_s*)e,dup_strs);
  	  if (!enn)
  	      x->GoverningAgreements = (struct zx_ac_GoverningAgreements_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AuthenticatingAuthority->gg;
       e && e->g.tok == zx_ac_AuthenticatingAuthority_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_AuthenticatingAuthority(c,(struct zx_ac_AuthenticatingAuthority_s*)e,dup_strs);
  	  if (!enn)
  	      x->AuthenticatingAuthority = (struct zx_ac_AuthenticatingAuthority_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_AuthenticationContextStatement) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_AuthenticationContextStatement(struct zx_ctx* c, struct zx_ac_AuthenticationContextStatement_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Identification->gg;
       e && e->g.tok == zx_ac_Identification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Identification(c, (struct zx_ac_Identification_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->TechnicalProtection->gg;
       e && e->g.tok == zx_ac_TechnicalProtection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_TechnicalProtection(c, (struct zx_ac_TechnicalProtection_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OperationalProtection->gg;
       e && e->g.tok == zx_ac_OperationalProtection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_OperationalProtection(c, (struct zx_ac_OperationalProtection_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AuthenticationMethod->gg;
       e && e->g.tok == zx_ac_AuthenticationMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_AuthenticationMethod(c, (struct zx_ac_AuthenticationMethod_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->GoverningAgreements->gg;
       e && e->g.tok == zx_ac_GoverningAgreements_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_GoverningAgreements(c, (struct zx_ac_GoverningAgreements_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AuthenticatingAuthority->gg;
       e && e->g.tok == zx_ac_AuthenticatingAuthority_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_AuthenticatingAuthority(c, (struct zx_ac_AuthenticatingAuthority_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_AuthenticationContextStatement) */

int zx_WALK_WO_ac_AuthenticationContextStatement(struct zx_ctx* c, struct zx_ac_AuthenticationContextStatement_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_AuthenticationMethod
#define EL_STRUCT zx_ac_AuthenticationMethod_s
#define EL_NS     ac
#define EL_TAG    AuthenticationMethod

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_AuthenticationMethod) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_AuthenticationMethod(struct zx_ctx* c, struct zx_ac_AuthenticationMethod_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PrincipalAuthenticationMechanism->gg;
       se && se->g.tok == zx_ac_PrincipalAuthenticationMechanism_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_PrincipalAuthenticationMechanism(c, (struct zx_ac_PrincipalAuthenticationMechanism_s*)se);
  for (se = &x->Authenticator->gg;
       se && se->g.tok == zx_ac_Authenticator_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Authenticator(c, (struct zx_ac_Authenticator_s*)se);
  for (se = &x->AuthenticatorTransportProtocol->gg;
       se && se->g.tok == zx_ac_AuthenticatorTransportProtocol_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_AuthenticatorTransportProtocol(c, (struct zx_ac_AuthenticatorTransportProtocol_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_AuthenticationMethod) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_AuthenticationMethod_s* zx_DEEP_CLONE_ac_AuthenticationMethod(struct zx_ctx* c, struct zx_ac_AuthenticationMethod_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_AuthenticationMethod_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_AuthenticationMethod_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PrincipalAuthenticationMechanism->gg;
       e && e->g.tok == zx_ac_PrincipalAuthenticationMechanism_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_PrincipalAuthenticationMechanism(c,(struct zx_ac_PrincipalAuthenticationMechanism_s*)e,dup_strs);
  	  if (!enn)
  	      x->PrincipalAuthenticationMechanism = (struct zx_ac_PrincipalAuthenticationMechanism_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Authenticator->gg;
       e && e->g.tok == zx_ac_Authenticator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Authenticator(c,(struct zx_ac_Authenticator_s*)e,dup_strs);
  	  if (!enn)
  	      x->Authenticator = (struct zx_ac_Authenticator_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AuthenticatorTransportProtocol->gg;
       e && e->g.tok == zx_ac_AuthenticatorTransportProtocol_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_AuthenticatorTransportProtocol(c,(struct zx_ac_AuthenticatorTransportProtocol_s*)e,dup_strs);
  	  if (!enn)
  	      x->AuthenticatorTransportProtocol = (struct zx_ac_AuthenticatorTransportProtocol_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_AuthenticationMethod) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_AuthenticationMethod(struct zx_ctx* c, struct zx_ac_AuthenticationMethod_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PrincipalAuthenticationMechanism->gg;
       e && e->g.tok == zx_ac_PrincipalAuthenticationMechanism_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_PrincipalAuthenticationMechanism(c, (struct zx_ac_PrincipalAuthenticationMechanism_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Authenticator->gg;
       e && e->g.tok == zx_ac_Authenticator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Authenticator(c, (struct zx_ac_Authenticator_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AuthenticatorTransportProtocol->gg;
       e && e->g.tok == zx_ac_AuthenticatorTransportProtocol_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_AuthenticatorTransportProtocol(c, (struct zx_ac_AuthenticatorTransportProtocol_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_AuthenticationMethod) */

int zx_WALK_WO_ac_AuthenticationMethod(struct zx_ctx* c, struct zx_ac_AuthenticationMethod_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_Authenticator
#define EL_STRUCT zx_ac_Authenticator_s
#define EL_NS     ac
#define EL_TAG    Authenticator

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_Authenticator) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_Authenticator(struct zx_ctx* c, struct zx_ac_Authenticator_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PreviousSession->gg;
       se && se->g.tok == zx_ac_PreviousSession_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_PreviousSession(c, (struct zx_ac_PreviousSession_s*)se);
  for (se = &x->ResumeSession->gg;
       se && se->g.tok == zx_ac_ResumeSession_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_ResumeSession(c, (struct zx_ac_ResumeSession_s*)se);
  for (se = &x->DigSig->gg;
       se && se->g.tok == zx_ac_DigSig_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_DigSig(c, (struct zx_ac_DigSig_s*)se);
  for (se = &x->Password->gg;
       se && se->g.tok == zx_ac_Password_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Password(c, (struct zx_ac_Password_s*)se);
  for (se = &x->ZeroKnowledge->gg;
       se && se->g.tok == zx_ac_ZeroKnowledge_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_ZeroKnowledge(c, (struct zx_ac_ZeroKnowledge_s*)se);
  for (se = &x->SharedSecretChallengeResponse->gg;
       se && se->g.tok == zx_ac_SharedSecretChallengeResponse_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_SharedSecretChallengeResponse(c, (struct zx_ac_SharedSecretChallengeResponse_s*)se);
  for (se = &x->SharedSecretDynamicPlaintext->gg;
       se && se->g.tok == zx_ac_SharedSecretDynamicPlaintext_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_SharedSecretDynamicPlaintext(c, (struct zx_ac_SharedSecretDynamicPlaintext_s*)se);
  for (se = &x->IPAddress->gg;
       se && se->g.tok == zx_ac_IPAddress_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_IPAddress(c, (struct zx_ac_IPAddress_s*)se);
  for (se = &x->AsymmetricDecryption->gg;
       se && se->g.tok == zx_ac_AsymmetricDecryption_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_AsymmetricDecryption(c, (struct zx_ac_AsymmetricDecryption_s*)se);
  for (se = &x->AsymmetricKeyAgreement->gg;
       se && se->g.tok == zx_ac_AsymmetricKeyAgreement_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_AsymmetricKeyAgreement(c, (struct zx_ac_AsymmetricKeyAgreement_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_Authenticator) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_Authenticator_s* zx_DEEP_CLONE_ac_Authenticator(struct zx_ctx* c, struct zx_ac_Authenticator_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_Authenticator_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_Authenticator_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PreviousSession->gg;
       e && e->g.tok == zx_ac_PreviousSession_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_PreviousSession(c,(struct zx_ac_PreviousSession_s*)e,dup_strs);
  	  if (!enn)
  	      x->PreviousSession = (struct zx_ac_PreviousSession_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ResumeSession->gg;
       e && e->g.tok == zx_ac_ResumeSession_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_ResumeSession(c,(struct zx_ac_ResumeSession_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResumeSession = (struct zx_ac_ResumeSession_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DigSig->gg;
       e && e->g.tok == zx_ac_DigSig_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_DigSig(c,(struct zx_ac_DigSig_s*)e,dup_strs);
  	  if (!enn)
  	      x->DigSig = (struct zx_ac_DigSig_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Password->gg;
       e && e->g.tok == zx_ac_Password_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Password(c,(struct zx_ac_Password_s*)e,dup_strs);
  	  if (!enn)
  	      x->Password = (struct zx_ac_Password_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ZeroKnowledge->gg;
       e && e->g.tok == zx_ac_ZeroKnowledge_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_ZeroKnowledge(c,(struct zx_ac_ZeroKnowledge_s*)e,dup_strs);
  	  if (!enn)
  	      x->ZeroKnowledge = (struct zx_ac_ZeroKnowledge_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SharedSecretChallengeResponse->gg;
       e && e->g.tok == zx_ac_SharedSecretChallengeResponse_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_SharedSecretChallengeResponse(c,(struct zx_ac_SharedSecretChallengeResponse_s*)e,dup_strs);
  	  if (!enn)
  	      x->SharedSecretChallengeResponse = (struct zx_ac_SharedSecretChallengeResponse_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SharedSecretDynamicPlaintext->gg;
       e && e->g.tok == zx_ac_SharedSecretDynamicPlaintext_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_SharedSecretDynamicPlaintext(c,(struct zx_ac_SharedSecretDynamicPlaintext_s*)e,dup_strs);
  	  if (!enn)
  	      x->SharedSecretDynamicPlaintext = (struct zx_ac_SharedSecretDynamicPlaintext_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->IPAddress->gg;
       e && e->g.tok == zx_ac_IPAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_IPAddress(c,(struct zx_ac_IPAddress_s*)e,dup_strs);
  	  if (!enn)
  	      x->IPAddress = (struct zx_ac_IPAddress_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AsymmetricDecryption->gg;
       e && e->g.tok == zx_ac_AsymmetricDecryption_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_AsymmetricDecryption(c,(struct zx_ac_AsymmetricDecryption_s*)e,dup_strs);
  	  if (!enn)
  	      x->AsymmetricDecryption = (struct zx_ac_AsymmetricDecryption_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AsymmetricKeyAgreement->gg;
       e && e->g.tok == zx_ac_AsymmetricKeyAgreement_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_AsymmetricKeyAgreement(c,(struct zx_ac_AsymmetricKeyAgreement_s*)e,dup_strs);
  	  if (!enn)
  	      x->AsymmetricKeyAgreement = (struct zx_ac_AsymmetricKeyAgreement_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_Authenticator) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_Authenticator(struct zx_ctx* c, struct zx_ac_Authenticator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PreviousSession->gg;
       e && e->g.tok == zx_ac_PreviousSession_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_PreviousSession(c, (struct zx_ac_PreviousSession_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ResumeSession->gg;
       e && e->g.tok == zx_ac_ResumeSession_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_ResumeSession(c, (struct zx_ac_ResumeSession_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DigSig->gg;
       e && e->g.tok == zx_ac_DigSig_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_DigSig(c, (struct zx_ac_DigSig_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Password->gg;
       e && e->g.tok == zx_ac_Password_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Password(c, (struct zx_ac_Password_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ZeroKnowledge->gg;
       e && e->g.tok == zx_ac_ZeroKnowledge_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_ZeroKnowledge(c, (struct zx_ac_ZeroKnowledge_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SharedSecretChallengeResponse->gg;
       e && e->g.tok == zx_ac_SharedSecretChallengeResponse_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_SharedSecretChallengeResponse(c, (struct zx_ac_SharedSecretChallengeResponse_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SharedSecretDynamicPlaintext->gg;
       e && e->g.tok == zx_ac_SharedSecretDynamicPlaintext_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_SharedSecretDynamicPlaintext(c, (struct zx_ac_SharedSecretDynamicPlaintext_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->IPAddress->gg;
       e && e->g.tok == zx_ac_IPAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_IPAddress(c, (struct zx_ac_IPAddress_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AsymmetricDecryption->gg;
       e && e->g.tok == zx_ac_AsymmetricDecryption_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_AsymmetricDecryption(c, (struct zx_ac_AsymmetricDecryption_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AsymmetricKeyAgreement->gg;
       e && e->g.tok == zx_ac_AsymmetricKeyAgreement_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_AsymmetricKeyAgreement(c, (struct zx_ac_AsymmetricKeyAgreement_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_Authenticator) */

int zx_WALK_WO_ac_Authenticator(struct zx_ctx* c, struct zx_ac_Authenticator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_AuthenticatorTransportProtocol
#define EL_STRUCT zx_ac_AuthenticatorTransportProtocol_s
#define EL_NS     ac
#define EL_TAG    AuthenticatorTransportProtocol

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_AuthenticatorTransportProtocol) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_AuthenticatorTransportProtocol(struct zx_ctx* c, struct zx_ac_AuthenticatorTransportProtocol_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->HTTP->gg;
       se && se->g.tok == zx_ac_HTTP_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_HTTP(c, (struct zx_ac_HTTP_s*)se);
  for (se = &x->SSL->gg;
       se && se->g.tok == zx_ac_SSL_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_SSL(c, (struct zx_ac_SSL_s*)se);
  for (se = &x->MobileNetworkNoEncryption->gg;
       se && se->g.tok == zx_ac_MobileNetworkNoEncryption_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_MobileNetworkNoEncryption(c, (struct zx_ac_MobileNetworkNoEncryption_s*)se);
  for (se = &x->MobileNetworkRadioEncryption->gg;
       se && se->g.tok == zx_ac_MobileNetworkRadioEncryption_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_MobileNetworkRadioEncryption(c, (struct zx_ac_MobileNetworkRadioEncryption_s*)se);
  for (se = &x->MobileNetworkEndToEndEncryption->gg;
       se && se->g.tok == zx_ac_MobileNetworkEndToEndEncryption_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_MobileNetworkEndToEndEncryption(c, (struct zx_ac_MobileNetworkEndToEndEncryption_s*)se);
  for (se = &x->WTLS->gg;
       se && se->g.tok == zx_ac_WTLS_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_WTLS(c, (struct zx_ac_WTLS_s*)se);
  for (se = &x->IPSec->gg;
       se && se->g.tok == zx_ac_IPSec_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_IPSec(c, (struct zx_ac_IPSec_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_AuthenticatorTransportProtocol) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_AuthenticatorTransportProtocol_s* zx_DEEP_CLONE_ac_AuthenticatorTransportProtocol(struct zx_ctx* c, struct zx_ac_AuthenticatorTransportProtocol_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_AuthenticatorTransportProtocol_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_AuthenticatorTransportProtocol_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->HTTP->gg;
       e && e->g.tok == zx_ac_HTTP_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_HTTP(c,(struct zx_ac_HTTP_s*)e,dup_strs);
  	  if (!enn)
  	      x->HTTP = (struct zx_ac_HTTP_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SSL->gg;
       e && e->g.tok == zx_ac_SSL_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_SSL(c,(struct zx_ac_SSL_s*)e,dup_strs);
  	  if (!enn)
  	      x->SSL = (struct zx_ac_SSL_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->MobileNetworkNoEncryption->gg;
       e && e->g.tok == zx_ac_MobileNetworkNoEncryption_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_MobileNetworkNoEncryption(c,(struct zx_ac_MobileNetworkNoEncryption_s*)e,dup_strs);
  	  if (!enn)
  	      x->MobileNetworkNoEncryption = (struct zx_ac_MobileNetworkNoEncryption_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->MobileNetworkRadioEncryption->gg;
       e && e->g.tok == zx_ac_MobileNetworkRadioEncryption_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_MobileNetworkRadioEncryption(c,(struct zx_ac_MobileNetworkRadioEncryption_s*)e,dup_strs);
  	  if (!enn)
  	      x->MobileNetworkRadioEncryption = (struct zx_ac_MobileNetworkRadioEncryption_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->MobileNetworkEndToEndEncryption->gg;
       e && e->g.tok == zx_ac_MobileNetworkEndToEndEncryption_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_MobileNetworkEndToEndEncryption(c,(struct zx_ac_MobileNetworkEndToEndEncryption_s*)e,dup_strs);
  	  if (!enn)
  	      x->MobileNetworkEndToEndEncryption = (struct zx_ac_MobileNetworkEndToEndEncryption_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->WTLS->gg;
       e && e->g.tok == zx_ac_WTLS_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_WTLS(c,(struct zx_ac_WTLS_s*)e,dup_strs);
  	  if (!enn)
  	      x->WTLS = (struct zx_ac_WTLS_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->IPSec->gg;
       e && e->g.tok == zx_ac_IPSec_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_IPSec(c,(struct zx_ac_IPSec_s*)e,dup_strs);
  	  if (!enn)
  	      x->IPSec = (struct zx_ac_IPSec_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_AuthenticatorTransportProtocol) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_AuthenticatorTransportProtocol(struct zx_ctx* c, struct zx_ac_AuthenticatorTransportProtocol_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->HTTP->gg;
       e && e->g.tok == zx_ac_HTTP_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_HTTP(c, (struct zx_ac_HTTP_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SSL->gg;
       e && e->g.tok == zx_ac_SSL_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_SSL(c, (struct zx_ac_SSL_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->MobileNetworkNoEncryption->gg;
       e && e->g.tok == zx_ac_MobileNetworkNoEncryption_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_MobileNetworkNoEncryption(c, (struct zx_ac_MobileNetworkNoEncryption_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->MobileNetworkRadioEncryption->gg;
       e && e->g.tok == zx_ac_MobileNetworkRadioEncryption_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_MobileNetworkRadioEncryption(c, (struct zx_ac_MobileNetworkRadioEncryption_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->MobileNetworkEndToEndEncryption->gg;
       e && e->g.tok == zx_ac_MobileNetworkEndToEndEncryption_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_MobileNetworkEndToEndEncryption(c, (struct zx_ac_MobileNetworkEndToEndEncryption_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->WTLS->gg;
       e && e->g.tok == zx_ac_WTLS_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_WTLS(c, (struct zx_ac_WTLS_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->IPSec->gg;
       e && e->g.tok == zx_ac_IPSec_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_IPSec(c, (struct zx_ac_IPSec_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_AuthenticatorTransportProtocol) */

int zx_WALK_WO_ac_AuthenticatorTransportProtocol(struct zx_ctx* c, struct zx_ac_AuthenticatorTransportProtocol_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_DeactivationCallCenter
#define EL_STRUCT zx_ac_DeactivationCallCenter_s
#define EL_NS     ac
#define EL_TAG    DeactivationCallCenter

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_DeactivationCallCenter) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_DeactivationCallCenter(struct zx_ctx* c, struct zx_ac_DeactivationCallCenter_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_DeactivationCallCenter) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_DeactivationCallCenter_s* zx_DEEP_CLONE_ac_DeactivationCallCenter(struct zx_ctx* c, struct zx_ac_DeactivationCallCenter_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_DeactivationCallCenter_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_DeactivationCallCenter_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_DeactivationCallCenter) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_DeactivationCallCenter(struct zx_ctx* c, struct zx_ac_DeactivationCallCenter_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_DeactivationCallCenter) */

int zx_WALK_WO_ac_DeactivationCallCenter(struct zx_ctx* c, struct zx_ac_DeactivationCallCenter_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_DigSig
#define EL_STRUCT zx_ac_DigSig_s
#define EL_NS     ac
#define EL_TAG    DigSig

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_DigSig) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_DigSig(struct zx_ctx* c, struct zx_ac_DigSig_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_DigSig) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_DigSig_s* zx_DEEP_CLONE_ac_DigSig(struct zx_ctx* c, struct zx_ac_DigSig_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_DigSig_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_DigSig_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_DigSig) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_DigSig(struct zx_ctx* c, struct zx_ac_DigSig_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_DigSig) */

int zx_WALK_WO_ac_DigSig(struct zx_ctx* c, struct zx_ac_DigSig_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_Extension
#define EL_STRUCT zx_ac_Extension_s
#define EL_NS     ac
#define EL_TAG    Extension

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_Extension) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_Extension(struct zx_ctx* c, struct zx_ac_Extension_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_ac_Extension) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_Extension_s* zx_DEEP_CLONE_ac_Extension(struct zx_ctx* c, struct zx_ac_Extension_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_Extension_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_Extension_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_ac_Extension) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_Extension(struct zx_ctx* c, struct zx_ac_Extension_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_Extension) */

int zx_WALK_WO_ac_Extension(struct zx_ctx* c, struct zx_ac_Extension_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_Generation
#define EL_STRUCT zx_ac_Generation_s
#define EL_NS     ac
#define EL_TAG    Generation

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_Generation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_Generation(struct zx_ctx* c, struct zx_ac_Generation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->mechanism);


}

/* FUNC(zx_DEEP_CLONE_ac_Generation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_Generation_s* zx_DEEP_CLONE_ac_Generation(struct zx_ctx* c, struct zx_ac_Generation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_Generation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_Generation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->mechanism = zx_clone_attr(c, x->mechanism);


  return x;
}

/* FUNC(zx_WALK_SO_ac_Generation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_Generation(struct zx_ctx* c, struct zx_ac_Generation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_Generation) */

int zx_WALK_WO_ac_Generation(struct zx_ctx* c, struct zx_ac_Generation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_GoverningAgreementRef
#define EL_STRUCT zx_ac_GoverningAgreementRef_s
#define EL_NS     ac
#define EL_TAG    GoverningAgreementRef

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_GoverningAgreementRef) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_GoverningAgreementRef(struct zx_ctx* c, struct zx_ac_GoverningAgreementRef_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->governingAgreementRef);


}

/* FUNC(zx_DEEP_CLONE_ac_GoverningAgreementRef) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_GoverningAgreementRef_s* zx_DEEP_CLONE_ac_GoverningAgreementRef(struct zx_ctx* c, struct zx_ac_GoverningAgreementRef_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_GoverningAgreementRef_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_GoverningAgreementRef_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->governingAgreementRef = zx_clone_attr(c, x->governingAgreementRef);


  return x;
}

/* FUNC(zx_WALK_SO_ac_GoverningAgreementRef) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_GoverningAgreementRef(struct zx_ctx* c, struct zx_ac_GoverningAgreementRef_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_GoverningAgreementRef) */

int zx_WALK_WO_ac_GoverningAgreementRef(struct zx_ctx* c, struct zx_ac_GoverningAgreementRef_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_GoverningAgreements
#define EL_STRUCT zx_ac_GoverningAgreements_s
#define EL_NS     ac
#define EL_TAG    GoverningAgreements

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_GoverningAgreements) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_GoverningAgreements(struct zx_ctx* c, struct zx_ac_GoverningAgreements_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->GoverningAgreementRef->gg;
       se && se->g.tok == zx_ac_GoverningAgreementRef_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_GoverningAgreementRef(c, (struct zx_ac_GoverningAgreementRef_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_GoverningAgreements) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_GoverningAgreements_s* zx_DEEP_CLONE_ac_GoverningAgreements(struct zx_ctx* c, struct zx_ac_GoverningAgreements_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_GoverningAgreements_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_GoverningAgreements_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->GoverningAgreementRef->gg;
       e && e->g.tok == zx_ac_GoverningAgreementRef_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_GoverningAgreementRef(c,(struct zx_ac_GoverningAgreementRef_s*)e,dup_strs);
  	  if (!enn)
  	      x->GoverningAgreementRef = (struct zx_ac_GoverningAgreementRef_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_GoverningAgreements) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_GoverningAgreements(struct zx_ctx* c, struct zx_ac_GoverningAgreements_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->GoverningAgreementRef->gg;
       e && e->g.tok == zx_ac_GoverningAgreementRef_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_GoverningAgreementRef(c, (struct zx_ac_GoverningAgreementRef_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_GoverningAgreements) */

int zx_WALK_WO_ac_GoverningAgreements(struct zx_ctx* c, struct zx_ac_GoverningAgreements_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_HTTP
#define EL_STRUCT zx_ac_HTTP_s
#define EL_NS     ac
#define EL_TAG    HTTP

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_HTTP) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_HTTP(struct zx_ctx* c, struct zx_ac_HTTP_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_HTTP) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_HTTP_s* zx_DEEP_CLONE_ac_HTTP(struct zx_ctx* c, struct zx_ac_HTTP_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_HTTP_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_HTTP_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_HTTP) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_HTTP(struct zx_ctx* c, struct zx_ac_HTTP_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_HTTP) */

int zx_WALK_WO_ac_HTTP(struct zx_ctx* c, struct zx_ac_HTTP_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_IPAddress
#define EL_STRUCT zx_ac_IPAddress_s
#define EL_NS     ac
#define EL_TAG    IPAddress

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_IPAddress) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_IPAddress(struct zx_ctx* c, struct zx_ac_IPAddress_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_IPAddress) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_IPAddress_s* zx_DEEP_CLONE_ac_IPAddress(struct zx_ctx* c, struct zx_ac_IPAddress_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_IPAddress_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_IPAddress_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_IPAddress) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_IPAddress(struct zx_ctx* c, struct zx_ac_IPAddress_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_IPAddress) */

int zx_WALK_WO_ac_IPAddress(struct zx_ctx* c, struct zx_ac_IPAddress_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_IPSec
#define EL_STRUCT zx_ac_IPSec_s
#define EL_NS     ac
#define EL_TAG    IPSec

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_IPSec) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_IPSec(struct zx_ctx* c, struct zx_ac_IPSec_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_IPSec) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_IPSec_s* zx_DEEP_CLONE_ac_IPSec(struct zx_ctx* c, struct zx_ac_IPSec_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_IPSec_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_IPSec_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_IPSec) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_IPSec(struct zx_ctx* c, struct zx_ac_IPSec_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_IPSec) */

int zx_WALK_WO_ac_IPSec(struct zx_ctx* c, struct zx_ac_IPSec_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_Identification
#define EL_STRUCT zx_ac_Identification_s
#define EL_NS     ac
#define EL_TAG    Identification

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_Identification) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_Identification(struct zx_ctx* c, struct zx_ac_Identification_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->nym);

  for (se = &x->PhysicalVerification->gg;
       se && se->g.tok == zx_ac_PhysicalVerification_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_PhysicalVerification(c, (struct zx_ac_PhysicalVerification_s*)se);
  for (se = &x->WrittenConsent->gg;
       se && se->g.tok == zx_ac_WrittenConsent_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_WrittenConsent(c, (struct zx_ac_WrittenConsent_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_Identification) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_Identification_s* zx_DEEP_CLONE_ac_Identification(struct zx_ctx* c, struct zx_ac_Identification_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_Identification_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_Identification_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->nym = zx_clone_attr(c, x->nym);

  for (enn = 0, e = &x->PhysicalVerification->gg;
       e && e->g.tok == zx_ac_PhysicalVerification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_PhysicalVerification(c,(struct zx_ac_PhysicalVerification_s*)e,dup_strs);
  	  if (!enn)
  	      x->PhysicalVerification = (struct zx_ac_PhysicalVerification_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->WrittenConsent->gg;
       e && e->g.tok == zx_ac_WrittenConsent_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_WrittenConsent(c,(struct zx_ac_WrittenConsent_s*)e,dup_strs);
  	  if (!enn)
  	      x->WrittenConsent = (struct zx_ac_WrittenConsent_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_Identification) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_Identification(struct zx_ctx* c, struct zx_ac_Identification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PhysicalVerification->gg;
       e && e->g.tok == zx_ac_PhysicalVerification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_PhysicalVerification(c, (struct zx_ac_PhysicalVerification_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->WrittenConsent->gg;
       e && e->g.tok == zx_ac_WrittenConsent_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_WrittenConsent(c, (struct zx_ac_WrittenConsent_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_Identification) */

int zx_WALK_WO_ac_Identification(struct zx_ctx* c, struct zx_ac_Identification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_KeyActivation
#define EL_STRUCT zx_ac_KeyActivation_s
#define EL_NS     ac
#define EL_TAG    KeyActivation

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_KeyActivation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_KeyActivation(struct zx_ctx* c, struct zx_ac_KeyActivation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ActivationPin->gg;
       se && se->g.tok == zx_ac_ActivationPin_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_ActivationPin(c, (struct zx_ac_ActivationPin_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_KeyActivation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_KeyActivation_s* zx_DEEP_CLONE_ac_KeyActivation(struct zx_ctx* c, struct zx_ac_KeyActivation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_KeyActivation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_KeyActivation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ActivationPin->gg;
       e && e->g.tok == zx_ac_ActivationPin_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_ActivationPin(c,(struct zx_ac_ActivationPin_s*)e,dup_strs);
  	  if (!enn)
  	      x->ActivationPin = (struct zx_ac_ActivationPin_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_KeyActivation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_KeyActivation(struct zx_ctx* c, struct zx_ac_KeyActivation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ActivationPin->gg;
       e && e->g.tok == zx_ac_ActivationPin_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_ActivationPin(c, (struct zx_ac_ActivationPin_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_KeyActivation) */

int zx_WALK_WO_ac_KeyActivation(struct zx_ctx* c, struct zx_ac_KeyActivation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_KeySharing
#define EL_STRUCT zx_ac_KeySharing_s
#define EL_NS     ac
#define EL_TAG    KeySharing

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_KeySharing) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_KeySharing(struct zx_ctx* c, struct zx_ac_KeySharing_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->sharing);


}

/* FUNC(zx_DEEP_CLONE_ac_KeySharing) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_KeySharing_s* zx_DEEP_CLONE_ac_KeySharing(struct zx_ctx* c, struct zx_ac_KeySharing_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_KeySharing_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_KeySharing_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->sharing = zx_clone_attr(c, x->sharing);


  return x;
}

/* FUNC(zx_WALK_SO_ac_KeySharing) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_KeySharing(struct zx_ctx* c, struct zx_ac_KeySharing_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_KeySharing) */

int zx_WALK_WO_ac_KeySharing(struct zx_ctx* c, struct zx_ac_KeySharing_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_KeyStorage
#define EL_STRUCT zx_ac_KeyStorage_s
#define EL_NS     ac
#define EL_TAG    KeyStorage

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_KeyStorage) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_KeyStorage(struct zx_ctx* c, struct zx_ac_KeyStorage_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->medium);


}

/* FUNC(zx_DEEP_CLONE_ac_KeyStorage) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_KeyStorage_s* zx_DEEP_CLONE_ac_KeyStorage(struct zx_ctx* c, struct zx_ac_KeyStorage_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_KeyStorage_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_KeyStorage_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->medium = zx_clone_attr(c, x->medium);


  return x;
}

/* FUNC(zx_WALK_SO_ac_KeyStorage) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_KeyStorage(struct zx_ctx* c, struct zx_ac_KeyStorage_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_KeyStorage) */

int zx_WALK_WO_ac_KeyStorage(struct zx_ctx* c, struct zx_ac_KeyStorage_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_Length
#define EL_STRUCT zx_ac_Length_s
#define EL_NS     ac
#define EL_TAG    Length

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_Length) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_Length(struct zx_ctx* c, struct zx_ac_Length_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->max);
  zx_dup_attr(c, x->min);


}

/* FUNC(zx_DEEP_CLONE_ac_Length) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_Length_s* zx_DEEP_CLONE_ac_Length(struct zx_ctx* c, struct zx_ac_Length_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_Length_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_Length_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->max = zx_clone_attr(c, x->max);
  x->min = zx_clone_attr(c, x->min);


  return x;
}

/* FUNC(zx_WALK_SO_ac_Length) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_Length(struct zx_ctx* c, struct zx_ac_Length_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_Length) */

int zx_WALK_WO_ac_Length(struct zx_ctx* c, struct zx_ac_Length_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_MobileNetworkEndToEndEncryption
#define EL_STRUCT zx_ac_MobileNetworkEndToEndEncryption_s
#define EL_NS     ac
#define EL_TAG    MobileNetworkEndToEndEncryption

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_MobileNetworkEndToEndEncryption) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_MobileNetworkEndToEndEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkEndToEndEncryption_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_MobileNetworkEndToEndEncryption) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_MobileNetworkEndToEndEncryption_s* zx_DEEP_CLONE_ac_MobileNetworkEndToEndEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkEndToEndEncryption_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_MobileNetworkEndToEndEncryption_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_MobileNetworkEndToEndEncryption_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_MobileNetworkEndToEndEncryption) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_MobileNetworkEndToEndEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkEndToEndEncryption_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_MobileNetworkEndToEndEncryption) */

int zx_WALK_WO_ac_MobileNetworkEndToEndEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkEndToEndEncryption_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_MobileNetworkNoEncryption
#define EL_STRUCT zx_ac_MobileNetworkNoEncryption_s
#define EL_NS     ac
#define EL_TAG    MobileNetworkNoEncryption

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_MobileNetworkNoEncryption) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_MobileNetworkNoEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkNoEncryption_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_MobileNetworkNoEncryption) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_MobileNetworkNoEncryption_s* zx_DEEP_CLONE_ac_MobileNetworkNoEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkNoEncryption_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_MobileNetworkNoEncryption_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_MobileNetworkNoEncryption_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_MobileNetworkNoEncryption) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_MobileNetworkNoEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkNoEncryption_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_MobileNetworkNoEncryption) */

int zx_WALK_WO_ac_MobileNetworkNoEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkNoEncryption_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_MobileNetworkRadioEncryption
#define EL_STRUCT zx_ac_MobileNetworkRadioEncryption_s
#define EL_NS     ac
#define EL_TAG    MobileNetworkRadioEncryption

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_MobileNetworkRadioEncryption) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_MobileNetworkRadioEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkRadioEncryption_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_MobileNetworkRadioEncryption) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_MobileNetworkRadioEncryption_s* zx_DEEP_CLONE_ac_MobileNetworkRadioEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkRadioEncryption_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_MobileNetworkRadioEncryption_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_MobileNetworkRadioEncryption_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_MobileNetworkRadioEncryption) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_MobileNetworkRadioEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkRadioEncryption_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_MobileNetworkRadioEncryption) */

int zx_WALK_WO_ac_MobileNetworkRadioEncryption(struct zx_ctx* c, struct zx_ac_MobileNetworkRadioEncryption_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_OperationalProtection
#define EL_STRUCT zx_ac_OperationalProtection_s
#define EL_NS     ac
#define EL_TAG    OperationalProtection

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_OperationalProtection) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_OperationalProtection(struct zx_ctx* c, struct zx_ac_OperationalProtection_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->SecurityAudit->gg;
       se && se->g.tok == zx_ac_SecurityAudit_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_SecurityAudit(c, (struct zx_ac_SecurityAudit_s*)se);
  for (se = &x->DeactivationCallCenter->gg;
       se && se->g.tok == zx_ac_DeactivationCallCenter_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_DeactivationCallCenter(c, (struct zx_ac_DeactivationCallCenter_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_OperationalProtection) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_OperationalProtection_s* zx_DEEP_CLONE_ac_OperationalProtection(struct zx_ctx* c, struct zx_ac_OperationalProtection_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_OperationalProtection_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_OperationalProtection_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->SecurityAudit->gg;
       e && e->g.tok == zx_ac_SecurityAudit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_SecurityAudit(c,(struct zx_ac_SecurityAudit_s*)e,dup_strs);
  	  if (!enn)
  	      x->SecurityAudit = (struct zx_ac_SecurityAudit_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DeactivationCallCenter->gg;
       e && e->g.tok == zx_ac_DeactivationCallCenter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_DeactivationCallCenter(c,(struct zx_ac_DeactivationCallCenter_s*)e,dup_strs);
  	  if (!enn)
  	      x->DeactivationCallCenter = (struct zx_ac_DeactivationCallCenter_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_OperationalProtection) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_OperationalProtection(struct zx_ctx* c, struct zx_ac_OperationalProtection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->SecurityAudit->gg;
       e && e->g.tok == zx_ac_SecurityAudit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_SecurityAudit(c, (struct zx_ac_SecurityAudit_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DeactivationCallCenter->gg;
       e && e->g.tok == zx_ac_DeactivationCallCenter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_DeactivationCallCenter(c, (struct zx_ac_DeactivationCallCenter_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_OperationalProtection) */

int zx_WALK_WO_ac_OperationalProtection(struct zx_ctx* c, struct zx_ac_OperationalProtection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_Password
#define EL_STRUCT zx_ac_Password_s
#define EL_NS     ac
#define EL_TAG    Password

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_Password) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_Password(struct zx_ctx* c, struct zx_ac_Password_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Length->gg;
       se && se->g.tok == zx_ac_Length_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Length(c, (struct zx_ac_Length_s*)se);
  for (se = &x->Alphabet->gg;
       se && se->g.tok == zx_ac_Alphabet_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Alphabet(c, (struct zx_ac_Alphabet_s*)se);
  for (se = &x->Generation->gg;
       se && se->g.tok == zx_ac_Generation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Generation(c, (struct zx_ac_Generation_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_Password) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_Password_s* zx_DEEP_CLONE_ac_Password(struct zx_ctx* c, struct zx_ac_Password_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_Password_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_Password_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Length->gg;
       e && e->g.tok == zx_ac_Length_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Length(c,(struct zx_ac_Length_s*)e,dup_strs);
  	  if (!enn)
  	      x->Length = (struct zx_ac_Length_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Alphabet->gg;
       e && e->g.tok == zx_ac_Alphabet_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Alphabet(c,(struct zx_ac_Alphabet_s*)e,dup_strs);
  	  if (!enn)
  	      x->Alphabet = (struct zx_ac_Alphabet_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Generation->gg;
       e && e->g.tok == zx_ac_Generation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Generation(c,(struct zx_ac_Generation_s*)e,dup_strs);
  	  if (!enn)
  	      x->Generation = (struct zx_ac_Generation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_Password) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_Password(struct zx_ctx* c, struct zx_ac_Password_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Length->gg;
       e && e->g.tok == zx_ac_Length_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Length(c, (struct zx_ac_Length_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Alphabet->gg;
       e && e->g.tok == zx_ac_Alphabet_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Alphabet(c, (struct zx_ac_Alphabet_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Generation->gg;
       e && e->g.tok == zx_ac_Generation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Generation(c, (struct zx_ac_Generation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_Password) */

int zx_WALK_WO_ac_Password(struct zx_ctx* c, struct zx_ac_Password_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_PhysicalVerification
#define EL_STRUCT zx_ac_PhysicalVerification_s
#define EL_NS     ac
#define EL_TAG    PhysicalVerification

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_PhysicalVerification) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_PhysicalVerification(struct zx_ctx* c, struct zx_ac_PhysicalVerification_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->credentialLevel);


}

/* FUNC(zx_DEEP_CLONE_ac_PhysicalVerification) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_PhysicalVerification_s* zx_DEEP_CLONE_ac_PhysicalVerification(struct zx_ctx* c, struct zx_ac_PhysicalVerification_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_PhysicalVerification_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_PhysicalVerification_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->credentialLevel = zx_clone_attr(c, x->credentialLevel);


  return x;
}

/* FUNC(zx_WALK_SO_ac_PhysicalVerification) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_PhysicalVerification(struct zx_ctx* c, struct zx_ac_PhysicalVerification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_PhysicalVerification) */

int zx_WALK_WO_ac_PhysicalVerification(struct zx_ctx* c, struct zx_ac_PhysicalVerification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_PreviousSession
#define EL_STRUCT zx_ac_PreviousSession_s
#define EL_NS     ac
#define EL_TAG    PreviousSession

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_PreviousSession) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_PreviousSession(struct zx_ctx* c, struct zx_ac_PreviousSession_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_PreviousSession) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_PreviousSession_s* zx_DEEP_CLONE_ac_PreviousSession(struct zx_ctx* c, struct zx_ac_PreviousSession_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_PreviousSession_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_PreviousSession_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_PreviousSession) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_PreviousSession(struct zx_ctx* c, struct zx_ac_PreviousSession_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_PreviousSession) */

int zx_WALK_WO_ac_PreviousSession(struct zx_ctx* c, struct zx_ac_PreviousSession_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_PrincipalAuthenticationMechanism
#define EL_STRUCT zx_ac_PrincipalAuthenticationMechanism_s
#define EL_NS     ac
#define EL_TAG    PrincipalAuthenticationMechanism

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_PrincipalAuthenticationMechanism) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_PrincipalAuthenticationMechanism(struct zx_ctx* c, struct zx_ac_PrincipalAuthenticationMechanism_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Password->gg;
       se && se->g.tok == zx_ac_Password_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Password(c, (struct zx_ac_Password_s*)se);
  for (se = &x->Token->gg;
       se && se->g.tok == zx_ac_Token_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Token(c, (struct zx_ac_Token_s*)se);
  for (se = &x->Smartcard->gg;
       se && se->g.tok == zx_ac_Smartcard_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Smartcard(c, (struct zx_ac_Smartcard_s*)se);
  for (se = &x->ActivationPin->gg;
       se && se->g.tok == zx_ac_ActivationPin_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_ActivationPin(c, (struct zx_ac_ActivationPin_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_PrincipalAuthenticationMechanism) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_PrincipalAuthenticationMechanism_s* zx_DEEP_CLONE_ac_PrincipalAuthenticationMechanism(struct zx_ctx* c, struct zx_ac_PrincipalAuthenticationMechanism_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_PrincipalAuthenticationMechanism_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_PrincipalAuthenticationMechanism_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Password->gg;
       e && e->g.tok == zx_ac_Password_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Password(c,(struct zx_ac_Password_s*)e,dup_strs);
  	  if (!enn)
  	      x->Password = (struct zx_ac_Password_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Token->gg;
       e && e->g.tok == zx_ac_Token_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Token(c,(struct zx_ac_Token_s*)e,dup_strs);
  	  if (!enn)
  	      x->Token = (struct zx_ac_Token_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Smartcard->gg;
       e && e->g.tok == zx_ac_Smartcard_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Smartcard(c,(struct zx_ac_Smartcard_s*)e,dup_strs);
  	  if (!enn)
  	      x->Smartcard = (struct zx_ac_Smartcard_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ActivationPin->gg;
       e && e->g.tok == zx_ac_ActivationPin_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_ActivationPin(c,(struct zx_ac_ActivationPin_s*)e,dup_strs);
  	  if (!enn)
  	      x->ActivationPin = (struct zx_ac_ActivationPin_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_PrincipalAuthenticationMechanism) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_PrincipalAuthenticationMechanism(struct zx_ctx* c, struct zx_ac_PrincipalAuthenticationMechanism_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Password->gg;
       e && e->g.tok == zx_ac_Password_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Password(c, (struct zx_ac_Password_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Token->gg;
       e && e->g.tok == zx_ac_Token_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Token(c, (struct zx_ac_Token_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Smartcard->gg;
       e && e->g.tok == zx_ac_Smartcard_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Smartcard(c, (struct zx_ac_Smartcard_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ActivationPin->gg;
       e && e->g.tok == zx_ac_ActivationPin_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_ActivationPin(c, (struct zx_ac_ActivationPin_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_PrincipalAuthenticationMechanism) */

int zx_WALK_WO_ac_PrincipalAuthenticationMechanism(struct zx_ctx* c, struct zx_ac_PrincipalAuthenticationMechanism_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_PrivateKeyProtection
#define EL_STRUCT zx_ac_PrivateKeyProtection_s
#define EL_NS     ac
#define EL_TAG    PrivateKeyProtection

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_PrivateKeyProtection) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_PrivateKeyProtection(struct zx_ctx* c, struct zx_ac_PrivateKeyProtection_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->KeyActivation->gg;
       se && se->g.tok == zx_ac_KeyActivation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_KeyActivation(c, (struct zx_ac_KeyActivation_s*)se);
  for (se = &x->KeyStorage->gg;
       se && se->g.tok == zx_ac_KeyStorage_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_KeyStorage(c, (struct zx_ac_KeyStorage_s*)se);
  for (se = &x->KeySharing->gg;
       se && se->g.tok == zx_ac_KeySharing_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_KeySharing(c, (struct zx_ac_KeySharing_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_PrivateKeyProtection) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_PrivateKeyProtection_s* zx_DEEP_CLONE_ac_PrivateKeyProtection(struct zx_ctx* c, struct zx_ac_PrivateKeyProtection_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_PrivateKeyProtection_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_PrivateKeyProtection_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->KeyActivation->gg;
       e && e->g.tok == zx_ac_KeyActivation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_KeyActivation(c,(struct zx_ac_KeyActivation_s*)e,dup_strs);
  	  if (!enn)
  	      x->KeyActivation = (struct zx_ac_KeyActivation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->KeyStorage->gg;
       e && e->g.tok == zx_ac_KeyStorage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_KeyStorage(c,(struct zx_ac_KeyStorage_s*)e,dup_strs);
  	  if (!enn)
  	      x->KeyStorage = (struct zx_ac_KeyStorage_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->KeySharing->gg;
       e && e->g.tok == zx_ac_KeySharing_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_KeySharing(c,(struct zx_ac_KeySharing_s*)e,dup_strs);
  	  if (!enn)
  	      x->KeySharing = (struct zx_ac_KeySharing_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_PrivateKeyProtection) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_PrivateKeyProtection(struct zx_ctx* c, struct zx_ac_PrivateKeyProtection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->KeyActivation->gg;
       e && e->g.tok == zx_ac_KeyActivation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_KeyActivation(c, (struct zx_ac_KeyActivation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->KeyStorage->gg;
       e && e->g.tok == zx_ac_KeyStorage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_KeyStorage(c, (struct zx_ac_KeyStorage_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->KeySharing->gg;
       e && e->g.tok == zx_ac_KeySharing_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_KeySharing(c, (struct zx_ac_KeySharing_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_PrivateKeyProtection) */

int zx_WALK_WO_ac_PrivateKeyProtection(struct zx_ctx* c, struct zx_ac_PrivateKeyProtection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_ResumeSession
#define EL_STRUCT zx_ac_ResumeSession_s
#define EL_NS     ac
#define EL_TAG    ResumeSession

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_ResumeSession) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_ResumeSession(struct zx_ctx* c, struct zx_ac_ResumeSession_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_ResumeSession) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_ResumeSession_s* zx_DEEP_CLONE_ac_ResumeSession(struct zx_ctx* c, struct zx_ac_ResumeSession_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_ResumeSession_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_ResumeSession_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_ResumeSession) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_ResumeSession(struct zx_ctx* c, struct zx_ac_ResumeSession_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_ResumeSession) */

int zx_WALK_WO_ac_ResumeSession(struct zx_ctx* c, struct zx_ac_ResumeSession_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_SSL
#define EL_STRUCT zx_ac_SSL_s
#define EL_NS     ac
#define EL_TAG    SSL

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_SSL) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_SSL(struct zx_ctx* c, struct zx_ac_SSL_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_SSL) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_SSL_s* zx_DEEP_CLONE_ac_SSL(struct zx_ctx* c, struct zx_ac_SSL_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_SSL_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_SSL_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_SSL) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_SSL(struct zx_ctx* c, struct zx_ac_SSL_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_SSL) */

int zx_WALK_WO_ac_SSL(struct zx_ctx* c, struct zx_ac_SSL_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_SecretKeyProtection
#define EL_STRUCT zx_ac_SecretKeyProtection_s
#define EL_NS     ac
#define EL_TAG    SecretKeyProtection

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_SecretKeyProtection) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_SecretKeyProtection(struct zx_ctx* c, struct zx_ac_SecretKeyProtection_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->KeyActivation->gg;
       se && se->g.tok == zx_ac_KeyActivation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_KeyActivation(c, (struct zx_ac_KeyActivation_s*)se);
  for (se = &x->KeyStorage->gg;
       se && se->g.tok == zx_ac_KeyStorage_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_KeyStorage(c, (struct zx_ac_KeyStorage_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_SecretKeyProtection) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_SecretKeyProtection_s* zx_DEEP_CLONE_ac_SecretKeyProtection(struct zx_ctx* c, struct zx_ac_SecretKeyProtection_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_SecretKeyProtection_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_SecretKeyProtection_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->KeyActivation->gg;
       e && e->g.tok == zx_ac_KeyActivation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_KeyActivation(c,(struct zx_ac_KeyActivation_s*)e,dup_strs);
  	  if (!enn)
  	      x->KeyActivation = (struct zx_ac_KeyActivation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->KeyStorage->gg;
       e && e->g.tok == zx_ac_KeyStorage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_KeyStorage(c,(struct zx_ac_KeyStorage_s*)e,dup_strs);
  	  if (!enn)
  	      x->KeyStorage = (struct zx_ac_KeyStorage_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_SecretKeyProtection) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_SecretKeyProtection(struct zx_ctx* c, struct zx_ac_SecretKeyProtection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->KeyActivation->gg;
       e && e->g.tok == zx_ac_KeyActivation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_KeyActivation(c, (struct zx_ac_KeyActivation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->KeyStorage->gg;
       e && e->g.tok == zx_ac_KeyStorage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_KeyStorage(c, (struct zx_ac_KeyStorage_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_SecretKeyProtection) */

int zx_WALK_WO_ac_SecretKeyProtection(struct zx_ctx* c, struct zx_ac_SecretKeyProtection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_SecurityAudit
#define EL_STRUCT zx_ac_SecurityAudit_s
#define EL_NS     ac
#define EL_TAG    SecurityAudit

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_SecurityAudit) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_SecurityAudit(struct zx_ctx* c, struct zx_ac_SecurityAudit_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->SwitchAudit->gg;
       se && se->g.tok == zx_ac_SwitchAudit_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_SwitchAudit(c, (struct zx_ac_SwitchAudit_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_SecurityAudit) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_SecurityAudit_s* zx_DEEP_CLONE_ac_SecurityAudit(struct zx_ctx* c, struct zx_ac_SecurityAudit_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_SecurityAudit_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_SecurityAudit_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->SwitchAudit->gg;
       e && e->g.tok == zx_ac_SwitchAudit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_SwitchAudit(c,(struct zx_ac_SwitchAudit_s*)e,dup_strs);
  	  if (!enn)
  	      x->SwitchAudit = (struct zx_ac_SwitchAudit_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_SecurityAudit) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_SecurityAudit(struct zx_ctx* c, struct zx_ac_SecurityAudit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->SwitchAudit->gg;
       e && e->g.tok == zx_ac_SwitchAudit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_SwitchAudit(c, (struct zx_ac_SwitchAudit_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_SecurityAudit) */

int zx_WALK_WO_ac_SecurityAudit(struct zx_ctx* c, struct zx_ac_SecurityAudit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_SharedSecretChallengeResponse
#define EL_STRUCT zx_ac_SharedSecretChallengeResponse_s
#define EL_NS     ac
#define EL_TAG    SharedSecretChallengeResponse

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_SharedSecretChallengeResponse) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_SharedSecretChallengeResponse(struct zx_ctx* c, struct zx_ac_SharedSecretChallengeResponse_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_SharedSecretChallengeResponse) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_SharedSecretChallengeResponse_s* zx_DEEP_CLONE_ac_SharedSecretChallengeResponse(struct zx_ctx* c, struct zx_ac_SharedSecretChallengeResponse_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_SharedSecretChallengeResponse_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_SharedSecretChallengeResponse_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_SharedSecretChallengeResponse) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_SharedSecretChallengeResponse(struct zx_ctx* c, struct zx_ac_SharedSecretChallengeResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_SharedSecretChallengeResponse) */

int zx_WALK_WO_ac_SharedSecretChallengeResponse(struct zx_ctx* c, struct zx_ac_SharedSecretChallengeResponse_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_SharedSecretDynamicPlaintext
#define EL_STRUCT zx_ac_SharedSecretDynamicPlaintext_s
#define EL_NS     ac
#define EL_TAG    SharedSecretDynamicPlaintext

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_SharedSecretDynamicPlaintext) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_SharedSecretDynamicPlaintext(struct zx_ctx* c, struct zx_ac_SharedSecretDynamicPlaintext_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_SharedSecretDynamicPlaintext) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_SharedSecretDynamicPlaintext_s* zx_DEEP_CLONE_ac_SharedSecretDynamicPlaintext(struct zx_ctx* c, struct zx_ac_SharedSecretDynamicPlaintext_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_SharedSecretDynamicPlaintext_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_SharedSecretDynamicPlaintext_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_SharedSecretDynamicPlaintext) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_SharedSecretDynamicPlaintext(struct zx_ctx* c, struct zx_ac_SharedSecretDynamicPlaintext_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_SharedSecretDynamicPlaintext) */

int zx_WALK_WO_ac_SharedSecretDynamicPlaintext(struct zx_ctx* c, struct zx_ac_SharedSecretDynamicPlaintext_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_Smartcard
#define EL_STRUCT zx_ac_Smartcard_s
#define EL_NS     ac
#define EL_TAG    Smartcard

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_Smartcard) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_Smartcard(struct zx_ctx* c, struct zx_ac_Smartcard_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_Smartcard) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_Smartcard_s* zx_DEEP_CLONE_ac_Smartcard(struct zx_ctx* c, struct zx_ac_Smartcard_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_Smartcard_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_Smartcard_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_Smartcard) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_Smartcard(struct zx_ctx* c, struct zx_ac_Smartcard_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_Smartcard) */

int zx_WALK_WO_ac_Smartcard(struct zx_ctx* c, struct zx_ac_Smartcard_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_SwitchAudit
#define EL_STRUCT zx_ac_SwitchAudit_s
#define EL_NS     ac
#define EL_TAG    SwitchAudit

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_SwitchAudit) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_SwitchAudit(struct zx_ctx* c, struct zx_ac_SwitchAudit_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_SwitchAudit) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_SwitchAudit_s* zx_DEEP_CLONE_ac_SwitchAudit(struct zx_ctx* c, struct zx_ac_SwitchAudit_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_SwitchAudit_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_SwitchAudit_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_SwitchAudit) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_SwitchAudit(struct zx_ctx* c, struct zx_ac_SwitchAudit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_SwitchAudit) */

int zx_WALK_WO_ac_SwitchAudit(struct zx_ctx* c, struct zx_ac_SwitchAudit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_TechnicalProtection
#define EL_STRUCT zx_ac_TechnicalProtection_s
#define EL_NS     ac
#define EL_TAG    TechnicalProtection

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_TechnicalProtection) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_TechnicalProtection(struct zx_ctx* c, struct zx_ac_TechnicalProtection_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PrivateKeyProtection->gg;
       se && se->g.tok == zx_ac_PrivateKeyProtection_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_PrivateKeyProtection(c, (struct zx_ac_PrivateKeyProtection_s*)se);
  for (se = &x->SecretKeyProtection->gg;
       se && se->g.tok == zx_ac_SecretKeyProtection_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_SecretKeyProtection(c, (struct zx_ac_SecretKeyProtection_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_TechnicalProtection) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_TechnicalProtection_s* zx_DEEP_CLONE_ac_TechnicalProtection(struct zx_ctx* c, struct zx_ac_TechnicalProtection_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_TechnicalProtection_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_TechnicalProtection_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PrivateKeyProtection->gg;
       e && e->g.tok == zx_ac_PrivateKeyProtection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_PrivateKeyProtection(c,(struct zx_ac_PrivateKeyProtection_s*)e,dup_strs);
  	  if (!enn)
  	      x->PrivateKeyProtection = (struct zx_ac_PrivateKeyProtection_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SecretKeyProtection->gg;
       e && e->g.tok == zx_ac_SecretKeyProtection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_SecretKeyProtection(c,(struct zx_ac_SecretKeyProtection_s*)e,dup_strs);
  	  if (!enn)
  	      x->SecretKeyProtection = (struct zx_ac_SecretKeyProtection_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_TechnicalProtection) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_TechnicalProtection(struct zx_ctx* c, struct zx_ac_TechnicalProtection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PrivateKeyProtection->gg;
       e && e->g.tok == zx_ac_PrivateKeyProtection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_PrivateKeyProtection(c, (struct zx_ac_PrivateKeyProtection_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SecretKeyProtection->gg;
       e && e->g.tok == zx_ac_SecretKeyProtection_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_SecretKeyProtection(c, (struct zx_ac_SecretKeyProtection_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_TechnicalProtection) */

int zx_WALK_WO_ac_TechnicalProtection(struct zx_ctx* c, struct zx_ac_TechnicalProtection_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_TimeSyncToken
#define EL_STRUCT zx_ac_TimeSyncToken_s
#define EL_NS     ac
#define EL_TAG    TimeSyncToken

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_TimeSyncToken) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_TimeSyncToken(struct zx_ctx* c, struct zx_ac_TimeSyncToken_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->DeviceInHand);
  zx_dup_attr(c, x->DeviceType);
  zx_dup_attr(c, x->SeedLength);


}

/* FUNC(zx_DEEP_CLONE_ac_TimeSyncToken) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_TimeSyncToken_s* zx_DEEP_CLONE_ac_TimeSyncToken(struct zx_ctx* c, struct zx_ac_TimeSyncToken_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_TimeSyncToken_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_TimeSyncToken_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->DeviceInHand = zx_clone_attr(c, x->DeviceInHand);
  x->DeviceType = zx_clone_attr(c, x->DeviceType);
  x->SeedLength = zx_clone_attr(c, x->SeedLength);


  return x;
}

/* FUNC(zx_WALK_SO_ac_TimeSyncToken) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_TimeSyncToken(struct zx_ctx* c, struct zx_ac_TimeSyncToken_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_TimeSyncToken) */

int zx_WALK_WO_ac_TimeSyncToken(struct zx_ctx* c, struct zx_ac_TimeSyncToken_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_Token
#define EL_STRUCT zx_ac_Token_s
#define EL_NS     ac
#define EL_TAG    Token

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_Token) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_Token(struct zx_ctx* c, struct zx_ac_Token_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->TimeSyncToken->gg;
       se && se->g.tok == zx_ac_TimeSyncToken_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_TimeSyncToken(c, (struct zx_ac_TimeSyncToken_s*)se);
  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_Token) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_Token_s* zx_DEEP_CLONE_ac_Token(struct zx_ctx* c, struct zx_ac_Token_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_Token_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_Token_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->TimeSyncToken->gg;
       e && e->g.tok == zx_ac_TimeSyncToken_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_TimeSyncToken(c,(struct zx_ac_TimeSyncToken_s*)e,dup_strs);
  	  if (!enn)
  	      x->TimeSyncToken = (struct zx_ac_TimeSyncToken_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_Token) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_Token(struct zx_ctx* c, struct zx_ac_Token_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->TimeSyncToken->gg;
       e && e->g.tok == zx_ac_TimeSyncToken_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_TimeSyncToken(c, (struct zx_ac_TimeSyncToken_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_Token) */

int zx_WALK_WO_ac_Token(struct zx_ctx* c, struct zx_ac_Token_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_WTLS
#define EL_STRUCT zx_ac_WTLS_s
#define EL_NS     ac
#define EL_TAG    WTLS

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_WTLS) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_WTLS(struct zx_ctx* c, struct zx_ac_WTLS_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_WTLS) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_WTLS_s* zx_DEEP_CLONE_ac_WTLS(struct zx_ctx* c, struct zx_ac_WTLS_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_WTLS_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_WTLS_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_WTLS) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_WTLS(struct zx_ctx* c, struct zx_ac_WTLS_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_WTLS) */

int zx_WALK_WO_ac_WTLS(struct zx_ctx* c, struct zx_ac_WTLS_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_WrittenConsent
#define EL_STRUCT zx_ac_WrittenConsent_s
#define EL_NS     ac
#define EL_TAG    WrittenConsent

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_WrittenConsent) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_WrittenConsent(struct zx_ctx* c, struct zx_ac_WrittenConsent_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_WrittenConsent) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_WrittenConsent_s* zx_DEEP_CLONE_ac_WrittenConsent(struct zx_ctx* c, struct zx_ac_WrittenConsent_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_WrittenConsent_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_WrittenConsent_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_WrittenConsent) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_WrittenConsent(struct zx_ctx* c, struct zx_ac_WrittenConsent_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_WrittenConsent) */

int zx_WALK_WO_ac_WrittenConsent(struct zx_ctx* c, struct zx_ac_WrittenConsent_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   ac_ZeroKnowledge
#define EL_STRUCT zx_ac_ZeroKnowledge_s
#define EL_NS     ac
#define EL_TAG    ZeroKnowledge

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_ac_ZeroKnowledge) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_ac_ZeroKnowledge(struct zx_ctx* c, struct zx_ac_ZeroKnowledge_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Extension->gg;
       se && se->g.tok == zx_ac_Extension_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_ac_Extension(c, (struct zx_ac_Extension_s*)se);

}

/* FUNC(zx_DEEP_CLONE_ac_ZeroKnowledge) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_ac_ZeroKnowledge_s* zx_DEEP_CLONE_ac_ZeroKnowledge(struct zx_ctx* c, struct zx_ac_ZeroKnowledge_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_ac_ZeroKnowledge_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_ac_ZeroKnowledge_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_ac_Extension(c,(struct zx_ac_Extension_s*)e,dup_strs);
  	  if (!enn)
  	      x->Extension = (struct zx_ac_Extension_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_ac_ZeroKnowledge) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_ac_ZeroKnowledge(struct zx_ctx* c, struct zx_ac_ZeroKnowledge_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Extension->gg;
       e && e->g.tok == zx_ac_Extension_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_ac_Extension(c, (struct zx_ac_Extension_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_ac_ZeroKnowledge) */

int zx_WALK_WO_ac_ZeroKnowledge(struct zx_ctx* c, struct zx_ac_ZeroKnowledge_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif


/* EOF -- c/zx-ac-aux.c */
