/* c/zx-as.ds - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** ds-templ.c  -  DirectoryScript template, used in code generation
 ** Copyright (c) 2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: ds-templ.c,v 1.1 2007-08-10 17:44:49 sampo Exp $
 **
 ** 6.6.2007, created, Sampo Kellomaki (sampo@iki.fi)
 **
 ** N.B: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/



function parse_as_Extensions(data, x) {


}

function build_as_Extensions(data) {
  attr = [];
  body = [];


  return TAG('as:Extensions', attr, body);
}




function parse_as_Parameter(data, x) {
  POPATTR(x[1], 'name', data.name);


}

function build_as_Parameter(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'name', data.name);


  return TAG('as:Parameter', attr, body);
}




function parse_as_PasswordTransforms(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'Transform', i); ++i) {
    h =  hash [];
    parse_as_Transform(h, tag);
    push data{'Transform'}, h;
  }

}

function build_as_PasswordTransforms(data) {
  attr = [];
  body = [];

  for d(data{'Transform'}) push body,build_as_Transform(d);

  return TAG('as:PasswordTransforms', attr, body);
}




function parse_as_SASLRequest(data, x) {
  POPATTR(x[1], 'advisoryAuthnID', data.advisoryAuthnID);
  POPATTR(x[1], 'authzID', data.authzID);
  POPATTR(x[1], 'mechanism', data.mechanism);

  POPTAG_RAW(x[2],  'Data', data.Data);
  tag = find_xml_local(x[2], 'RequestedAuthnContext', 1);
  h =  hash [];
  parse_sp_RequestedAuthnContext(h, aux1);
  data{'RequestedAuthnContext'} = h;
  tag = find_xml_local(x[2], 'Extensions', 1);
  h =  hash [];
  parse_as_Extensions(h, aux1);
  data{'Extensions'} = h;

}

function build_as_SASLRequest(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'advisoryAuthnID', data.advisoryAuthnID);
  PUSHATTR(attr, 'authzID', data.authzID);
  PUSHATTR(attr, 'mechanism', data.mechanism);

  PUSHTAG_RAW(body, 'Data', data.Data);
  push body, build_sp_RequestedAuthnContext(data{'RequestedAuthnContext'});
  push body, build_as_Extensions(data{'Extensions'});

  return TAG('as:SASLRequest', attr, body);
}




function parse_as_SASLResponse(data, x) {
  POPATTR(x[1], 'serverMechanism', data.serverMechanism);

  tag = find_xml_local(x[2], 'Status', 1);
  h =  hash [];
  parse_lu_Status(h, aux1);
  data{'Status'} = h;
  tag = find_xml_local(x[2], 'PasswordTransforms', 1);
  h =  hash [];
  parse_as_PasswordTransforms(h, aux1);
  data{'PasswordTransforms'} = h;
  POPTAG_RAW(x[2],  'Data', data.Data);
  for (i=1; tag = find_xml_local(x[2], 'EndpointReference', i); ++i) {
    h =  hash [];
    parse_a_EndpointReference(h, tag);
    push data{'EndpointReference'}, h;
  }

}

function build_as_SASLResponse(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'serverMechanism', data.serverMechanism);

  push body, build_lu_Status(data{'Status'});
  push body, build_as_PasswordTransforms(data{'PasswordTransforms'});
  PUSHTAG_RAW(body, 'Data', data.Data);
  for d(data{'EndpointReference'}) push body,build_a_EndpointReference(d);

  return TAG('as:SASLResponse', attr, body);
}




function parse_as_Transform(data, x) {
  POPATTR(x[1], 'name', data.name);

  for (i=1; tag = find_xml_local(x[2], 'Parameter', i); ++i) {
    h =  hash [];
    parse_as_Parameter(h, tag);
    push data{'Parameter'}, h;
  }

}

function build_as_Transform(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'name', data.name);

  for d(data{'Parameter'}) push body,build_as_Parameter(d);

  return TAG('as:Transform', attr, body);
}


/* EOF -- c/zx-as.ds */
