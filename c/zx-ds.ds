/* c/zx-ds.ds - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** ds-templ.c  -  DirectoryScript template, used in code generation
 ** Copyright (c) 2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: ds-templ.c,v 1.1 2007-08-10 17:44:49 sampo Exp $
 **
 ** 6.6.2007, created, Sampo Kellomaki (sampo@iki.fi)
 **
 ** N.B: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/



function parse_ds_CanonicalizationMethod(data, x) {
  POPATTR(x[1], 'Algorithm', data.Algorithm);


}

function build_ds_CanonicalizationMethod(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Algorithm', data.Algorithm);


  return TAG('ds:CanonicalizationMethod', attr, body);
}




function parse_ds_DSAKeyValue(data, x) {

  POPTAG_RAW(x[2],  'P', data.P);
  POPTAG_RAW(x[2],  'Q', data.Q);
  POPTAG_RAW(x[2],  'G', data.G);
  POPTAG_RAW(x[2],  'Y', data.Y);
  POPTAG_RAW(x[2],  'J', data.J);
  POPTAG_RAW(x[2],  'Seed', data.Seed);
  POPTAG_RAW(x[2],  'PgenCounter', data.PgenCounter);

}

function build_ds_DSAKeyValue(data) {
  attr = [];
  body = [];

  PUSHTAG_RAW(body, 'P', data.P);
  PUSHTAG_RAW(body, 'Q', data.Q);
  PUSHTAG_RAW(body, 'G', data.G);
  PUSHTAG_RAW(body, 'Y', data.Y);
  PUSHTAG_RAW(body, 'J', data.J);
  PUSHTAG_RAW(body, 'Seed', data.Seed);
  PUSHTAG_RAW(body, 'PgenCounter', data.PgenCounter);

  return TAG('ds:DSAKeyValue', attr, body);
}




function parse_ds_DigestMethod(data, x) {
  POPATTR(x[1], 'Algorithm', data.Algorithm);


}

function build_ds_DigestMethod(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Algorithm', data.Algorithm);


  return TAG('ds:DigestMethod', attr, body);
}




function parse_ds_KeyInfo(data, x) {
  POPATTR(x[1], 'Id', data.Id);

  for (i=1; tag = find_xml_local(x[2], 'KeyName', i); ++i)
    push data{'KeyName'}, tag[2];
  for (i=1; tag = find_xml_local(x[2], 'KeyValue', i); ++i) {
    h =  hash [];
    parse_ds_KeyValue(h, tag);
    push data{'KeyValue'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'RetrievalMethod', i); ++i) {
    h =  hash [];
    parse_ds_RetrievalMethod(h, tag);
    push data{'RetrievalMethod'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'X509Data', i); ++i) {
    h =  hash [];
    parse_ds_X509Data(h, tag);
    push data{'X509Data'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'PGPData', i); ++i) {
    h =  hash [];
    parse_ds_PGPData(h, tag);
    push data{'PGPData'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'SPKIData', i); ++i) {
    h =  hash [];
    parse_ds_SPKIData(h, tag);
    push data{'SPKIData'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'MgmtData', i); ++i)
    push data{'MgmtData'}, tag[2];
  for (i=1; tag = find_xml_local(x[2], 'EncryptedKey', i); ++i) {
    h =  hash [];
    parse_xenc_EncryptedKey(h, tag);
    push data{'EncryptedKey'}, h;
  }

}

function build_ds_KeyInfo(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Id', data.Id);

  for d(data{'KeyName'})PUSHTAG_RAW(body,'KeyName',d);
  for d(data{'KeyValue'}) push body,build_ds_KeyValue(d);
  for d(data{'RetrievalMethod'}) push body,build_ds_RetrievalMethod(d);
  for d(data{'X509Data'}) push body,build_ds_X509Data(d);
  for d(data{'PGPData'}) push body,build_ds_PGPData(d);
  for d(data{'SPKIData'}) push body,build_ds_SPKIData(d);
  for d(data{'MgmtData'})PUSHTAG_RAW(body,'MgmtData',d);
  for d(data{'EncryptedKey'}) push body,build_xenc_EncryptedKey(d);

  return TAG('ds:KeyInfo', attr, body);
}




function parse_ds_KeyValue(data, x) {

  tag = find_xml_local(x[2], 'DSAKeyValue', 1);
  h =  hash [];
  parse_ds_DSAKeyValue(h, aux1);
  data{'DSAKeyValue'} = h;
  tag = find_xml_local(x[2], 'RSAKeyValue', 1);
  h =  hash [];
  parse_ds_RSAKeyValue(h, aux1);
  data{'RSAKeyValue'} = h;

}

function build_ds_KeyValue(data) {
  attr = [];
  body = [];

  push body, build_ds_DSAKeyValue(data{'DSAKeyValue'});
  push body, build_ds_RSAKeyValue(data{'RSAKeyValue'});

  return TAG('ds:KeyValue', attr, body);
}




function parse_ds_Manifest(data, x) {
  POPATTR(x[1], 'Id', data.Id);

  for (i=1; tag = find_xml_local(x[2], 'Reference', i); ++i) {
    h =  hash [];
    parse_ds_Reference(h, tag);
    push data{'Reference'}, h;
  }

}

function build_ds_Manifest(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Id', data.Id);

  for d(data{'Reference'}) push body,build_ds_Reference(d);

  return TAG('ds:Manifest', attr, body);
}




function parse_ds_Object(data, x) {
  POPATTR(x[1], 'Encoding', data.Encoding);
  POPATTR(x[1], 'Id', data.Id);
  POPATTR(x[1], 'MimeType', data.MimeType);


}

function build_ds_Object(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Encoding', data.Encoding);
  PUSHATTR(attr, 'Id', data.Id);
  PUSHATTR(attr, 'MimeType', data.MimeType);


  return TAG('ds:Object', attr, body);
}




function parse_ds_PGPData(data, x) {

  POPTAG_RAW(x[2],  'PGPKeyID', data.PGPKeyID);
  POPTAG_RAW(x[2],  'PGPKeyPacket', data.PGPKeyPacket);

}

function build_ds_PGPData(data) {
  attr = [];
  body = [];

  PUSHTAG_RAW(body, 'PGPKeyID', data.PGPKeyID);
  PUSHTAG_RAW(body, 'PGPKeyPacket', data.PGPKeyPacket);

  return TAG('ds:PGPData', attr, body);
}




function parse_ds_RSAKeyValue(data, x) {

  POPTAG_RAW(x[2],  'Modulus', data.Modulus);
  POPTAG_RAW(x[2],  'Exponent', data.Exponent);

}

function build_ds_RSAKeyValue(data) {
  attr = [];
  body = [];

  PUSHTAG_RAW(body, 'Modulus', data.Modulus);
  PUSHTAG_RAW(body, 'Exponent', data.Exponent);

  return TAG('ds:RSAKeyValue', attr, body);
}




function parse_ds_Reference(data, x) {
  POPATTR(x[1], 'Id', data.Id);
  POPATTR(x[1], 'Type', data.Type);
  POPATTR(x[1], 'URI', data.URI);

  tag = find_xml_local(x[2], 'Transforms', 1);
  h =  hash [];
  parse_ds_Transforms(h, aux1);
  data{'Transforms'} = h;
  tag = find_xml_local(x[2], 'DigestMethod', 1);
  h =  hash [];
  parse_ds_DigestMethod(h, aux1);
  data{'DigestMethod'} = h;
  POPTAG_RAW(x[2],  'DigestValue', data.DigestValue);

}

function build_ds_Reference(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Id', data.Id);
  PUSHATTR(attr, 'Type', data.Type);
  PUSHATTR(attr, 'URI', data.URI);

  push body, build_ds_Transforms(data{'Transforms'});
  push body, build_ds_DigestMethod(data{'DigestMethod'});
  PUSHTAG_RAW(body, 'DigestValue', data.DigestValue);

  return TAG('ds:Reference', attr, body);
}




function parse_ds_RetrievalMethod(data, x) {
  POPATTR(x[1], 'Type', data.Type);
  POPATTR(x[1], 'URI', data.URI);

  tag = find_xml_local(x[2], 'Transforms', 1);
  h =  hash [];
  parse_ds_Transforms(h, aux1);
  data{'Transforms'} = h;

}

function build_ds_RetrievalMethod(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Type', data.Type);
  PUSHATTR(attr, 'URI', data.URI);

  push body, build_ds_Transforms(data{'Transforms'});

  return TAG('ds:RetrievalMethod', attr, body);
}




function parse_ds_SPKIData(data, x) {

  POPTAG_RAW(x[2],  'SPKISexp', data.SPKISexp);

}

function build_ds_SPKIData(data) {
  attr = [];
  body = [];

  PUSHTAG_RAW(body, 'SPKISexp', data.SPKISexp);

  return TAG('ds:SPKIData', attr, body);
}




function parse_ds_Signature(data, x) {
  POPATTR(x[1], 'Id', data.Id);

  tag = find_xml_local(x[2], 'SignedInfo', 1);
  h =  hash [];
  parse_ds_SignedInfo(h, aux1);
  data{'SignedInfo'} = h;
  tag = find_xml_local(x[2], 'SignatureValue', 1);
  h =  hash [];
  parse_ds_SignatureValue(h, aux1);
  data{'SignatureValue'} = h;
  tag = find_xml_local(x[2], 'KeyInfo', 1);
  h =  hash [];
  parse_ds_KeyInfo(h, aux1);
  data{'KeyInfo'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Object', i); ++i) {
    h =  hash [];
    parse_ds_Object(h, tag);
    push data{'Object'}, h;
  }

}

function build_ds_Signature(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Id', data.Id);

  push body, build_ds_SignedInfo(data{'SignedInfo'});
  push body, build_ds_SignatureValue(data{'SignatureValue'});
  push body, build_ds_KeyInfo(data{'KeyInfo'});
  for d(data{'Object'}) push body,build_ds_Object(d);

  return TAG('ds:Signature', attr, body);
}




function parse_ds_SignatureMethod(data, x) {
  POPATTR(x[1], 'Algorithm', data.Algorithm);

  POPTAG_RAW(x[2],  'HMACOutputLength', data.HMACOutputLength);

}

function build_ds_SignatureMethod(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Algorithm', data.Algorithm);

  PUSHTAG_RAW(body, 'HMACOutputLength', data.HMACOutputLength);

  return TAG('ds:SignatureMethod', attr, body);
}




function parse_ds_SignatureProperties(data, x) {
  POPATTR(x[1], 'Id', data.Id);

  for (i=1; tag = find_xml_local(x[2], 'SignatureProperty', i); ++i) {
    h =  hash [];
    parse_ds_SignatureProperty(h, tag);
    push data{'SignatureProperty'}, h;
  }

}

function build_ds_SignatureProperties(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Id', data.Id);

  for d(data{'SignatureProperty'}) push body,build_ds_SignatureProperty(d);

  return TAG('ds:SignatureProperties', attr, body);
}




function parse_ds_SignatureProperty(data, x) {
  POPATTR(x[1], 'Id', data.Id);
  POPATTR(x[1], 'Target', data.Target);


}

function build_ds_SignatureProperty(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Id', data.Id);
  PUSHATTR(attr, 'Target', data.Target);


  return TAG('ds:SignatureProperty', attr, body);
}




function parse_ds_SignatureValue(data, x) {
  POPATTR(x[1], 'Id', data.Id);


}

function build_ds_SignatureValue(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Id', data.Id);


  return TAG('ds:SignatureValue', attr, body);
}




function parse_ds_SignedInfo(data, x) {
  POPATTR(x[1], 'Id', data.Id);

  tag = find_xml_local(x[2], 'CanonicalizationMethod', 1);
  h =  hash [];
  parse_ds_CanonicalizationMethod(h, aux1);
  data{'CanonicalizationMethod'} = h;
  tag = find_xml_local(x[2], 'SignatureMethod', 1);
  h =  hash [];
  parse_ds_SignatureMethod(h, aux1);
  data{'SignatureMethod'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Reference', i); ++i) {
    h =  hash [];
    parse_ds_Reference(h, tag);
    push data{'Reference'}, h;
  }

}

function build_ds_SignedInfo(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Id', data.Id);

  push body, build_ds_CanonicalizationMethod(data{'CanonicalizationMethod'});
  push body, build_ds_SignatureMethod(data{'SignatureMethod'});
  for d(data{'Reference'}) push body,build_ds_Reference(d);

  return TAG('ds:SignedInfo', attr, body);
}




function parse_ds_Transform(data, x) {
  POPATTR(x[1], 'Algorithm', data.Algorithm);

  for (i=1; tag = find_xml_local(x[2], 'XPath', i); ++i)
    push data{'XPath'}, tag[2];
  tag = find_xml_local(x[2], 'InclusiveNamespaces', 1);
  h =  hash [];
  parse_exca_InclusiveNamespaces(h, aux1);
  data{'InclusiveNamespaces'} = h;

}

function build_ds_Transform(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Algorithm', data.Algorithm);

  for d(data{'XPath'})PUSHTAG_RAW(body,'XPath',d);
  push body, build_exca_InclusiveNamespaces(data{'InclusiveNamespaces'});

  return TAG('ds:Transform', attr, body);
}




function parse_ds_Transforms(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'Transform', i); ++i) {
    h =  hash [];
    parse_ds_Transform(h, tag);
    push data{'Transform'}, h;
  }

}

function build_ds_Transforms(data) {
  attr = [];
  body = [];

  for d(data{'Transform'}) push body,build_ds_Transform(d);

  return TAG('ds:Transforms', attr, body);
}




function parse_ds_X509Data(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'X509IssuerSerial', i); ++i) {
    h =  hash [];
    parse_ds_X509IssuerSerial(h, tag);
    push data{'X509IssuerSerial'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'X509SKI', i); ++i)
    push data{'X509SKI'}, tag[2];
  for (i=1; tag = find_xml_local(x[2], 'X509SubjectName', i); ++i)
    push data{'X509SubjectName'}, tag[2];
  for (i=1; tag = find_xml_local(x[2], 'X509Certificate', i); ++i)
    push data{'X509Certificate'}, tag[2];
  for (i=1; tag = find_xml_local(x[2], 'X509CRL', i); ++i)
    push data{'X509CRL'}, tag[2];

}

function build_ds_X509Data(data) {
  attr = [];
  body = [];

  for d(data{'X509IssuerSerial'}) push body,build_ds_X509IssuerSerial(d);
  for d(data{'X509SKI'})PUSHTAG_RAW(body,'X509SKI',d);
  for d(data{'X509SubjectName'})PUSHTAG_RAW(body,'X509SubjectName',d);
  for d(data{'X509Certificate'})PUSHTAG_RAW(body,'X509Certificate',d);
  for d(data{'X509CRL'})PUSHTAG_RAW(body,'X509CRL',d);

  return TAG('ds:X509Data', attr, body);
}




function parse_ds_X509IssuerSerial(data, x) {

  POPTAG_RAW(x[2],  'X509IssuerName', data.X509IssuerName);
  POPTAG_RAW(x[2],  'X509SerialNumber', data.X509SerialNumber);

}

function build_ds_X509IssuerSerial(data) {
  attr = [];
  body = [];

  PUSHTAG_RAW(body, 'X509IssuerName', data.X509IssuerName);
  PUSHTAG_RAW(body, 'X509SerialNumber', data.X509SerialNumber);

  return TAG('ds:X509IssuerSerial', attr, body);
}


/* EOF -- c/zx-ds.ds */
