/* c/zx-hrxml-enc.c - WARNING: This file was automatically generated. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** enc-templ.c  -  XML encoder template, used in code generation
 ** Copyright (c) 2010 Sampo Kellomaki (sampo@iki.fi), All Rights Reserved.
 ** Copyright (c) 2006-2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: enc-templ.c,v 1.27 2007-10-05 22:24:28 sampo Exp $
 **
 ** 30.5.2006, created, Sampo Kellomaki (sampo@iki.fi)
 ** 6.8.2006,  factored data structure walking to aux-templ.c --Sampo
 ** 8.8.2006,  reworked namespace handling --Sampo
 ** 26.8.2006, some CSE --Sampo
 ** 23.9.2006, added WO logic --Sampo
 ** 30.9.2007, improvements to WO encoding --Sampo
 ** 8.2.2010,  better handling of schema order encoding of unknown namespace prefixes --Sampo
 **
 ** N.B: wo=wire order (needed for exc-c14n), so=schema order
 ** N.B2: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/

#include <memory.h>
#include "errmac.h"
#include "zx.h"
#include "c/zx-const.h"
#include "c/zx-data.h"
#include "c/zx-hrxml-data.h"
#include "c/zx-ns.h"



#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AccountingCode
#define EL_STRUCT zx_hrxml_AccountingCode_s
#define EL_NS     hrxml
#define EL_TAG    AccountingCode

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AccountingCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AccountingCode")-1 + 1 + sizeof("</hrxml:AccountingCode>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AccountingCode", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_AccountingCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("AccountingCode")-1 + 1 + 2 + sizeof("AccountingCode")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->description, sizeof("description")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AccountingCode", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AccountingCode) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AccountingCode");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AccountingCode>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AccountingCode", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_AccountingCode) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "AccountingCode", sizeof("AccountingCode")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->description, "description=\"", sizeof("description=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AccountingCode", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AccountingCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AccountingCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AccountingCode(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_AccountingCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_AccountingCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_AccountingCode(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Achievement
#define EL_STRUCT zx_hrxml_Achievement_s
#define EL_NS     hrxml
#define EL_TAG    Achievement

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Achievement) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Achievement")-1 + 1 + sizeof("</hrxml:Achievement>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Date; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Date")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IssuingAuthority(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Achievement", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Achievement) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Achievement")-1 + 1 + 2 + sizeof("Achievement")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Date; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Date")-1);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IssuingAuthority(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Achievement", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Achievement) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Achievement");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Date; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Date", sizeof("hrxml:Date")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IssuingAuthority(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Achievement>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Achievement", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Achievement) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Achievement", sizeof("Achievement")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Achievement", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Achievement) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Achievement(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Achievement(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Achievement) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Achievement(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Achievement(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Achievements
#define EL_STRUCT zx_hrxml_Achievements_s
#define EL_NS     hrxml
#define EL_TAG    Achievements

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Achievements) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Achievements")-1 + 1 + sizeof("</hrxml:Achievements>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Achievement_s* e;
      for (e = x->Achievement; e; e = (struct zx_hrxml_Achievement_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Achievement(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Achievements", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Achievements) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Achievements")-1 + 1 + 2 + sizeof("Achievements")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Achievement_s* e;
      for (e = x->Achievement; e; e = (struct zx_hrxml_Achievement_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Achievement(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Achievements", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Achievements) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Achievements");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Achievement_s* e;
      for (e = x->Achievement; e; e = (struct zx_hrxml_Achievement_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Achievement(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Achievements>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Achievements", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Achievements) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Achievements", sizeof("Achievements")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Achievements", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Achievements) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Achievements(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Achievements(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Achievements) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Achievements(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Achievements(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AffirmativeActionPlanJobGroupId
#define EL_STRUCT zx_hrxml_AffirmativeActionPlanJobGroupId_s
#define EL_NS     hrxml
#define EL_TAG    AffirmativeActionPlanJobGroupId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AffirmativeActionPlanJobGroupId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AffirmativeActionPlanJobGroupId")-1 + 1 + sizeof("</hrxml:AffirmativeActionPlanJobGroupId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AffirmativeActionPlanJobGroupId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_AffirmativeActionPlanJobGroupId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("AffirmativeActionPlanJobGroupId")-1 + 1 + 2 + sizeof("AffirmativeActionPlanJobGroupId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AffirmativeActionPlanJobGroupId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AffirmativeActionPlanJobGroupId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AffirmativeActionPlanJobGroupId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AffirmativeActionPlanJobGroupId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AffirmativeActionPlanJobGroupId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_AffirmativeActionPlanJobGroupId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "AffirmativeActionPlanJobGroupId", sizeof("AffirmativeActionPlanJobGroupId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AffirmativeActionPlanJobGroupId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AffirmativeActionPlanJobGroupId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AffirmativeActionPlanJobGroupId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AffirmativeActionPlanJobGroupId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_AffirmativeActionPlanJobGroupId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_AffirmativeActionPlanJobGroupId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_AffirmativeActionPlanJobGroupId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Affix
#define EL_STRUCT zx_hrxml_Affix_s
#define EL_NS     hrxml
#define EL_TAG    Affix

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Affix) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Affix")-1 + 1 + sizeof("</hrxml:Affix>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Affix", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Affix) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Affix")-1 + 1 + 2 + sizeof("Affix")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Affix", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Affix) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Affix");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Affix>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Affix", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Affix) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Affix", sizeof("Affix")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Affix", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Affix) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Affix(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Affix(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Affix) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Affix(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Affix(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AlternateScript
#define EL_STRUCT zx_hrxml_AlternateScript_s
#define EL_NS     hrxml
#define EL_TAG    AlternateScript

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AlternateScript) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AlternateScript")-1 + 1 + sizeof("</hrxml:AlternateScript>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->script, sizeof("script")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_FamilyName_s* e;
      for (e = x->FamilyName; e; e = (struct zx_hrxml_FamilyName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_FamilyName(c, e);
  }
  {
      struct zx_hrxml_Affix_s* e;
      for (e = x->Affix; e; e = (struct zx_hrxml_Affix_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Affix(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AlternateScript", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_AlternateScript) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("AlternateScript")-1 + 1 + 2 + sizeof("AlternateScript")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->script, sizeof("script")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("FormattedName")-1);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("LegalName")-1);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("GivenName")-1);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PreferredGivenName")-1);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MiddleName")-1);
  {
      struct zx_hrxml_FamilyName_s* e;
      for (e = x->FamilyName; e; e = (struct zx_hrxml_FamilyName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_FamilyName(c, e);
  }
  {
      struct zx_hrxml_Affix_s* e;
      for (e = x->Affix; e; e = (struct zx_hrxml_Affix_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Affix(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AlternateScript", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AlternateScript) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AlternateScript");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->script, " script=\"", sizeof(" script=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedName", sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:LegalName", sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:GivenName", sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PreferredGivenName", sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MiddleName", sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_FamilyName_s* e;
      for (e = x->FamilyName; e; e = (struct zx_hrxml_FamilyName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_FamilyName(c, e, p);
  }
  {
      struct zx_hrxml_Affix_s* e;
      for (e = x->Affix; e; e = (struct zx_hrxml_Affix_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Affix(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AlternateScript>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AlternateScript", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_AlternateScript) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "AlternateScript", sizeof("AlternateScript")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->script, "script=\"", sizeof("script=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AlternateScript", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AlternateScript) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AlternateScript(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AlternateScript(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_AlternateScript) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_AlternateScript(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_AlternateScript(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Area
#define EL_STRUCT zx_hrxml_Area_s
#define EL_NS     hrxml
#define EL_TAG    Area

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Area) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Area")-1 + 1 + sizeof("</hrxml:Area>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Value")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Area_s* e;
      for (e = x->Area; e; e = (struct zx_hrxml_Area_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Area(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Area", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Area) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Area")-1 + 1 + 2 + sizeof("Area")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Value")-1);
  {
      struct zx_hrxml_Area_s* e;
      for (e = x->Area; e; e = (struct zx_hrxml_Area_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Area(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Area", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Area) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Area");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Value", sizeof("hrxml:Value")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Area_s* e;
      for (e = x->Area; e; e = (struct zx_hrxml_Area_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Area(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Area>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Area", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Area) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Area", sizeof("Area")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Area", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Area) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Area(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Area(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Area) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Area(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Area(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Article
#define EL_STRUCT zx_hrxml_Article_s
#define EL_NS     hrxml
#define EL_TAG    Article

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Article) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Article")-1 + 1 + sizeof("</hrxml:Article>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PublicationDate(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Copyright(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->JournalOrSerialName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:JournalOrSerialName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Volume; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Volume")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Issue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Issue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PageNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PageNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PublicationLanguage_s* e;
      for (e = x->PublicationLanguage; e; e = (struct zx_hrxml_PublicationLanguage_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PublicationLanguage(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Article", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Article) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Article")-1 + 1 + 2 + sizeof("Article")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Title")-1);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PublicationDate(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Link")-1);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Abstract")-1);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Copyright(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  for (se = x->JournalOrSerialName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("JournalOrSerialName")-1);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ISSN")-1);
  for (se = x->Volume; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Volume")-1);
  for (se = x->Issue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Issue")-1);
  for (se = x->PageNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PageNumber")-1);
  {
      struct zx_hrxml_PublicationLanguage_s* e;
      for (e = x->PublicationLanguage; e; e = (struct zx_hrxml_PublicationLanguage_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PublicationLanguage(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Article", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Article) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Article");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PublicationDate(c, e, p);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Abstract", sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Copyright(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->JournalOrSerialName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:JournalOrSerialName", sizeof("hrxml:JournalOrSerialName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISSN", sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Volume; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Volume", sizeof("hrxml:Volume")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Issue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Issue", sizeof("hrxml:Issue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PageNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PageNumber", sizeof("hrxml:PageNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PublicationLanguage_s* e;
      for (e = x->PublicationLanguage; e; e = (struct zx_hrxml_PublicationLanguage_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PublicationLanguage(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Article>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Article", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Article) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Article", sizeof("Article")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Article", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Article) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Article(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Article(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Article) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Article(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Article(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Association
#define EL_STRUCT zx_hrxml_Association_s
#define EL_NS     hrxml
#define EL_TAG    Association

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Association) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Association")-1 + 1 + sizeof("</hrxml:Association>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EndDate(c, e);
  }
  for (se = x->Role; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Role")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Association", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Association) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Association")-1 + 1 + 2 + sizeof("Association")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Link")-1);
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EndDate(c, e);
  }
  for (se = x->Role; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Role")-1);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Association", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Association) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Association");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StartDate(c, e, p);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EndDate(c, e, p);
  }
  for (se = x->Role; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Role", sizeof("hrxml:Role")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Association>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Association", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Association) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Association", sizeof("Association")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Association", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Association) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Association(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Association(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Association) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Association(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Association(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Associations
#define EL_STRUCT zx_hrxml_Associations_s
#define EL_NS     hrxml
#define EL_TAG    Associations

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Associations) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Associations")-1 + 1 + sizeof("</hrxml:Associations>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Association_s* e;
      for (e = x->Association; e; e = (struct zx_hrxml_Association_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Association(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Associations", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Associations) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Associations")-1 + 1 + 2 + sizeof("Associations")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Association_s* e;
      for (e = x->Association; e; e = (struct zx_hrxml_Association_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Association(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Associations", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Associations) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Associations");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Association_s* e;
      for (e = x->Association; e; e = (struct zx_hrxml_Association_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Association(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Associations>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Associations", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Associations) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Associations", sizeof("Associations")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Associations", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Associations) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Associations(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Associations(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Associations) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Associations(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Associations(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AttachmentReference
#define EL_STRUCT zx_hrxml_AttachmentReference_s
#define EL_NS     hrxml
#define EL_TAG    AttachmentReference

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AttachmentReference) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AttachmentReference")-1 + 1 + sizeof("</hrxml:AttachmentReference>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->context, sizeof("context")-1, &pop_seen);
  len += zx_attr_so_len(c, x->mimeType, sizeof("mimeType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AttachmentReference", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_AttachmentReference) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("AttachmentReference")-1 + 1 + 2 + sizeof("AttachmentReference")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->context, sizeof("context")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->mimeType, sizeof("mimeType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AttachmentReference", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AttachmentReference) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AttachmentReference");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->context, " context=\"", sizeof(" context=\"")-1);
  p = zx_attr_so_enc(p, x->mimeType, " mimeType=\"", sizeof(" mimeType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AttachmentReference>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AttachmentReference", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_AttachmentReference) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "AttachmentReference", sizeof("AttachmentReference")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->context, "context=\"", sizeof("context=\"")-1);
  p = zx_attr_wo_enc(p, x->mimeType, "mimeType=\"", sizeof("mimeType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AttachmentReference", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AttachmentReference) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AttachmentReference(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AttachmentReference(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_AttachmentReference) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_AttachmentReference(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_AttachmentReference(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AvailabilityDates
#define EL_STRUCT zx_hrxml_AvailabilityDates_s
#define EL_NS     hrxml
#define EL_TAG    AvailabilityDates

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AvailabilityDates) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AvailabilityDates")-1 + 1 + sizeof("</hrxml:AvailabilityDates>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EndDate(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityDates", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_AvailabilityDates) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("AvailabilityDates")-1 + 1 + 2 + sizeof("AvailabilityDates")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EndDate(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityDates", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AvailabilityDates) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AvailabilityDates");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StartDate(c, e, p);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EndDate(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AvailabilityDates>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityDates", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_AvailabilityDates) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "AvailabilityDates", sizeof("AvailabilityDates")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityDates", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AvailabilityDates) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AvailabilityDates(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AvailabilityDates(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_AvailabilityDates) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_AvailabilityDates(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_AvailabilityDates(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AvailabilityInfo
#define EL_STRUCT zx_hrxml_AvailabilityInfo_s
#define EL_NS     hrxml
#define EL_TAG    AvailabilityInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AvailabilityInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AvailabilityInfo")-1 + 1 + sizeof("</hrxml:AvailabilityInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_AvailabilityDates_s* e;
      for (e = x->AvailabilityDates; e; e = (struct zx_hrxml_AvailabilityDates_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_AvailabilityDates(c, e);
  }
  {
      struct zx_hrxml_TermOfNotice_s* e;
      for (e = x->TermOfNotice; e; e = (struct zx_hrxml_TermOfNotice_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_TermOfNotice(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityInfo", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_AvailabilityInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("AvailabilityInfo")-1 + 1 + 2 + sizeof("AvailabilityInfo")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_AvailabilityDates_s* e;
      for (e = x->AvailabilityDates; e; e = (struct zx_hrxml_AvailabilityDates_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_AvailabilityDates(c, e);
  }
  {
      struct zx_hrxml_TermOfNotice_s* e;
      for (e = x->TermOfNotice; e; e = (struct zx_hrxml_TermOfNotice_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_TermOfNotice(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AvailabilityInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AvailabilityInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_AvailabilityDates_s* e;
      for (e = x->AvailabilityDates; e; e = (struct zx_hrxml_AvailabilityDates_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_AvailabilityDates(c, e, p);
  }
  {
      struct zx_hrxml_TermOfNotice_s* e;
      for (e = x->TermOfNotice; e; e = (struct zx_hrxml_TermOfNotice_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_TermOfNotice(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AvailabilityInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityInfo", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_AvailabilityInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "AvailabilityInfo", sizeof("AvailabilityInfo")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AvailabilityInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AvailabilityInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AvailabilityInfo(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_AvailabilityInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_AvailabilityInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_AvailabilityInfo(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BKZClassification
#define EL_STRUCT zx_hrxml_BKZClassification_s
#define EL_NS     hrxml
#define EL_TAG    BKZClassification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_BKZClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:BKZClassification")-1 + 1 + sizeof("</hrxml:BKZClassification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_BKZId_s* e;
      for (e = x->BKZId; e; e = (struct zx_hrxml_BKZId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_BKZId(c, e);
  }
  for (se = x->BKZName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:BKZName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BKZClassification", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_BKZClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("BKZClassification")-1 + 1 + 2 + sizeof("BKZClassification")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_BKZId_s* e;
      for (e = x->BKZId; e; e = (struct zx_hrxml_BKZId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_BKZId(c, e);
  }
  for (se = x->BKZName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("BKZName")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BKZClassification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_BKZClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:BKZClassification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_BKZId_s* e;
      for (e = x->BKZId; e; e = (struct zx_hrxml_BKZId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_BKZId(c, e, p);
  }
  for (se = x->BKZName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:BKZName", sizeof("hrxml:BKZName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:BKZClassification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BKZClassification", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_BKZClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "BKZClassification", sizeof("BKZClassification")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BKZClassification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_BKZClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_BKZClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_BKZClassification(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_BKZClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_BKZClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_BKZClassification(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BKZId
#define EL_STRUCT zx_hrxml_BKZId_s
#define EL_NS     hrxml
#define EL_TAG    BKZId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_BKZId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:BKZId")-1 + 1 + sizeof("</hrxml:BKZId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BKZId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_BKZId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("BKZId")-1 + 1 + 2 + sizeof("BKZId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BKZId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_BKZId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:BKZId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:BKZId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BKZId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_BKZId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "BKZId", sizeof("BKZId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BKZId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_BKZId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_BKZId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_BKZId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_BKZId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_BKZId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_BKZId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BasePay
#define EL_STRUCT zx_hrxml_BasePay_s
#define EL_NS     hrxml
#define EL_TAG    BasePay

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_BasePay) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:BasePay")-1 + 1 + sizeof("</hrxml:BasePay>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->baseInterval, sizeof("baseInterval")-1, &pop_seen);
  len += zx_attr_so_len(c, x->currencyCode, sizeof("currencyCode")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->BasePayAmountMin; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:BasePayAmountMin")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->BasePayAmountMax; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:BasePayAmountMax")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BasePay", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_BasePay) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("BasePay")-1 + 1 + 2 + sizeof("BasePay")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->baseInterval, sizeof("baseInterval")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->currencyCode, sizeof("currencyCode")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->BasePayAmountMin; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("BasePayAmountMin")-1);
  for (se = x->BasePayAmountMax; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("BasePayAmountMax")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BasePay", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_BasePay) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:BasePay");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->baseInterval, " baseInterval=\"", sizeof(" baseInterval=\"")-1);
  p = zx_attr_so_enc(p, x->currencyCode, " currencyCode=\"", sizeof(" currencyCode=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->BasePayAmountMin; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:BasePayAmountMin", sizeof("hrxml:BasePayAmountMin")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->BasePayAmountMax; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:BasePayAmountMax", sizeof("hrxml:BasePayAmountMax")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:BasePay>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BasePay", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_BasePay) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "BasePay", sizeof("BasePay")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->baseInterval, "baseInterval=\"", sizeof("baseInterval=\"")-1);
  p = zx_attr_wo_enc(p, x->currencyCode, "currencyCode=\"", sizeof("currencyCode=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BasePay", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_BasePay) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_BasePay(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_BasePay(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_BasePay) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_BasePay(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_BasePay(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Benefits
#define EL_STRUCT zx_hrxml_Benefits_s
#define EL_NS     hrxml
#define EL_TAG    Benefits

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Benefits) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Benefits")-1 + 1 + sizeof("</hrxml:Benefits>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Insurance_s* e;
      for (e = x->Insurance; e; e = (struct zx_hrxml_Insurance_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Insurance(c, e);
  }
  for (se = x->RetirementOrSavingsPlan; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:RetirementOrSavingsPlan")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_CompanyVehicle_s* e;
      for (e = x->CompanyVehicle; e; e = (struct zx_hrxml_CompanyVehicle_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_CompanyVehicle(c, e);
  }
  {
      struct zx_hrxml_RelocationAssistance_s* e;
      for (e = x->RelocationAssistance; e; e = (struct zx_hrxml_RelocationAssistance_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RelocationAssistance(c, e);
  }
  for (se = x->VisaSponsorship; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:VisaSponsorship")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_TimeOffAllowance_s* e;
      for (e = x->TimeOffAllowance; e; e = (struct zx_hrxml_TimeOffAllowance_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_TimeOffAllowance(c, e);
  }
  {
      struct zx_hrxml_ExpatriateBenefits_s* e;
      for (e = x->ExpatriateBenefits; e; e = (struct zx_hrxml_ExpatriateBenefits_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ExpatriateBenefits(c, e);
  }
  {
      struct zx_hrxml_OtherBenefits_s* e;
      for (e = x->OtherBenefits; e; e = (struct zx_hrxml_OtherBenefits_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OtherBenefits(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Benefits", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Benefits) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Benefits")-1 + 1 + 2 + sizeof("Benefits")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Insurance_s* e;
      for (e = x->Insurance; e; e = (struct zx_hrxml_Insurance_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Insurance(c, e);
  }
  for (se = x->RetirementOrSavingsPlan; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("RetirementOrSavingsPlan")-1);
  {
      struct zx_hrxml_CompanyVehicle_s* e;
      for (e = x->CompanyVehicle; e; e = (struct zx_hrxml_CompanyVehicle_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_CompanyVehicle(c, e);
  }
  {
      struct zx_hrxml_RelocationAssistance_s* e;
      for (e = x->RelocationAssistance; e; e = (struct zx_hrxml_RelocationAssistance_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RelocationAssistance(c, e);
  }
  for (se = x->VisaSponsorship; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("VisaSponsorship")-1);
  {
      struct zx_hrxml_TimeOffAllowance_s* e;
      for (e = x->TimeOffAllowance; e; e = (struct zx_hrxml_TimeOffAllowance_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_TimeOffAllowance(c, e);
  }
  {
      struct zx_hrxml_ExpatriateBenefits_s* e;
      for (e = x->ExpatriateBenefits; e; e = (struct zx_hrxml_ExpatriateBenefits_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ExpatriateBenefits(c, e);
  }
  {
      struct zx_hrxml_OtherBenefits_s* e;
      for (e = x->OtherBenefits; e; e = (struct zx_hrxml_OtherBenefits_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OtherBenefits(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Benefits", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Benefits) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Benefits");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Insurance_s* e;
      for (e = x->Insurance; e; e = (struct zx_hrxml_Insurance_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Insurance(c, e, p);
  }
  for (se = x->RetirementOrSavingsPlan; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:RetirementOrSavingsPlan", sizeof("hrxml:RetirementOrSavingsPlan")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_CompanyVehicle_s* e;
      for (e = x->CompanyVehicle; e; e = (struct zx_hrxml_CompanyVehicle_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_CompanyVehicle(c, e, p);
  }
  {
      struct zx_hrxml_RelocationAssistance_s* e;
      for (e = x->RelocationAssistance; e; e = (struct zx_hrxml_RelocationAssistance_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RelocationAssistance(c, e, p);
  }
  for (se = x->VisaSponsorship; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:VisaSponsorship", sizeof("hrxml:VisaSponsorship")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_TimeOffAllowance_s* e;
      for (e = x->TimeOffAllowance; e; e = (struct zx_hrxml_TimeOffAllowance_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_TimeOffAllowance(c, e, p);
  }
  {
      struct zx_hrxml_ExpatriateBenefits_s* e;
      for (e = x->ExpatriateBenefits; e; e = (struct zx_hrxml_ExpatriateBenefits_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ExpatriateBenefits(c, e, p);
  }
  {
      struct zx_hrxml_OtherBenefits_s* e;
      for (e = x->OtherBenefits; e; e = (struct zx_hrxml_OtherBenefits_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OtherBenefits(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Benefits>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Benefits", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Benefits) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Benefits", sizeof("Benefits")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Benefits", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Benefits) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Benefits(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Benefits(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Benefits) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Benefits(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Benefits(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BiologicalDescriptors
#define EL_STRUCT zx_hrxml_BiologicalDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    BiologicalDescriptors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_BiologicalDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:BiologicalDescriptors")-1 + 1 + sizeof("</hrxml:BiologicalDescriptors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->DateOfBirth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DateOfBirth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDayOfBirth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDayOfBirth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Age; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Age")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->GenderCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:GenderCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->EyeColor; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EyeColor")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->HairColor; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:HairColor")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Height_s* e;
      for (e = x->Height; e; e = (struct zx_hrxml_Height_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Height(c, e);
  }
  {
      struct zx_hrxml_Weight_s* e;
      for (e = x->Weight; e; e = (struct zx_hrxml_Weight_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Weight(c, e);
  }
  for (se = x->IdentifyingMarks; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:IdentifyingMarks")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DisabilityInfo_s* e;
      for (e = x->DisabilityInfo; e; e = (struct zx_hrxml_DisabilityInfo_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DisabilityInfo(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BiologicalDescriptors", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_BiologicalDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("BiologicalDescriptors")-1 + 1 + 2 + sizeof("BiologicalDescriptors")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->DateOfBirth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("DateOfBirth")-1);
  for (se = x->MonthDayOfBirth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDayOfBirth")-1);
  for (se = x->Age; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Age")-1);
  for (se = x->GenderCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("GenderCode")-1);
  for (se = x->EyeColor; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("EyeColor")-1);
  for (se = x->HairColor; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("HairColor")-1);
  {
      struct zx_hrxml_Height_s* e;
      for (e = x->Height; e; e = (struct zx_hrxml_Height_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Height(c, e);
  }
  {
      struct zx_hrxml_Weight_s* e;
      for (e = x->Weight; e; e = (struct zx_hrxml_Weight_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Weight(c, e);
  }
  for (se = x->IdentifyingMarks; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("IdentifyingMarks")-1);
  {
      struct zx_hrxml_DisabilityInfo_s* e;
      for (e = x->DisabilityInfo; e; e = (struct zx_hrxml_DisabilityInfo_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DisabilityInfo(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BiologicalDescriptors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_BiologicalDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:BiologicalDescriptors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->DateOfBirth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DateOfBirth", sizeof("hrxml:DateOfBirth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDayOfBirth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDayOfBirth", sizeof("hrxml:MonthDayOfBirth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Age; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Age", sizeof("hrxml:Age")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->GenderCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:GenderCode", sizeof("hrxml:GenderCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->EyeColor; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EyeColor", sizeof("hrxml:EyeColor")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->HairColor; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:HairColor", sizeof("hrxml:HairColor")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Height_s* e;
      for (e = x->Height; e; e = (struct zx_hrxml_Height_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Height(c, e, p);
  }
  {
      struct zx_hrxml_Weight_s* e;
      for (e = x->Weight; e; e = (struct zx_hrxml_Weight_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Weight(c, e, p);
  }
  for (se = x->IdentifyingMarks; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:IdentifyingMarks", sizeof("hrxml:IdentifyingMarks")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DisabilityInfo_s* e;
      for (e = x->DisabilityInfo; e; e = (struct zx_hrxml_DisabilityInfo_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DisabilityInfo(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:BiologicalDescriptors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BiologicalDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_BiologicalDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "BiologicalDescriptors", sizeof("BiologicalDescriptors")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BiologicalDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_BiologicalDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_BiologicalDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_BiologicalDescriptors(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_BiologicalDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_BiologicalDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_BiologicalDescriptors(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Book
#define EL_STRUCT zx_hrxml_Book_s
#define EL_NS     hrxml
#define EL_TAG    Book

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Book) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Book")-1 + 1 + sizeof("</hrxml:Book>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PublicationDate(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Copyright(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Edition; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Edition")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Chapter; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Chapter")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISBN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISBN")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->NumberOfPages; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:NumberOfPages")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PublisherName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PublisherName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PublisherLocation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PublisherLocation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Book", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Book) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Book")-1 + 1 + 2 + sizeof("Book")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Title")-1);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PublicationDate(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Link")-1);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Abstract")-1);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Copyright(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  for (se = x->Edition; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Edition")-1);
  for (se = x->Chapter; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Chapter")-1);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ISSN")-1);
  for (se = x->ISBN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ISBN")-1);
  for (se = x->NumberOfPages; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("NumberOfPages")-1);
  for (se = x->PublisherName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PublisherName")-1);
  for (se = x->PublisherLocation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PublisherLocation")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Book", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Book) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Book");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PublicationDate(c, e, p);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Abstract", sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Copyright(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Edition; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Edition", sizeof("hrxml:Edition")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Chapter; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Chapter", sizeof("hrxml:Chapter")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISSN", sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISBN; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISBN", sizeof("hrxml:ISBN")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->NumberOfPages; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:NumberOfPages", sizeof("hrxml:NumberOfPages")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PublisherName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PublisherName", sizeof("hrxml:PublisherName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PublisherLocation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PublisherLocation", sizeof("hrxml:PublisherLocation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Book>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Book", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Book) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Book", sizeof("Book")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Book", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Book) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Book(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Book(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Book) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Book(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Book(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Candidate
#define EL_STRUCT zx_hrxml_Candidate_s
#define EL_NS     hrxml
#define EL_TAG    Candidate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Candidate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Candidate")-1 + 1 + sizeof("</hrxml:Candidate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_CandidateRecordInfo_s* e;
      for (e = x->CandidateRecordInfo; e; e = (struct zx_hrxml_CandidateRecordInfo_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_CandidateRecordInfo(c, e);
  }
  {
      struct zx_hrxml_RelatedPositionPostings_s* e;
      for (e = x->RelatedPositionPostings; e; e = (struct zx_hrxml_RelatedPositionPostings_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RelatedPositionPostings(c, e);
  }
  {
      struct zx_hrxml_CandidateSupplier_s* e;
      for (e = x->CandidateSupplier; e; e = (struct zx_hrxml_CandidateSupplier_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_CandidateSupplier(c, e);
  }
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_CandidateProfile_s* e;
      for (e = x->CandidateProfile; e; e = (struct zx_hrxml_CandidateProfile_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_CandidateProfile(c, e);
  }
  {
      struct zx_hrxml_Resume_s* e;
      for (e = x->Resume; e; e = (struct zx_hrxml_Resume_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Resume(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Candidate", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Candidate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Candidate")-1 + 1 + 2 + sizeof("Candidate")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->lang, sizeof("lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_CandidateRecordInfo_s* e;
      for (e = x->CandidateRecordInfo; e; e = (struct zx_hrxml_CandidateRecordInfo_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_CandidateRecordInfo(c, e);
  }
  {
      struct zx_hrxml_RelatedPositionPostings_s* e;
      for (e = x->RelatedPositionPostings; e; e = (struct zx_hrxml_RelatedPositionPostings_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RelatedPositionPostings(c, e);
  }
  {
      struct zx_hrxml_CandidateSupplier_s* e;
      for (e = x->CandidateSupplier; e; e = (struct zx_hrxml_CandidateSupplier_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_CandidateSupplier(c, e);
  }
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("DistributionGuidelines")-1);
  {
      struct zx_hrxml_CandidateProfile_s* e;
      for (e = x->CandidateProfile; e; e = (struct zx_hrxml_CandidateProfile_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_CandidateProfile(c, e);
  }
  {
      struct zx_hrxml_Resume_s* e;
      for (e = x->Resume; e; e = (struct zx_hrxml_Resume_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Resume(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Candidate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Candidate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Candidate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_CandidateRecordInfo_s* e;
      for (e = x->CandidateRecordInfo; e; e = (struct zx_hrxml_CandidateRecordInfo_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_CandidateRecordInfo(c, e, p);
  }
  {
      struct zx_hrxml_RelatedPositionPostings_s* e;
      for (e = x->RelatedPositionPostings; e; e = (struct zx_hrxml_RelatedPositionPostings_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RelatedPositionPostings(c, e, p);
  }
  {
      struct zx_hrxml_CandidateSupplier_s* e;
      for (e = x->CandidateSupplier; e; e = (struct zx_hrxml_CandidateSupplier_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_CandidateSupplier(c, e, p);
  }
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DistributionGuidelines", sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_CandidateProfile_s* e;
      for (e = x->CandidateProfile; e; e = (struct zx_hrxml_CandidateProfile_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_CandidateProfile(c, e, p);
  }
  {
      struct zx_hrxml_Resume_s* e;
      for (e = x->Resume; e; e = (struct zx_hrxml_Resume_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Resume(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Candidate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Candidate", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Candidate) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Candidate", sizeof("Candidate")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->lang, "lang=\"", sizeof("lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Candidate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Candidate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Candidate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Candidate(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Candidate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Candidate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Candidate(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CandidateProfile
#define EL_STRUCT zx_hrxml_CandidateProfile_s
#define EL_NS     hrxml
#define EL_TAG    CandidateProfile

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CandidateProfile) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CandidateProfile")-1 + 1 + sizeof("</hrxml:CandidateProfile>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ProfileId_s* e;
      for (e = x->ProfileId; e; e = (struct zx_hrxml_ProfileId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ProfileId(c, e);
  }
  for (se = x->ProfileName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ProfileName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_AvailabilityInfo_s* e;
      for (e = x->AvailabilityInfo; e; e = (struct zx_hrxml_AvailabilityInfo_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_AvailabilityInfo(c, e);
  }
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PersonalData_s* e;
      for (e = x->PersonalData; e; e = (struct zx_hrxml_PersonalData_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonalData(c, e);
  }
  {
      struct zx_hrxml_PreferredPosition_s* e;
      for (e = x->PreferredPosition; e; e = (struct zx_hrxml_PreferredPosition_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PreferredPosition(c, e);
  }
  {
      struct zx_hrxml_EmploymentHistory_s* e;
      for (e = x->EmploymentHistory; e; e = (struct zx_hrxml_EmploymentHistory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EmploymentHistory(c, e);
  }
  {
      struct zx_hrxml_EducationHistory_s* e;
      for (e = x->EducationHistory; e; e = (struct zx_hrxml_EducationHistory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EducationHistory(c, e);
  }
  {
      struct zx_hrxml_MilitaryHistory_s* e;
      for (e = x->MilitaryHistory; e; e = (struct zx_hrxml_MilitaryHistory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_MilitaryHistory(c, e);
  }
  {
      struct zx_hrxml_Associations_s* e;
      for (e = x->Associations; e; e = (struct zx_hrxml_Associations_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Associations(c, e);
  }
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SupportingMaterials(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CandidateProfile", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_CandidateProfile) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("CandidateProfile")-1 + 1 + 2 + sizeof("CandidateProfile")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->lang, sizeof("lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ProfileId_s* e;
      for (e = x->ProfileId; e; e = (struct zx_hrxml_ProfileId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ProfileId(c, e);
  }
  for (se = x->ProfileName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ProfileName")-1);
  {
      struct zx_hrxml_AvailabilityInfo_s* e;
      for (e = x->AvailabilityInfo; e; e = (struct zx_hrxml_AvailabilityInfo_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_AvailabilityInfo(c, e);
  }
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("DistributionGuidelines")-1);
  {
      struct zx_hrxml_PersonalData_s* e;
      for (e = x->PersonalData; e; e = (struct zx_hrxml_PersonalData_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonalData(c, e);
  }
  {
      struct zx_hrxml_PreferredPosition_s* e;
      for (e = x->PreferredPosition; e; e = (struct zx_hrxml_PreferredPosition_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PreferredPosition(c, e);
  }
  {
      struct zx_hrxml_EmploymentHistory_s* e;
      for (e = x->EmploymentHistory; e; e = (struct zx_hrxml_EmploymentHistory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EmploymentHistory(c, e);
  }
  {
      struct zx_hrxml_EducationHistory_s* e;
      for (e = x->EducationHistory; e; e = (struct zx_hrxml_EducationHistory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EducationHistory(c, e);
  }
  {
      struct zx_hrxml_MilitaryHistory_s* e;
      for (e = x->MilitaryHistory; e; e = (struct zx_hrxml_MilitaryHistory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_MilitaryHistory(c, e);
  }
  {
      struct zx_hrxml_Associations_s* e;
      for (e = x->Associations; e; e = (struct zx_hrxml_Associations_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Associations(c, e);
  }
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SupportingMaterials(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CandidateProfile", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CandidateProfile) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CandidateProfile");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_ProfileId_s* e;
      for (e = x->ProfileId; e; e = (struct zx_hrxml_ProfileId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ProfileId(c, e, p);
  }
  for (se = x->ProfileName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ProfileName", sizeof("hrxml:ProfileName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_AvailabilityInfo_s* e;
      for (e = x->AvailabilityInfo; e; e = (struct zx_hrxml_AvailabilityInfo_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_AvailabilityInfo(c, e, p);
  }
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DistributionGuidelines", sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PersonalData_s* e;
      for (e = x->PersonalData; e; e = (struct zx_hrxml_PersonalData_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonalData(c, e, p);
  }
  {
      struct zx_hrxml_PreferredPosition_s* e;
      for (e = x->PreferredPosition; e; e = (struct zx_hrxml_PreferredPosition_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PreferredPosition(c, e, p);
  }
  {
      struct zx_hrxml_EmploymentHistory_s* e;
      for (e = x->EmploymentHistory; e; e = (struct zx_hrxml_EmploymentHistory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EmploymentHistory(c, e, p);
  }
  {
      struct zx_hrxml_EducationHistory_s* e;
      for (e = x->EducationHistory; e; e = (struct zx_hrxml_EducationHistory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EducationHistory(c, e, p);
  }
  {
      struct zx_hrxml_MilitaryHistory_s* e;
      for (e = x->MilitaryHistory; e; e = (struct zx_hrxml_MilitaryHistory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_MilitaryHistory(c, e, p);
  }
  {
      struct zx_hrxml_Associations_s* e;
      for (e = x->Associations; e; e = (struct zx_hrxml_Associations_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Associations(c, e, p);
  }
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SupportingMaterials(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CandidateProfile>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CandidateProfile", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_CandidateProfile) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "CandidateProfile", sizeof("CandidateProfile")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->lang, "lang=\"", sizeof("lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CandidateProfile", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CandidateProfile) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CandidateProfile(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CandidateProfile(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_CandidateProfile) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_CandidateProfile(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_CandidateProfile(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CandidateRecordInfo
#define EL_STRUCT zx_hrxml_CandidateRecordInfo_s
#define EL_NS     hrxml
#define EL_TAG    CandidateRecordInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CandidateRecordInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CandidateRecordInfo")-1 + 1 + sizeof("</hrxml:CandidateRecordInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_Status_s* e;
      for (e = x->Status; e; e = (struct zx_hrxml_Status_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Status(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CandidateRecordInfo", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_CandidateRecordInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("CandidateRecordInfo")-1 + 1 + 2 + sizeof("CandidateRecordInfo")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_Status_s* e;
      for (e = x->Status; e; e = (struct zx_hrxml_Status_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Status(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CandidateRecordInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CandidateRecordInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CandidateRecordInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  {
      struct zx_hrxml_Status_s* e;
      for (e = x->Status; e; e = (struct zx_hrxml_Status_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Status(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CandidateRecordInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CandidateRecordInfo", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_CandidateRecordInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "CandidateRecordInfo", sizeof("CandidateRecordInfo")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CandidateRecordInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CandidateRecordInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CandidateRecordInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CandidateRecordInfo(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_CandidateRecordInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_CandidateRecordInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_CandidateRecordInfo(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CandidateSupplier
#define EL_STRUCT zx_hrxml_CandidateSupplier_s
#define EL_NS     hrxml
#define EL_TAG    CandidateSupplier

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CandidateSupplier) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CandidateSupplier")-1 + 1 + sizeof("</hrxml:CandidateSupplier>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->relationship, sizeof("relationship")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SupplierId_s* e;
      for (e = x->SupplierId; e; e = (struct zx_hrxml_SupplierId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SupplierId(c, e);
  }
  for (se = x->EntityName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EntityName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ContactName_s* e;
      for (e = x->ContactName; e; e = (struct zx_hrxml_ContactName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactName(c, e);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactMethod(c, e);
  }
  {
      struct zx_hrxml_SourceType_s* e;
      for (e = x->SourceType; e; e = (struct zx_hrxml_SourceType_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SourceType(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CandidateSupplier", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_CandidateSupplier) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("CandidateSupplier")-1 + 1 + 2 + sizeof("CandidateSupplier")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->relationship, sizeof("relationship")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SupplierId_s* e;
      for (e = x->SupplierId; e; e = (struct zx_hrxml_SupplierId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SupplierId(c, e);
  }
  for (se = x->EntityName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("EntityName")-1);
  {
      struct zx_hrxml_ContactName_s* e;
      for (e = x->ContactName; e; e = (struct zx_hrxml_ContactName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactName(c, e);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactMethod(c, e);
  }
  {
      struct zx_hrxml_SourceType_s* e;
      for (e = x->SourceType; e; e = (struct zx_hrxml_SourceType_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SourceType(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CandidateSupplier", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CandidateSupplier) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CandidateSupplier");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->relationship, " relationship=\"", sizeof(" relationship=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_SupplierId_s* e;
      for (e = x->SupplierId; e; e = (struct zx_hrxml_SupplierId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SupplierId(c, e, p);
  }
  for (se = x->EntityName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EntityName", sizeof("hrxml:EntityName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ContactName_s* e;
      for (e = x->ContactName; e; e = (struct zx_hrxml_ContactName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactName(c, e, p);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactMethod(c, e, p);
  }
  {
      struct zx_hrxml_SourceType_s* e;
      for (e = x->SourceType; e; e = (struct zx_hrxml_SourceType_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SourceType(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CandidateSupplier>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CandidateSupplier", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_CandidateSupplier) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "CandidateSupplier", sizeof("CandidateSupplier")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->relationship, "relationship=\"", sizeof("relationship=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CandidateSupplier", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CandidateSupplier) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CandidateSupplier(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CandidateSupplier(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_CandidateSupplier) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_CandidateSupplier(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_CandidateSupplier(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ChildrenInfo
#define EL_STRUCT zx_hrxml_ChildrenInfo_s
#define EL_NS     hrxml
#define EL_TAG    ChildrenInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ChildrenInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ChildrenInfo")-1 + 1 + sizeof("</hrxml:ChildrenInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->NumberOfChildren; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:NumberOfChildren")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ChildrenInfo", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ChildrenInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ChildrenInfo")-1 + 1 + 2 + sizeof("ChildrenInfo")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->NumberOfChildren; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("NumberOfChildren")-1);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ChildrenInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ChildrenInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ChildrenInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->NumberOfChildren; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:NumberOfChildren", sizeof("hrxml:NumberOfChildren")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ChildrenInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ChildrenInfo", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ChildrenInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ChildrenInfo", sizeof("ChildrenInfo")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ChildrenInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ChildrenInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ChildrenInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ChildrenInfo(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ChildrenInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ChildrenInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ChildrenInfo(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ClassRank
#define EL_STRUCT zx_hrxml_ClassRank_s
#define EL_NS     hrxml
#define EL_TAG    ClassRank

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ClassRank) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ClassRank")-1 + 1 + sizeof("</hrxml:ClassRank>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->numberOfStudents, sizeof("numberOfStudents")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ClassRank", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ClassRank) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ClassRank")-1 + 1 + 2 + sizeof("ClassRank")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->numberOfStudents, sizeof("numberOfStudents")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ClassRank", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ClassRank) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ClassRank");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->numberOfStudents, " numberOfStudents=\"", sizeof(" numberOfStudents=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ClassRank>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ClassRank", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ClassRank) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ClassRank", sizeof("ClassRank")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->numberOfStudents, "numberOfStudents=\"", sizeof("numberOfStudents=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ClassRank", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ClassRank) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ClassRank(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ClassRank(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ClassRank) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ClassRank(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ClassRank(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Commute
#define EL_STRUCT zx_hrxml_Commute_s
#define EL_NS     hrxml
#define EL_TAG    Commute

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Commute) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Commute")-1 + 1 + sizeof("</hrxml:Commute>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_TimeMax_s* e;
      for (e = x->TimeMax; e; e = (struct zx_hrxml_TimeMax_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_TimeMax(c, e);
  }
  {
      struct zx_hrxml_DistanceMax_s* e;
      for (e = x->DistanceMax; e; e = (struct zx_hrxml_DistanceMax_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DistanceMax(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Commute", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Commute) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Commute")-1 + 1 + 2 + sizeof("Commute")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_TimeMax_s* e;
      for (e = x->TimeMax; e; e = (struct zx_hrxml_TimeMax_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_TimeMax(c, e);
  }
  {
      struct zx_hrxml_DistanceMax_s* e;
      for (e = x->DistanceMax; e; e = (struct zx_hrxml_DistanceMax_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DistanceMax(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Commute", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Commute) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Commute");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_TimeMax_s* e;
      for (e = x->TimeMax; e; e = (struct zx_hrxml_TimeMax_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_TimeMax(c, e, p);
  }
  {
      struct zx_hrxml_DistanceMax_s* e;
      for (e = x->DistanceMax; e; e = (struct zx_hrxml_DistanceMax_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DistanceMax(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Commute>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Commute", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Commute) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Commute", sizeof("Commute")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Commute", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Commute) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Commute(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Commute(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Commute) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Commute(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Commute(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Company
#define EL_STRUCT zx_hrxml_Company_s
#define EL_NS     hrxml
#define EL_TAG    Company

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Company) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Company")-1 + 1 + sizeof("</hrxml:Company>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Company", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Company) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Company")-1 + 1 + 2 + sizeof("Company")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Company", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Company) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Company");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Company>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Company", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Company) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Company", sizeof("Company")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Company", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Company) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Company(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Company(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Company) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Company(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Company(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompanyVehicle
#define EL_STRUCT zx_hrxml_CompanyVehicle_s
#define EL_NS     hrxml
#define EL_TAG    CompanyVehicle

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CompanyVehicle) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CompanyVehicle")-1 + 1 + sizeof("</hrxml:CompanyVehicle>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->companyOffered, sizeof("companyOffered")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompanyVehicle", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_CompanyVehicle) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("CompanyVehicle")-1 + 1 + 2 + sizeof("CompanyVehicle")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->companyOffered, sizeof("companyOffered")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompanyVehicle", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CompanyVehicle) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CompanyVehicle");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->companyOffered, " companyOffered=\"", sizeof(" companyOffered=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CompanyVehicle>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompanyVehicle", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_CompanyVehicle) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "CompanyVehicle", sizeof("CompanyVehicle")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->companyOffered, "companyOffered=\"", sizeof("companyOffered=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompanyVehicle", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CompanyVehicle) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CompanyVehicle(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CompanyVehicle(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_CompanyVehicle) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_CompanyVehicle(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_CompanyVehicle(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Compensation
#define EL_STRUCT zx_hrxml_Compensation_s
#define EL_NS     hrxml
#define EL_TAG    Compensation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Compensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Compensation")-1 + 1 + sizeof("</hrxml:Compensation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_StartingCompensation_s* e;
      for (e = x->StartingCompensation; e; e = (struct zx_hrxml_StartingCompensation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StartingCompensation(c, e);
  }
  {
      struct zx_hrxml_EndingCompensation_s* e;
      for (e = x->EndingCompensation; e; e = (struct zx_hrxml_EndingCompensation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EndingCompensation(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OtherCompensation_s* e;
      for (e = x->OtherCompensation; e; e = (struct zx_hrxml_OtherCompensation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OtherCompensation(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Compensation", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Compensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Compensation")-1 + 1 + 2 + sizeof("Compensation")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_StartingCompensation_s* e;
      for (e = x->StartingCompensation; e; e = (struct zx_hrxml_StartingCompensation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StartingCompensation(c, e);
  }
  {
      struct zx_hrxml_EndingCompensation_s* e;
      for (e = x->EndingCompensation; e; e = (struct zx_hrxml_EndingCompensation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EndingCompensation(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  {
      struct zx_hrxml_OtherCompensation_s* e;
      for (e = x->OtherCompensation; e; e = (struct zx_hrxml_OtherCompensation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OtherCompensation(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Compensation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Compensation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Compensation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_StartingCompensation_s* e;
      for (e = x->StartingCompensation; e; e = (struct zx_hrxml_StartingCompensation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StartingCompensation(c, e, p);
  }
  {
      struct zx_hrxml_EndingCompensation_s* e;
      for (e = x->EndingCompensation; e; e = (struct zx_hrxml_EndingCompensation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EndingCompensation(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OtherCompensation_s* e;
      for (e = x->OtherCompensation; e; e = (struct zx_hrxml_OtherCompensation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OtherCompensation(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Compensation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Compensation", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Compensation) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Compensation", sizeof("Compensation")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Compensation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Compensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Compensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Compensation(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Compensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Compensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Compensation(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Competency
#define EL_STRUCT zx_hrxml_Competency_s
#define EL_NS     hrxml
#define EL_TAG    Competency

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Competency) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Competency")-1 + 1 + sizeof("</hrxml:Competency>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->name, sizeof("name")-1, &pop_seen);
  len += zx_attr_so_len(c, x->required, sizeof("required")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_CompetencyId_s* e;
      for (e = x->CompetencyId; e; e = (struct zx_hrxml_CompetencyId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_CompetencyId(c, e);
  }
  {
      struct zx_hrxml_TaxonomyId_s* e;
      for (e = x->TaxonomyId; e; e = (struct zx_hrxml_TaxonomyId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_TaxonomyId(c, e);
  }
  {
      struct zx_hrxml_CompetencyEvidence_s* e;
      for (e = x->CompetencyEvidence; e; e = (struct zx_hrxml_CompetencyEvidence_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_CompetencyEvidence(c, e);
  }
  {
      struct zx_hrxml_CompetencyWeight_s* e;
      for (e = x->CompetencyWeight; e; e = (struct zx_hrxml_CompetencyWeight_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_CompetencyWeight(c, e);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Competency(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Competency", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Competency) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Competency")-1 + 1 + 2 + sizeof("Competency")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->name, sizeof("name")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->required, sizeof("required")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_CompetencyId_s* e;
      for (e = x->CompetencyId; e; e = (struct zx_hrxml_CompetencyId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_CompetencyId(c, e);
  }
  {
      struct zx_hrxml_TaxonomyId_s* e;
      for (e = x->TaxonomyId; e; e = (struct zx_hrxml_TaxonomyId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_TaxonomyId(c, e);
  }
  {
      struct zx_hrxml_CompetencyEvidence_s* e;
      for (e = x->CompetencyEvidence; e; e = (struct zx_hrxml_CompetencyEvidence_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_CompetencyEvidence(c, e);
  }
  {
      struct zx_hrxml_CompetencyWeight_s* e;
      for (e = x->CompetencyWeight; e; e = (struct zx_hrxml_CompetencyWeight_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_CompetencyWeight(c, e);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Competency(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Competency", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Competency) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Competency");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->name, " name=\"", sizeof(" name=\"")-1);
  p = zx_attr_so_enc(p, x->required, " required=\"", sizeof(" required=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_CompetencyId_s* e;
      for (e = x->CompetencyId; e; e = (struct zx_hrxml_CompetencyId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_CompetencyId(c, e, p);
  }
  {
      struct zx_hrxml_TaxonomyId_s* e;
      for (e = x->TaxonomyId; e; e = (struct zx_hrxml_TaxonomyId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_TaxonomyId(c, e, p);
  }
  {
      struct zx_hrxml_CompetencyEvidence_s* e;
      for (e = x->CompetencyEvidence; e; e = (struct zx_hrxml_CompetencyEvidence_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_CompetencyEvidence(c, e, p);
  }
  {
      struct zx_hrxml_CompetencyWeight_s* e;
      for (e = x->CompetencyWeight; e; e = (struct zx_hrxml_CompetencyWeight_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_CompetencyWeight(c, e, p);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Competency(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Competency>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Competency", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Competency) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Competency", sizeof("Competency")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->description, "description=\"", sizeof("description=\"")-1);
  p = zx_attr_wo_enc(p, x->name, "name=\"", sizeof("name=\"")-1);
  p = zx_attr_wo_enc(p, x->required, "required=\"", sizeof("required=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Competency", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Competency) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Competency(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Competency(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Competency) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Competency(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Competency(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompetencyEvidence
#define EL_STRUCT zx_hrxml_CompetencyEvidence_s
#define EL_NS     hrxml
#define EL_TAG    CompetencyEvidence

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CompetencyEvidence) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CompetencyEvidence")-1 + 1 + sizeof("</hrxml:CompetencyEvidence>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateOfIncident, sizeof("dateOfIncident")-1, &pop_seen);
  len += zx_attr_so_len(c, x->expirationDate, sizeof("expirationDate")-1, &pop_seen);
  len += zx_attr_so_len(c, x->lastUsed, sizeof("lastUsed")-1, &pop_seen);
  len += zx_attr_so_len(c, x->name, sizeof("name")-1, &pop_seen);
  len += zx_attr_so_len(c, x->required, sizeof("required")-1, &pop_seen);
  len += zx_attr_so_len(c, x->typeDescription, sizeof("typeDescription")-1, &pop_seen);
  len += zx_attr_so_len(c, x->typeId, sizeof("typeId")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_EvidenceId_s* e;
      for (e = x->EvidenceId; e; e = (struct zx_hrxml_EvidenceId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EvidenceId(c, e);
  }
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_NumericValue(c, e);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StringValue(c, e);
  }
  for (se = x->SupportingInformation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SupportingInformation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompetencyEvidence", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_CompetencyEvidence) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("CompetencyEvidence")-1 + 1 + 2 + sizeof("CompetencyEvidence")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateOfIncident, sizeof("dateOfIncident")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->expirationDate, sizeof("expirationDate")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->lastUsed, sizeof("lastUsed")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->name, sizeof("name")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->required, sizeof("required")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->typeDescription, sizeof("typeDescription")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->typeId, sizeof("typeId")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_EvidenceId_s* e;
      for (e = x->EvidenceId; e; e = (struct zx_hrxml_EvidenceId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EvidenceId(c, e);
  }
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_NumericValue(c, e);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StringValue(c, e);
  }
  for (se = x->SupportingInformation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SupportingInformation")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompetencyEvidence", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CompetencyEvidence) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CompetencyEvidence");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateOfIncident, " dateOfIncident=\"", sizeof(" dateOfIncident=\"")-1);
  p = zx_attr_so_enc(p, x->expirationDate, " expirationDate=\"", sizeof(" expirationDate=\"")-1);
  p = zx_attr_so_enc(p, x->lastUsed, " lastUsed=\"", sizeof(" lastUsed=\"")-1);
  p = zx_attr_so_enc(p, x->name, " name=\"", sizeof(" name=\"")-1);
  p = zx_attr_so_enc(p, x->required, " required=\"", sizeof(" required=\"")-1);
  p = zx_attr_so_enc(p, x->typeDescription, " typeDescription=\"", sizeof(" typeDescription=\"")-1);
  p = zx_attr_so_enc(p, x->typeId, " typeId=\"", sizeof(" typeId=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_EvidenceId_s* e;
      for (e = x->EvidenceId; e; e = (struct zx_hrxml_EvidenceId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EvidenceId(c, e, p);
  }
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_NumericValue(c, e, p);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StringValue(c, e, p);
  }
  for (se = x->SupportingInformation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SupportingInformation", sizeof("hrxml:SupportingInformation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CompetencyEvidence>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompetencyEvidence", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_CompetencyEvidence) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "CompetencyEvidence", sizeof("CompetencyEvidence")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateOfIncident, "dateOfIncident=\"", sizeof("dateOfIncident=\"")-1);
  p = zx_attr_wo_enc(p, x->expirationDate, "expirationDate=\"", sizeof("expirationDate=\"")-1);
  p = zx_attr_wo_enc(p, x->lastUsed, "lastUsed=\"", sizeof("lastUsed=\"")-1);
  p = zx_attr_wo_enc(p, x->name, "name=\"", sizeof("name=\"")-1);
  p = zx_attr_wo_enc(p, x->required, "required=\"", sizeof("required=\"")-1);
  p = zx_attr_wo_enc(p, x->typeDescription, "typeDescription=\"", sizeof("typeDescription=\"")-1);
  p = zx_attr_wo_enc(p, x->typeId, "typeId=\"", sizeof("typeId=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompetencyEvidence", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CompetencyEvidence) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CompetencyEvidence(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CompetencyEvidence(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_CompetencyEvidence) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_CompetencyEvidence(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_CompetencyEvidence(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompetencyId
#define EL_STRUCT zx_hrxml_CompetencyId_s
#define EL_NS     hrxml
#define EL_TAG    CompetencyId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CompetencyId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CompetencyId")-1 + 1 + sizeof("</hrxml:CompetencyId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompetencyId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_CompetencyId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("CompetencyId")-1 + 1 + 2 + sizeof("CompetencyId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompetencyId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CompetencyId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CompetencyId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CompetencyId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompetencyId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_CompetencyId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "CompetencyId", sizeof("CompetencyId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompetencyId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CompetencyId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CompetencyId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CompetencyId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_CompetencyId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_CompetencyId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_CompetencyId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompetencyWeight
#define EL_STRUCT zx_hrxml_CompetencyWeight_s
#define EL_NS     hrxml
#define EL_TAG    CompetencyWeight

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CompetencyWeight) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CompetencyWeight")-1 + 1 + sizeof("</hrxml:CompetencyWeight>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_NumericValue(c, e);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StringValue(c, e);
  }
  for (se = x->SupportingInformation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SupportingInformation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompetencyWeight", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_CompetencyWeight) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("CompetencyWeight")-1 + 1 + 2 + sizeof("CompetencyWeight")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_NumericValue(c, e);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StringValue(c, e);
  }
  for (se = x->SupportingInformation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SupportingInformation")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompetencyWeight", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CompetencyWeight) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CompetencyWeight");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_NumericValue(c, e, p);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StringValue(c, e, p);
  }
  for (se = x->SupportingInformation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SupportingInformation", sizeof("hrxml:SupportingInformation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CompetencyWeight>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompetencyWeight", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_CompetencyWeight) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "CompetencyWeight", sizeof("CompetencyWeight")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompetencyWeight", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CompetencyWeight) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CompetencyWeight(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CompetencyWeight(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_CompetencyWeight) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_CompetencyWeight(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_CompetencyWeight(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ConferenceDate
#define EL_STRUCT zx_hrxml_ConferenceDate_s
#define EL_NS     hrxml
#define EL_TAG    ConferenceDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ConferenceDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ConferenceDate")-1 + 1 + sizeof("</hrxml:ConferenceDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ConferenceDate", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ConferenceDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ConferenceDate")-1 + 1 + 2 + sizeof("ConferenceDate")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AnyDate")-1);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("YearMonth")-1);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Year")-1);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDay")-1);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StringDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ConferenceDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ConferenceDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ConferenceDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ConferenceDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ConferenceDate", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ConferenceDate) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ConferenceDate", sizeof("ConferenceDate")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateDescription, "dateDescription=\"", sizeof("dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ConferenceDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ConferenceDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ConferenceDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ConferenceDate(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ConferenceDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ConferenceDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ConferenceDate(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ConferencePaper
#define EL_STRUCT zx_hrxml_ConferencePaper_s
#define EL_NS     hrxml
#define EL_TAG    ConferencePaper

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ConferencePaper) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ConferencePaper")-1 + 1 + sizeof("</hrxml:ConferencePaper>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PublicationDate(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Copyright(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->EventName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EventName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ConferenceDate_s* e;
      for (e = x->ConferenceDate; e; e = (struct zx_hrxml_ConferenceDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ConferenceDate(c, e);
  }
  for (se = x->ConferenceLocation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ConferenceLocation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ConferencePaper", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ConferencePaper) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ConferencePaper")-1 + 1 + 2 + sizeof("ConferencePaper")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Title")-1);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PublicationDate(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Link")-1);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Abstract")-1);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Copyright(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  for (se = x->EventName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("EventName")-1);
  {
      struct zx_hrxml_ConferenceDate_s* e;
      for (e = x->ConferenceDate; e; e = (struct zx_hrxml_ConferenceDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ConferenceDate(c, e);
  }
  for (se = x->ConferenceLocation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ConferenceLocation")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ConferencePaper", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ConferencePaper) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ConferencePaper");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PublicationDate(c, e, p);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Abstract", sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Copyright(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->EventName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EventName", sizeof("hrxml:EventName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ConferenceDate_s* e;
      for (e = x->ConferenceDate; e; e = (struct zx_hrxml_ConferenceDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ConferenceDate(c, e, p);
  }
  for (se = x->ConferenceLocation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ConferenceLocation", sizeof("hrxml:ConferenceLocation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ConferencePaper>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ConferencePaper", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ConferencePaper) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ConferencePaper", sizeof("ConferencePaper")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ConferencePaper", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ConferencePaper) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ConferencePaper(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ConferencePaper(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ConferencePaper) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ConferencePaper(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ConferencePaper(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Considerations
#define EL_STRUCT zx_hrxml_Considerations_s
#define EL_NS     hrxml
#define EL_TAG    Considerations

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Considerations) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Considerations")-1 + 1 + sizeof("</hrxml:Considerations>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->General; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:General")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Physical; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Physical")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_SafetyEquipment_s* e;
      for (e = x->SafetyEquipment; e; e = (struct zx_hrxml_SafetyEquipment_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SafetyEquipment(c, e);
  }
  {
      struct zx_hrxml_DressCode_s* e;
      for (e = x->DressCode; e; e = (struct zx_hrxml_DressCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DressCode(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Considerations", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Considerations) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Considerations")-1 + 1 + 2 + sizeof("Considerations")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->lang, sizeof("lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->General; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("General")-1);
  for (se = x->Physical; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Physical")-1);
  {
      struct zx_hrxml_SafetyEquipment_s* e;
      for (e = x->SafetyEquipment; e; e = (struct zx_hrxml_SafetyEquipment_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SafetyEquipment(c, e);
  }
  {
      struct zx_hrxml_DressCode_s* e;
      for (e = x->DressCode; e; e = (struct zx_hrxml_DressCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DressCode(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Considerations", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Considerations) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Considerations");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->General; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:General", sizeof("hrxml:General")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Physical; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Physical", sizeof("hrxml:Physical")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_SafetyEquipment_s* e;
      for (e = x->SafetyEquipment; e; e = (struct zx_hrxml_SafetyEquipment_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SafetyEquipment(c, e, p);
  }
  {
      struct zx_hrxml_DressCode_s* e;
      for (e = x->DressCode; e; e = (struct zx_hrxml_DressCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DressCode(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Considerations>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Considerations", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Considerations) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Considerations", sizeof("Considerations")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->lang, "lang=\"", sizeof("lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Considerations", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Considerations) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Considerations(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Considerations(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Considerations) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Considerations(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Considerations(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactId
#define EL_STRUCT zx_hrxml_ContactId_s
#define EL_NS     hrxml
#define EL_TAG    ContactId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ContactId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ContactId")-1 + 1 + sizeof("</hrxml:ContactId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ContactId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ContactId")-1 + 1 + 2 + sizeof("ContactId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ContactId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ContactId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ContactId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ContactId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ContactId", sizeof("ContactId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ContactId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ContactId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ContactId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ContactId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ContactId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ContactId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactInfo
#define EL_STRUCT zx_hrxml_ContactInfo_s
#define EL_NS     hrxml
#define EL_TAG    ContactInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ContactInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ContactInfo")-1 + 1 + sizeof("</hrxml:ContactInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonName(c, e);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactMethod(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactInfo", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ContactInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ContactInfo")-1 + 1 + 2 + sizeof("ContactInfo")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonName(c, e);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactMethod(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ContactInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ContactInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonName(c, e, p);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactMethod(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ContactInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactInfo", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ContactInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ContactInfo", sizeof("ContactInfo")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ContactInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ContactInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ContactInfo(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ContactInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ContactInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ContactInfo(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactMethod
#define EL_STRUCT zx_hrxml_ContactMethod_s
#define EL_NS     hrxml
#define EL_TAG    ContactMethod

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ContactMethod) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ContactMethod")-1 + 1 + sizeof("</hrxml:ContactMethod>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Use; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Use")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Location; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Location")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->WhenAvailable; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:WhenAvailable")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Telephone_s* e;
      for (e = x->Telephone; e; e = (struct zx_hrxml_Telephone_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Telephone(c, e);
  }
  {
      struct zx_hrxml_Mobile_s* e;
      for (e = x->Mobile; e; e = (struct zx_hrxml_Mobile_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Mobile(c, e);
  }
  {
      struct zx_hrxml_Fax_s* e;
      for (e = x->Fax; e; e = (struct zx_hrxml_Fax_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Fax(c, e);
  }
  {
      struct zx_hrxml_Pager_s* e;
      for (e = x->Pager; e; e = (struct zx_hrxml_Pager_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Pager(c, e);
  }
  {
      struct zx_hrxml_TTYTDD_s* e;
      for (e = x->TTYTDD; e; e = (struct zx_hrxml_TTYTDD_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_TTYTDD(c, e);
  }
  for (se = x->InternetEmailAddress; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:InternetEmailAddress")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->InternetWebAddress; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:InternetWebAddress")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PostalAddress(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactMethod", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ContactMethod) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ContactMethod")-1 + 1 + 2 + sizeof("ContactMethod")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Use; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Use")-1);
  for (se = x->Location; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Location")-1);
  for (se = x->WhenAvailable; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("WhenAvailable")-1);
  {
      struct zx_hrxml_Telephone_s* e;
      for (e = x->Telephone; e; e = (struct zx_hrxml_Telephone_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Telephone(c, e);
  }
  {
      struct zx_hrxml_Mobile_s* e;
      for (e = x->Mobile; e; e = (struct zx_hrxml_Mobile_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Mobile(c, e);
  }
  {
      struct zx_hrxml_Fax_s* e;
      for (e = x->Fax; e; e = (struct zx_hrxml_Fax_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Fax(c, e);
  }
  {
      struct zx_hrxml_Pager_s* e;
      for (e = x->Pager; e; e = (struct zx_hrxml_Pager_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Pager(c, e);
  }
  {
      struct zx_hrxml_TTYTDD_s* e;
      for (e = x->TTYTDD; e; e = (struct zx_hrxml_TTYTDD_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_TTYTDD(c, e);
  }
  for (se = x->InternetEmailAddress; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("InternetEmailAddress")-1);
  for (se = x->InternetWebAddress; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("InternetWebAddress")-1);
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PostalAddress(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactMethod", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ContactMethod) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ContactMethod");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Use; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Use", sizeof("hrxml:Use")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Location; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Location", sizeof("hrxml:Location")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->WhenAvailable; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:WhenAvailable", sizeof("hrxml:WhenAvailable")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Telephone_s* e;
      for (e = x->Telephone; e; e = (struct zx_hrxml_Telephone_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Telephone(c, e, p);
  }
  {
      struct zx_hrxml_Mobile_s* e;
      for (e = x->Mobile; e; e = (struct zx_hrxml_Mobile_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Mobile(c, e, p);
  }
  {
      struct zx_hrxml_Fax_s* e;
      for (e = x->Fax; e; e = (struct zx_hrxml_Fax_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Fax(c, e, p);
  }
  {
      struct zx_hrxml_Pager_s* e;
      for (e = x->Pager; e; e = (struct zx_hrxml_Pager_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Pager(c, e, p);
  }
  {
      struct zx_hrxml_TTYTDD_s* e;
      for (e = x->TTYTDD; e; e = (struct zx_hrxml_TTYTDD_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_TTYTDD(c, e, p);
  }
  for (se = x->InternetEmailAddress; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:InternetEmailAddress", sizeof("hrxml:InternetEmailAddress")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->InternetWebAddress; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:InternetWebAddress", sizeof("hrxml:InternetWebAddress")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PostalAddress(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ContactMethod>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactMethod", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ContactMethod) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ContactMethod", sizeof("ContactMethod")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactMethod", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ContactMethod) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ContactMethod(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ContactMethod(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ContactMethod) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ContactMethod(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ContactMethod(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactName
#define EL_STRUCT zx_hrxml_ContactName_s
#define EL_NS     hrxml
#define EL_TAG    ContactName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ContactName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ContactName")-1 + 1 + sizeof("</hrxml:ContactName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->script, sizeof("script")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_FamilyName_s* e;
      for (e = x->FamilyName; e; e = (struct zx_hrxml_FamilyName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_FamilyName(c, e);
  }
  {
      struct zx_hrxml_Affix_s* e;
      for (e = x->Affix; e; e = (struct zx_hrxml_Affix_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Affix(c, e);
  }
  {
      struct zx_hrxml_AlternateScript_s* e;
      for (e = x->AlternateScript; e; e = (struct zx_hrxml_AlternateScript_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_AlternateScript(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactName", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ContactName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ContactName")-1 + 1 + 2 + sizeof("ContactName")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->script, sizeof("script")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("FormattedName")-1);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("LegalName")-1);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("GivenName")-1);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PreferredGivenName")-1);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MiddleName")-1);
  {
      struct zx_hrxml_FamilyName_s* e;
      for (e = x->FamilyName; e; e = (struct zx_hrxml_FamilyName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_FamilyName(c, e);
  }
  {
      struct zx_hrxml_Affix_s* e;
      for (e = x->Affix; e; e = (struct zx_hrxml_Affix_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Affix(c, e);
  }
  {
      struct zx_hrxml_AlternateScript_s* e;
      for (e = x->AlternateScript; e; e = (struct zx_hrxml_AlternateScript_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_AlternateScript(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ContactName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ContactName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->script, " script=\"", sizeof(" script=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedName", sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:LegalName", sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:GivenName", sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PreferredGivenName", sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MiddleName", sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_FamilyName_s* e;
      for (e = x->FamilyName; e; e = (struct zx_hrxml_FamilyName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_FamilyName(c, e, p);
  }
  {
      struct zx_hrxml_Affix_s* e;
      for (e = x->Affix; e; e = (struct zx_hrxml_Affix_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Affix(c, e, p);
  }
  {
      struct zx_hrxml_AlternateScript_s* e;
      for (e = x->AlternateScript; e; e = (struct zx_hrxml_AlternateScript_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_AlternateScript(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ContactName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactName", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ContactName) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ContactName", sizeof("ContactName")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->script, "script=\"", sizeof("script=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ContactName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ContactName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ContactName(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ContactName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ContactName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ContactName(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Copyright
#define EL_STRUCT zx_hrxml_Copyright_s
#define EL_NS     hrxml
#define EL_TAG    Copyright

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Copyright) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Copyright")-1 + 1 + sizeof("</hrxml:Copyright>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_CopyrightDates_s* e;
      for (e = x->CopyrightDates; e; e = (struct zx_hrxml_CopyrightDates_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_CopyrightDates(c, e);
  }
  for (se = x->CopyrightText; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CopyrightText")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Copyright", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Copyright) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Copyright")-1 + 1 + 2 + sizeof("Copyright")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_CopyrightDates_s* e;
      for (e = x->CopyrightDates; e; e = (struct zx_hrxml_CopyrightDates_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_CopyrightDates(c, e);
  }
  for (se = x->CopyrightText; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CopyrightText")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Copyright", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Copyright) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Copyright");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_CopyrightDates_s* e;
      for (e = x->CopyrightDates; e; e = (struct zx_hrxml_CopyrightDates_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_CopyrightDates(c, e, p);
  }
  for (se = x->CopyrightText; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CopyrightText", sizeof("hrxml:CopyrightText")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Copyright>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Copyright", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Copyright) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Copyright", sizeof("Copyright")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Copyright", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Copyright) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Copyright(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Copyright(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Copyright) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Copyright(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Copyright(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CopyrightDates
#define EL_STRUCT zx_hrxml_CopyrightDates_s
#define EL_NS     hrxml
#define EL_TAG    CopyrightDates

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CopyrightDates) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CopyrightDates")-1 + 1 + sizeof("</hrxml:CopyrightDates>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_OriginalDate_s* e;
      for (e = x->OriginalDate; e; e = (struct zx_hrxml_OriginalDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OriginalDate(c, e);
  }
  {
      struct zx_hrxml_MostRecentDate_s* e;
      for (e = x->MostRecentDate; e; e = (struct zx_hrxml_MostRecentDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_MostRecentDate(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CopyrightDates", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_CopyrightDates) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("CopyrightDates")-1 + 1 + 2 + sizeof("CopyrightDates")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_OriginalDate_s* e;
      for (e = x->OriginalDate; e; e = (struct zx_hrxml_OriginalDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OriginalDate(c, e);
  }
  {
      struct zx_hrxml_MostRecentDate_s* e;
      for (e = x->MostRecentDate; e; e = (struct zx_hrxml_MostRecentDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_MostRecentDate(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CopyrightDates", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CopyrightDates) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CopyrightDates");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_OriginalDate_s* e;
      for (e = x->OriginalDate; e; e = (struct zx_hrxml_OriginalDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OriginalDate(c, e, p);
  }
  {
      struct zx_hrxml_MostRecentDate_s* e;
      for (e = x->MostRecentDate; e; e = (struct zx_hrxml_MostRecentDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_MostRecentDate(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CopyrightDates>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CopyrightDates", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_CopyrightDates) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "CopyrightDates", sizeof("CopyrightDates")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CopyrightDates", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CopyrightDates) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CopyrightDates(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CopyrightDates(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_CopyrightDates) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_CopyrightDates(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_CopyrightDates(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DatesOfAttendance
#define EL_STRUCT zx_hrxml_DatesOfAttendance_s
#define EL_NS     hrxml
#define EL_TAG    DatesOfAttendance

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DatesOfAttendance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DatesOfAttendance")-1 + 1 + sizeof("</hrxml:DatesOfAttendance>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->currentlyEnrolled, sizeof("currentlyEnrolled")-1, &pop_seen);
  len += zx_attr_so_len(c, x->enrollmentStatus, sizeof("enrollmentStatus")-1, &pop_seen);
  len += zx_attr_so_len(c, x->studentInGoodStanding, sizeof("studentInGoodStanding")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EndDate(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DatesOfAttendance", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DatesOfAttendance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DatesOfAttendance")-1 + 1 + 2 + sizeof("DatesOfAttendance")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->currentlyEnrolled, sizeof("currentlyEnrolled")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->enrollmentStatus, sizeof("enrollmentStatus")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->studentInGoodStanding, sizeof("studentInGoodStanding")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EndDate(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DatesOfAttendance", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DatesOfAttendance) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DatesOfAttendance");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->currentlyEnrolled, " currentlyEnrolled=\"", sizeof(" currentlyEnrolled=\"")-1);
  p = zx_attr_so_enc(p, x->enrollmentStatus, " enrollmentStatus=\"", sizeof(" enrollmentStatus=\"")-1);
  p = zx_attr_so_enc(p, x->studentInGoodStanding, " studentInGoodStanding=\"", sizeof(" studentInGoodStanding=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StartDate(c, e, p);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EndDate(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DatesOfAttendance>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DatesOfAttendance", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DatesOfAttendance) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DatesOfAttendance", sizeof("DatesOfAttendance")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->currentlyEnrolled, "currentlyEnrolled=\"", sizeof("currentlyEnrolled=\"")-1);
  p = zx_attr_wo_enc(p, x->enrollmentStatus, "enrollmentStatus=\"", sizeof("enrollmentStatus=\"")-1);
  p = zx_attr_wo_enc(p, x->studentInGoodStanding, "studentInGoodStanding=\"", sizeof("studentInGoodStanding=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DatesOfAttendance", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DatesOfAttendance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DatesOfAttendance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DatesOfAttendance(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DatesOfAttendance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DatesOfAttendance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DatesOfAttendance(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DatesOfService
#define EL_STRUCT zx_hrxml_DatesOfService_s
#define EL_NS     hrxml
#define EL_TAG    DatesOfService

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DatesOfService) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DatesOfService")-1 + 1 + sizeof("</hrxml:DatesOfService>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EndDate(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DatesOfService", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DatesOfService) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DatesOfService")-1 + 1 + 2 + sizeof("DatesOfService")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EndDate(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DatesOfService", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DatesOfService) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DatesOfService");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StartDate(c, e, p);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EndDate(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DatesOfService>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DatesOfService", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DatesOfService) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DatesOfService", sizeof("DatesOfService")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DatesOfService", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DatesOfService) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DatesOfService(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DatesOfService(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DatesOfService) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DatesOfService(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DatesOfService(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Degree
#define EL_STRUCT zx_hrxml_Degree_s
#define EL_NS     hrxml
#define EL_TAG    Degree

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Degree) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Degree")-1 + 1 + sizeof("</hrxml:Degree>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->degreeType, sizeof("degreeType")-1, &pop_seen);
  len += zx_attr_so_len(c, x->examPassed, sizeof("examPassed")-1, &pop_seen);
  len += zx_attr_so_len(c, x->graduatingDegree, sizeof("graduatingDegree")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_DegreeName_s* e;
      for (e = x->DegreeName; e; e = (struct zx_hrxml_DegreeName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DegreeName(c, e);
  }
  {
      struct zx_hrxml_DegreeDate_s* e;
      for (e = x->DegreeDate; e; e = (struct zx_hrxml_DegreeDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DegreeDate(c, e);
  }
  {
      struct zx_hrxml_OtherHonors_s* e;
      for (e = x->OtherHonors; e; e = (struct zx_hrxml_OtherHonors_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OtherHonors(c, e);
  }
  {
      struct zx_hrxml_DegreeMajor_s* e;
      for (e = x->DegreeMajor; e; e = (struct zx_hrxml_DegreeMajor_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DegreeMajor(c, e);
  }
  {
      struct zx_hrxml_DegreeMinor_s* e;
      for (e = x->DegreeMinor; e; e = (struct zx_hrxml_DegreeMinor_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DegreeMinor(c, e);
  }
  {
      struct zx_hrxml_DegreeMeasure_s* e;
      for (e = x->DegreeMeasure; e; e = (struct zx_hrxml_DegreeMeasure_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DegreeMeasure(c, e);
  }
  {
      struct zx_hrxml_DatesOfAttendance_s* e;
      for (e = x->DatesOfAttendance; e; e = (struct zx_hrxml_DatesOfAttendance_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DatesOfAttendance(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DegreeClassification_s* e;
      for (e = x->DegreeClassification; e; e = (struct zx_hrxml_DegreeClassification_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DegreeClassification(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Degree", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Degree) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Degree")-1 + 1 + 2 + sizeof("Degree")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->degreeType, sizeof("degreeType")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->examPassed, sizeof("examPassed")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->graduatingDegree, sizeof("graduatingDegree")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_DegreeName_s* e;
      for (e = x->DegreeName; e; e = (struct zx_hrxml_DegreeName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DegreeName(c, e);
  }
  {
      struct zx_hrxml_DegreeDate_s* e;
      for (e = x->DegreeDate; e; e = (struct zx_hrxml_DegreeDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DegreeDate(c, e);
  }
  {
      struct zx_hrxml_OtherHonors_s* e;
      for (e = x->OtherHonors; e; e = (struct zx_hrxml_OtherHonors_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OtherHonors(c, e);
  }
  {
      struct zx_hrxml_DegreeMajor_s* e;
      for (e = x->DegreeMajor; e; e = (struct zx_hrxml_DegreeMajor_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DegreeMajor(c, e);
  }
  {
      struct zx_hrxml_DegreeMinor_s* e;
      for (e = x->DegreeMinor; e; e = (struct zx_hrxml_DegreeMinor_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DegreeMinor(c, e);
  }
  {
      struct zx_hrxml_DegreeMeasure_s* e;
      for (e = x->DegreeMeasure; e; e = (struct zx_hrxml_DegreeMeasure_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DegreeMeasure(c, e);
  }
  {
      struct zx_hrxml_DatesOfAttendance_s* e;
      for (e = x->DatesOfAttendance; e; e = (struct zx_hrxml_DatesOfAttendance_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DatesOfAttendance(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  {
      struct zx_hrxml_DegreeClassification_s* e;
      for (e = x->DegreeClassification; e; e = (struct zx_hrxml_DegreeClassification_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DegreeClassification(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Degree", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Degree) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Degree");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->degreeType, " degreeType=\"", sizeof(" degreeType=\"")-1);
  p = zx_attr_so_enc(p, x->examPassed, " examPassed=\"", sizeof(" examPassed=\"")-1);
  p = zx_attr_so_enc(p, x->graduatingDegree, " graduatingDegree=\"", sizeof(" graduatingDegree=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_DegreeName_s* e;
      for (e = x->DegreeName; e; e = (struct zx_hrxml_DegreeName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DegreeName(c, e, p);
  }
  {
      struct zx_hrxml_DegreeDate_s* e;
      for (e = x->DegreeDate; e; e = (struct zx_hrxml_DegreeDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DegreeDate(c, e, p);
  }
  {
      struct zx_hrxml_OtherHonors_s* e;
      for (e = x->OtherHonors; e; e = (struct zx_hrxml_OtherHonors_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OtherHonors(c, e, p);
  }
  {
      struct zx_hrxml_DegreeMajor_s* e;
      for (e = x->DegreeMajor; e; e = (struct zx_hrxml_DegreeMajor_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DegreeMajor(c, e, p);
  }
  {
      struct zx_hrxml_DegreeMinor_s* e;
      for (e = x->DegreeMinor; e; e = (struct zx_hrxml_DegreeMinor_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DegreeMinor(c, e, p);
  }
  {
      struct zx_hrxml_DegreeMeasure_s* e;
      for (e = x->DegreeMeasure; e; e = (struct zx_hrxml_DegreeMeasure_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DegreeMeasure(c, e, p);
  }
  {
      struct zx_hrxml_DatesOfAttendance_s* e;
      for (e = x->DatesOfAttendance; e; e = (struct zx_hrxml_DatesOfAttendance_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DatesOfAttendance(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DegreeClassification_s* e;
      for (e = x->DegreeClassification; e; e = (struct zx_hrxml_DegreeClassification_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DegreeClassification(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Degree>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Degree", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Degree) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Degree", sizeof("Degree")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->degreeType, "degreeType=\"", sizeof("degreeType=\"")-1);
  p = zx_attr_wo_enc(p, x->examPassed, "examPassed=\"", sizeof("examPassed=\"")-1);
  p = zx_attr_wo_enc(p, x->graduatingDegree, "graduatingDegree=\"", sizeof("graduatingDegree=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Degree", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Degree) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Degree(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Degree(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Degree) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Degree(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Degree(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeClassification
#define EL_STRUCT zx_hrxml_DegreeClassification_s
#define EL_NS     hrxml
#define EL_TAG    DegreeClassification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeClassification")-1 + 1 + sizeof("</hrxml:DegreeClassification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeClassification", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DegreeClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DegreeClassification")-1 + 1 + 2 + sizeof("DegreeClassification")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeClassification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeClassification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeClassification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeClassification", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DegreeClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DegreeClassification", sizeof("DegreeClassification")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeClassification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeClassification(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DegreeClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DegreeClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DegreeClassification(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeDate
#define EL_STRUCT zx_hrxml_DegreeDate_s
#define EL_NS     hrxml
#define EL_TAG    DegreeDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeDate")-1 + 1 + sizeof("</hrxml:DegreeDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeDate", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DegreeDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DegreeDate")-1 + 1 + 2 + sizeof("DegreeDate")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AnyDate")-1);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("YearMonth")-1);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Year")-1);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDay")-1);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StringDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeDate", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DegreeDate) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DegreeDate", sizeof("DegreeDate")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateDescription, "dateDescription=\"", sizeof("dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeDate(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DegreeDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DegreeDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DegreeDate(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeMajor
#define EL_STRUCT zx_hrxml_DegreeMajor_s
#define EL_NS     hrxml
#define EL_TAG    DegreeMajor

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeMajor) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeMajor")-1 + 1 + sizeof("</hrxml:DegreeMajor>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ProgramId_s* e;
      for (e = x->ProgramId; e; e = (struct zx_hrxml_ProgramId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ProgramId(c, e);
  }
  for (se = x->DegreeConcentration; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DegreeConcentration")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Option; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Option")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeMajor", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DegreeMajor) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DegreeMajor")-1 + 1 + 2 + sizeof("DegreeMajor")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ProgramId_s* e;
      for (e = x->ProgramId; e; e = (struct zx_hrxml_ProgramId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ProgramId(c, e);
  }
  for (se = x->DegreeConcentration; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("DegreeConcentration")-1);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  for (se = x->Option; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Option")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeMajor", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeMajor) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeMajor");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_ProgramId_s* e;
      for (e = x->ProgramId; e; e = (struct zx_hrxml_ProgramId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ProgramId(c, e, p);
  }
  for (se = x->DegreeConcentration; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DegreeConcentration", sizeof("hrxml:DegreeConcentration")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Option; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Option", sizeof("hrxml:Option")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeMajor>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeMajor", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DegreeMajor) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DegreeMajor", sizeof("DegreeMajor")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeMajor", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeMajor) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeMajor(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeMajor(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DegreeMajor) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DegreeMajor(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DegreeMajor(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeMeasure
#define EL_STRUCT zx_hrxml_DegreeMeasure_s
#define EL_NS     hrxml
#define EL_TAG    DegreeMeasure

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeMeasure) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeMeasure")-1 + 1 + sizeof("</hrxml:DegreeMeasure>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->measureType, sizeof("measureType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_EducationalMeasure_s* e;
      for (e = x->EducationalMeasure; e; e = (struct zx_hrxml_EducationalMeasure_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EducationalMeasure(c, e);
  }
  for (se = x->AcademicCreditCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AcademicCreditCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CourseLevelCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CourseLevelCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CumulativeSummaryIndicator; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CumulativeSummaryIndicator")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AcademicCreditHoursIncluded; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AcademicCreditHoursIncluded")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AcademicCreditHoursAttempted; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AcademicCreditHoursAttempted")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AcademicCreditHoursEarned; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AcademicCreditHoursEarned")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ClassRank_s* e;
      for (e = x->ClassRank; e; e = (struct zx_hrxml_ClassRank_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ClassRank(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeMeasure", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DegreeMeasure) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DegreeMeasure")-1 + 1 + 2 + sizeof("DegreeMeasure")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->measureType, sizeof("measureType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_EducationalMeasure_s* e;
      for (e = x->EducationalMeasure; e; e = (struct zx_hrxml_EducationalMeasure_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EducationalMeasure(c, e);
  }
  for (se = x->AcademicCreditCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AcademicCreditCode")-1);
  for (se = x->CourseLevelCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CourseLevelCode")-1);
  for (se = x->CumulativeSummaryIndicator; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CumulativeSummaryIndicator")-1);
  for (se = x->AcademicCreditHoursIncluded; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AcademicCreditHoursIncluded")-1);
  for (se = x->AcademicCreditHoursAttempted; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AcademicCreditHoursAttempted")-1);
  for (se = x->AcademicCreditHoursEarned; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AcademicCreditHoursEarned")-1);
  {
      struct zx_hrxml_ClassRank_s* e;
      for (e = x->ClassRank; e; e = (struct zx_hrxml_ClassRank_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ClassRank(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeMeasure", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeMeasure) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeMeasure");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->measureType, " measureType=\"", sizeof(" measureType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_EducationalMeasure_s* e;
      for (e = x->EducationalMeasure; e; e = (struct zx_hrxml_EducationalMeasure_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EducationalMeasure(c, e, p);
  }
  for (se = x->AcademicCreditCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AcademicCreditCode", sizeof("hrxml:AcademicCreditCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CourseLevelCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CourseLevelCode", sizeof("hrxml:CourseLevelCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CumulativeSummaryIndicator; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CumulativeSummaryIndicator", sizeof("hrxml:CumulativeSummaryIndicator")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AcademicCreditHoursIncluded; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AcademicCreditHoursIncluded", sizeof("hrxml:AcademicCreditHoursIncluded")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AcademicCreditHoursAttempted; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AcademicCreditHoursAttempted", sizeof("hrxml:AcademicCreditHoursAttempted")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AcademicCreditHoursEarned; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AcademicCreditHoursEarned", sizeof("hrxml:AcademicCreditHoursEarned")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ClassRank_s* e;
      for (e = x->ClassRank; e; e = (struct zx_hrxml_ClassRank_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ClassRank(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeMeasure>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeMeasure", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DegreeMeasure) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DegreeMeasure", sizeof("DegreeMeasure")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->measureType, "measureType=\"", sizeof("measureType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeMeasure", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeMeasure) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeMeasure(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeMeasure(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DegreeMeasure) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DegreeMeasure(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DegreeMeasure(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeMinor
#define EL_STRUCT zx_hrxml_DegreeMinor_s
#define EL_NS     hrxml
#define EL_TAG    DegreeMinor

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeMinor) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeMinor")-1 + 1 + sizeof("</hrxml:DegreeMinor>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ProgramId_s* e;
      for (e = x->ProgramId; e; e = (struct zx_hrxml_ProgramId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ProgramId(c, e);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeMinor", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DegreeMinor) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DegreeMinor")-1 + 1 + 2 + sizeof("DegreeMinor")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ProgramId_s* e;
      for (e = x->ProgramId; e; e = (struct zx_hrxml_ProgramId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ProgramId(c, e);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeMinor", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeMinor) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeMinor");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_ProgramId_s* e;
      for (e = x->ProgramId; e; e = (struct zx_hrxml_ProgramId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ProgramId(c, e, p);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeMinor>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeMinor", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DegreeMinor) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DegreeMinor", sizeof("DegreeMinor")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeMinor", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeMinor) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeMinor(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeMinor(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DegreeMinor) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DegreeMinor(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DegreeMinor(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeName
#define EL_STRUCT zx_hrxml_DegreeName_s
#define EL_NS     hrxml
#define EL_TAG    DegreeName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeName")-1 + 1 + sizeof("</hrxml:DegreeName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->academicHonors, sizeof("academicHonors")-1, &pop_seen);
  len += zx_attr_so_len(c, x->honorsProgram, sizeof("honorsProgram")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeName", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DegreeName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DegreeName")-1 + 1 + 2 + sizeof("DegreeName")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->academicHonors, sizeof("academicHonors")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->honorsProgram, sizeof("honorsProgram")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->academicHonors, " academicHonors=\"", sizeof(" academicHonors=\"")-1);
  p = zx_attr_so_enc(p, x->honorsProgram, " honorsProgram=\"", sizeof(" honorsProgram=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeName", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DegreeName) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DegreeName", sizeof("DegreeName")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->academicHonors, "academicHonors=\"", sizeof("academicHonors=\"")-1);
  p = zx_attr_wo_enc(p, x->honorsProgram, "honorsProgram=\"", sizeof("honorsProgram=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeName(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DegreeName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DegreeName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DegreeName(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DeliveryAddress
#define EL_STRUCT zx_hrxml_DeliveryAddress_s
#define EL_NS     hrxml
#define EL_TAG    DeliveryAddress

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DeliveryAddress) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DeliveryAddress")-1 + 1 + sizeof("</hrxml:DeliveryAddress>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AddressLine; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AddressLine")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StreetName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StreetName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->BuildingNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:BuildingNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Unit; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Unit")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PostOfficeBox; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PostOfficeBox")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DeliveryAddress", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DeliveryAddress) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DeliveryAddress")-1 + 1 + 2 + sizeof("DeliveryAddress")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AddressLine; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AddressLine")-1);
  for (se = x->StreetName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StreetName")-1);
  for (se = x->BuildingNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("BuildingNumber")-1);
  for (se = x->Unit; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Unit")-1);
  for (se = x->PostOfficeBox; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PostOfficeBox")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DeliveryAddress", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DeliveryAddress) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DeliveryAddress");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AddressLine; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AddressLine", sizeof("hrxml:AddressLine")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StreetName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StreetName", sizeof("hrxml:StreetName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->BuildingNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:BuildingNumber", sizeof("hrxml:BuildingNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Unit; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Unit", sizeof("hrxml:Unit")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PostOfficeBox; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PostOfficeBox", sizeof("hrxml:PostOfficeBox")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DeliveryAddress>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DeliveryAddress", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DeliveryAddress) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DeliveryAddress", sizeof("DeliveryAddress")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DeliveryAddress", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DeliveryAddress) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DeliveryAddress(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DeliveryAddress(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DeliveryAddress) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DeliveryAddress(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DeliveryAddress(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DemographicDescriptors
#define EL_STRUCT zx_hrxml_DemographicDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    DemographicDescriptors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DemographicDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DemographicDescriptors")-1 + 1 + sizeof("</hrxml:DemographicDescriptors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Race; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Race")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Ethnicity; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Ethnicity")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Nationality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Nationality")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PrimaryLanguage_s* e;
      for (e = x->PrimaryLanguage; e; e = (struct zx_hrxml_PrimaryLanguage_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PrimaryLanguage(c, e);
  }
  for (se = x->BirthPlace; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:BirthPlace")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Religion; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Religion")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MaritalStatus; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MaritalStatus")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ChildrenInfo_s* e;
      for (e = x->ChildrenInfo; e; e = (struct zx_hrxml_ChildrenInfo_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ChildrenInfo(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DemographicDescriptors", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DemographicDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DemographicDescriptors")-1 + 1 + 2 + sizeof("DemographicDescriptors")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Race; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Race")-1);
  for (se = x->Ethnicity; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Ethnicity")-1);
  for (se = x->Nationality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Nationality")-1);
  {
      struct zx_hrxml_PrimaryLanguage_s* e;
      for (e = x->PrimaryLanguage; e; e = (struct zx_hrxml_PrimaryLanguage_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PrimaryLanguage(c, e);
  }
  for (se = x->BirthPlace; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("BirthPlace")-1);
  for (se = x->Religion; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Religion")-1);
  for (se = x->MaritalStatus; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MaritalStatus")-1);
  {
      struct zx_hrxml_ChildrenInfo_s* e;
      for (e = x->ChildrenInfo; e; e = (struct zx_hrxml_ChildrenInfo_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ChildrenInfo(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DemographicDescriptors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DemographicDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DemographicDescriptors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Race; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Race", sizeof("hrxml:Race")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Ethnicity; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Ethnicity", sizeof("hrxml:Ethnicity")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Nationality; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Nationality", sizeof("hrxml:Nationality")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PrimaryLanguage_s* e;
      for (e = x->PrimaryLanguage; e; e = (struct zx_hrxml_PrimaryLanguage_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PrimaryLanguage(c, e, p);
  }
  for (se = x->BirthPlace; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:BirthPlace", sizeof("hrxml:BirthPlace")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Religion; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Religion", sizeof("hrxml:Religion")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MaritalStatus; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MaritalStatus", sizeof("hrxml:MaritalStatus")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ChildrenInfo_s* e;
      for (e = x->ChildrenInfo; e; e = (struct zx_hrxml_ChildrenInfo_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ChildrenInfo(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DemographicDescriptors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DemographicDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DemographicDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DemographicDescriptors", sizeof("DemographicDescriptors")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DemographicDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DemographicDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DemographicDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DemographicDescriptors(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DemographicDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DemographicDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DemographicDescriptors(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Description
#define EL_STRUCT zx_hrxml_Description_s
#define EL_NS     hrxml
#define EL_TAG    Description

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Description) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Description")-1 + 1 + sizeof("</hrxml:Description>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Description", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Description) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Description")-1 + 1 + 2 + sizeof("Description")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->lang, sizeof("lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Description", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Description) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Description");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Description>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Description", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Description) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Description", sizeof("Description")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->lang, "lang=\"", sizeof("lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Description", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Description) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Description(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Description(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Description) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Description(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Description(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Details
#define EL_STRUCT zx_hrxml_Details_s
#define EL_NS     hrxml
#define EL_TAG    Details

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Details) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Details")-1 + 1 + sizeof("</hrxml:Details>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);
  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Details", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Details) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Details")-1 + 1 + 2 + sizeof("Details")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->lang, sizeof("lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Details", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Details) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Details");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Details>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Details", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Details) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Details", sizeof("Details")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);
  p = zx_attr_wo_enc(p, x->lang, "lang=\"", sizeof("lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Details", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Details) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Details(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Details(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Details) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Details(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Details(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DisabilityInfo
#define EL_STRUCT zx_hrxml_DisabilityInfo_s
#define EL_NS     hrxml
#define EL_TAG    DisabilityInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DisabilityInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DisabilityInfo")-1 + 1 + sizeof("</hrxml:DisabilityInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->LevelOfDisability; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:LevelOfDisability")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Percentage; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Percentage")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Type; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Type")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AccommodationsNeeded; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AccommodationsNeeded")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DisabilityInfo", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DisabilityInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DisabilityInfo")-1 + 1 + 2 + sizeof("DisabilityInfo")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->LevelOfDisability; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("LevelOfDisability")-1);
  for (se = x->Percentage; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Percentage")-1);
  for (se = x->Type; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Type")-1);
  for (se = x->AccommodationsNeeded; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AccommodationsNeeded")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DisabilityInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DisabilityInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DisabilityInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->LevelOfDisability; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:LevelOfDisability", sizeof("hrxml:LevelOfDisability")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Percentage; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Percentage", sizeof("hrxml:Percentage")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Type; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Type", sizeof("hrxml:Type")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AccommodationsNeeded; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AccommodationsNeeded", sizeof("hrxml:AccommodationsNeeded")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DisabilityInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DisabilityInfo", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DisabilityInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DisabilityInfo", sizeof("DisabilityInfo")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DisabilityInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DisabilityInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DisabilityInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DisabilityInfo(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DisabilityInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DisabilityInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DisabilityInfo(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DistanceMax
#define EL_STRUCT zx_hrxml_DistanceMax_s
#define EL_NS     hrxml
#define EL_TAG    DistanceMax

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DistanceMax) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DistanceMax")-1 + 1 + sizeof("</hrxml:DistanceMax>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DistanceMax", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DistanceMax) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DistanceMax")-1 + 1 + 2 + sizeof("DistanceMax")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DistanceMax", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DistanceMax) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DistanceMax");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->unitOfMeasure, " unitOfMeasure=\"", sizeof(" unitOfMeasure=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DistanceMax>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DistanceMax", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DistanceMax) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DistanceMax", sizeof("DistanceMax")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->unitOfMeasure, "unitOfMeasure=\"", sizeof("unitOfMeasure=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DistanceMax", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DistanceMax) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DistanceMax(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DistanceMax(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DistanceMax) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DistanceMax(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DistanceMax(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DistributeTo
#define EL_STRUCT zx_hrxml_DistributeTo_s
#define EL_NS     hrxml
#define EL_TAG    DistributeTo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DistributeTo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DistributeTo")-1 + 1 + sizeof("</hrxml:DistributeTo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactMethod(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DistributeTo", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DistributeTo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DistributeTo")-1 + 1 + 2 + sizeof("DistributeTo")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactMethod(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DistributeTo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DistributeTo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DistributeTo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactMethod(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DistributeTo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DistributeTo", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DistributeTo) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DistributeTo", sizeof("DistributeTo")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DistributeTo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DistributeTo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DistributeTo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DistributeTo(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DistributeTo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DistributeTo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DistributeTo(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DoingBusinessAs
#define EL_STRUCT zx_hrxml_DoingBusinessAs_s
#define EL_NS     hrxml
#define EL_TAG    DoingBusinessAs

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DoingBusinessAs) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DoingBusinessAs")-1 + 1 + sizeof("</hrxml:DoingBusinessAs>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DoingBusinessAs", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DoingBusinessAs) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DoingBusinessAs")-1 + 1 + 2 + sizeof("DoingBusinessAs")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->lang, sizeof("lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DoingBusinessAs", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DoingBusinessAs) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DoingBusinessAs");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DoingBusinessAs>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DoingBusinessAs", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DoingBusinessAs) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DoingBusinessAs", sizeof("DoingBusinessAs")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->lang, "lang=\"", sizeof("lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DoingBusinessAs", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DoingBusinessAs) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DoingBusinessAs(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DoingBusinessAs(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DoingBusinessAs) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DoingBusinessAs(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DoingBusinessAs(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DressCode
#define EL_STRUCT zx_hrxml_DressCode_s
#define EL_NS     hrxml
#define EL_TAG    DressCode

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DressCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DressCode")-1 + 1 + sizeof("</hrxml:DressCode>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->suppliedByOrganization, sizeof("suppliedByOrganization")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DressCode", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DressCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DressCode")-1 + 1 + 2 + sizeof("DressCode")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->suppliedByOrganization, sizeof("suppliedByOrganization")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DressCode", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DressCode) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DressCode");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->suppliedByOrganization, " suppliedByOrganization=\"", sizeof(" suppliedByOrganization=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DressCode>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DressCode", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DressCode) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DressCode", sizeof("DressCode")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->suppliedByOrganization, "suppliedByOrganization=\"", sizeof("suppliedByOrganization=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DressCode", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DressCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DressCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DressCode(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DressCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DressCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DressCode(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DunsNumber
#define EL_STRUCT zx_hrxml_DunsNumber_s
#define EL_NS     hrxml
#define EL_TAG    DunsNumber

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DunsNumber) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DunsNumber")-1 + 1 + sizeof("</hrxml:DunsNumber>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dunsNumberType, sizeof("dunsNumberType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DunsNumber", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_DunsNumber) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("DunsNumber")-1 + 1 + 2 + sizeof("DunsNumber")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dunsNumberType, sizeof("dunsNumberType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DunsNumber", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DunsNumber) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DunsNumber");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dunsNumberType, " dunsNumberType=\"", sizeof(" dunsNumberType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DunsNumber>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DunsNumber", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_DunsNumber) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "DunsNumber", sizeof("DunsNumber")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dunsNumberType, "dunsNumberType=\"", sizeof("dunsNumberType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DunsNumber", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DunsNumber) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DunsNumber(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DunsNumber(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_DunsNumber) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_DunsNumber(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_DunsNumber(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EEOCJobCategory
#define EL_STRUCT zx_hrxml_EEOCJobCategory_s
#define EL_NS     hrxml
#define EL_TAG    EEOCJobCategory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EEOCJobCategory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EEOCJobCategory")-1 + 1 + sizeof("</hrxml:EEOCJobCategory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->StandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StandardValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->NonStandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:NonStandardValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EEOCJobCategory", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EEOCJobCategory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EEOCJobCategory")-1 + 1 + 2 + sizeof("EEOCJobCategory")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->StandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StandardValue")-1);
  for (se = x->NonStandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("NonStandardValue")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EEOCJobCategory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EEOCJobCategory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EEOCJobCategory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->StandardValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StandardValue", sizeof("hrxml:StandardValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->NonStandardValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:NonStandardValue", sizeof("hrxml:NonStandardValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EEOCJobCategory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EEOCJobCategory", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EEOCJobCategory) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EEOCJobCategory", sizeof("EEOCJobCategory")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EEOCJobCategory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EEOCJobCategory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EEOCJobCategory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EEOCJobCategory(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EEOCJobCategory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EEOCJobCategory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EEOCJobCategory(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EducationHistory
#define EL_STRUCT zx_hrxml_EducationHistory_s
#define EL_NS     hrxml
#define EL_TAG    EducationHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EducationHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EducationHistory")-1 + 1 + sizeof("</hrxml:EducationHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SchoolOrInstitution_s* e;
      for (e = x->SchoolOrInstitution; e; e = (struct zx_hrxml_SchoolOrInstitution_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SchoolOrInstitution(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EducationHistory", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EducationHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EducationHistory")-1 + 1 + 2 + sizeof("EducationHistory")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SchoolOrInstitution_s* e;
      for (e = x->SchoolOrInstitution; e; e = (struct zx_hrxml_SchoolOrInstitution_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SchoolOrInstitution(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EducationHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EducationHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EducationHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_SchoolOrInstitution_s* e;
      for (e = x->SchoolOrInstitution; e; e = (struct zx_hrxml_SchoolOrInstitution_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SchoolOrInstitution(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EducationHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EducationHistory", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EducationHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EducationHistory", sizeof("EducationHistory")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EducationHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EducationHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EducationHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EducationHistory(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EducationHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EducationHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EducationHistory(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EducationalMeasure
#define EL_STRUCT zx_hrxml_EducationalMeasure_s
#define EL_NS     hrxml
#define EL_TAG    EducationalMeasure

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EducationalMeasure) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EducationalMeasure")-1 + 1 + sizeof("</hrxml:EducationalMeasure>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->MeasureSystem; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MeasureSystem")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MeasureValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MeasureValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_LowestPossibleValue_s* e;
      for (e = x->LowestPossibleValue; e; e = (struct zx_hrxml_LowestPossibleValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LowestPossibleValue(c, e);
  }
  {
      struct zx_hrxml_HighestPossibleValue_s* e;
      for (e = x->HighestPossibleValue; e; e = (struct zx_hrxml_HighestPossibleValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_HighestPossibleValue(c, e);
  }
  for (se = x->ExcessiveValueIndicator; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ExcessiveValueIndicator")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->GoodStudentIndicator; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:GoodStudentIndicator")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EducationalMeasure", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EducationalMeasure) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EducationalMeasure")-1 + 1 + 2 + sizeof("EducationalMeasure")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->MeasureSystem; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MeasureSystem")-1);
  for (se = x->MeasureValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MeasureValue")-1);
  {
      struct zx_hrxml_LowestPossibleValue_s* e;
      for (e = x->LowestPossibleValue; e; e = (struct zx_hrxml_LowestPossibleValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LowestPossibleValue(c, e);
  }
  {
      struct zx_hrxml_HighestPossibleValue_s* e;
      for (e = x->HighestPossibleValue; e; e = (struct zx_hrxml_HighestPossibleValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_HighestPossibleValue(c, e);
  }
  for (se = x->ExcessiveValueIndicator; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ExcessiveValueIndicator")-1);
  for (se = x->GoodStudentIndicator; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("GoodStudentIndicator")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EducationalMeasure", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EducationalMeasure) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EducationalMeasure");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->MeasureSystem; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MeasureSystem", sizeof("hrxml:MeasureSystem")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MeasureValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MeasureValue", sizeof("hrxml:MeasureValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_LowestPossibleValue_s* e;
      for (e = x->LowestPossibleValue; e; e = (struct zx_hrxml_LowestPossibleValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LowestPossibleValue(c, e, p);
  }
  {
      struct zx_hrxml_HighestPossibleValue_s* e;
      for (e = x->HighestPossibleValue; e; e = (struct zx_hrxml_HighestPossibleValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_HighestPossibleValue(c, e, p);
  }
  for (se = x->ExcessiveValueIndicator; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ExcessiveValueIndicator", sizeof("hrxml:ExcessiveValueIndicator")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->GoodStudentIndicator; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:GoodStudentIndicator", sizeof("hrxml:GoodStudentIndicator")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EducationalMeasure>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EducationalMeasure", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EducationalMeasure) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EducationalMeasure", sizeof("EducationalMeasure")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EducationalMeasure", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EducationalMeasure) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EducationalMeasure(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EducationalMeasure(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EducationalMeasure) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EducationalMeasure(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EducationalMeasure(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EffectiveDate
#define EL_STRUCT zx_hrxml_EffectiveDate_s
#define EL_NS     hrxml
#define EL_TAG    EffectiveDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EffectiveDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EffectiveDate")-1 + 1 + sizeof("</hrxml:EffectiveDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EndDate(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EffectiveDate", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EffectiveDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EffectiveDate")-1 + 1 + 2 + sizeof("EffectiveDate")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EndDate(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EffectiveDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EffectiveDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EffectiveDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StartDate(c, e, p);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EndDate(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EffectiveDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EffectiveDate", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EffectiveDate) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EffectiveDate", sizeof("EffectiveDate")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EffectiveDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EffectiveDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EffectiveDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EffectiveDate(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EffectiveDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EffectiveDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EffectiveDate(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EmployerContactInfo
#define EL_STRUCT zx_hrxml_EmployerContactInfo_s
#define EL_NS     hrxml
#define EL_TAG    EmployerContactInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EmployerContactInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EmployerContactInfo")-1 + 1 + sizeof("</hrxml:EmployerContactInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->contactType, sizeof("contactType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonName(c, e);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactMethod(c, e);
  }
  {
      struct zx_hrxml_LocationSummary_s* e;
      for (e = x->LocationSummary; e; e = (struct zx_hrxml_LocationSummary_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LocationSummary(c, e);
  }
  {
      struct zx_hrxml_InternetDomainName_s* e;
      for (e = x->InternetDomainName; e; e = (struct zx_hrxml_InternetDomainName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_InternetDomainName(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EmployerContactInfo", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EmployerContactInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EmployerContactInfo")-1 + 1 + 2 + sizeof("EmployerContactInfo")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->contactType, sizeof("contactType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonName(c, e);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactMethod(c, e);
  }
  {
      struct zx_hrxml_LocationSummary_s* e;
      for (e = x->LocationSummary; e; e = (struct zx_hrxml_LocationSummary_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LocationSummary(c, e);
  }
  {
      struct zx_hrxml_InternetDomainName_s* e;
      for (e = x->InternetDomainName; e; e = (struct zx_hrxml_InternetDomainName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_InternetDomainName(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EmployerContactInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EmployerContactInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EmployerContactInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->contactType, " contactType=\"", sizeof(" contactType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonName(c, e, p);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactMethod(c, e, p);
  }
  {
      struct zx_hrxml_LocationSummary_s* e;
      for (e = x->LocationSummary; e; e = (struct zx_hrxml_LocationSummary_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LocationSummary(c, e, p);
  }
  {
      struct zx_hrxml_InternetDomainName_s* e;
      for (e = x->InternetDomainName; e; e = (struct zx_hrxml_InternetDomainName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_InternetDomainName(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EmployerContactInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EmployerContactInfo", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EmployerContactInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EmployerContactInfo", sizeof("EmployerContactInfo")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->contactType, "contactType=\"", sizeof("contactType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EmployerContactInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EmployerContactInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EmployerContactInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EmployerContactInfo(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EmployerContactInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EmployerContactInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EmployerContactInfo(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EmployerOrg
#define EL_STRUCT zx_hrxml_EmployerOrg_s
#define EL_NS     hrxml
#define EL_TAG    EmployerOrg

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EmployerOrg) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EmployerOrg")-1 + 1 + sizeof("</hrxml:EmployerOrg>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->employerOrgType, sizeof("employerOrgType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->EmployerOrgName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EmployerOrgName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_EmployerContactInfo_s* e;
      for (e = x->EmployerContactInfo; e; e = (struct zx_hrxml_EmployerContactInfo_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EmployerContactInfo(c, e);
  }
  {
      struct zx_hrxml_PositionHistory_s* e;
      for (e = x->PositionHistory; e; e = (struct zx_hrxml_PositionHistory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PositionHistory(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EmployerOrg", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EmployerOrg) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EmployerOrg")-1 + 1 + 2 + sizeof("EmployerOrg")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->employerOrgType, sizeof("employerOrgType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->EmployerOrgName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("EmployerOrgName")-1);
  {
      struct zx_hrxml_EmployerContactInfo_s* e;
      for (e = x->EmployerContactInfo; e; e = (struct zx_hrxml_EmployerContactInfo_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EmployerContactInfo(c, e);
  }
  {
      struct zx_hrxml_PositionHistory_s* e;
      for (e = x->PositionHistory; e; e = (struct zx_hrxml_PositionHistory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PositionHistory(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EmployerOrg", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EmployerOrg) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EmployerOrg");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->employerOrgType, " employerOrgType=\"", sizeof(" employerOrgType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->EmployerOrgName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EmployerOrgName", sizeof("hrxml:EmployerOrgName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_EmployerContactInfo_s* e;
      for (e = x->EmployerContactInfo; e; e = (struct zx_hrxml_EmployerContactInfo_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EmployerContactInfo(c, e, p);
  }
  {
      struct zx_hrxml_PositionHistory_s* e;
      for (e = x->PositionHistory; e; e = (struct zx_hrxml_PositionHistory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PositionHistory(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EmployerOrg>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EmployerOrg", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EmployerOrg) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EmployerOrg", sizeof("EmployerOrg")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->employerOrgType, "employerOrgType=\"", sizeof("employerOrgType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EmployerOrg", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EmployerOrg) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EmployerOrg(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EmployerOrg(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EmployerOrg) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EmployerOrg(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EmployerOrg(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EmploymentHistory
#define EL_STRUCT zx_hrxml_EmploymentHistory_s
#define EL_NS     hrxml
#define EL_TAG    EmploymentHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EmploymentHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EmploymentHistory")-1 + 1 + sizeof("</hrxml:EmploymentHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_EmployerOrg_s* e;
      for (e = x->EmployerOrg; e; e = (struct zx_hrxml_EmployerOrg_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EmployerOrg(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EmploymentHistory", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EmploymentHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EmploymentHistory")-1 + 1 + 2 + sizeof("EmploymentHistory")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_EmployerOrg_s* e;
      for (e = x->EmployerOrg; e; e = (struct zx_hrxml_EmployerOrg_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EmployerOrg(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EmploymentHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EmploymentHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EmploymentHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_EmployerOrg_s* e;
      for (e = x->EmployerOrg; e; e = (struct zx_hrxml_EmployerOrg_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EmployerOrg(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EmploymentHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EmploymentHistory", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EmploymentHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EmploymentHistory", sizeof("EmploymentHistory")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EmploymentHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EmploymentHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EmploymentHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EmploymentHistory(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EmploymentHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EmploymentHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EmploymentHistory(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EndDate
#define EL_STRUCT zx_hrxml_EndDate_s
#define EL_NS     hrxml
#define EL_TAG    EndDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EndDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EndDate")-1 + 1 + sizeof("</hrxml:EndDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EndDate", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EndDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EndDate")-1 + 1 + 2 + sizeof("EndDate")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AnyDate")-1);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("YearMonth")-1);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Year")-1);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDay")-1);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StringDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EndDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EndDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EndDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EndDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EndDate", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EndDate) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EndDate", sizeof("EndDate")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateDescription, "dateDescription=\"", sizeof("dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EndDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EndDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EndDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EndDate(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EndDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EndDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EndDate(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EndingCompensation
#define EL_STRUCT zx_hrxml_EndingCompensation_s
#define EL_NS     hrxml
#define EL_TAG    EndingCompensation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EndingCompensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EndingCompensation")-1 + 1 + sizeof("</hrxml:EndingCompensation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->currency, sizeof("currency")-1, &pop_seen);
  len += zx_attr_so_len(c, x->intervalType, sizeof("intervalType")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EndingCompensation", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EndingCompensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EndingCompensation")-1 + 1 + 2 + sizeof("EndingCompensation")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->currency, sizeof("currency")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->intervalType, sizeof("intervalType")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EndingCompensation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EndingCompensation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EndingCompensation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->currency, " currency=\"", sizeof(" currency=\"")-1);
  p = zx_attr_so_enc(p, x->intervalType, " intervalType=\"", sizeof(" intervalType=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EndingCompensation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EndingCompensation", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EndingCompensation) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EndingCompensation", sizeof("EndingCompensation")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->currency, "currency=\"", sizeof("currency=\"")-1);
  p = zx_attr_wo_enc(p, x->intervalType, "intervalType=\"", sizeof("intervalType=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EndingCompensation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EndingCompensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EndingCompensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EndingCompensation(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EndingCompensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EndingCompensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EndingCompensation(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EnvironmentId
#define EL_STRUCT zx_hrxml_EnvironmentId_s
#define EL_NS     hrxml
#define EL_TAG    EnvironmentId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EnvironmentId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EnvironmentId")-1 + 1 + sizeof("</hrxml:EnvironmentId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EnvironmentId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EnvironmentId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EnvironmentId")-1 + 1 + 2 + sizeof("EnvironmentId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EnvironmentId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EnvironmentId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EnvironmentId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EnvironmentId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EnvironmentId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EnvironmentId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EnvironmentId", sizeof("EnvironmentId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EnvironmentId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EnvironmentId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EnvironmentId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EnvironmentId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EnvironmentId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EnvironmentId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EnvironmentId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EvidenceId
#define EL_STRUCT zx_hrxml_EvidenceId_s
#define EL_NS     hrxml
#define EL_TAG    EvidenceId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EvidenceId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EvidenceId")-1 + 1 + sizeof("</hrxml:EvidenceId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EvidenceId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_EvidenceId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("EvidenceId")-1 + 1 + 2 + sizeof("EvidenceId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->id, sizeof("id")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EvidenceId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EvidenceId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EvidenceId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->id, " id=\"", sizeof(" id=\"")-1);
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EvidenceId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EvidenceId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_EvidenceId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "EvidenceId", sizeof("EvidenceId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->description, "description=\"", sizeof("description=\"")-1);
  p = zx_attr_wo_enc(p, x->id, "id=\"", sizeof("id=\"")-1);
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EvidenceId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EvidenceId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EvidenceId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EvidenceId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_EvidenceId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_EvidenceId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_EvidenceId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ExpatriateBenefits
#define EL_STRUCT zx_hrxml_ExpatriateBenefits_s
#define EL_NS     hrxml
#define EL_TAG    ExpatriateBenefits

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ExpatriateBenefits) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ExpatriateBenefits")-1 + 1 + sizeof("</hrxml:ExpatriateBenefits>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->ExpatriateBenefitsOffered; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ExpatriateBenefitsOffered")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ExpatriateBenefitList; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ExpatriateBenefitList")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ExpatriateBenefits", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ExpatriateBenefits) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ExpatriateBenefits")-1 + 1 + 2 + sizeof("ExpatriateBenefits")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->ExpatriateBenefitsOffered; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ExpatriateBenefitsOffered")-1);
  for (se = x->ExpatriateBenefitList; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ExpatriateBenefitList")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ExpatriateBenefits", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ExpatriateBenefits) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ExpatriateBenefits");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->ExpatriateBenefitsOffered; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ExpatriateBenefitsOffered", sizeof("hrxml:ExpatriateBenefitsOffered")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ExpatriateBenefitList; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ExpatriateBenefitList", sizeof("hrxml:ExpatriateBenefitList")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ExpatriateBenefits>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ExpatriateBenefits", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ExpatriateBenefits) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ExpatriateBenefits", sizeof("ExpatriateBenefits")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ExpatriateBenefits", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ExpatriateBenefits) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ExpatriateBenefits(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ExpatriateBenefits(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ExpatriateBenefits) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ExpatriateBenefits(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ExpatriateBenefits(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_FamilyName
#define EL_STRUCT zx_hrxml_FamilyName_s
#define EL_NS     hrxml
#define EL_TAG    FamilyName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_FamilyName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:FamilyName")-1 + 1 + sizeof("</hrxml:FamilyName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->prefix, sizeof("prefix")-1, &pop_seen);
  len += zx_attr_so_len(c, x->primary, sizeof("primary")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:FamilyName", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_FamilyName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("FamilyName")-1 + 1 + 2 + sizeof("FamilyName")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->prefix, sizeof("prefix")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->primary, sizeof("primary")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:FamilyName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_FamilyName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:FamilyName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->prefix, " prefix=\"", sizeof(" prefix=\"")-1);
  p = zx_attr_so_enc(p, x->primary, " primary=\"", sizeof(" primary=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:FamilyName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:FamilyName", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_FamilyName) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "FamilyName", sizeof("FamilyName")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->prefix, "prefix=\"", sizeof("prefix=\"")-1);
  p = zx_attr_wo_enc(p, x->primary, "primary=\"", sizeof("primary=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:FamilyName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_FamilyName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_FamilyName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_FamilyName(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_FamilyName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_FamilyName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_FamilyName(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Fax
#define EL_STRUCT zx_hrxml_Fax_s
#define EL_NS     hrxml
#define EL_TAG    Fax

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Fax) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Fax")-1 + 1 + sizeof("</hrxml:Fax>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Fax", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Fax) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Fax")-1 + 1 + 2 + sizeof("Fax")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("FormattedNumber")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Fax", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Fax) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Fax");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedNumber", sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Fax>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Fax", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Fax) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Fax", sizeof("Fax")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Fax", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Fax) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Fax(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Fax(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Fax) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Fax(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Fax(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_FirstIssuedDate
#define EL_STRUCT zx_hrxml_FirstIssuedDate_s
#define EL_NS     hrxml
#define EL_TAG    FirstIssuedDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_FirstIssuedDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:FirstIssuedDate")-1 + 1 + sizeof("</hrxml:FirstIssuedDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:FirstIssuedDate", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_FirstIssuedDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("FirstIssuedDate")-1 + 1 + 2 + sizeof("FirstIssuedDate")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AnyDate")-1);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("YearMonth")-1);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Year")-1);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDay")-1);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StringDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:FirstIssuedDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_FirstIssuedDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:FirstIssuedDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:FirstIssuedDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:FirstIssuedDate", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_FirstIssuedDate) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "FirstIssuedDate", sizeof("FirstIssuedDate")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateDescription, "dateDescription=\"", sizeof("dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:FirstIssuedDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_FirstIssuedDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_FirstIssuedDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_FirstIssuedDate(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_FirstIssuedDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_FirstIssuedDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_FirstIssuedDate(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_FormattedPublicationDescription
#define EL_STRUCT zx_hrxml_FormattedPublicationDescription_s
#define EL_NS     hrxml
#define EL_TAG    FormattedPublicationDescription

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_FormattedPublicationDescription) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:FormattedPublicationDescription")-1 + 1 + sizeof("</hrxml:FormattedPublicationDescription>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:FormattedPublicationDescription", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_FormattedPublicationDescription) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("FormattedPublicationDescription")-1 + 1 + 2 + sizeof("FormattedPublicationDescription")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:FormattedPublicationDescription", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_FormattedPublicationDescription) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:FormattedPublicationDescription");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:FormattedPublicationDescription>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:FormattedPublicationDescription", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_FormattedPublicationDescription) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "FormattedPublicationDescription", sizeof("FormattedPublicationDescription")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:FormattedPublicationDescription", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_FormattedPublicationDescription) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_FormattedPublicationDescription(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_FormattedPublicationDescription(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_FormattedPublicationDescription) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_FormattedPublicationDescription(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_FormattedPublicationDescription(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Height
#define EL_STRUCT zx_hrxml_Height_s
#define EL_NS     hrxml
#define EL_TAG    Height

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Height) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Height")-1 + 1 + sizeof("</hrxml:Height>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Height", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Height) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Height")-1 + 1 + 2 + sizeof("Height")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Height", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Height) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Height");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->unitOfMeasure, " unitOfMeasure=\"", sizeof(" unitOfMeasure=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Height>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Height", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Height) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Height", sizeof("Height")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->unitOfMeasure, "unitOfMeasure=\"", sizeof("unitOfMeasure=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Height", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Height) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Height(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Height(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Height) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Height(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Height(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_HighestPossibleValue
#define EL_STRUCT zx_hrxml_HighestPossibleValue_s
#define EL_NS     hrxml
#define EL_TAG    HighestPossibleValue

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_HighestPossibleValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:HighestPossibleValue")-1 + 1 + sizeof("</hrxml:HighestPossibleValue>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_NumericValue(c, e);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StringValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:HighestPossibleValue", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_HighestPossibleValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("HighestPossibleValue")-1 + 1 + 2 + sizeof("HighestPossibleValue")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_NumericValue(c, e);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StringValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:HighestPossibleValue", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_HighestPossibleValue) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:HighestPossibleValue");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_NumericValue(c, e, p);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StringValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:HighestPossibleValue>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:HighestPossibleValue", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_HighestPossibleValue) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "HighestPossibleValue", sizeof("HighestPossibleValue")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:HighestPossibleValue", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_HighestPossibleValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_HighestPossibleValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_HighestPossibleValue(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_HighestPossibleValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_HighestPossibleValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_HighestPossibleValue(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_HorizontalAccuracy
#define EL_STRUCT zx_hrxml_HorizontalAccuracy_s
#define EL_NS     hrxml
#define EL_TAG    HorizontalAccuracy

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_HorizontalAccuracy) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:HorizontalAccuracy")-1 + 1 + sizeof("</hrxml:HorizontalAccuracy>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:HorizontalAccuracy", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_HorizontalAccuracy) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("HorizontalAccuracy")-1 + 1 + 2 + sizeof("HorizontalAccuracy")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:HorizontalAccuracy", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_HorizontalAccuracy) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:HorizontalAccuracy");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:HorizontalAccuracy>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:HorizontalAccuracy", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_HorizontalAccuracy) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "HorizontalAccuracy", sizeof("HorizontalAccuracy")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:HorizontalAccuracy", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_HorizontalAccuracy) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_HorizontalAccuracy(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_HorizontalAccuracy(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_HorizontalAccuracy) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_HorizontalAccuracy(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_HorizontalAccuracy(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Id
#define EL_STRUCT zx_hrxml_Id_s
#define EL_NS     hrxml
#define EL_TAG    Id

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Id) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Id")-1 + 1 + sizeof("</hrxml:Id>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Id", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Id) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Id")-1 + 1 + 2 + sizeof("Id")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Id", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Id) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Id");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Id>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Id", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Id) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Id", sizeof("Id")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Id", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Id) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Id(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Id(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Id) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Id(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Id(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_IdValue
#define EL_STRUCT zx_hrxml_IdValue_s
#define EL_NS     hrxml
#define EL_TAG    IdValue

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_IdValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:IdValue")-1 + 1 + sizeof("</hrxml:IdValue>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->name, sizeof("name")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:IdValue", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_IdValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("IdValue")-1 + 1 + 2 + sizeof("IdValue")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->name, sizeof("name")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:IdValue", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_IdValue) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:IdValue");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->name, " name=\"", sizeof(" name=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:IdValue>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:IdValue", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_IdValue) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "IdValue", sizeof("IdValue")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->name, "name=\"", sizeof("name=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:IdValue", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_IdValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_IdValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_IdValue(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_IdValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_IdValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_IdValue(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_IndustryCode
#define EL_STRUCT zx_hrxml_IndustryCode_s
#define EL_NS     hrxml
#define EL_TAG    IndustryCode

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_IndustryCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:IndustryCode")-1 + 1 + sizeof("</hrxml:IndustryCode>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->classificationName, sizeof("classificationName")-1, &pop_seen);
  len += zx_attr_so_len(c, x->primaryIndicator, sizeof("primaryIndicator")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:IndustryCode", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_IndustryCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("IndustryCode")-1 + 1 + 2 + sizeof("IndustryCode")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->classificationName, sizeof("classificationName")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->primaryIndicator, sizeof("primaryIndicator")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:IndustryCode", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_IndustryCode) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:IndustryCode");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->classificationName, " classificationName=\"", sizeof(" classificationName=\"")-1);
  p = zx_attr_so_enc(p, x->primaryIndicator, " primaryIndicator=\"", sizeof(" primaryIndicator=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:IndustryCode>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:IndustryCode", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_IndustryCode) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "IndustryCode", sizeof("IndustryCode")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->classificationName, "classificationName=\"", sizeof("classificationName=\"")-1);
  p = zx_attr_wo_enc(p, x->primaryIndicator, "primaryIndicator=\"", sizeof("primaryIndicator=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:IndustryCode", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_IndustryCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_IndustryCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_IndustryCode(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_IndustryCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_IndustryCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_IndustryCode(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Insurance
#define EL_STRUCT zx_hrxml_Insurance_s
#define EL_NS     hrxml
#define EL_TAG    Insurance

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Insurance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Insurance")-1 + 1 + sizeof("</hrxml:Insurance>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Insurance", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Insurance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Insurance")-1 + 1 + 2 + sizeof("Insurance")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Insurance", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Insurance) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Insurance");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Insurance>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Insurance", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Insurance) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Insurance", sizeof("Insurance")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Insurance", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Insurance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Insurance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Insurance(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Insurance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Insurance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Insurance(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_InternetDomainName
#define EL_STRUCT zx_hrxml_InternetDomainName_s
#define EL_NS     hrxml
#define EL_TAG    InternetDomainName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_InternetDomainName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:InternetDomainName")-1 + 1 + sizeof("</hrxml:InternetDomainName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->primaryIndicator, sizeof("primaryIndicator")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:InternetDomainName", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_InternetDomainName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("InternetDomainName")-1 + 1 + 2 + sizeof("InternetDomainName")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->primaryIndicator, sizeof("primaryIndicator")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:InternetDomainName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_InternetDomainName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:InternetDomainName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->primaryIndicator, " primaryIndicator=\"", sizeof(" primaryIndicator=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:InternetDomainName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:InternetDomainName", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_InternetDomainName) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "InternetDomainName", sizeof("InternetDomainName")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->primaryIndicator, "primaryIndicator=\"", sizeof("primaryIndicator=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:InternetDomainName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_InternetDomainName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_InternetDomainName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_InternetDomainName(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_InternetDomainName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_InternetDomainName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_InternetDomainName(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Inventors
#define EL_STRUCT zx_hrxml_Inventors_s
#define EL_NS     hrxml
#define EL_TAG    Inventors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Inventors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Inventors")-1 + 1 + sizeof("</hrxml:Inventors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->InventorName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:InventorName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Inventors", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Inventors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Inventors")-1 + 1 + 2 + sizeof("Inventors")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->InventorName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("InventorName")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Inventors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Inventors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Inventors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->InventorName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:InventorName", sizeof("hrxml:InventorName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Inventors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Inventors", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Inventors) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Inventors", sizeof("Inventors")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Inventors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Inventors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Inventors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Inventors(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Inventors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Inventors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Inventors(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_IssuingAuthority
#define EL_STRUCT zx_hrxml_IssuingAuthority_s
#define EL_NS     hrxml
#define EL_TAG    IssuingAuthority

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_IssuingAuthority) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:IssuingAuthority")-1 + 1 + sizeof("</hrxml:IssuingAuthority>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:IssuingAuthority", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_IssuingAuthority) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("IssuingAuthority")-1 + 1 + 2 + sizeof("IssuingAuthority")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:IssuingAuthority", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_IssuingAuthority) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:IssuingAuthority");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->countryCode, " countryCode=\"", sizeof(" countryCode=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:IssuingAuthority>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:IssuingAuthority", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_IssuingAuthority) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "IssuingAuthority", sizeof("IssuingAuthority")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->countryCode, "countryCode=\"", sizeof("countryCode=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:IssuingAuthority", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_IssuingAuthority) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_IssuingAuthority(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_IssuingAuthority(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_IssuingAuthority) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_IssuingAuthority(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_IssuingAuthority(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_JobCategory
#define EL_STRUCT zx_hrxml_JobCategory_s
#define EL_NS     hrxml
#define EL_TAG    JobCategory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_JobCategory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:JobCategory")-1 + 1 + sizeof("</hrxml:JobCategory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_TaxonomyName_s* e;
      for (e = x->TaxonomyName; e; e = (struct zx_hrxml_TaxonomyName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_TaxonomyName(c, e);
  }
  for (se = x->CategoryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CategoryCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CategoryDescription; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CategoryDescription")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_JobCategory(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:JobCategory", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_JobCategory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("JobCategory")-1 + 1 + 2 + sizeof("JobCategory")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_TaxonomyName_s* e;
      for (e = x->TaxonomyName; e; e = (struct zx_hrxml_TaxonomyName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_TaxonomyName(c, e);
  }
  for (se = x->CategoryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CategoryCode")-1);
  for (se = x->CategoryDescription; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CategoryDescription")-1);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_JobCategory(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:JobCategory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_JobCategory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:JobCategory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_TaxonomyName_s* e;
      for (e = x->TaxonomyName; e; e = (struct zx_hrxml_TaxonomyName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_TaxonomyName(c, e, p);
  }
  for (se = x->CategoryCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CategoryCode", sizeof("hrxml:CategoryCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CategoryDescription; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CategoryDescription", sizeof("hrxml:CategoryDescription")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_JobCategory(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:JobCategory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:JobCategory", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_JobCategory) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "JobCategory", sizeof("JobCategory")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:JobCategory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_JobCategory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_JobCategory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_JobCategory(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_JobCategory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_JobCategory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_JobCategory(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_JobLevelInfo
#define EL_STRUCT zx_hrxml_JobLevelInfo_s
#define EL_NS     hrxml
#define EL_TAG    JobLevelInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_JobLevelInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:JobLevelInfo")-1 + 1 + sizeof("</hrxml:JobLevelInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->JobPlan; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:JobPlan")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->JobGrade; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:JobGrade")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->JobStep; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:JobStep")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:JobLevelInfo", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_JobLevelInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("JobLevelInfo")-1 + 1 + 2 + sizeof("JobLevelInfo")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->JobPlan; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("JobPlan")-1);
  for (se = x->JobGrade; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("JobGrade")-1);
  for (se = x->JobStep; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("JobStep")-1);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:JobLevelInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_JobLevelInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:JobLevelInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->JobPlan; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:JobPlan", sizeof("hrxml:JobPlan")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->JobGrade; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:JobGrade", sizeof("hrxml:JobGrade")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->JobStep; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:JobStep", sizeof("hrxml:JobStep")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:JobLevelInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:JobLevelInfo", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_JobLevelInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "JobLevelInfo", sizeof("JobLevelInfo")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:JobLevelInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_JobLevelInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_JobLevelInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_JobLevelInfo(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_JobLevelInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_JobLevelInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_JobLevelInfo(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Language
#define EL_STRUCT zx_hrxml_Language_s
#define EL_NS     hrxml
#define EL_TAG    Language

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Language) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Language")-1 + 1 + sizeof("</hrxml:Language>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_LanguageCode_s* e;
      for (e = x->LanguageCode; e; e = (struct zx_hrxml_LanguageCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LanguageCode(c, e);
  }
  for (se = x->Read; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Read")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Write; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Write")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Speak; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Speak")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Language", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Language) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Language")-1 + 1 + 2 + sizeof("Language")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_LanguageCode_s* e;
      for (e = x->LanguageCode; e; e = (struct zx_hrxml_LanguageCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LanguageCode(c, e);
  }
  for (se = x->Read; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Read")-1);
  for (se = x->Write; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Write")-1);
  for (se = x->Speak; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Speak")-1);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Language", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Language) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Language");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_LanguageCode_s* e;
      for (e = x->LanguageCode; e; e = (struct zx_hrxml_LanguageCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LanguageCode(c, e, p);
  }
  for (se = x->Read; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Read", sizeof("hrxml:Read")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Write; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Write", sizeof("hrxml:Write")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Speak; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Speak", sizeof("hrxml:Speak")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Language>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Language", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Language) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Language", sizeof("Language")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Language", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Language) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Language(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Language(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Language) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Language(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Language(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LanguageCode
#define EL_STRUCT zx_hrxml_LanguageCode_s
#define EL_NS     hrxml
#define EL_TAG    LanguageCode

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LanguageCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LanguageCode")-1 + 1 + sizeof("</hrxml:LanguageCode>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LanguageCode", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_LanguageCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("LanguageCode")-1 + 1 + 2 + sizeof("LanguageCode")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LanguageCode", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LanguageCode) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LanguageCode");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LanguageCode>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LanguageCode", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_LanguageCode) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "LanguageCode", sizeof("LanguageCode")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LanguageCode", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LanguageCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LanguageCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LanguageCode(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_LanguageCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_LanguageCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_LanguageCode(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Languages
#define EL_STRUCT zx_hrxml_Languages_s
#define EL_NS     hrxml
#define EL_TAG    Languages

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Languages) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Languages")-1 + 1 + sizeof("</hrxml:Languages>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Language_s* e;
      for (e = x->Language; e; e = (struct zx_hrxml_Language_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Language(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Languages", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Languages) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Languages")-1 + 1 + 2 + sizeof("Languages")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Language_s* e;
      for (e = x->Language; e; e = (struct zx_hrxml_Language_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Language(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Languages", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Languages) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Languages");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Language_s* e;
      for (e = x->Language; e; e = (struct zx_hrxml_Language_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Language(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Languages>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Languages", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Languages) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Languages", sizeof("Languages")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Languages", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Languages) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Languages(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Languages(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Languages) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Languages(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Languages(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Latitude
#define EL_STRUCT zx_hrxml_Latitude_s
#define EL_NS     hrxml
#define EL_TAG    Latitude

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Latitude) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Latitude")-1 + 1 + sizeof("</hrxml:Latitude>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Latitude", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Latitude) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Latitude")-1 + 1 + 2 + sizeof("Latitude")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Latitude", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Latitude) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Latitude");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Latitude>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Latitude", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Latitude) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Latitude", sizeof("Latitude")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Latitude", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Latitude) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Latitude(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Latitude(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Latitude) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Latitude(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Latitude(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LegalClassification
#define EL_STRUCT zx_hrxml_LegalClassification_s
#define EL_NS     hrxml
#define EL_TAG    LegalClassification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LegalClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LegalClassification")-1 + 1 + sizeof("</hrxml:LegalClassification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ownership, sizeof("ownership")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LegalClassification", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_LegalClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("LegalClassification")-1 + 1 + 2 + sizeof("LegalClassification")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->ownership, sizeof("ownership")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LegalClassification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LegalClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LegalClassification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->countryCode, " countryCode=\"", sizeof(" countryCode=\"")-1);
  p = zx_attr_so_enc(p, x->ownership, " ownership=\"", sizeof(" ownership=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LegalClassification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LegalClassification", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_LegalClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "LegalClassification", sizeof("LegalClassification")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->countryCode, "countryCode=\"", sizeof("countryCode=\"")-1);
  p = zx_attr_wo_enc(p, x->ownership, "ownership=\"", sizeof("ownership=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LegalClassification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LegalClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LegalClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LegalClassification(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_LegalClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_LegalClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_LegalClassification(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LegalId
#define EL_STRUCT zx_hrxml_LegalId_s
#define EL_NS     hrxml
#define EL_TAG    LegalId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LegalId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LegalId")-1 + 1 + sizeof("</hrxml:LegalId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LegalId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_LegalId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("LegalId")-1 + 1 + 2 + sizeof("LegalId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LegalId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LegalId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LegalId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LegalId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LegalId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_LegalId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "LegalId", sizeof("LegalId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LegalId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LegalId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LegalId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LegalId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_LegalId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_LegalId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_LegalId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LegalIdentifiers
#define EL_STRUCT zx_hrxml_LegalIdentifiers_s
#define EL_NS     hrxml
#define EL_TAG    LegalIdentifiers

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LegalIdentifiers) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LegalIdentifiers")-1 + 1 + sizeof("</hrxml:LegalIdentifiers>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonLegalId_s* e;
      for (e = x->PersonLegalId; e; e = (struct zx_hrxml_PersonLegalId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonLegalId(c, e);
  }
  {
      struct zx_hrxml_MilitaryStatus_s* e;
      for (e = x->MilitaryStatus; e; e = (struct zx_hrxml_MilitaryStatus_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_MilitaryStatus(c, e);
  }
  {
      struct zx_hrxml_VisaStatus_s* e;
      for (e = x->VisaStatus; e; e = (struct zx_hrxml_VisaStatus_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_VisaStatus(c, e);
  }
  for (se = x->Citizenship; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Citizenship")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Residency; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Residency")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LegalIdentifiers", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_LegalIdentifiers) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("LegalIdentifiers")-1 + 1 + 2 + sizeof("LegalIdentifiers")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonLegalId_s* e;
      for (e = x->PersonLegalId; e; e = (struct zx_hrxml_PersonLegalId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonLegalId(c, e);
  }
  {
      struct zx_hrxml_MilitaryStatus_s* e;
      for (e = x->MilitaryStatus; e; e = (struct zx_hrxml_MilitaryStatus_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_MilitaryStatus(c, e);
  }
  {
      struct zx_hrxml_VisaStatus_s* e;
      for (e = x->VisaStatus; e; e = (struct zx_hrxml_VisaStatus_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_VisaStatus(c, e);
  }
  for (se = x->Citizenship; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Citizenship")-1);
  for (se = x->Residency; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Residency")-1);
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LegalIdentifiers", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LegalIdentifiers) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LegalIdentifiers");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_PersonLegalId_s* e;
      for (e = x->PersonLegalId; e; e = (struct zx_hrxml_PersonLegalId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonLegalId(c, e, p);
  }
  {
      struct zx_hrxml_MilitaryStatus_s* e;
      for (e = x->MilitaryStatus; e; e = (struct zx_hrxml_MilitaryStatus_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_MilitaryStatus(c, e, p);
  }
  {
      struct zx_hrxml_VisaStatus_s* e;
      for (e = x->VisaStatus; e; e = (struct zx_hrxml_VisaStatus_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_VisaStatus(c, e, p);
  }
  for (se = x->Citizenship; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Citizenship", sizeof("hrxml:Citizenship")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Residency; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Residency", sizeof("hrxml:Residency")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LegalIdentifiers>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LegalIdentifiers", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_LegalIdentifiers) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "LegalIdentifiers", sizeof("LegalIdentifiers")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LegalIdentifiers", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LegalIdentifiers) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LegalIdentifiers(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LegalIdentifiers(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_LegalIdentifiers) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_LegalIdentifiers(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_LegalIdentifiers(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LicenseOrCertification
#define EL_STRUCT zx_hrxml_LicenseOrCertification_s
#define EL_NS     hrxml
#define EL_TAG    LicenseOrCertification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LicenseOrCertification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LicenseOrCertification")-1 + 1 + sizeof("</hrxml:LicenseOrCertification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IssuingAuthority(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EffectiveDate(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LicenseOrCertification", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_LicenseOrCertification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("LicenseOrCertification")-1 + 1 + 2 + sizeof("LicenseOrCertification")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IssuingAuthority(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EffectiveDate(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LicenseOrCertification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LicenseOrCertification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LicenseOrCertification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IssuingAuthority(c, e, p);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EffectiveDate(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LicenseOrCertification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LicenseOrCertification", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_LicenseOrCertification) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "LicenseOrCertification", sizeof("LicenseOrCertification")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LicenseOrCertification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LicenseOrCertification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LicenseOrCertification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LicenseOrCertification(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_LicenseOrCertification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_LicenseOrCertification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_LicenseOrCertification(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LicensesAndCertifications
#define EL_STRUCT zx_hrxml_LicensesAndCertifications_s
#define EL_NS     hrxml
#define EL_TAG    LicensesAndCertifications

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LicensesAndCertifications) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LicensesAndCertifications")-1 + 1 + sizeof("</hrxml:LicensesAndCertifications>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_LicenseOrCertification_s* e;
      for (e = x->LicenseOrCertification; e; e = (struct zx_hrxml_LicenseOrCertification_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LicenseOrCertification(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LicensesAndCertifications", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_LicensesAndCertifications) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("LicensesAndCertifications")-1 + 1 + 2 + sizeof("LicensesAndCertifications")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_LicenseOrCertification_s* e;
      for (e = x->LicenseOrCertification; e; e = (struct zx_hrxml_LicenseOrCertification_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LicenseOrCertification(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LicensesAndCertifications", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LicensesAndCertifications) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LicensesAndCertifications");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_LicenseOrCertification_s* e;
      for (e = x->LicenseOrCertification; e; e = (struct zx_hrxml_LicenseOrCertification_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LicenseOrCertification(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LicensesAndCertifications>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LicensesAndCertifications", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_LicensesAndCertifications) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "LicensesAndCertifications", sizeof("LicensesAndCertifications")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LicensesAndCertifications", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LicensesAndCertifications) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LicensesAndCertifications(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LicensesAndCertifications(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_LicensesAndCertifications) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_LicensesAndCertifications(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_LicensesAndCertifications(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_List
#define EL_STRUCT zx_hrxml_List_s
#define EL_NS     hrxml
#define EL_TAG    List

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_List) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:List")-1 + 1 + sizeof("</hrxml:List>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Item; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Item")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:List", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_List) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("List")-1 + 1 + 2 + sizeof("List")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Item; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Item")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:List", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_List) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:List");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Item; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Item", sizeof("hrxml:Item")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:List>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:List", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_List) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "List", sizeof("List")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:List", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_List) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_List(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_List(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_List) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_List(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_List(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LocalInstitutionClassification
#define EL_STRUCT zx_hrxml_LocalInstitutionClassification_s
#define EL_NS     hrxml
#define EL_TAG    LocalInstitutionClassification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LocalInstitutionClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LocalInstitutionClassification")-1 + 1 + sizeof("</hrxml:LocalInstitutionClassification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LocalInstitutionClassification", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_LocalInstitutionClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("LocalInstitutionClassification")-1 + 1 + 2 + sizeof("LocalInstitutionClassification")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LocalInstitutionClassification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LocalInstitutionClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LocalInstitutionClassification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LocalInstitutionClassification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LocalInstitutionClassification", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_LocalInstitutionClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "LocalInstitutionClassification", sizeof("LocalInstitutionClassification")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LocalInstitutionClassification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LocalInstitutionClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LocalInstitutionClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LocalInstitutionClassification(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_LocalInstitutionClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_LocalInstitutionClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_LocalInstitutionClassification(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LocationSummary
#define EL_STRUCT zx_hrxml_LocationSummary_s
#define EL_NS     hrxml
#define EL_TAG    LocationSummary

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LocationSummary) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LocationSummary")-1 + 1 + sizeof("</hrxml:LocationSummary>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Region")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LocationSummary", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_LocationSummary) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("LocationSummary")-1 + 1 + 2 + sizeof("LocationSummary")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Municipality")-1);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Region")-1);
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CountryCode")-1);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PostalCode")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LocationSummary", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LocationSummary) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LocationSummary");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Municipality", sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Region", sizeof("hrxml:Region")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CountryCode", sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PostalCode", sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LocationSummary>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LocationSummary", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_LocationSummary) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "LocationSummary", sizeof("LocationSummary")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LocationSummary", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LocationSummary) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LocationSummary(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LocationSummary(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_LocationSummary) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_LocationSummary(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_LocationSummary(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Longitude
#define EL_STRUCT zx_hrxml_Longitude_s
#define EL_NS     hrxml
#define EL_TAG    Longitude

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Longitude) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Longitude")-1 + 1 + sizeof("</hrxml:Longitude>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Longitude", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Longitude) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Longitude")-1 + 1 + 2 + sizeof("Longitude")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Longitude", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Longitude) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Longitude");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Longitude>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Longitude", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Longitude) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Longitude", sizeof("Longitude")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Longitude", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Longitude) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Longitude(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Longitude(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Longitude) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Longitude(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Longitude(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LowestPossibleValue
#define EL_STRUCT zx_hrxml_LowestPossibleValue_s
#define EL_NS     hrxml
#define EL_TAG    LowestPossibleValue

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LowestPossibleValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LowestPossibleValue")-1 + 1 + sizeof("</hrxml:LowestPossibleValue>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_NumericValue(c, e);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StringValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LowestPossibleValue", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_LowestPossibleValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("LowestPossibleValue")-1 + 1 + 2 + sizeof("LowestPossibleValue")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_NumericValue(c, e);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StringValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LowestPossibleValue", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LowestPossibleValue) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LowestPossibleValue");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_NumericValue_s* e;
      for (e = x->NumericValue; e; e = (struct zx_hrxml_NumericValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_NumericValue(c, e, p);
  }
  {
      struct zx_hrxml_StringValue_s* e;
      for (e = x->StringValue; e; e = (struct zx_hrxml_StringValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StringValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LowestPossibleValue>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LowestPossibleValue", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_LowestPossibleValue) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "LowestPossibleValue", sizeof("LowestPossibleValue")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LowestPossibleValue", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LowestPossibleValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LowestPossibleValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LowestPossibleValue(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_LowestPossibleValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_LowestPossibleValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_LowestPossibleValue(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MatchedObjectId
#define EL_STRUCT zx_hrxml_MatchedObjectId_s
#define EL_NS     hrxml
#define EL_TAG    MatchedObjectId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_MatchedObjectId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:MatchedObjectId")-1 + 1 + sizeof("</hrxml:MatchedObjectId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MatchedObjectId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_MatchedObjectId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("MatchedObjectId")-1 + 1 + 2 + sizeof("MatchedObjectId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MatchedObjectId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_MatchedObjectId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:MatchedObjectId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:MatchedObjectId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MatchedObjectId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_MatchedObjectId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "MatchedObjectId", sizeof("MatchedObjectId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MatchedObjectId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_MatchedObjectId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_MatchedObjectId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_MatchedObjectId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_MatchedObjectId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_MatchedObjectId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_MatchedObjectId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Measure
#define EL_STRUCT zx_hrxml_Measure_s
#define EL_NS     hrxml
#define EL_TAG    Measure

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Measure) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Measure")-1 + 1 + sizeof("</hrxml:Measure>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->measureType, sizeof("measureType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->MeasureSystem; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MeasureSystem")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MeasureValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MeasureValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Measure", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Measure) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Measure")-1 + 1 + 2 + sizeof("Measure")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->measureType, sizeof("measureType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->MeasureSystem; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MeasureSystem")-1);
  for (se = x->MeasureValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MeasureValue")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Measure", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Measure) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Measure");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->measureType, " measureType=\"", sizeof(" measureType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->MeasureSystem; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MeasureSystem", sizeof("hrxml:MeasureSystem")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MeasureValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MeasureValue", sizeof("hrxml:MeasureValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Measure>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Measure", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Measure) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Measure", sizeof("Measure")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->measureType, "measureType=\"", sizeof("measureType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Measure", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Measure) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Measure(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Measure(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Measure) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Measure(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Measure(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MilitaryHistory
#define EL_STRUCT zx_hrxml_MilitaryHistory_s
#define EL_NS     hrxml
#define EL_TAG    MilitaryHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_MilitaryHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:MilitaryHistory")-1 + 1 + sizeof("</hrxml:MilitaryHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CountryServed; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CountryServed")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ServiceNumber_s* e;
      for (e = x->ServiceNumber; e; e = (struct zx_hrxml_ServiceNumber_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ServiceNumber(c, e);
  }
  {
      struct zx_hrxml_ServiceDetail_s* e;
      for (e = x->ServiceDetail; e; e = (struct zx_hrxml_ServiceDetail_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ServiceDetail(c, e);
  }
  for (se = x->ServiceStatus; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ServiceStatus")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MilitaryHistory", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_MilitaryHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("MilitaryHistory")-1 + 1 + 2 + sizeof("MilitaryHistory")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CountryServed; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CountryServed")-1);
  {
      struct zx_hrxml_ServiceNumber_s* e;
      for (e = x->ServiceNumber; e; e = (struct zx_hrxml_ServiceNumber_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ServiceNumber(c, e);
  }
  {
      struct zx_hrxml_ServiceDetail_s* e;
      for (e = x->ServiceDetail; e; e = (struct zx_hrxml_ServiceDetail_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ServiceDetail(c, e);
  }
  for (se = x->ServiceStatus; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ServiceStatus")-1);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MilitaryHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_MilitaryHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:MilitaryHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->CountryServed; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CountryServed", sizeof("hrxml:CountryServed")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ServiceNumber_s* e;
      for (e = x->ServiceNumber; e; e = (struct zx_hrxml_ServiceNumber_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ServiceNumber(c, e, p);
  }
  {
      struct zx_hrxml_ServiceDetail_s* e;
      for (e = x->ServiceDetail; e; e = (struct zx_hrxml_ServiceDetail_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ServiceDetail(c, e, p);
  }
  for (se = x->ServiceStatus; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ServiceStatus", sizeof("hrxml:ServiceStatus")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:MilitaryHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MilitaryHistory", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_MilitaryHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "MilitaryHistory", sizeof("MilitaryHistory")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MilitaryHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_MilitaryHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_MilitaryHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_MilitaryHistory(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_MilitaryHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_MilitaryHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_MilitaryHistory(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MilitaryStatus
#define EL_STRUCT zx_hrxml_MilitaryStatus_s
#define EL_NS     hrxml
#define EL_TAG    MilitaryStatus

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_MilitaryStatus) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:MilitaryStatus")-1 + 1 + sizeof("</hrxml:MilitaryStatus>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MilitaryStatus", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_MilitaryStatus) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("MilitaryStatus")-1 + 1 + 2 + sizeof("MilitaryStatus")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MilitaryStatus", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_MilitaryStatus) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:MilitaryStatus");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:MilitaryStatus>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MilitaryStatus", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_MilitaryStatus) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "MilitaryStatus", sizeof("MilitaryStatus")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MilitaryStatus", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_MilitaryStatus) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_MilitaryStatus(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_MilitaryStatus(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_MilitaryStatus) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_MilitaryStatus(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_MilitaryStatus(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Mobile
#define EL_STRUCT zx_hrxml_Mobile_s
#define EL_NS     hrxml
#define EL_TAG    Mobile

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Mobile) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Mobile")-1 + 1 + sizeof("</hrxml:Mobile>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->smsEnabled, sizeof("smsEnabled")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Mobile", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Mobile) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Mobile")-1 + 1 + 2 + sizeof("Mobile")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->smsEnabled, sizeof("smsEnabled")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("FormattedNumber")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Mobile", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Mobile) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Mobile");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->smsEnabled, " smsEnabled=\"", sizeof(" smsEnabled=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedNumber", sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Mobile>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Mobile", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Mobile) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Mobile", sizeof("Mobile")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->smsEnabled, "smsEnabled=\"", sizeof("smsEnabled=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Mobile", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Mobile) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Mobile(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Mobile(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Mobile) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Mobile(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Mobile(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MostRecentDate
#define EL_STRUCT zx_hrxml_MostRecentDate_s
#define EL_NS     hrxml
#define EL_TAG    MostRecentDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_MostRecentDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:MostRecentDate")-1 + 1 + sizeof("</hrxml:MostRecentDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MostRecentDate", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_MostRecentDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("MostRecentDate")-1 + 1 + 2 + sizeof("MostRecentDate")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AnyDate")-1);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("YearMonth")-1);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Year")-1);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDay")-1);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StringDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MostRecentDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_MostRecentDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:MostRecentDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:MostRecentDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MostRecentDate", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_MostRecentDate) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "MostRecentDate", sizeof("MostRecentDate")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateDescription, "dateDescription=\"", sizeof("dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MostRecentDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_MostRecentDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_MostRecentDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_MostRecentDate(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_MostRecentDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_MostRecentDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_MostRecentDate(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_NonXMLResume
#define EL_STRUCT zx_hrxml_NonXMLResume_s
#define EL_NS     hrxml
#define EL_TAG    NonXMLResume

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_NonXMLResume) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:NonXMLResume")-1 + 1 + sizeof("</hrxml:NonXMLResume>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->TextResume; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:TextResume")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->LinkToResume; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:LinkToResume")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SupportingMaterials(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->RevisionDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:RevisionDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:NonXMLResume", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_NonXMLResume) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("NonXMLResume")-1 + 1 + 2 + sizeof("NonXMLResume")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->TextResume; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("TextResume")-1);
  for (se = x->LinkToResume; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("LinkToResume")-1);
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SupportingMaterials(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  for (se = x->RevisionDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("RevisionDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:NonXMLResume", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_NonXMLResume) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:NonXMLResume");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->TextResume; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:TextResume", sizeof("hrxml:TextResume")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->LinkToResume; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:LinkToResume", sizeof("hrxml:LinkToResume")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SupportingMaterials(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->RevisionDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:RevisionDate", sizeof("hrxml:RevisionDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:NonXMLResume>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:NonXMLResume", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_NonXMLResume) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "NonXMLResume", sizeof("NonXMLResume")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:NonXMLResume", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_NonXMLResume) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_NonXMLResume(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_NonXMLResume(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_NonXMLResume) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_NonXMLResume(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_NonXMLResume(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_NumericValue
#define EL_STRUCT zx_hrxml_NumericValue_s
#define EL_NS     hrxml
#define EL_TAG    NumericValue

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_NumericValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:NumericValue")-1 + 1 + sizeof("</hrxml:NumericValue>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->interval, sizeof("interval")-1, &pop_seen);
  len += zx_attr_so_len(c, x->maxValue, sizeof("maxValue")-1, &pop_seen);
  len += zx_attr_so_len(c, x->minValue, sizeof("minValue")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:NumericValue", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_NumericValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("NumericValue")-1 + 1 + 2 + sizeof("NumericValue")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->interval, sizeof("interval")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->maxValue, sizeof("maxValue")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->minValue, sizeof("minValue")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:NumericValue", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_NumericValue) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:NumericValue");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->interval, " interval=\"", sizeof(" interval=\"")-1);
  p = zx_attr_so_enc(p, x->maxValue, " maxValue=\"", sizeof(" maxValue=\"")-1);
  p = zx_attr_so_enc(p, x->minValue, " minValue=\"", sizeof(" minValue=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:NumericValue>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:NumericValue", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_NumericValue) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "NumericValue", sizeof("NumericValue")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->description, "description=\"", sizeof("description=\"")-1);
  p = zx_attr_wo_enc(p, x->interval, "interval=\"", sizeof("interval=\"")-1);
  p = zx_attr_wo_enc(p, x->maxValue, "maxValue=\"", sizeof("maxValue=\"")-1);
  p = zx_attr_wo_enc(p, x->minValue, "minValue=\"", sizeof("minValue=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:NumericValue", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_NumericValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_NumericValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_NumericValue(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_NumericValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_NumericValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_NumericValue(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrgIndustry
#define EL_STRUCT zx_hrxml_OrgIndustry_s
#define EL_NS     hrxml
#define EL_TAG    OrgIndustry

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrgIndustry) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrgIndustry")-1 + 1 + sizeof("</hrxml:OrgIndustry>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->primaryIndicator, sizeof("primaryIndicator")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->IndustryDescription; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:IndustryDescription")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IndustryCode(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrgIndustry", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OrgIndustry) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OrgIndustry")-1 + 1 + 2 + sizeof("OrgIndustry")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->primaryIndicator, sizeof("primaryIndicator")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->IndustryDescription; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("IndustryDescription")-1);
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IndustryCode(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrgIndustry", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrgIndustry) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrgIndustry");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->primaryIndicator, " primaryIndicator=\"", sizeof(" primaryIndicator=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->IndustryDescription; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:IndustryDescription", sizeof("hrxml:IndustryDescription")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IndustryCode(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrgIndustry>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrgIndustry", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OrgIndustry) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OrgIndustry", sizeof("OrgIndustry")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->primaryIndicator, "primaryIndicator=\"", sizeof("primaryIndicator=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrgIndustry", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrgIndustry) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrgIndustry(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrgIndustry(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OrgIndustry) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OrgIndustry(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OrgIndustry(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrgInfo
#define EL_STRUCT zx_hrxml_OrgInfo_s
#define EL_NS     hrxml
#define EL_TAG    OrgInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrgInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrgInfo")-1 + 1 + sizeof("</hrxml:OrgInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PositionLocation_s* e;
      for (e = x->PositionLocation; e; e = (struct zx_hrxml_PositionLocation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PositionLocation(c, e);
  }
  for (se = x->WebSite; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:WebSite")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_LocationSummary_s* e;
      for (e = x->LocationSummary; e; e = (struct zx_hrxml_LocationSummary_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LocationSummary(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrgInfo", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OrgInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OrgInfo")-1 + 1 + 2 + sizeof("OrgInfo")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PositionLocation_s* e;
      for (e = x->PositionLocation; e; e = (struct zx_hrxml_PositionLocation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PositionLocation(c, e);
  }
  for (se = x->WebSite; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("WebSite")-1);
  {
      struct zx_hrxml_LocationSummary_s* e;
      for (e = x->LocationSummary; e; e = (struct zx_hrxml_LocationSummary_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LocationSummary(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrgInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrgInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrgInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_PositionLocation_s* e;
      for (e = x->PositionLocation; e; e = (struct zx_hrxml_PositionLocation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PositionLocation(c, e, p);
  }
  for (se = x->WebSite; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:WebSite", sizeof("hrxml:WebSite")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_LocationSummary_s* e;
      for (e = x->LocationSummary; e; e = (struct zx_hrxml_LocationSummary_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LocationSummary(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrgInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrgInfo", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OrgInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OrgInfo", sizeof("OrgInfo")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrgInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrgInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrgInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrgInfo(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OrgInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OrgInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OrgInfo(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrgName
#define EL_STRUCT zx_hrxml_OrgName_s
#define EL_NS     hrxml
#define EL_TAG    OrgName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrgName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrgName")-1 + 1 + sizeof("</hrxml:OrgName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->organizationType, sizeof("organizationType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OrgName_s* e;
      for (e = x->OrgName; e; e = (struct zx_hrxml_OrgName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrgName(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrgName", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OrgName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OrgName")-1 + 1 + 2 + sizeof("OrgName")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->organizationType, sizeof("organizationType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("OrganizationName")-1);
  {
      struct zx_hrxml_OrgName_s* e;
      for (e = x->OrgName; e; e = (struct zx_hrxml_OrgName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrgName(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrgName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrgName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrgName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->organizationType, " organizationType=\"", sizeof(" organizationType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrganizationName", sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OrgName_s* e;
      for (e = x->OrgName; e; e = (struct zx_hrxml_OrgName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrgName(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrgName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrgName", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OrgName) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OrgName", sizeof("OrgName")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->organizationType, "organizationType=\"", sizeof("organizationType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrgName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrgName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrgName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrgName(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OrgName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OrgName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OrgName(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Organization
#define EL_STRUCT zx_hrxml_Organization_s
#define EL_NS     hrxml
#define EL_TAG    Organization

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Organization) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Organization")-1 + 1 + sizeof("</hrxml:Organization>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Organization", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Organization) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Organization")-1 + 1 + 2 + sizeof("Organization")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Organization", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Organization) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Organization");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Organization>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Organization", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Organization) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Organization", sizeof("Organization")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Organization", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Organization) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Organization(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Organization(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Organization) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Organization(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Organization(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationId
#define EL_STRUCT zx_hrxml_OrganizationId_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrganizationId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrganizationId")-1 + 1 + sizeof("</hrxml:OrganizationId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OrganizationId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OrganizationId")-1 + 1 + 2 + sizeof("OrganizationId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrganizationId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrganizationId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrganizationId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OrganizationId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OrganizationId", sizeof("OrganizationId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrganizationId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrganizationId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrganizationId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OrganizationId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OrganizationId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OrganizationId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationUnit
#define EL_STRUCT zx_hrxml_OrganizationUnit_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationUnit

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrganizationUnit) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrganizationUnit")-1 + 1 + sizeof("</hrxml:OrganizationUnit>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->attendanceStatus, sizeof("attendanceStatus")-1, &pop_seen);
  len += zx_attr_so_len(c, x->organizationType, sizeof("organizationType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationUnit", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OrganizationUnit) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OrganizationUnit")-1 + 1 + 2 + sizeof("OrganizationUnit")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->attendanceStatus, sizeof("attendanceStatus")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->organizationType, sizeof("organizationType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationUnit", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrganizationUnit) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrganizationUnit");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->attendanceStatus, " attendanceStatus=\"", sizeof(" attendanceStatus=\"")-1);
  p = zx_attr_so_enc(p, x->organizationType, " organizationType=\"", sizeof(" organizationType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrganizationUnit>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationUnit", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OrganizationUnit) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OrganizationUnit", sizeof("OrganizationUnit")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->attendanceStatus, "attendanceStatus=\"", sizeof("attendanceStatus=\"")-1);
  p = zx_attr_wo_enc(p, x->organizationType, "organizationType=\"", sizeof("organizationType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationUnit", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrganizationUnit) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrganizationUnit(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrganizationUnit(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OrganizationUnit) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OrganizationUnit(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OrganizationUnit(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationalUnit
#define EL_STRUCT zx_hrxml_OrganizationalUnit_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationalUnit

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrganizationalUnit) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrganizationalUnit")-1 + 1 + sizeof("</hrxml:OrganizationalUnit>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->hierarchicalRole, sizeof("hierarchicalRole")-1, &pop_seen);
  len += zx_attr_so_len(c, x->typeOfGroup, sizeof("typeOfGroup")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationalUnitName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrganizationalUnitName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OrganizationalUnitId_s* e;
      for (e = x->OrganizationalUnitId; e; e = (struct zx_hrxml_OrganizationalUnitId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrganizationalUnitId(c, e);
  }
  {
      struct zx_hrxml_OrganizationId_s* e;
      for (e = x->OrganizationId; e; e = (struct zx_hrxml_OrganizationId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrganizationId(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IndustryCode(c, e);
  }
  {
      struct zx_hrxml_AccountingCode_s* e;
      for (e = x->AccountingCode; e; e = (struct zx_hrxml_AccountingCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_AccountingCode(c, e);
  }
  {
      struct zx_hrxml_WorkSite_s* e;
      for (e = x->WorkSite; e; e = (struct zx_hrxml_WorkSite_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_WorkSite(c, e);
  }
  {
      struct zx_hrxml_RelatedOrganizationalUnit_s* e;
      for (e = x->RelatedOrganizationalUnit; e; e = (struct zx_hrxml_RelatedOrganizationalUnit_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RelatedOrganizationalUnit(c, e);
  }
  {
      struct zx_hrxml_PersonMember_s* e;
      for (e = x->PersonMember; e; e = (struct zx_hrxml_PersonMember_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonMember(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnit", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OrganizationalUnit) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OrganizationalUnit")-1 + 1 + 2 + sizeof("OrganizationalUnit")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->hierarchicalRole, sizeof("hierarchicalRole")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->typeOfGroup, sizeof("typeOfGroup")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationalUnitName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("OrganizationalUnitName")-1);
  {
      struct zx_hrxml_OrganizationalUnitId_s* e;
      for (e = x->OrganizationalUnitId; e; e = (struct zx_hrxml_OrganizationalUnitId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrganizationalUnitId(c, e);
  }
  {
      struct zx_hrxml_OrganizationId_s* e;
      for (e = x->OrganizationId; e; e = (struct zx_hrxml_OrganizationId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrganizationId(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IndustryCode(c, e);
  }
  {
      struct zx_hrxml_AccountingCode_s* e;
      for (e = x->AccountingCode; e; e = (struct zx_hrxml_AccountingCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_AccountingCode(c, e);
  }
  {
      struct zx_hrxml_WorkSite_s* e;
      for (e = x->WorkSite; e; e = (struct zx_hrxml_WorkSite_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_WorkSite(c, e);
  }
  {
      struct zx_hrxml_RelatedOrganizationalUnit_s* e;
      for (e = x->RelatedOrganizationalUnit; e; e = (struct zx_hrxml_RelatedOrganizationalUnit_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RelatedOrganizationalUnit(c, e);
  }
  {
      struct zx_hrxml_PersonMember_s* e;
      for (e = x->PersonMember; e; e = (struct zx_hrxml_PersonMember_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonMember(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnit", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrganizationalUnit) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrganizationalUnit");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->hierarchicalRole, " hierarchicalRole=\"", sizeof(" hierarchicalRole=\"")-1);
  p = zx_attr_so_enc(p, x->typeOfGroup, " typeOfGroup=\"", sizeof(" typeOfGroup=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->OrganizationalUnitName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrganizationalUnitName", sizeof("hrxml:OrganizationalUnitName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OrganizationalUnitId_s* e;
      for (e = x->OrganizationalUnitId; e; e = (struct zx_hrxml_OrganizationalUnitId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrganizationalUnitId(c, e, p);
  }
  {
      struct zx_hrxml_OrganizationId_s* e;
      for (e = x->OrganizationId; e; e = (struct zx_hrxml_OrganizationId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrganizationId(c, e, p);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IndustryCode(c, e, p);
  }
  {
      struct zx_hrxml_AccountingCode_s* e;
      for (e = x->AccountingCode; e; e = (struct zx_hrxml_AccountingCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_AccountingCode(c, e, p);
  }
  {
      struct zx_hrxml_WorkSite_s* e;
      for (e = x->WorkSite; e; e = (struct zx_hrxml_WorkSite_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_WorkSite(c, e, p);
  }
  {
      struct zx_hrxml_RelatedOrganizationalUnit_s* e;
      for (e = x->RelatedOrganizationalUnit; e; e = (struct zx_hrxml_RelatedOrganizationalUnit_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RelatedOrganizationalUnit(c, e, p);
  }
  {
      struct zx_hrxml_PersonMember_s* e;
      for (e = x->PersonMember; e; e = (struct zx_hrxml_PersonMember_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonMember(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrganizationalUnit>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnit", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OrganizationalUnit) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OrganizationalUnit", sizeof("OrganizationalUnit")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->hierarchicalRole, "hierarchicalRole=\"", sizeof("hierarchicalRole=\"")-1);
  p = zx_attr_wo_enc(p, x->typeOfGroup, "typeOfGroup=\"", sizeof("typeOfGroup=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnit", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrganizationalUnit) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrganizationalUnit(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrganizationalUnit(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OrganizationalUnit) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OrganizationalUnit(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OrganizationalUnit(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationalUnitId
#define EL_STRUCT zx_hrxml_OrganizationalUnitId_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationalUnitId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrganizationalUnitId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrganizationalUnitId")-1 + 1 + sizeof("</hrxml:OrganizationalUnitId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnitId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OrganizationalUnitId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OrganizationalUnitId")-1 + 1 + 2 + sizeof("OrganizationalUnitId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnitId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrganizationalUnitId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrganizationalUnitId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrganizationalUnitId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnitId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OrganizationalUnitId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OrganizationalUnitId", sizeof("OrganizationalUnitId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnitId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrganizationalUnitId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrganizationalUnitId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrganizationalUnitId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OrganizationalUnitId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OrganizationalUnitId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OrganizationalUnitId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OriginalDate
#define EL_STRUCT zx_hrxml_OriginalDate_s
#define EL_NS     hrxml
#define EL_TAG    OriginalDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OriginalDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OriginalDate")-1 + 1 + sizeof("</hrxml:OriginalDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OriginalDate", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OriginalDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OriginalDate")-1 + 1 + 2 + sizeof("OriginalDate")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AnyDate")-1);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("YearMonth")-1);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Year")-1);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDay")-1);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StringDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OriginalDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OriginalDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OriginalDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OriginalDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OriginalDate", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OriginalDate) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OriginalDate", sizeof("OriginalDate")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateDescription, "dateDescription=\"", sizeof("dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OriginalDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OriginalDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OriginalDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OriginalDate(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OriginalDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OriginalDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OriginalDate(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherBenefits
#define EL_STRUCT zx_hrxml_OtherBenefits_s
#define EL_NS     hrxml
#define EL_TAG    OtherBenefits

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherBenefits) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherBenefits")-1 + 1 + sizeof("</hrxml:OtherBenefits>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherBenefits", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OtherBenefits) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OtherBenefits")-1 + 1 + 2 + sizeof("OtherBenefits")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherBenefits", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherBenefits) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherBenefits");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherBenefits>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherBenefits", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OtherBenefits) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OtherBenefits", sizeof("OtherBenefits")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherBenefits", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherBenefits) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherBenefits(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherBenefits(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OtherBenefits) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OtherBenefits(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OtherBenefits(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherCompensation
#define EL_STRUCT zx_hrxml_OtherCompensation_s
#define EL_NS     hrxml
#define EL_TAG    OtherCompensation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherCompensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherCompensation")-1 + 1 + sizeof("</hrxml:OtherCompensation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherCompensation", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OtherCompensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OtherCompensation")-1 + 1 + 2 + sizeof("OtherCompensation")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherCompensation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherCompensation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherCompensation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherCompensation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherCompensation", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OtherCompensation) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OtherCompensation", sizeof("OtherCompensation")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherCompensation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherCompensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherCompensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherCompensation(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OtherCompensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OtherCompensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OtherCompensation(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherDescriptors
#define EL_STRUCT zx_hrxml_OtherDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    OtherDescriptors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherDescriptors")-1 + 1 + sizeof("</hrxml:OtherDescriptors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Applicable; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Applicable")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Value")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_List_s* e;
      for (e = x->List; e; e = (struct zx_hrxml_List_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_List(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherDescriptors", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OtherDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OtherDescriptors")-1 + 1 + 2 + sizeof("OtherDescriptors")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  for (se = x->Applicable; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Applicable")-1);
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Value")-1);
  {
      struct zx_hrxml_List_s* e;
      for (e = x->List; e; e = (struct zx_hrxml_List_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_List(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherDescriptors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherDescriptors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Applicable; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Applicable", sizeof("hrxml:Applicable")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Value", sizeof("hrxml:Value")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_List_s* e;
      for (e = x->List; e; e = (struct zx_hrxml_List_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_List(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherDescriptors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OtherDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OtherDescriptors", sizeof("OtherDescriptors")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherDescriptors(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OtherDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OtherDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OtherDescriptors(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherHonors
#define EL_STRUCT zx_hrxml_OtherHonors_s
#define EL_NS     hrxml
#define EL_TAG    OtherHonors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherHonors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherHonors")-1 + 1 + sizeof("</hrxml:OtherHonors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherHonors", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OtherHonors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OtherHonors")-1 + 1 + 2 + sizeof("OtherHonors")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherHonors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherHonors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherHonors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherHonors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherHonors", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OtherHonors) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OtherHonors", sizeof("OtherHonors")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherHonors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherHonors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherHonors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherHonors(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OtherHonors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OtherHonors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OtherHonors(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherPay
#define EL_STRUCT zx_hrxml_OtherPay_s
#define EL_NS     hrxml
#define EL_TAG    OtherPay

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherPay) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherPay")-1 + 1 + sizeof("</hrxml:OtherPay>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->currencyCode, sizeof("currencyCode")-1, &pop_seen);
  len += zx_attr_so_len(c, x->otherInterval, sizeof("otherInterval")-1, &pop_seen);
  len += zx_attr_so_len(c, x->otherPayType, sizeof("otherPayType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OtherPayAmountMin; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OtherPayAmountMin")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->OtherPayAmountMax; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OtherPayAmountMax")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->OtherPayCalculation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OtherPayCalculation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherPay", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OtherPay) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OtherPay")-1 + 1 + 2 + sizeof("OtherPay")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->currencyCode, sizeof("currencyCode")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->otherInterval, sizeof("otherInterval")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->otherPayType, sizeof("otherPayType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OtherPayAmountMin; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("OtherPayAmountMin")-1);
  for (se = x->OtherPayAmountMax; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("OtherPayAmountMax")-1);
  for (se = x->OtherPayCalculation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("OtherPayCalculation")-1);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherPay", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherPay) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherPay");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->currencyCode, " currencyCode=\"", sizeof(" currencyCode=\"")-1);
  p = zx_attr_so_enc(p, x->otherInterval, " otherInterval=\"", sizeof(" otherInterval=\"")-1);
  p = zx_attr_so_enc(p, x->otherPayType, " otherPayType=\"", sizeof(" otherPayType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->OtherPayAmountMin; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OtherPayAmountMin", sizeof("hrxml:OtherPayAmountMin")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->OtherPayAmountMax; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OtherPayAmountMax", sizeof("hrxml:OtherPayAmountMax")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->OtherPayCalculation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OtherPayCalculation", sizeof("hrxml:OtherPayCalculation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherPay>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherPay", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OtherPay) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OtherPay", sizeof("OtherPay")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->currencyCode, "currencyCode=\"", sizeof("currencyCode=\"")-1);
  p = zx_attr_wo_enc(p, x->otherInterval, "otherInterval=\"", sizeof("otherInterval=\"")-1);
  p = zx_attr_wo_enc(p, x->otherPayType, "otherPayType=\"", sizeof("otherPayType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherPay", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherPay) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherPay(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherPay(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OtherPay) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OtherPay(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OtherPay(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherPublication
#define EL_STRUCT zx_hrxml_OtherPublication_s
#define EL_NS     hrxml
#define EL_TAG    OtherPublication

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherPublication) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherPublication")-1 + 1 + sizeof("</hrxml:OtherPublication>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PublicationDate(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Copyright(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISBN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISBN")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->NumberOfPages; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:NumberOfPages")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PublisherName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PublisherName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PublisherLocation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PublisherLocation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherPublication", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_OtherPublication) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("OtherPublication")-1 + 1 + 2 + sizeof("OtherPublication")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Title")-1);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PublicationDate(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Link")-1);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Abstract")-1);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Copyright(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ISSN")-1);
  for (se = x->ISBN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ISBN")-1);
  for (se = x->NumberOfPages; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("NumberOfPages")-1);
  for (se = x->PublisherName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PublisherName")-1);
  for (se = x->PublisherLocation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PublisherLocation")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherPublication", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherPublication) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherPublication");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PublicationDate_s* e;
      for (e = x->PublicationDate; e; e = (struct zx_hrxml_PublicationDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PublicationDate(c, e, p);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Abstract", sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Copyright_s* e;
      for (e = x->Copyright; e; e = (struct zx_hrxml_Copyright_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Copyright(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISSN", sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISBN; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISBN", sizeof("hrxml:ISBN")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->NumberOfPages; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:NumberOfPages", sizeof("hrxml:NumberOfPages")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PublisherName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PublisherName", sizeof("hrxml:PublisherName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PublisherLocation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PublisherLocation", sizeof("hrxml:PublisherLocation")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherPublication>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherPublication", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_OtherPublication) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "OtherPublication", sizeof("OtherPublication")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherPublication", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherPublication) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherPublication(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherPublication(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_OtherPublication) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_OtherPublication(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_OtherPublication(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Pager
#define EL_STRUCT zx_hrxml_Pager_s
#define EL_NS     hrxml
#define EL_TAG    Pager

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Pager) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Pager")-1 + 1 + sizeof("</hrxml:Pager>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Pager", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Pager) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Pager")-1 + 1 + 2 + sizeof("Pager")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("FormattedNumber")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Pager", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Pager) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Pager");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedNumber", sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Pager>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Pager", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Pager) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Pager", sizeof("Pager")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Pager", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Pager) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Pager(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Pager(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Pager) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Pager(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Pager(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ParkingInstructions
#define EL_STRUCT zx_hrxml_ParkingInstructions_s
#define EL_NS     hrxml
#define EL_TAG    ParkingInstructions

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ParkingInstructions) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ParkingInstructions")-1 + 1 + sizeof("</hrxml:ParkingInstructions>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ParkingInstructions", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ParkingInstructions) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ParkingInstructions")-1 + 1 + 2 + sizeof("ParkingInstructions")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->lang, sizeof("lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ParkingInstructions", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ParkingInstructions) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ParkingInstructions");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ParkingInstructions>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ParkingInstructions", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ParkingInstructions) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ParkingInstructions", sizeof("ParkingInstructions")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->lang, "lang=\"", sizeof("lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ParkingInstructions", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ParkingInstructions) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ParkingInstructions(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ParkingInstructions(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ParkingInstructions) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ParkingInstructions(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ParkingInstructions(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Patent
#define EL_STRUCT zx_hrxml_Patent_s
#define EL_NS     hrxml
#define EL_TAG    Patent

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Patent) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Patent")-1 + 1 + sizeof("</hrxml:Patent>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->PatentTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PatentTitle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_Inventors_s* e;
      for (e = x->Inventors; e; e = (struct zx_hrxml_Inventors_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Inventors(c, e);
  }
  {
      struct zx_hrxml_PatentDetail_s* e;
      for (e = x->PatentDetail; e; e = (struct zx_hrxml_PatentDetail_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PatentDetail(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Patent", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Patent) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Patent")-1 + 1 + 2 + sizeof("Patent")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->PatentTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PatentTitle")-1);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_Inventors_s* e;
      for (e = x->Inventors; e; e = (struct zx_hrxml_Inventors_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Inventors(c, e);
  }
  {
      struct zx_hrxml_PatentDetail_s* e;
      for (e = x->PatentDetail; e; e = (struct zx_hrxml_PatentDetail_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PatentDetail(c, e);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Link")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Patent", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Patent) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Patent");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->PatentTitle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PatentTitle", sizeof("hrxml:PatentTitle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }
  {
      struct zx_hrxml_Inventors_s* e;
      for (e = x->Inventors; e; e = (struct zx_hrxml_Inventors_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Inventors(c, e, p);
  }
  {
      struct zx_hrxml_PatentDetail_s* e;
      for (e = x->PatentDetail; e; e = (struct zx_hrxml_PatentDetail_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PatentDetail(c, e, p);
  }
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Patent>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Patent", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Patent) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Patent", sizeof("Patent")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Patent", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Patent) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Patent(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Patent(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Patent) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Patent(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Patent(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PatentDetail
#define EL_STRUCT zx_hrxml_PatentDetail_s
#define EL_NS     hrxml
#define EL_TAG    PatentDetail

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PatentDetail) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PatentDetail")-1 + 1 + sizeof("</hrxml:PatentDetail>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IssuingAuthority(c, e);
  }
  {
      struct zx_hrxml_PatentMilestone_s* e;
      for (e = x->PatentMilestone; e; e = (struct zx_hrxml_PatentMilestone_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PatentMilestone(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PatentDetail", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PatentDetail) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PatentDetail")-1 + 1 + 2 + sizeof("PatentDetail")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IssuingAuthority(c, e);
  }
  {
      struct zx_hrxml_PatentMilestone_s* e;
      for (e = x->PatentMilestone; e; e = (struct zx_hrxml_PatentMilestone_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PatentMilestone(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PatentDetail", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PatentDetail) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PatentDetail");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IssuingAuthority(c, e, p);
  }
  {
      struct zx_hrxml_PatentMilestone_s* e;
      for (e = x->PatentMilestone; e; e = (struct zx_hrxml_PatentMilestone_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PatentMilestone(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PatentDetail>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PatentDetail", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PatentDetail) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PatentDetail", sizeof("PatentDetail")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PatentDetail", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PatentDetail) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PatentDetail(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PatentDetail(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PatentDetail) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PatentDetail(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PatentDetail(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PatentHistory
#define EL_STRUCT zx_hrxml_PatentHistory_s
#define EL_NS     hrxml
#define EL_TAG    PatentHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PatentHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PatentHistory")-1 + 1 + sizeof("</hrxml:PatentHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Patent_s* e;
      for (e = x->Patent; e; e = (struct zx_hrxml_Patent_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Patent(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PatentHistory", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PatentHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PatentHistory")-1 + 1 + 2 + sizeof("PatentHistory")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Patent_s* e;
      for (e = x->Patent; e; e = (struct zx_hrxml_Patent_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Patent(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PatentHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PatentHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PatentHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Patent_s* e;
      for (e = x->Patent; e; e = (struct zx_hrxml_Patent_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Patent(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PatentHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PatentHistory", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PatentHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PatentHistory", sizeof("PatentHistory")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PatentHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PatentHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PatentHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PatentHistory(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PatentHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PatentHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PatentHistory(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PatentMilestone
#define EL_STRUCT zx_hrxml_PatentMilestone_s
#define EL_NS     hrxml
#define EL_TAG    PatentMilestone

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PatentMilestone) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PatentMilestone")-1 + 1 + sizeof("</hrxml:PatentMilestone>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_Status_s* e;
      for (e = x->Status; e; e = (struct zx_hrxml_Status_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Status(c, e);
  }
  for (se = x->Date; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Date")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PatentMilestone", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PatentMilestone) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PatentMilestone")-1 + 1 + 2 + sizeof("PatentMilestone")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_Status_s* e;
      for (e = x->Status; e; e = (struct zx_hrxml_Status_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Status(c, e);
  }
  for (se = x->Date; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Date")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PatentMilestone", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PatentMilestone) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PatentMilestone");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  {
      struct zx_hrxml_Status_s* e;
      for (e = x->Status; e; e = (struct zx_hrxml_Status_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Status(c, e, p);
  }
  for (se = x->Date; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Date", sizeof("hrxml:Date")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PatentMilestone>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PatentMilestone", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PatentMilestone) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PatentMilestone", sizeof("PatentMilestone")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PatentMilestone", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PatentMilestone) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PatentMilestone(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PatentMilestone(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PatentMilestone) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PatentMilestone(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PatentMilestone(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonDescriptors
#define EL_STRUCT zx_hrxml_PersonDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    PersonDescriptors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonDescriptors")-1 + 1 + sizeof("</hrxml:PersonDescriptors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_LegalIdentifiers_s* e;
      for (e = x->LegalIdentifiers; e; e = (struct zx_hrxml_LegalIdentifiers_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LegalIdentifiers(c, e);
  }
  {
      struct zx_hrxml_DemographicDescriptors_s* e;
      for (e = x->DemographicDescriptors; e; e = (struct zx_hrxml_DemographicDescriptors_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DemographicDescriptors(c, e);
  }
  {
      struct zx_hrxml_BiologicalDescriptors_s* e;
      for (e = x->BiologicalDescriptors; e; e = (struct zx_hrxml_BiologicalDescriptors_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_BiologicalDescriptors(c, e);
  }
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SupportingMaterials(c, e);
  }
  {
      struct zx_hrxml_OtherDescriptors_s* e;
      for (e = x->OtherDescriptors; e; e = (struct zx_hrxml_OtherDescriptors_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OtherDescriptors(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonDescriptors", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PersonDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PersonDescriptors")-1 + 1 + 2 + sizeof("PersonDescriptors")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_LegalIdentifiers_s* e;
      for (e = x->LegalIdentifiers; e; e = (struct zx_hrxml_LegalIdentifiers_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LegalIdentifiers(c, e);
  }
  {
      struct zx_hrxml_DemographicDescriptors_s* e;
      for (e = x->DemographicDescriptors; e; e = (struct zx_hrxml_DemographicDescriptors_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DemographicDescriptors(c, e);
  }
  {
      struct zx_hrxml_BiologicalDescriptors_s* e;
      for (e = x->BiologicalDescriptors; e; e = (struct zx_hrxml_BiologicalDescriptors_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_BiologicalDescriptors(c, e);
  }
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SupportingMaterials(c, e);
  }
  {
      struct zx_hrxml_OtherDescriptors_s* e;
      for (e = x->OtherDescriptors; e; e = (struct zx_hrxml_OtherDescriptors_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OtherDescriptors(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonDescriptors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonDescriptors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_LegalIdentifiers_s* e;
      for (e = x->LegalIdentifiers; e; e = (struct zx_hrxml_LegalIdentifiers_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LegalIdentifiers(c, e, p);
  }
  {
      struct zx_hrxml_DemographicDescriptors_s* e;
      for (e = x->DemographicDescriptors; e; e = (struct zx_hrxml_DemographicDescriptors_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DemographicDescriptors(c, e, p);
  }
  {
      struct zx_hrxml_BiologicalDescriptors_s* e;
      for (e = x->BiologicalDescriptors; e; e = (struct zx_hrxml_BiologicalDescriptors_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_BiologicalDescriptors(c, e, p);
  }
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SupportingMaterials(c, e, p);
  }
  {
      struct zx_hrxml_OtherDescriptors_s* e;
      for (e = x->OtherDescriptors; e; e = (struct zx_hrxml_OtherDescriptors_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OtherDescriptors(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonDescriptors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PersonDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PersonDescriptors", sizeof("PersonDescriptors")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonDescriptors(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PersonDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PersonDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PersonDescriptors(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonId
#define EL_STRUCT zx_hrxml_PersonId_s
#define EL_NS     hrxml
#define EL_TAG    PersonId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonId")-1 + 1 + sizeof("</hrxml:PersonId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PersonId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PersonId")-1 + 1 + 2 + sizeof("PersonId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PersonId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PersonId", sizeof("PersonId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PersonId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PersonId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PersonId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonLegalId
#define EL_STRUCT zx_hrxml_PersonLegalId_s
#define EL_NS     hrxml
#define EL_TAG    PersonLegalId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonLegalId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonLegalId")-1 + 1 + sizeof("</hrxml:PersonLegalId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);
  len += zx_attr_so_len(c, x->documentType, sizeof("documentType")-1, &pop_seen);
  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->idSource, sizeof("idSource")-1, &pop_seen);
  len += zx_attr_so_len(c, x->issuingRegion, sizeof("issuingRegion")-1, &pop_seen);
  len += zx_attr_so_len(c, x->jurisdiction, sizeof("jurisdiction")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonLegalId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PersonLegalId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PersonLegalId")-1 + 1 + 2 + sizeof("PersonLegalId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->documentType, sizeof("documentType")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->idSource, sizeof("idSource")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->issuingRegion, sizeof("issuingRegion")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->jurisdiction, sizeof("jurisdiction")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonLegalId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonLegalId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonLegalId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->countryCode, " countryCode=\"", sizeof(" countryCode=\"")-1);
  p = zx_attr_so_enc(p, x->documentType, " documentType=\"", sizeof(" documentType=\"")-1);
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->idSource, " idSource=\"", sizeof(" idSource=\"")-1);
  p = zx_attr_so_enc(p, x->issuingRegion, " issuingRegion=\"", sizeof(" issuingRegion=\"")-1);
  p = zx_attr_so_enc(p, x->jurisdiction, " jurisdiction=\"", sizeof(" jurisdiction=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonLegalId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonLegalId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PersonLegalId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PersonLegalId", sizeof("PersonLegalId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->countryCode, "countryCode=\"", sizeof("countryCode=\"")-1);
  p = zx_attr_wo_enc(p, x->documentType, "documentType=\"", sizeof("documentType=\"")-1);
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->idSource, "idSource=\"", sizeof("idSource=\"")-1);
  p = zx_attr_wo_enc(p, x->issuingRegion, "issuingRegion=\"", sizeof("issuingRegion=\"")-1);
  p = zx_attr_wo_enc(p, x->jurisdiction, "jurisdiction=\"", sizeof("jurisdiction=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonLegalId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonLegalId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonLegalId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonLegalId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PersonLegalId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PersonLegalId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PersonLegalId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonMember
#define EL_STRUCT zx_hrxml_PersonMember_s
#define EL_NS     hrxml
#define EL_TAG    PersonMember

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonMember) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonMember")-1 + 1 + sizeof("</hrxml:PersonMember>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonName(c, e);
  }
  {
      struct zx_hrxml_PersonId_s* e;
      for (e = x->PersonId; e; e = (struct zx_hrxml_PersonId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonId(c, e);
  }
  {
      struct zx_hrxml_PersonRole_s* e;
      for (e = x->PersonRole; e; e = (struct zx_hrxml_PersonRole_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonRole(c, e);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactMethod(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonMember", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PersonMember) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PersonMember")-1 + 1 + 2 + sizeof("PersonMember")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonName(c, e);
  }
  {
      struct zx_hrxml_PersonId_s* e;
      for (e = x->PersonId; e; e = (struct zx_hrxml_PersonId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonId(c, e);
  }
  {
      struct zx_hrxml_PersonRole_s* e;
      for (e = x->PersonRole; e; e = (struct zx_hrxml_PersonRole_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonRole(c, e);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactMethod(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonMember", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonMember) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonMember");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonName(c, e, p);
  }
  {
      struct zx_hrxml_PersonId_s* e;
      for (e = x->PersonId; e; e = (struct zx_hrxml_PersonId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonId(c, e, p);
  }
  {
      struct zx_hrxml_PersonRole_s* e;
      for (e = x->PersonRole; e; e = (struct zx_hrxml_PersonRole_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonRole(c, e, p);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactMethod(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonMember>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonMember", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PersonMember) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PersonMember", sizeof("PersonMember")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonMember", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonMember) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonMember(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonMember(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PersonMember) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PersonMember(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PersonMember(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonName
#define EL_STRUCT zx_hrxml_PersonName_s
#define EL_NS     hrxml
#define EL_TAG    PersonName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonName")-1 + 1 + sizeof("</hrxml:PersonName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->script, sizeof("script")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_FamilyName_s* e;
      for (e = x->FamilyName; e; e = (struct zx_hrxml_FamilyName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_FamilyName(c, e);
  }
  {
      struct zx_hrxml_Affix_s* e;
      for (e = x->Affix; e; e = (struct zx_hrxml_Affix_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Affix(c, e);
  }
  {
      struct zx_hrxml_AlternateScript_s* e;
      for (e = x->AlternateScript; e; e = (struct zx_hrxml_AlternateScript_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_AlternateScript(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonName", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PersonName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PersonName")-1 + 1 + 2 + sizeof("PersonName")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->script, sizeof("script")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("FormattedName")-1);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("LegalName")-1);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("GivenName")-1);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PreferredGivenName")-1);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MiddleName")-1);
  {
      struct zx_hrxml_FamilyName_s* e;
      for (e = x->FamilyName; e; e = (struct zx_hrxml_FamilyName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_FamilyName(c, e);
  }
  {
      struct zx_hrxml_Affix_s* e;
      for (e = x->Affix; e; e = (struct zx_hrxml_Affix_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Affix(c, e);
  }
  {
      struct zx_hrxml_AlternateScript_s* e;
      for (e = x->AlternateScript; e; e = (struct zx_hrxml_AlternateScript_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_AlternateScript(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->script, " script=\"", sizeof(" script=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedName", sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:LegalName", sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:GivenName", sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PreferredGivenName", sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MiddleName", sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_FamilyName_s* e;
      for (e = x->FamilyName; e; e = (struct zx_hrxml_FamilyName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_FamilyName(c, e, p);
  }
  {
      struct zx_hrxml_Affix_s* e;
      for (e = x->Affix; e; e = (struct zx_hrxml_Affix_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Affix(c, e, p);
  }
  {
      struct zx_hrxml_AlternateScript_s* e;
      for (e = x->AlternateScript; e; e = (struct zx_hrxml_AlternateScript_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_AlternateScript(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonName", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PersonName) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PersonName", sizeof("PersonName")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->script, "script=\"", sizeof("script=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonName(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PersonName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PersonName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PersonName(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonRole
#define EL_STRUCT zx_hrxml_PersonRole_s
#define EL_NS     hrxml
#define EL_TAG    PersonRole

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonRole) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonRole")-1 + 1 + sizeof("</hrxml:PersonRole>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->leader, sizeof("leader")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->RoleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:RoleName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_RoleId_s* e;
      for (e = x->RoleId; e; e = (struct zx_hrxml_RoleId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RoleId(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonRole", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PersonRole) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PersonRole")-1 + 1 + 2 + sizeof("PersonRole")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->leader, sizeof("leader")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->RoleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("RoleName")-1);
  {
      struct zx_hrxml_RoleId_s* e;
      for (e = x->RoleId; e; e = (struct zx_hrxml_RoleId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RoleId(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonRole", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonRole) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonRole");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->leader, " leader=\"", sizeof(" leader=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->RoleName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:RoleName", sizeof("hrxml:RoleName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_RoleId_s* e;
      for (e = x->RoleId; e; e = (struct zx_hrxml_RoleId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RoleId(c, e, p);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonRole>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonRole", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PersonRole) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PersonRole", sizeof("PersonRole")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->leader, "leader=\"", sizeof("leader=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonRole", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonRole) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonRole(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonRole(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PersonRole) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PersonRole(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PersonRole(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonalData
#define EL_STRUCT zx_hrxml_PersonalData_s
#define EL_NS     hrxml
#define EL_TAG    PersonalData

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonalData) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonalData")-1 + 1 + sizeof("</hrxml:PersonalData>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonId_s* e;
      for (e = x->PersonId; e; e = (struct zx_hrxml_PersonId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonId(c, e);
  }
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonName(c, e);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactMethod(c, e);
  }
  {
      struct zx_hrxml_PersonDescriptors_s* e;
      for (e = x->PersonDescriptors; e; e = (struct zx_hrxml_PersonDescriptors_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonDescriptors(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonalData", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PersonalData) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PersonalData")-1 + 1 + 2 + sizeof("PersonalData")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonId_s* e;
      for (e = x->PersonId; e; e = (struct zx_hrxml_PersonId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonId(c, e);
  }
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonName(c, e);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactMethod(c, e);
  }
  {
      struct zx_hrxml_PersonDescriptors_s* e;
      for (e = x->PersonDescriptors; e; e = (struct zx_hrxml_PersonDescriptors_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonDescriptors(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonalData", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonalData) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonalData");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_PersonId_s* e;
      for (e = x->PersonId; e; e = (struct zx_hrxml_PersonId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonId(c, e, p);
  }
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonName(c, e, p);
  }
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactMethod(c, e, p);
  }
  {
      struct zx_hrxml_PersonDescriptors_s* e;
      for (e = x->PersonDescriptors; e; e = (struct zx_hrxml_PersonDescriptors_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonDescriptors(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonalData>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonalData", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PersonalData) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PersonalData", sizeof("PersonalData")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonalData", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonalData) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonalData(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonalData(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PersonalData) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PersonalData(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PersonalData(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PhysicalLocation
#define EL_STRUCT zx_hrxml_PhysicalLocation_s
#define EL_NS     hrxml
#define EL_TAG    PhysicalLocation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PhysicalLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PhysicalLocation")-1 + 1 + sizeof("</hrxml:PhysicalLocation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EffectiveDate(c, e);
  }
  {
      struct zx_hrxml_SpatialLocation_s* e;
      for (e = x->SpatialLocation; e; e = (struct zx_hrxml_SpatialLocation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SpatialLocation(c, e);
  }
  {
      struct zx_hrxml_TravelDirections_s* e;
      for (e = x->TravelDirections; e; e = (struct zx_hrxml_TravelDirections_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_TravelDirections(c, e);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PostalAddress(c, e);
  }
  {
      struct zx_hrxml_Area_s* e;
      for (e = x->Area; e; e = (struct zx_hrxml_Area_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Area(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PhysicalLocation", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PhysicalLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PhysicalLocation")-1 + 1 + 2 + sizeof("PhysicalLocation")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EffectiveDate(c, e);
  }
  {
      struct zx_hrxml_SpatialLocation_s* e;
      for (e = x->SpatialLocation; e; e = (struct zx_hrxml_SpatialLocation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SpatialLocation(c, e);
  }
  {
      struct zx_hrxml_TravelDirections_s* e;
      for (e = x->TravelDirections; e; e = (struct zx_hrxml_TravelDirections_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_TravelDirections(c, e);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PostalAddress(c, e);
  }
  {
      struct zx_hrxml_Area_s* e;
      for (e = x->Area; e; e = (struct zx_hrxml_Area_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Area(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PhysicalLocation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PhysicalLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PhysicalLocation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EffectiveDate(c, e, p);
  }
  {
      struct zx_hrxml_SpatialLocation_s* e;
      for (e = x->SpatialLocation; e; e = (struct zx_hrxml_SpatialLocation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SpatialLocation(c, e, p);
  }
  {
      struct zx_hrxml_TravelDirections_s* e;
      for (e = x->TravelDirections; e; e = (struct zx_hrxml_TravelDirections_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_TravelDirections(c, e, p);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PostalAddress(c, e, p);
  }
  {
      struct zx_hrxml_Area_s* e;
      for (e = x->Area; e; e = (struct zx_hrxml_Area_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Area(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PhysicalLocation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PhysicalLocation", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PhysicalLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PhysicalLocation", sizeof("PhysicalLocation")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PhysicalLocation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PhysicalLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PhysicalLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PhysicalLocation(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PhysicalLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PhysicalLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PhysicalLocation(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionHistory
#define EL_STRUCT zx_hrxml_PositionHistory_s
#define EL_NS     hrxml
#define EL_TAG    PositionHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PositionHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PositionHistory")-1 + 1 + sizeof("</hrxml:PositionHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->currentEmployer, sizeof("currentEmployer")-1, &pop_seen);
  len += zx_attr_so_len(c, x->positionType, sizeof("positionType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OrgName_s* e;
      for (e = x->OrgName; e; e = (struct zx_hrxml_OrgName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrgName(c, e);
  }
  {
      struct zx_hrxml_OrgInfo_s* e;
      for (e = x->OrgInfo; e; e = (struct zx_hrxml_OrgInfo_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrgInfo(c, e);
  }
  {
      struct zx_hrxml_OrgIndustry_s* e;
      for (e = x->OrgIndustry; e; e = (struct zx_hrxml_OrgIndustry_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrgIndustry(c, e);
  }
  for (se = x->OrgSize; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrgSize")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EndDate(c, e);
  }
  {
      struct zx_hrxml_Compensation_s* e;
      for (e = x->Compensation; e; e = (struct zx_hrxml_Compensation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Compensation(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Verification_s* e;
      for (e = x->Verification; e; e = (struct zx_hrxml_Verification_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Verification(c, e);
  }
  {
      struct zx_hrxml_JobLevelInfo_s* e;
      for (e = x->JobLevelInfo; e; e = (struct zx_hrxml_JobLevelInfo_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_JobLevelInfo(c, e);
  }
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_JobCategory(c, e);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Competency(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionHistory", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PositionHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PositionHistory")-1 + 1 + 2 + sizeof("PositionHistory")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->currentEmployer, sizeof("currentEmployer")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->positionType, sizeof("positionType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Title")-1);
  {
      struct zx_hrxml_OrgName_s* e;
      for (e = x->OrgName; e; e = (struct zx_hrxml_OrgName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrgName(c, e);
  }
  {
      struct zx_hrxml_OrgInfo_s* e;
      for (e = x->OrgInfo; e; e = (struct zx_hrxml_OrgInfo_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrgInfo(c, e);
  }
  {
      struct zx_hrxml_OrgIndustry_s* e;
      for (e = x->OrgIndustry; e; e = (struct zx_hrxml_OrgIndustry_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrgIndustry(c, e);
  }
  for (se = x->OrgSize; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("OrgSize")-1);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EndDate(c, e);
  }
  {
      struct zx_hrxml_Compensation_s* e;
      for (e = x->Compensation; e; e = (struct zx_hrxml_Compensation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Compensation(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  {
      struct zx_hrxml_Verification_s* e;
      for (e = x->Verification; e; e = (struct zx_hrxml_Verification_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Verification(c, e);
  }
  {
      struct zx_hrxml_JobLevelInfo_s* e;
      for (e = x->JobLevelInfo; e; e = (struct zx_hrxml_JobLevelInfo_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_JobLevelInfo(c, e);
  }
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_JobCategory(c, e);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Competency(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PositionHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PositionHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->currentEmployer, " currentEmployer=\"", sizeof(" currentEmployer=\"")-1);
  p = zx_attr_so_enc(p, x->positionType, " positionType=\"", sizeof(" positionType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OrgName_s* e;
      for (e = x->OrgName; e; e = (struct zx_hrxml_OrgName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrgName(c, e, p);
  }
  {
      struct zx_hrxml_OrgInfo_s* e;
      for (e = x->OrgInfo; e; e = (struct zx_hrxml_OrgInfo_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrgInfo(c, e, p);
  }
  {
      struct zx_hrxml_OrgIndustry_s* e;
      for (e = x->OrgIndustry; e; e = (struct zx_hrxml_OrgIndustry_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrgIndustry(c, e, p);
  }
  for (se = x->OrgSize; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrgSize", sizeof("hrxml:OrgSize")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StartDate(c, e, p);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EndDate(c, e, p);
  }
  {
      struct zx_hrxml_Compensation_s* e;
      for (e = x->Compensation; e; e = (struct zx_hrxml_Compensation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Compensation(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Verification_s* e;
      for (e = x->Verification; e; e = (struct zx_hrxml_Verification_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Verification(c, e, p);
  }
  {
      struct zx_hrxml_JobLevelInfo_s* e;
      for (e = x->JobLevelInfo; e; e = (struct zx_hrxml_JobLevelInfo_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_JobLevelInfo(c, e, p);
  }
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_JobCategory(c, e, p);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Competency(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PositionHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionHistory", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PositionHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PositionHistory", sizeof("PositionHistory")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->currentEmployer, "currentEmployer=\"", sizeof("currentEmployer=\"")-1);
  p = zx_attr_wo_enc(p, x->positionType, "positionType=\"", sizeof("positionType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PositionHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PositionHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PositionHistory(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PositionHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PositionHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PositionHistory(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionLocation
#define EL_STRUCT zx_hrxml_PositionLocation_s
#define EL_NS     hrxml
#define EL_TAG    PositionLocation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PositionLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PositionLocation")-1 + 1 + sizeof("</hrxml:PositionLocation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Region")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DeliveryAddress_s* e;
      for (e = x->DeliveryAddress; e; e = (struct zx_hrxml_DeliveryAddress_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DeliveryAddress(c, e);
  }
  {
      struct zx_hrxml_Recipient_s* e;
      for (e = x->Recipient; e; e = (struct zx_hrxml_Recipient_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Recipient(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionLocation", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PositionLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PositionLocation")-1 + 1 + 2 + sizeof("PositionLocation")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CountryCode")-1);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PostalCode")-1);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Region")-1);
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Municipality")-1);
  {
      struct zx_hrxml_DeliveryAddress_s* e;
      for (e = x->DeliveryAddress; e; e = (struct zx_hrxml_DeliveryAddress_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DeliveryAddress(c, e);
  }
  {
      struct zx_hrxml_Recipient_s* e;
      for (e = x->Recipient; e; e = (struct zx_hrxml_Recipient_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Recipient(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionLocation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PositionLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PositionLocation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CountryCode", sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PostalCode", sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Region", sizeof("hrxml:Region")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Municipality", sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DeliveryAddress_s* e;
      for (e = x->DeliveryAddress; e; e = (struct zx_hrxml_DeliveryAddress_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DeliveryAddress(c, e, p);
  }
  {
      struct zx_hrxml_Recipient_s* e;
      for (e = x->Recipient; e; e = (struct zx_hrxml_Recipient_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Recipient(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PositionLocation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionLocation", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PositionLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PositionLocation", sizeof("PositionLocation")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionLocation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PositionLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PositionLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PositionLocation(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PositionLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PositionLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PositionLocation(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionMatching
#define EL_STRUCT zx_hrxml_PositionMatching_s
#define EL_NS     hrxml
#define EL_TAG    PositionMatching

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PositionMatching) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PositionMatching")-1 + 1 + sizeof("</hrxml:PositionMatching>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Company_s* e;
      for (e = x->Company; e; e = (struct zx_hrxml_Company_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Company(c, e);
  }
  for (se = x->CompanyScale; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CompanyScale")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IndustryCode(c, e);
  }
  {
      struct zx_hrxml_PhysicalLocation_s* e;
      for (e = x->PhysicalLocation; e; e = (struct zx_hrxml_PhysicalLocation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PhysicalLocation(c, e);
  }
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_JobCategory(c, e);
  }
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PositionClassification; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PositionClassification")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PositionSchedule_s* e;
      for (e = x->PositionSchedule; e; e = (struct zx_hrxml_PositionSchedule_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PositionSchedule(c, e);
  }
  {
      struct zx_hrxml_Shift_s* e;
      for (e = x->Shift; e; e = (struct zx_hrxml_Shift_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Shift(c, e);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Competency(c, e);
  }
  {
      struct zx_hrxml_RemunerationPackage_s* e;
      for (e = x->RemunerationPackage; e; e = (struct zx_hrxml_RemunerationPackage_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RemunerationPackage(c, e);
  }
  for (se = x->WorkStyle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:WorkStyle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DressCode_s* e;
      for (e = x->DressCode; e; e = (struct zx_hrxml_DressCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DressCode(c, e);
  }
  {
      struct zx_hrxml_Travel_s* e;
      for (e = x->Travel; e; e = (struct zx_hrxml_Travel_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Travel(c, e);
  }
  {
      struct zx_hrxml_Relocation_s* e;
      for (e = x->Relocation; e; e = (struct zx_hrxml_Relocation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Relocation(c, e);
  }
  {
      struct zx_hrxml_PreferredLanguage_s* e;
      for (e = x->PreferredLanguage; e; e = (struct zx_hrxml_PreferredLanguage_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PreferredLanguage(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionMatching", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PositionMatching) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PositionMatching")-1 + 1 + 2 + sizeof("PositionMatching")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Company_s* e;
      for (e = x->Company; e; e = (struct zx_hrxml_Company_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Company(c, e);
  }
  for (se = x->CompanyScale; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CompanyScale")-1);
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IndustryCode(c, e);
  }
  {
      struct zx_hrxml_PhysicalLocation_s* e;
      for (e = x->PhysicalLocation; e; e = (struct zx_hrxml_PhysicalLocation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PhysicalLocation(c, e);
  }
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_JobCategory(c, e);
  }
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PositionTitle")-1);
  for (se = x->PositionClassification; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PositionClassification")-1);
  {
      struct zx_hrxml_PositionSchedule_s* e;
      for (e = x->PositionSchedule; e; e = (struct zx_hrxml_PositionSchedule_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PositionSchedule(c, e);
  }
  {
      struct zx_hrxml_Shift_s* e;
      for (e = x->Shift; e; e = (struct zx_hrxml_Shift_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Shift(c, e);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Competency(c, e);
  }
  {
      struct zx_hrxml_RemunerationPackage_s* e;
      for (e = x->RemunerationPackage; e; e = (struct zx_hrxml_RemunerationPackage_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RemunerationPackage(c, e);
  }
  for (se = x->WorkStyle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("WorkStyle")-1);
  {
      struct zx_hrxml_DressCode_s* e;
      for (e = x->DressCode; e; e = (struct zx_hrxml_DressCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DressCode(c, e);
  }
  {
      struct zx_hrxml_Travel_s* e;
      for (e = x->Travel; e; e = (struct zx_hrxml_Travel_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Travel(c, e);
  }
  {
      struct zx_hrxml_Relocation_s* e;
      for (e = x->Relocation; e; e = (struct zx_hrxml_Relocation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Relocation(c, e);
  }
  {
      struct zx_hrxml_PreferredLanguage_s* e;
      for (e = x->PreferredLanguage; e; e = (struct zx_hrxml_PreferredLanguage_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PreferredLanguage(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionMatching", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PositionMatching) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PositionMatching");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Company_s* e;
      for (e = x->Company; e; e = (struct zx_hrxml_Company_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Company(c, e, p);
  }
  for (se = x->CompanyScale; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CompanyScale", sizeof("hrxml:CompanyScale")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IndustryCode(c, e, p);
  }
  {
      struct zx_hrxml_PhysicalLocation_s* e;
      for (e = x->PhysicalLocation; e; e = (struct zx_hrxml_PhysicalLocation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PhysicalLocation(c, e, p);
  }
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_JobCategory(c, e, p);
  }
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PositionTitle", sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PositionClassification; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PositionClassification", sizeof("hrxml:PositionClassification")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PositionSchedule_s* e;
      for (e = x->PositionSchedule; e; e = (struct zx_hrxml_PositionSchedule_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PositionSchedule(c, e, p);
  }
  {
      struct zx_hrxml_Shift_s* e;
      for (e = x->Shift; e; e = (struct zx_hrxml_Shift_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Shift(c, e, p);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Competency(c, e, p);
  }
  {
      struct zx_hrxml_RemunerationPackage_s* e;
      for (e = x->RemunerationPackage; e; e = (struct zx_hrxml_RemunerationPackage_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RemunerationPackage(c, e, p);
  }
  for (se = x->WorkStyle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:WorkStyle", sizeof("hrxml:WorkStyle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DressCode_s* e;
      for (e = x->DressCode; e; e = (struct zx_hrxml_DressCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DressCode(c, e, p);
  }
  {
      struct zx_hrxml_Travel_s* e;
      for (e = x->Travel; e; e = (struct zx_hrxml_Travel_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Travel(c, e, p);
  }
  {
      struct zx_hrxml_Relocation_s* e;
      for (e = x->Relocation; e; e = (struct zx_hrxml_Relocation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Relocation(c, e, p);
  }
  {
      struct zx_hrxml_PreferredLanguage_s* e;
      for (e = x->PreferredLanguage; e; e = (struct zx_hrxml_PreferredLanguage_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PreferredLanguage(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PositionMatching>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionMatching", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PositionMatching) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PositionMatching", sizeof("PositionMatching")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionMatching", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PositionMatching) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PositionMatching(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PositionMatching(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PositionMatching) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PositionMatching(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PositionMatching(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionPosting
#define EL_STRUCT zx_hrxml_PositionPosting_s
#define EL_NS     hrxml
#define EL_TAG    PositionPosting

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PositionPosting) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PositionPosting")-1 + 1 + sizeof("</hrxml:PositionPosting>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_SearchCriteria_s* e;
      for (e = x->SearchCriteria; e; e = (struct zx_hrxml_SearchCriteria_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SearchCriteria(c, e);
  }
  {
      struct zx_hrxml_SearchResult_s* e;
      for (e = x->SearchResult; e; e = (struct zx_hrxml_SearchResult_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SearchResult(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionPosting", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PositionPosting) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PositionPosting")-1 + 1 + 2 + sizeof("PositionPosting")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Title")-1);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Link")-1);
  {
      struct zx_hrxml_SearchCriteria_s* e;
      for (e = x->SearchCriteria; e; e = (struct zx_hrxml_SearchCriteria_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SearchCriteria(c, e);
  }
  {
      struct zx_hrxml_SearchResult_s* e;
      for (e = x->SearchResult; e; e = (struct zx_hrxml_SearchResult_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SearchResult(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionPosting", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PositionPosting) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PositionPosting");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_SearchCriteria_s* e;
      for (e = x->SearchCriteria; e; e = (struct zx_hrxml_SearchCriteria_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SearchCriteria(c, e, p);
  }
  {
      struct zx_hrxml_SearchResult_s* e;
      for (e = x->SearchResult; e; e = (struct zx_hrxml_SearchResult_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SearchResult(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PositionPosting>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionPosting", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PositionPosting) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PositionPosting", sizeof("PositionPosting")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionPosting", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PositionPosting) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PositionPosting(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PositionPosting(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PositionPosting) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PositionPosting(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PositionPosting(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionSchedule
#define EL_STRUCT zx_hrxml_PositionSchedule_s
#define EL_NS     hrxml
#define EL_TAG    PositionSchedule

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PositionSchedule) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PositionSchedule")-1 + 1 + sizeof("</hrxml:PositionSchedule>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->percentage, sizeof("percentage")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionSchedule", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PositionSchedule) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PositionSchedule")-1 + 1 + 2 + sizeof("PositionSchedule")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->percentage, sizeof("percentage")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionSchedule", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PositionSchedule) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PositionSchedule");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->percentage, " percentage=\"", sizeof(" percentage=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PositionSchedule>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionSchedule", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PositionSchedule) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PositionSchedule", sizeof("PositionSchedule")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->percentage, "percentage=\"", sizeof("percentage=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionSchedule", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PositionSchedule) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PositionSchedule(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PositionSchedule(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PositionSchedule) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PositionSchedule(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PositionSchedule(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PostalAddress
#define EL_STRUCT zx_hrxml_PostalAddress_s
#define EL_NS     hrxml
#define EL_TAG    PostalAddress

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PostalAddress) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PostalAddress")-1 + 1 + sizeof("</hrxml:PostalAddress>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Region")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DeliveryAddress_s* e;
      for (e = x->DeliveryAddress; e; e = (struct zx_hrxml_DeliveryAddress_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DeliveryAddress(c, e);
  }
  {
      struct zx_hrxml_Recipient_s* e;
      for (e = x->Recipient; e; e = (struct zx_hrxml_Recipient_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Recipient(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PostalAddress", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PostalAddress) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PostalAddress")-1 + 1 + 2 + sizeof("PostalAddress")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CountryCode")-1);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PostalCode")-1);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Region")-1);
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Municipality")-1);
  {
      struct zx_hrxml_DeliveryAddress_s* e;
      for (e = x->DeliveryAddress; e; e = (struct zx_hrxml_DeliveryAddress_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DeliveryAddress(c, e);
  }
  {
      struct zx_hrxml_Recipient_s* e;
      for (e = x->Recipient; e; e = (struct zx_hrxml_Recipient_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Recipient(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PostalAddress", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PostalAddress) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PostalAddress");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CountryCode", sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PostalCode", sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Region", sizeof("hrxml:Region")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Municipality", sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DeliveryAddress_s* e;
      for (e = x->DeliveryAddress; e; e = (struct zx_hrxml_DeliveryAddress_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DeliveryAddress(c, e, p);
  }
  {
      struct zx_hrxml_Recipient_s* e;
      for (e = x->Recipient; e; e = (struct zx_hrxml_Recipient_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Recipient(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PostalAddress>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PostalAddress", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PostalAddress) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PostalAddress", sizeof("PostalAddress")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PostalAddress", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PostalAddress) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PostalAddress(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PostalAddress(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PostalAddress) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PostalAddress(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PostalAddress(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PreferredLanguage
#define EL_STRUCT zx_hrxml_PreferredLanguage_s
#define EL_NS     hrxml
#define EL_TAG    PreferredLanguage

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PreferredLanguage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PreferredLanguage")-1 + 1 + sizeof("</hrxml:PreferredLanguage>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PreferredLanguage", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PreferredLanguage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PreferredLanguage")-1 + 1 + 2 + sizeof("PreferredLanguage")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PreferredLanguage", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PreferredLanguage) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PreferredLanguage");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PreferredLanguage>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PreferredLanguage", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PreferredLanguage) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PreferredLanguage", sizeof("PreferredLanguage")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PreferredLanguage", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PreferredLanguage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PreferredLanguage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PreferredLanguage(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PreferredLanguage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PreferredLanguage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PreferredLanguage(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PreferredPosition
#define EL_STRUCT zx_hrxml_PreferredPosition_s
#define EL_NS     hrxml
#define EL_TAG    PreferredPosition

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PreferredPosition) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PreferredPosition")-1 + 1 + sizeof("</hrxml:PreferredPosition>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Company_s* e;
      for (e = x->Company; e; e = (struct zx_hrxml_Company_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Company(c, e);
  }
  for (se = x->CompanyScale; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CompanyScale")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IndustryCode(c, e);
  }
  {
      struct zx_hrxml_PhysicalLocation_s* e;
      for (e = x->PhysicalLocation; e; e = (struct zx_hrxml_PhysicalLocation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PhysicalLocation(c, e);
  }
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_JobCategory(c, e);
  }
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PositionClassification; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PositionClassification")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PositionSchedule_s* e;
      for (e = x->PositionSchedule; e; e = (struct zx_hrxml_PositionSchedule_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PositionSchedule(c, e);
  }
  {
      struct zx_hrxml_Shift_s* e;
      for (e = x->Shift; e; e = (struct zx_hrxml_Shift_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Shift(c, e);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Competency(c, e);
  }
  {
      struct zx_hrxml_RemunerationPackage_s* e;
      for (e = x->RemunerationPackage; e; e = (struct zx_hrxml_RemunerationPackage_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RemunerationPackage(c, e);
  }
  for (se = x->WorkStyle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:WorkStyle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DressCode_s* e;
      for (e = x->DressCode; e; e = (struct zx_hrxml_DressCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DressCode(c, e);
  }
  {
      struct zx_hrxml_Travel_s* e;
      for (e = x->Travel; e; e = (struct zx_hrxml_Travel_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Travel(c, e);
  }
  {
      struct zx_hrxml_Relocation_s* e;
      for (e = x->Relocation; e; e = (struct zx_hrxml_Relocation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Relocation(c, e);
  }
  {
      struct zx_hrxml_PreferredLanguage_s* e;
      for (e = x->PreferredLanguage; e; e = (struct zx_hrxml_PreferredLanguage_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PreferredLanguage(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }
  {
      struct zx_hrxml_Commute_s* e;
      for (e = x->Commute; e; e = (struct zx_hrxml_Commute_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Commute(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PreferredPosition", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PreferredPosition) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PreferredPosition")-1 + 1 + 2 + sizeof("PreferredPosition")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Company_s* e;
      for (e = x->Company; e; e = (struct zx_hrxml_Company_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Company(c, e);
  }
  for (se = x->CompanyScale; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CompanyScale")-1);
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IndustryCode(c, e);
  }
  {
      struct zx_hrxml_PhysicalLocation_s* e;
      for (e = x->PhysicalLocation; e; e = (struct zx_hrxml_PhysicalLocation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PhysicalLocation(c, e);
  }
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_JobCategory(c, e);
  }
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PositionTitle")-1);
  for (se = x->PositionClassification; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PositionClassification")-1);
  {
      struct zx_hrxml_PositionSchedule_s* e;
      for (e = x->PositionSchedule; e; e = (struct zx_hrxml_PositionSchedule_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PositionSchedule(c, e);
  }
  {
      struct zx_hrxml_Shift_s* e;
      for (e = x->Shift; e; e = (struct zx_hrxml_Shift_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Shift(c, e);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Competency(c, e);
  }
  {
      struct zx_hrxml_RemunerationPackage_s* e;
      for (e = x->RemunerationPackage; e; e = (struct zx_hrxml_RemunerationPackage_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RemunerationPackage(c, e);
  }
  for (se = x->WorkStyle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("WorkStyle")-1);
  {
      struct zx_hrxml_DressCode_s* e;
      for (e = x->DressCode; e; e = (struct zx_hrxml_DressCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DressCode(c, e);
  }
  {
      struct zx_hrxml_Travel_s* e;
      for (e = x->Travel; e; e = (struct zx_hrxml_Travel_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Travel(c, e);
  }
  {
      struct zx_hrxml_Relocation_s* e;
      for (e = x->Relocation; e; e = (struct zx_hrxml_Relocation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Relocation(c, e);
  }
  {
      struct zx_hrxml_PreferredLanguage_s* e;
      for (e = x->PreferredLanguage; e; e = (struct zx_hrxml_PreferredLanguage_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PreferredLanguage(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }
  {
      struct zx_hrxml_Commute_s* e;
      for (e = x->Commute; e; e = (struct zx_hrxml_Commute_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Commute(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PreferredPosition", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PreferredPosition) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PreferredPosition");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Company_s* e;
      for (e = x->Company; e; e = (struct zx_hrxml_Company_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Company(c, e, p);
  }
  for (se = x->CompanyScale; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CompanyScale", sizeof("hrxml:CompanyScale")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IndustryCode(c, e, p);
  }
  {
      struct zx_hrxml_PhysicalLocation_s* e;
      for (e = x->PhysicalLocation; e; e = (struct zx_hrxml_PhysicalLocation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PhysicalLocation(c, e, p);
  }
  {
      struct zx_hrxml_JobCategory_s* e;
      for (e = x->JobCategory; e; e = (struct zx_hrxml_JobCategory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_JobCategory(c, e, p);
  }
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PositionTitle", sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PositionClassification; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PositionClassification", sizeof("hrxml:PositionClassification")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_PositionSchedule_s* e;
      for (e = x->PositionSchedule; e; e = (struct zx_hrxml_PositionSchedule_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PositionSchedule(c, e, p);
  }
  {
      struct zx_hrxml_Shift_s* e;
      for (e = x->Shift; e; e = (struct zx_hrxml_Shift_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Shift(c, e, p);
  }
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Competency(c, e, p);
  }
  {
      struct zx_hrxml_RemunerationPackage_s* e;
      for (e = x->RemunerationPackage; e; e = (struct zx_hrxml_RemunerationPackage_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RemunerationPackage(c, e, p);
  }
  for (se = x->WorkStyle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:WorkStyle", sizeof("hrxml:WorkStyle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_DressCode_s* e;
      for (e = x->DressCode; e; e = (struct zx_hrxml_DressCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DressCode(c, e, p);
  }
  {
      struct zx_hrxml_Travel_s* e;
      for (e = x->Travel; e; e = (struct zx_hrxml_Travel_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Travel(c, e, p);
  }
  {
      struct zx_hrxml_Relocation_s* e;
      for (e = x->Relocation; e; e = (struct zx_hrxml_Relocation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Relocation(c, e, p);
  }
  {
      struct zx_hrxml_PreferredLanguage_s* e;
      for (e = x->PreferredLanguage; e; e = (struct zx_hrxml_PreferredLanguage_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PreferredLanguage(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }
  {
      struct zx_hrxml_Commute_s* e;
      for (e = x->Commute; e; e = (struct zx_hrxml_Commute_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Commute(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PreferredPosition>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PreferredPosition", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PreferredPosition) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PreferredPosition", sizeof("PreferredPosition")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PreferredPosition", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PreferredPosition) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PreferredPosition(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PreferredPosition(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PreferredPosition) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PreferredPosition(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PreferredPosition(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PrehireRemuneration
#define EL_STRUCT zx_hrxml_PrehireRemuneration_s
#define EL_NS     hrxml
#define EL_TAG    PrehireRemuneration

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PrehireRemuneration) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PrehireRemuneration")-1 + 1 + sizeof("</hrxml:PrehireRemuneration>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_BasePay_s* e;
      for (e = x->BasePay; e; e = (struct zx_hrxml_BasePay_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_BasePay(c, e);
  }
  {
      struct zx_hrxml_OtherPay_s* e;
      for (e = x->OtherPay; e; e = (struct zx_hrxml_OtherPay_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OtherPay(c, e);
  }
  {
      struct zx_hrxml_Benefits_s* e;
      for (e = x->Benefits; e; e = (struct zx_hrxml_Benefits_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Benefits(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PrehireRemuneration", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PrehireRemuneration) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PrehireRemuneration")-1 + 1 + 2 + sizeof("PrehireRemuneration")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_BasePay_s* e;
      for (e = x->BasePay; e; e = (struct zx_hrxml_BasePay_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_BasePay(c, e);
  }
  {
      struct zx_hrxml_OtherPay_s* e;
      for (e = x->OtherPay; e; e = (struct zx_hrxml_OtherPay_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OtherPay(c, e);
  }
  {
      struct zx_hrxml_Benefits_s* e;
      for (e = x->Benefits; e; e = (struct zx_hrxml_Benefits_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Benefits(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PrehireRemuneration", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PrehireRemuneration) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PrehireRemuneration");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_BasePay_s* e;
      for (e = x->BasePay; e; e = (struct zx_hrxml_BasePay_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_BasePay(c, e, p);
  }
  {
      struct zx_hrxml_OtherPay_s* e;
      for (e = x->OtherPay; e; e = (struct zx_hrxml_OtherPay_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OtherPay(c, e, p);
  }
  {
      struct zx_hrxml_Benefits_s* e;
      for (e = x->Benefits; e; e = (struct zx_hrxml_Benefits_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Benefits(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PrehireRemuneration>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PrehireRemuneration", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PrehireRemuneration) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PrehireRemuneration", sizeof("PrehireRemuneration")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PrehireRemuneration", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PrehireRemuneration) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PrehireRemuneration(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PrehireRemuneration(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PrehireRemuneration) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PrehireRemuneration(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PrehireRemuneration(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PrimaryLanguage
#define EL_STRUCT zx_hrxml_PrimaryLanguage_s
#define EL_NS     hrxml
#define EL_TAG    PrimaryLanguage

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PrimaryLanguage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PrimaryLanguage")-1 + 1 + sizeof("</hrxml:PrimaryLanguage>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PrimaryLanguage", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PrimaryLanguage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PrimaryLanguage")-1 + 1 + 2 + sizeof("PrimaryLanguage")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PrimaryLanguage", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PrimaryLanguage) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PrimaryLanguage");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PrimaryLanguage>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PrimaryLanguage", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PrimaryLanguage) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PrimaryLanguage", sizeof("PrimaryLanguage")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PrimaryLanguage", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PrimaryLanguage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PrimaryLanguage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PrimaryLanguage(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PrimaryLanguage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PrimaryLanguage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PrimaryLanguage(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ProfessionalAssociations
#define EL_STRUCT zx_hrxml_ProfessionalAssociations_s
#define EL_NS     hrxml
#define EL_TAG    ProfessionalAssociations

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ProfessionalAssociations) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ProfessionalAssociations")-1 + 1 + sizeof("</hrxml:ProfessionalAssociations>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Association_s* e;
      for (e = x->Association; e; e = (struct zx_hrxml_Association_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Association(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ProfessionalAssociations", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ProfessionalAssociations) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ProfessionalAssociations")-1 + 1 + 2 + sizeof("ProfessionalAssociations")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Association_s* e;
      for (e = x->Association; e; e = (struct zx_hrxml_Association_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Association(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ProfessionalAssociations", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ProfessionalAssociations) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ProfessionalAssociations");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Association_s* e;
      for (e = x->Association; e; e = (struct zx_hrxml_Association_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Association(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ProfessionalAssociations>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ProfessionalAssociations", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ProfessionalAssociations) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ProfessionalAssociations", sizeof("ProfessionalAssociations")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ProfessionalAssociations", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ProfessionalAssociations) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ProfessionalAssociations(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ProfessionalAssociations(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ProfessionalAssociations) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ProfessionalAssociations(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ProfessionalAssociations(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ProfileId
#define EL_STRUCT zx_hrxml_ProfileId_s
#define EL_NS     hrxml
#define EL_TAG    ProfileId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ProfileId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ProfileId")-1 + 1 + sizeof("</hrxml:ProfileId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ProfileId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ProfileId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ProfileId")-1 + 1 + 2 + sizeof("ProfileId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ProfileId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ProfileId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ProfileId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ProfileId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ProfileId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ProfileId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ProfileId", sizeof("ProfileId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ProfileId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ProfileId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ProfileId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ProfileId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ProfileId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ProfileId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ProfileId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ProgramId
#define EL_STRUCT zx_hrxml_ProgramId_s
#define EL_NS     hrxml
#define EL_TAG    ProgramId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ProgramId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ProgramId")-1 + 1 + sizeof("</hrxml:ProgramId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ProgramId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ProgramId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ProgramId")-1 + 1 + 2 + sizeof("ProgramId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ProgramId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ProgramId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ProgramId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ProgramId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ProgramId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ProgramId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ProgramId", sizeof("ProgramId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ProgramId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ProgramId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ProgramId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ProgramId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ProgramId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ProgramId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ProgramId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PublicationDate
#define EL_STRUCT zx_hrxml_PublicationDate_s
#define EL_NS     hrxml
#define EL_TAG    PublicationDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PublicationDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PublicationDate")-1 + 1 + sizeof("</hrxml:PublicationDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PublicationDate", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PublicationDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PublicationDate")-1 + 1 + 2 + sizeof("PublicationDate")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AnyDate")-1);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("YearMonth")-1);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Year")-1);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDay")-1);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StringDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PublicationDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PublicationDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PublicationDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PublicationDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PublicationDate", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PublicationDate) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PublicationDate", sizeof("PublicationDate")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateDescription, "dateDescription=\"", sizeof("dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PublicationDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PublicationDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PublicationDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PublicationDate(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PublicationDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PublicationDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PublicationDate(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PublicationHistory
#define EL_STRUCT zx_hrxml_PublicationHistory_s
#define EL_NS     hrxml
#define EL_TAG    PublicationHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PublicationHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PublicationHistory")-1 + 1 + sizeof("</hrxml:PublicationHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_FormattedPublicationDescription_s* e;
      for (e = x->FormattedPublicationDescription; e; e = (struct zx_hrxml_FormattedPublicationDescription_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_FormattedPublicationDescription(c, e);
  }
  {
      struct zx_hrxml_Article_s* e;
      for (e = x->Article; e; e = (struct zx_hrxml_Article_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Article(c, e);
  }
  {
      struct zx_hrxml_Book_s* e;
      for (e = x->Book; e; e = (struct zx_hrxml_Book_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Book(c, e);
  }
  {
      struct zx_hrxml_ConferencePaper_s* e;
      for (e = x->ConferencePaper; e; e = (struct zx_hrxml_ConferencePaper_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ConferencePaper(c, e);
  }
  {
      struct zx_hrxml_OtherPublication_s* e;
      for (e = x->OtherPublication; e; e = (struct zx_hrxml_OtherPublication_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OtherPublication(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PublicationHistory", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PublicationHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PublicationHistory")-1 + 1 + 2 + sizeof("PublicationHistory")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_FormattedPublicationDescription_s* e;
      for (e = x->FormattedPublicationDescription; e; e = (struct zx_hrxml_FormattedPublicationDescription_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_FormattedPublicationDescription(c, e);
  }
  {
      struct zx_hrxml_Article_s* e;
      for (e = x->Article; e; e = (struct zx_hrxml_Article_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Article(c, e);
  }
  {
      struct zx_hrxml_Book_s* e;
      for (e = x->Book; e; e = (struct zx_hrxml_Book_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Book(c, e);
  }
  {
      struct zx_hrxml_ConferencePaper_s* e;
      for (e = x->ConferencePaper; e; e = (struct zx_hrxml_ConferencePaper_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ConferencePaper(c, e);
  }
  {
      struct zx_hrxml_OtherPublication_s* e;
      for (e = x->OtherPublication; e; e = (struct zx_hrxml_OtherPublication_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OtherPublication(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PublicationHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PublicationHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PublicationHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_FormattedPublicationDescription_s* e;
      for (e = x->FormattedPublicationDescription; e; e = (struct zx_hrxml_FormattedPublicationDescription_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_FormattedPublicationDescription(c, e, p);
  }
  {
      struct zx_hrxml_Article_s* e;
      for (e = x->Article; e; e = (struct zx_hrxml_Article_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Article(c, e, p);
  }
  {
      struct zx_hrxml_Book_s* e;
      for (e = x->Book; e; e = (struct zx_hrxml_Book_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Book(c, e, p);
  }
  {
      struct zx_hrxml_ConferencePaper_s* e;
      for (e = x->ConferencePaper; e; e = (struct zx_hrxml_ConferencePaper_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ConferencePaper(c, e, p);
  }
  {
      struct zx_hrxml_OtherPublication_s* e;
      for (e = x->OtherPublication; e; e = (struct zx_hrxml_OtherPublication_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OtherPublication(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PublicationHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PublicationHistory", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PublicationHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PublicationHistory", sizeof("PublicationHistory")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PublicationHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PublicationHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PublicationHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PublicationHistory(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PublicationHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PublicationHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PublicationHistory(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PublicationLanguage
#define EL_STRUCT zx_hrxml_PublicationLanguage_s
#define EL_NS     hrxml
#define EL_TAG    PublicationLanguage

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PublicationLanguage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PublicationLanguage")-1 + 1 + sizeof("</hrxml:PublicationLanguage>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PublicationLanguage", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_PublicationLanguage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("PublicationLanguage")-1 + 1 + 2 + sizeof("PublicationLanguage")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PublicationLanguage", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PublicationLanguage) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PublicationLanguage");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PublicationLanguage>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PublicationLanguage", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_PublicationLanguage) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "PublicationLanguage", sizeof("PublicationLanguage")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PublicationLanguage", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PublicationLanguage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PublicationLanguage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PublicationLanguage(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_PublicationLanguage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_PublicationLanguage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_PublicationLanguage(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Qualifications
#define EL_STRUCT zx_hrxml_Qualifications_s
#define EL_NS     hrxml
#define EL_TAG    Qualifications

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Qualifications) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Qualifications")-1 + 1 + sizeof("</hrxml:Qualifications>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->QualificationSummary; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:QualificationSummary")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Competency(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Qualifications", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Qualifications) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Qualifications")-1 + 1 + 2 + sizeof("Qualifications")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->QualificationSummary; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("QualificationSummary")-1);
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Competency(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Qualifications", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Qualifications) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Qualifications");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->QualificationSummary; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:QualificationSummary", sizeof("hrxml:QualificationSummary")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Competency_s* e;
      for (e = x->Competency; e; e = (struct zx_hrxml_Competency_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Competency(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Qualifications>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Qualifications", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Qualifications) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Qualifications", sizeof("Qualifications")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Qualifications", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Qualifications) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Qualifications(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Qualifications(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Qualifications) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Qualifications(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Qualifications(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RankAchieved
#define EL_STRUCT zx_hrxml_RankAchieved_s
#define EL_NS     hrxml
#define EL_TAG    RankAchieved

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RankAchieved) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RankAchieved")-1 + 1 + sizeof("</hrxml:RankAchieved>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->StartRank; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StartRank")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CurrentOrEndRank; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CurrentOrEndRank")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RankAchieved", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_RankAchieved) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("RankAchieved")-1 + 1 + 2 + sizeof("RankAchieved")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->StartRank; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StartRank")-1);
  for (se = x->CurrentOrEndRank; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CurrentOrEndRank")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RankAchieved", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RankAchieved) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RankAchieved");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->StartRank; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StartRank", sizeof("hrxml:StartRank")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CurrentOrEndRank; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CurrentOrEndRank", sizeof("hrxml:CurrentOrEndRank")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RankAchieved>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RankAchieved", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_RankAchieved) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "RankAchieved", sizeof("RankAchieved")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RankAchieved", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RankAchieved) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RankAchieved(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RankAchieved(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_RankAchieved) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_RankAchieved(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_RankAchieved(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RankedResult
#define EL_STRUCT zx_hrxml_RankedResult_s
#define EL_NS     hrxml
#define EL_TAG    RankedResult

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RankedResult) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RankedResult")-1 + 1 + sizeof("</hrxml:RankedResult>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CriterionName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CriterionName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Requested; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Requested")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Offered; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Offered")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Score_s* e;
      for (e = x->Score; e; e = (struct zx_hrxml_Score_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Score(c, e);
  }
  {
      struct zx_hrxml_Weight_s* e;
      for (e = x->Weight; e; e = (struct zx_hrxml_Weight_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Weight(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }
  {
      struct zx_hrxml_RankedResult_s* e;
      for (e = x->RankedResult; e; e = (struct zx_hrxml_RankedResult_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RankedResult(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RankedResult", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_RankedResult) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("RankedResult")-1 + 1 + 2 + sizeof("RankedResult")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CriterionName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CriterionName")-1);
  for (se = x->Requested; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Requested")-1);
  for (se = x->Offered; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Offered")-1);
  {
      struct zx_hrxml_Score_s* e;
      for (e = x->Score; e; e = (struct zx_hrxml_Score_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Score(c, e);
  }
  {
      struct zx_hrxml_Weight_s* e;
      for (e = x->Weight; e; e = (struct zx_hrxml_Weight_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Weight(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }
  {
      struct zx_hrxml_RankedResult_s* e;
      for (e = x->RankedResult; e; e = (struct zx_hrxml_RankedResult_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RankedResult(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RankedResult", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RankedResult) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RankedResult");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->CriterionName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CriterionName", sizeof("hrxml:CriterionName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Requested; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Requested", sizeof("hrxml:Requested")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Offered; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Offered", sizeof("hrxml:Offered")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Score_s* e;
      for (e = x->Score; e; e = (struct zx_hrxml_Score_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Score(c, e, p);
  }
  {
      struct zx_hrxml_Weight_s* e;
      for (e = x->Weight; e; e = (struct zx_hrxml_Weight_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Weight(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }
  {
      struct zx_hrxml_RankedResult_s* e;
      for (e = x->RankedResult; e; e = (struct zx_hrxml_RankedResult_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RankedResult(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RankedResult>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RankedResult", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_RankedResult) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "RankedResult", sizeof("RankedResult")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RankedResult", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RankedResult) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RankedResult(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RankedResult(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_RankedResult) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_RankedResult(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_RankedResult(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RankedSearchResults
#define EL_STRUCT zx_hrxml_RankedSearchResults_s
#define EL_NS     hrxml
#define EL_TAG    RankedSearchResults

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RankedSearchResults) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RankedSearchResults")-1 + 1 + sizeof("</hrxml:RankedSearchResults>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_RankedResult_s* e;
      for (e = x->RankedResult; e; e = (struct zx_hrxml_RankedResult_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RankedResult(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RankedSearchResults", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_RankedSearchResults) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("RankedSearchResults")-1 + 1 + 2 + sizeof("RankedSearchResults")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_RankedResult_s* e;
      for (e = x->RankedResult; e; e = (struct zx_hrxml_RankedResult_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RankedResult(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RankedSearchResults", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RankedSearchResults) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RankedSearchResults");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_RankedResult_s* e;
      for (e = x->RankedResult; e; e = (struct zx_hrxml_RankedResult_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RankedResult(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RankedSearchResults>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RankedSearchResults", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_RankedSearchResults) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "RankedSearchResults", sizeof("RankedSearchResults")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RankedSearchResults", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RankedSearchResults) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RankedSearchResults(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RankedSearchResults(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_RankedSearchResults) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_RankedSearchResults(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_RankedSearchResults(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Recipient
#define EL_STRUCT zx_hrxml_Recipient_s
#define EL_NS     hrxml
#define EL_TAG    Recipient

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Recipient) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Recipient")-1 + 1 + sizeof("</hrxml:Recipient>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonName(c, e);
  }
  for (se = x->AdditionalText; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AdditionalText")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Organization_s* e;
      for (e = x->Organization; e; e = (struct zx_hrxml_Organization_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Organization(c, e);
  }
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Recipient", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Recipient) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Recipient")-1 + 1 + 2 + sizeof("Recipient")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonName(c, e);
  }
  for (se = x->AdditionalText; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AdditionalText")-1);
  {
      struct zx_hrxml_Organization_s* e;
      for (e = x->Organization; e; e = (struct zx_hrxml_Organization_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Organization(c, e);
  }
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("OrganizationName")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Recipient", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Recipient) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Recipient");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonName(c, e, p);
  }
  for (se = x->AdditionalText; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AdditionalText", sizeof("hrxml:AdditionalText")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Organization_s* e;
      for (e = x->Organization; e; e = (struct zx_hrxml_Organization_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Organization(c, e, p);
  }
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrganizationName", sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Recipient>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Recipient", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Recipient) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Recipient", sizeof("Recipient")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Recipient", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Recipient) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Recipient(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Recipient(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Recipient) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Recipient(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Recipient(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Reference
#define EL_STRUCT zx_hrxml_Reference_s
#define EL_NS     hrxml
#define EL_TAG    Reference

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Reference) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Reference")-1 + 1 + sizeof("</hrxml:Reference>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonName(c, e);
  }
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactMethod(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Reference", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Reference) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Reference")-1 + 1 + 2 + sizeof("Reference")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonName(c, e);
  }
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PositionTitle")-1);
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactMethod(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Reference", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Reference) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Reference");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_PersonName_s* e;
      for (e = x->PersonName; e; e = (struct zx_hrxml_PersonName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonName(c, e, p);
  }
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PositionTitle", sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_ContactMethod_s* e;
      for (e = x->ContactMethod; e; e = (struct zx_hrxml_ContactMethod_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactMethod(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Reference>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Reference", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Reference) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Reference", sizeof("Reference")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Reference", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Reference) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Reference(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Reference(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Reference) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Reference(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Reference(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_References
#define EL_STRUCT zx_hrxml_References_s
#define EL_NS     hrxml
#define EL_TAG    References

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_References) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:References")-1 + 1 + sizeof("</hrxml:References>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Reference_s* e;
      for (e = x->Reference; e; e = (struct zx_hrxml_Reference_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Reference(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:References", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_References) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("References")-1 + 1 + 2 + sizeof("References")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Reference_s* e;
      for (e = x->Reference; e; e = (struct zx_hrxml_Reference_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Reference(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:References", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_References) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:References");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Reference_s* e;
      for (e = x->Reference; e; e = (struct zx_hrxml_Reference_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Reference(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:References>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:References", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_References) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "References", sizeof("References")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:References", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_References) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_References(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_References(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_References) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_References(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_References(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelatedOrganization
#define EL_STRUCT zx_hrxml_RelatedOrganization_s
#define EL_NS     hrxml
#define EL_TAG    RelatedOrganization

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RelatedOrganization) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RelatedOrganization")-1 + 1 + sizeof("</hrxml:RelatedOrganization>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->relationship, sizeof("relationship")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OrganizationId_s* e;
      for (e = x->OrganizationId; e; e = (struct zx_hrxml_OrganizationId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrganizationId(c, e);
  }
  {
      struct zx_hrxml_TaxId_s* e;
      for (e = x->TaxId; e; e = (struct zx_hrxml_TaxId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_TaxId(c, e);
  }
  {
      struct zx_hrxml_LegalId_s* e;
      for (e = x->LegalId; e; e = (struct zx_hrxml_LegalId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LegalId(c, e);
  }
  {
      struct zx_hrxml_DunsNumber_s* e;
      for (e = x->DunsNumber; e; e = (struct zx_hrxml_DunsNumber_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DunsNumber(c, e);
  }
  for (se = x->IsPublicCompany; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:IsPublicCompany")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Stock_s* e;
      for (e = x->Stock; e; e = (struct zx_hrxml_Stock_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Stock(c, e);
  }
  for (se = x->MissionStatement; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MissionStatement")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ValueStatement; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ValueStatement")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_InternetDomainName_s* e;
      for (e = x->InternetDomainName; e; e = (struct zx_hrxml_InternetDomainName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_InternetDomainName(c, e);
  }
  {
      struct zx_hrxml_DoingBusinessAs_s* e;
      for (e = x->DoingBusinessAs; e; e = (struct zx_hrxml_DoingBusinessAs_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DoingBusinessAs(c, e);
  }
  {
      struct zx_hrxml_LegalClassification_s* e;
      for (e = x->LegalClassification; e; e = (struct zx_hrxml_LegalClassification_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LegalClassification(c, e);
  }
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IndustryCode(c, e);
  }
  for (se = x->Headcount; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Headcount")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_WorkSite_s* e;
      for (e = x->WorkSite; e; e = (struct zx_hrxml_WorkSite_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_WorkSite(c, e);
  }
  {
      struct zx_hrxml_ContactInfo_s* e;
      for (e = x->ContactInfo; e; e = (struct zx_hrxml_ContactInfo_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactInfo(c, e);
  }
  {
      struct zx_hrxml_RelatedOrganization_s* e;
      for (e = x->RelatedOrganization; e; e = (struct zx_hrxml_RelatedOrganization_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RelatedOrganization(c, e);
  }
  {
      struct zx_hrxml_OrganizationalUnit_s* e;
      for (e = x->OrganizationalUnit; e; e = (struct zx_hrxml_OrganizationalUnit_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrganizationalUnit(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganization", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_RelatedOrganization) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("RelatedOrganization")-1 + 1 + 2 + sizeof("RelatedOrganization")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->relationship, sizeof("relationship")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("OrganizationName")-1);
  {
      struct zx_hrxml_OrganizationId_s* e;
      for (e = x->OrganizationId; e; e = (struct zx_hrxml_OrganizationId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrganizationId(c, e);
  }
  {
      struct zx_hrxml_TaxId_s* e;
      for (e = x->TaxId; e; e = (struct zx_hrxml_TaxId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_TaxId(c, e);
  }
  {
      struct zx_hrxml_LegalId_s* e;
      for (e = x->LegalId; e; e = (struct zx_hrxml_LegalId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LegalId(c, e);
  }
  {
      struct zx_hrxml_DunsNumber_s* e;
      for (e = x->DunsNumber; e; e = (struct zx_hrxml_DunsNumber_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DunsNumber(c, e);
  }
  for (se = x->IsPublicCompany; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("IsPublicCompany")-1);
  {
      struct zx_hrxml_Stock_s* e;
      for (e = x->Stock; e; e = (struct zx_hrxml_Stock_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Stock(c, e);
  }
  for (se = x->MissionStatement; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MissionStatement")-1);
  for (se = x->ValueStatement; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ValueStatement")-1);
  {
      struct zx_hrxml_InternetDomainName_s* e;
      for (e = x->InternetDomainName; e; e = (struct zx_hrxml_InternetDomainName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_InternetDomainName(c, e);
  }
  {
      struct zx_hrxml_DoingBusinessAs_s* e;
      for (e = x->DoingBusinessAs; e; e = (struct zx_hrxml_DoingBusinessAs_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DoingBusinessAs(c, e);
  }
  {
      struct zx_hrxml_LegalClassification_s* e;
      for (e = x->LegalClassification; e; e = (struct zx_hrxml_LegalClassification_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LegalClassification(c, e);
  }
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IndustryCode(c, e);
  }
  for (se = x->Headcount; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Headcount")-1);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_WorkSite_s* e;
      for (e = x->WorkSite; e; e = (struct zx_hrxml_WorkSite_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_WorkSite(c, e);
  }
  {
      struct zx_hrxml_ContactInfo_s* e;
      for (e = x->ContactInfo; e; e = (struct zx_hrxml_ContactInfo_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactInfo(c, e);
  }
  {
      struct zx_hrxml_RelatedOrganization_s* e;
      for (e = x->RelatedOrganization; e; e = (struct zx_hrxml_RelatedOrganization_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RelatedOrganization(c, e);
  }
  {
      struct zx_hrxml_OrganizationalUnit_s* e;
      for (e = x->OrganizationalUnit; e; e = (struct zx_hrxml_OrganizationalUnit_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrganizationalUnit(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganization", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RelatedOrganization) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RelatedOrganization");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->relationship, " relationship=\"", sizeof(" relationship=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrganizationName", sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OrganizationId_s* e;
      for (e = x->OrganizationId; e; e = (struct zx_hrxml_OrganizationId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrganizationId(c, e, p);
  }
  {
      struct zx_hrxml_TaxId_s* e;
      for (e = x->TaxId; e; e = (struct zx_hrxml_TaxId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_TaxId(c, e, p);
  }
  {
      struct zx_hrxml_LegalId_s* e;
      for (e = x->LegalId; e; e = (struct zx_hrxml_LegalId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LegalId(c, e, p);
  }
  {
      struct zx_hrxml_DunsNumber_s* e;
      for (e = x->DunsNumber; e; e = (struct zx_hrxml_DunsNumber_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DunsNumber(c, e, p);
  }
  for (se = x->IsPublicCompany; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:IsPublicCompany", sizeof("hrxml:IsPublicCompany")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Stock_s* e;
      for (e = x->Stock; e; e = (struct zx_hrxml_Stock_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Stock(c, e, p);
  }
  for (se = x->MissionStatement; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MissionStatement", sizeof("hrxml:MissionStatement")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ValueStatement; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ValueStatement", sizeof("hrxml:ValueStatement")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_InternetDomainName_s* e;
      for (e = x->InternetDomainName; e; e = (struct zx_hrxml_InternetDomainName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_InternetDomainName(c, e, p);
  }
  {
      struct zx_hrxml_DoingBusinessAs_s* e;
      for (e = x->DoingBusinessAs; e; e = (struct zx_hrxml_DoingBusinessAs_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DoingBusinessAs(c, e, p);
  }
  {
      struct zx_hrxml_LegalClassification_s* e;
      for (e = x->LegalClassification; e; e = (struct zx_hrxml_LegalClassification_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LegalClassification(c, e, p);
  }
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IndustryCode(c, e, p);
  }
  for (se = x->Headcount; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Headcount", sizeof("hrxml:Headcount")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }
  {
      struct zx_hrxml_WorkSite_s* e;
      for (e = x->WorkSite; e; e = (struct zx_hrxml_WorkSite_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_WorkSite(c, e, p);
  }
  {
      struct zx_hrxml_ContactInfo_s* e;
      for (e = x->ContactInfo; e; e = (struct zx_hrxml_ContactInfo_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactInfo(c, e, p);
  }
  {
      struct zx_hrxml_RelatedOrganization_s* e;
      for (e = x->RelatedOrganization; e; e = (struct zx_hrxml_RelatedOrganization_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RelatedOrganization(c, e, p);
  }
  {
      struct zx_hrxml_OrganizationalUnit_s* e;
      for (e = x->OrganizationalUnit; e; e = (struct zx_hrxml_OrganizationalUnit_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrganizationalUnit(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RelatedOrganization>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganization", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_RelatedOrganization) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "RelatedOrganization", sizeof("RelatedOrganization")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->relationship, "relationship=\"", sizeof("relationship=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganization", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RelatedOrganization) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RelatedOrganization(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RelatedOrganization(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_RelatedOrganization) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_RelatedOrganization(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_RelatedOrganization(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelatedOrganizationalUnit
#define EL_STRUCT zx_hrxml_RelatedOrganizationalUnit_s
#define EL_NS     hrxml
#define EL_TAG    RelatedOrganizationalUnit

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RelatedOrganizationalUnit) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RelatedOrganizationalUnit")-1 + 1 + sizeof("</hrxml:RelatedOrganizationalUnit>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->hierarchicalRole, sizeof("hierarchicalRole")-1, &pop_seen);
  len += zx_attr_so_len(c, x->natureOfRelationship, sizeof("natureOfRelationship")-1, &pop_seen);
  len += zx_attr_so_len(c, x->relationship, sizeof("relationship")-1, &pop_seen);
  len += zx_attr_so_len(c, x->typeOfGroup, sizeof("typeOfGroup")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationalUnitName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrganizationalUnitName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OrganizationalUnitId_s* e;
      for (e = x->OrganizationalUnitId; e; e = (struct zx_hrxml_OrganizationalUnitId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrganizationalUnitId(c, e);
  }
  {
      struct zx_hrxml_OrganizationId_s* e;
      for (e = x->OrganizationId; e; e = (struct zx_hrxml_OrganizationId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrganizationId(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IndustryCode(c, e);
  }
  {
      struct zx_hrxml_AccountingCode_s* e;
      for (e = x->AccountingCode; e; e = (struct zx_hrxml_AccountingCode_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_AccountingCode(c, e);
  }
  {
      struct zx_hrxml_WorkSite_s* e;
      for (e = x->WorkSite; e; e = (struct zx_hrxml_WorkSite_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_WorkSite(c, e);
  }
  {
      struct zx_hrxml_RelatedOrganizationalUnit_s* e;
      for (e = x->RelatedOrganizationalUnit; e; e = (struct zx_hrxml_RelatedOrganizationalUnit_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RelatedOrganizationalUnit(c, e);
  }
  {
      struct zx_hrxml_PersonMember_s* e;
      for (e = x->PersonMember; e; e = (struct zx_hrxml_PersonMember_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PersonMember(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganizationalUnit", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_RelatedOrganizationalUnit) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("RelatedOrganizationalUnit")-1 + 1 + 2 + sizeof("RelatedOrganizationalUnit")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->hierarchicalRole, sizeof("hierarchicalRole")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->natureOfRelationship, sizeof("natureOfRelationship")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->relationship, sizeof("relationship")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->typeOfGroup, sizeof("typeOfGroup")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationalUnitName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("OrganizationalUnitName")-1);
  {
      struct zx_hrxml_OrganizationalUnitId_s* e;
      for (e = x->OrganizationalUnitId; e; e = (struct zx_hrxml_OrganizationalUnitId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrganizationalUnitId(c, e);
  }
  {
      struct zx_hrxml_OrganizationId_s* e;
      for (e = x->OrganizationId; e; e = (struct zx_hrxml_OrganizationId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrganizationId(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IndustryCode(c, e);
  }
  {
      struct zx_hrxml_AccountingCode_s* e;
      for (e = x->AccountingCode; e; e = (struct zx_hrxml_AccountingCode_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_AccountingCode(c, e);
  }
  {
      struct zx_hrxml_WorkSite_s* e;
      for (e = x->WorkSite; e; e = (struct zx_hrxml_WorkSite_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_WorkSite(c, e);
  }
  {
      struct zx_hrxml_RelatedOrganizationalUnit_s* e;
      for (e = x->RelatedOrganizationalUnit; e; e = (struct zx_hrxml_RelatedOrganizationalUnit_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RelatedOrganizationalUnit(c, e);
  }
  {
      struct zx_hrxml_PersonMember_s* e;
      for (e = x->PersonMember; e; e = (struct zx_hrxml_PersonMember_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PersonMember(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganizationalUnit", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RelatedOrganizationalUnit) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RelatedOrganizationalUnit");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->hierarchicalRole, " hierarchicalRole=\"", sizeof(" hierarchicalRole=\"")-1);
  p = zx_attr_so_enc(p, x->natureOfRelationship, " natureOfRelationship=\"", sizeof(" natureOfRelationship=\"")-1);
  p = zx_attr_so_enc(p, x->relationship, " relationship=\"", sizeof(" relationship=\"")-1);
  p = zx_attr_so_enc(p, x->typeOfGroup, " typeOfGroup=\"", sizeof(" typeOfGroup=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->OrganizationalUnitName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrganizationalUnitName", sizeof("hrxml:OrganizationalUnitName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_OrganizationalUnitId_s* e;
      for (e = x->OrganizationalUnitId; e; e = (struct zx_hrxml_OrganizationalUnitId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrganizationalUnitId(c, e, p);
  }
  {
      struct zx_hrxml_OrganizationId_s* e;
      for (e = x->OrganizationId; e; e = (struct zx_hrxml_OrganizationId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrganizationId(c, e, p);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }
  {
      struct zx_hrxml_IndustryCode_s* e;
      for (e = x->IndustryCode; e; e = (struct zx_hrxml_IndustryCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IndustryCode(c, e, p);
  }
  {
      struct zx_hrxml_AccountingCode_s* e;
      for (e = x->AccountingCode; e; e = (struct zx_hrxml_AccountingCode_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_AccountingCode(c, e, p);
  }
  {
      struct zx_hrxml_WorkSite_s* e;
      for (e = x->WorkSite; e; e = (struct zx_hrxml_WorkSite_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_WorkSite(c, e, p);
  }
  {
      struct zx_hrxml_RelatedOrganizationalUnit_s* e;
      for (e = x->RelatedOrganizationalUnit; e; e = (struct zx_hrxml_RelatedOrganizationalUnit_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RelatedOrganizationalUnit(c, e, p);
  }
  {
      struct zx_hrxml_PersonMember_s* e;
      for (e = x->PersonMember; e; e = (struct zx_hrxml_PersonMember_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PersonMember(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RelatedOrganizationalUnit>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganizationalUnit", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_RelatedOrganizationalUnit) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "RelatedOrganizationalUnit", sizeof("RelatedOrganizationalUnit")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->hierarchicalRole, "hierarchicalRole=\"", sizeof("hierarchicalRole=\"")-1);
  p = zx_attr_wo_enc(p, x->natureOfRelationship, "natureOfRelationship=\"", sizeof("natureOfRelationship=\"")-1);
  p = zx_attr_wo_enc(p, x->relationship, "relationship=\"", sizeof("relationship=\"")-1);
  p = zx_attr_wo_enc(p, x->typeOfGroup, "typeOfGroup=\"", sizeof("typeOfGroup=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganizationalUnit", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RelatedOrganizationalUnit) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RelatedOrganizationalUnit(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RelatedOrganizationalUnit(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_RelatedOrganizationalUnit) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_RelatedOrganizationalUnit(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_RelatedOrganizationalUnit(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelatedPositionPostings
#define EL_STRUCT zx_hrxml_RelatedPositionPostings_s
#define EL_NS     hrxml
#define EL_TAG    RelatedPositionPostings

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RelatedPositionPostings) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RelatedPositionPostings")-1 + 1 + sizeof("</hrxml:RelatedPositionPostings>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PositionPosting_s* e;
      for (e = x->PositionPosting; e; e = (struct zx_hrxml_PositionPosting_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PositionPosting(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelatedPositionPostings", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_RelatedPositionPostings) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("RelatedPositionPostings")-1 + 1 + 2 + sizeof("RelatedPositionPostings")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_PositionPosting_s* e;
      for (e = x->PositionPosting; e; e = (struct zx_hrxml_PositionPosting_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PositionPosting(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelatedPositionPostings", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RelatedPositionPostings) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RelatedPositionPostings");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_PositionPosting_s* e;
      for (e = x->PositionPosting; e; e = (struct zx_hrxml_PositionPosting_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PositionPosting(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RelatedPositionPostings>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelatedPositionPostings", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_RelatedPositionPostings) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "RelatedPositionPostings", sizeof("RelatedPositionPostings")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelatedPositionPostings", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RelatedPositionPostings) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RelatedPositionPostings(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RelatedPositionPostings(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_RelatedPositionPostings) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_RelatedPositionPostings(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_RelatedPositionPostings(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Relocation
#define EL_STRUCT zx_hrxml_Relocation_s
#define EL_NS     hrxml
#define EL_TAG    Relocation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Relocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Relocation")-1 + 1 + sizeof("</hrxml:Relocation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->relocationConsidered, sizeof("relocationConsidered")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Relocation", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Relocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Relocation")-1 + 1 + 2 + sizeof("Relocation")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->relocationConsidered, sizeof("relocationConsidered")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Relocation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Relocation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Relocation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->relocationConsidered, " relocationConsidered=\"", sizeof(" relocationConsidered=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Relocation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Relocation", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Relocation) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Relocation", sizeof("Relocation")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->relocationConsidered, "relocationConsidered=\"", sizeof("relocationConsidered=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Relocation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Relocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Relocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Relocation(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Relocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Relocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Relocation(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelocationAssistance
#define EL_STRUCT zx_hrxml_RelocationAssistance_s
#define EL_NS     hrxml
#define EL_TAG    RelocationAssistance

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RelocationAssistance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RelocationAssistance")-1 + 1 + sizeof("</hrxml:RelocationAssistance>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->companyOffered, sizeof("companyOffered")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelocationAssistance", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_RelocationAssistance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("RelocationAssistance")-1 + 1 + 2 + sizeof("RelocationAssistance")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->companyOffered, sizeof("companyOffered")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelocationAssistance", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RelocationAssistance) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RelocationAssistance");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->companyOffered, " companyOffered=\"", sizeof(" companyOffered=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RelocationAssistance>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelocationAssistance", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_RelocationAssistance) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "RelocationAssistance", sizeof("RelocationAssistance")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->companyOffered, "companyOffered=\"", sizeof("companyOffered=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelocationAssistance", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RelocationAssistance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RelocationAssistance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RelocationAssistance(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_RelocationAssistance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_RelocationAssistance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_RelocationAssistance(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RemunerationPackage
#define EL_STRUCT zx_hrxml_RemunerationPackage_s
#define EL_NS     hrxml
#define EL_TAG    RemunerationPackage

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RemunerationPackage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RemunerationPackage")-1 + 1 + sizeof("</hrxml:RemunerationPackage>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_BasePay_s* e;
      for (e = x->BasePay; e; e = (struct zx_hrxml_BasePay_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_BasePay(c, e);
  }
  {
      struct zx_hrxml_OtherPay_s* e;
      for (e = x->OtherPay; e; e = (struct zx_hrxml_OtherPay_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OtherPay(c, e);
  }
  {
      struct zx_hrxml_Benefits_s* e;
      for (e = x->Benefits; e; e = (struct zx_hrxml_Benefits_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Benefits(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RemunerationPackage", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_RemunerationPackage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("RemunerationPackage")-1 + 1 + 2 + sizeof("RemunerationPackage")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_BasePay_s* e;
      for (e = x->BasePay; e; e = (struct zx_hrxml_BasePay_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_BasePay(c, e);
  }
  {
      struct zx_hrxml_OtherPay_s* e;
      for (e = x->OtherPay; e; e = (struct zx_hrxml_OtherPay_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OtherPay(c, e);
  }
  {
      struct zx_hrxml_Benefits_s* e;
      for (e = x->Benefits; e; e = (struct zx_hrxml_Benefits_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Benefits(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RemunerationPackage", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RemunerationPackage) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RemunerationPackage");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_BasePay_s* e;
      for (e = x->BasePay; e; e = (struct zx_hrxml_BasePay_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_BasePay(c, e, p);
  }
  {
      struct zx_hrxml_OtherPay_s* e;
      for (e = x->OtherPay; e; e = (struct zx_hrxml_OtherPay_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OtherPay(c, e, p);
  }
  {
      struct zx_hrxml_Benefits_s* e;
      for (e = x->Benefits; e; e = (struct zx_hrxml_Benefits_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Benefits(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RemunerationPackage>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RemunerationPackage", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_RemunerationPackage) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "RemunerationPackage", sizeof("RemunerationPackage")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RemunerationPackage", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RemunerationPackage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RemunerationPackage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RemunerationPackage(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_RemunerationPackage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_RemunerationPackage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_RemunerationPackage(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Resume
#define EL_STRUCT zx_hrxml_Resume_s
#define EL_NS     hrxml
#define EL_TAG    Resume

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Resume) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Resume")-1 + 1 + sizeof("</hrxml:Resume>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->ResumeId; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ResumeId")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_StructuredXMLResume_s* e;
      for (e = x->StructuredXMLResume; e; e = (struct zx_hrxml_StructuredXMLResume_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StructuredXMLResume(c, e);
  }
  {
      struct zx_hrxml_NonXMLResume_s* e;
      for (e = x->NonXMLResume; e; e = (struct zx_hrxml_NonXMLResume_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_NonXMLResume(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Resume", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Resume) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Resume")-1 + 1 + 2 + sizeof("Resume")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->lang, sizeof("lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->ResumeId; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ResumeId")-1);
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("DistributionGuidelines")-1);
  {
      struct zx_hrxml_StructuredXMLResume_s* e;
      for (e = x->StructuredXMLResume; e; e = (struct zx_hrxml_StructuredXMLResume_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StructuredXMLResume(c, e);
  }
  {
      struct zx_hrxml_NonXMLResume_s* e;
      for (e = x->NonXMLResume; e; e = (struct zx_hrxml_NonXMLResume_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_NonXMLResume(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Resume", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Resume) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Resume");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->ResumeId; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ResumeId", sizeof("hrxml:ResumeId")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DistributionGuidelines", sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_StructuredXMLResume_s* e;
      for (e = x->StructuredXMLResume; e; e = (struct zx_hrxml_StructuredXMLResume_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StructuredXMLResume(c, e, p);
  }
  {
      struct zx_hrxml_NonXMLResume_s* e;
      for (e = x->NonXMLResume; e; e = (struct zx_hrxml_NonXMLResume_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_NonXMLResume(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Resume>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Resume", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Resume) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Resume", sizeof("Resume")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->lang, "lang=\"", sizeof("lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Resume", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Resume) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Resume(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Resume(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Resume) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Resume(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Resume(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ResumeAdditionalItem
#define EL_STRUCT zx_hrxml_ResumeAdditionalItem_s
#define EL_NS     hrxml
#define EL_TAG    ResumeAdditionalItem

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ResumeAdditionalItem) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ResumeAdditionalItem")-1 + 1 + sizeof("</hrxml:ResumeAdditionalItem>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EffectiveDate(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItem", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ResumeAdditionalItem) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ResumeAdditionalItem")-1 + 1 + 2 + sizeof("ResumeAdditionalItem")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EffectiveDate(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItem", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ResumeAdditionalItem) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ResumeAdditionalItem");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EffectiveDate(c, e, p);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ResumeAdditionalItem>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItem", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ResumeAdditionalItem) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ResumeAdditionalItem", sizeof("ResumeAdditionalItem")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItem", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ResumeAdditionalItem) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ResumeAdditionalItem(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ResumeAdditionalItem(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ResumeAdditionalItem) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ResumeAdditionalItem(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ResumeAdditionalItem(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ResumeAdditionalItems
#define EL_STRUCT zx_hrxml_ResumeAdditionalItems_s
#define EL_NS     hrxml
#define EL_TAG    ResumeAdditionalItems

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ResumeAdditionalItems) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ResumeAdditionalItems")-1 + 1 + sizeof("</hrxml:ResumeAdditionalItems>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ResumeAdditionalItem_s* e;
      for (e = x->ResumeAdditionalItem; e; e = (struct zx_hrxml_ResumeAdditionalItem_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ResumeAdditionalItem(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItems", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ResumeAdditionalItems) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ResumeAdditionalItems")-1 + 1 + 2 + sizeof("ResumeAdditionalItems")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ResumeAdditionalItem_s* e;
      for (e = x->ResumeAdditionalItem; e; e = (struct zx_hrxml_ResumeAdditionalItem_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ResumeAdditionalItem(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItems", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ResumeAdditionalItems) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ResumeAdditionalItems");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_ResumeAdditionalItem_s* e;
      for (e = x->ResumeAdditionalItem; e; e = (struct zx_hrxml_ResumeAdditionalItem_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ResumeAdditionalItem(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ResumeAdditionalItems>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItems", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ResumeAdditionalItems) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ResumeAdditionalItems", sizeof("ResumeAdditionalItems")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItems", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ResumeAdditionalItems) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ResumeAdditionalItems(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ResumeAdditionalItems(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ResumeAdditionalItems) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ResumeAdditionalItems(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ResumeAdditionalItems(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RoleId
#define EL_STRUCT zx_hrxml_RoleId_s
#define EL_NS     hrxml
#define EL_TAG    RoleId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RoleId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RoleId")-1 + 1 + sizeof("</hrxml:RoleId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RoleId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_RoleId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("RoleId")-1 + 1 + 2 + sizeof("RoleId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RoleId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RoleId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RoleId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RoleId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RoleId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_RoleId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "RoleId", sizeof("RoleId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RoleId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RoleId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RoleId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RoleId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_RoleId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_RoleId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_RoleId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SEPPhysicalLocation
#define EL_STRUCT zx_hrxml_SEPPhysicalLocation_s
#define EL_NS     hrxml
#define EL_TAG    SEPPhysicalLocation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SEPPhysicalLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SEPPhysicalLocation")-1 + 1 + sizeof("</hrxml:SEPPhysicalLocation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_SpatialLocation_s* e;
      for (e = x->SpatialLocation; e; e = (struct zx_hrxml_SpatialLocation_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SpatialLocation(c, e);
  }
  {
      struct zx_hrxml_TravelDirections_s* e;
      for (e = x->TravelDirections; e; e = (struct zx_hrxml_TravelDirections_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_TravelDirections(c, e);
  }
  {
      struct zx_hrxml_Area_s* e;
      for (e = x->Area; e; e = (struct zx_hrxml_Area_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Area(c, e);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PostalAddress(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SEPPhysicalLocation", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SEPPhysicalLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SEPPhysicalLocation")-1 + 1 + 2 + sizeof("SEPPhysicalLocation")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  {
      struct zx_hrxml_SpatialLocation_s* e;
      for (e = x->SpatialLocation; e; e = (struct zx_hrxml_SpatialLocation_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SpatialLocation(c, e);
  }
  {
      struct zx_hrxml_TravelDirections_s* e;
      for (e = x->TravelDirections; e; e = (struct zx_hrxml_TravelDirections_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_TravelDirections(c, e);
  }
  {
      struct zx_hrxml_Area_s* e;
      for (e = x->Area; e; e = (struct zx_hrxml_Area_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Area(c, e);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PostalAddress(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SEPPhysicalLocation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SEPPhysicalLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SEPPhysicalLocation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_SpatialLocation_s* e;
      for (e = x->SpatialLocation; e; e = (struct zx_hrxml_SpatialLocation_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SpatialLocation(c, e, p);
  }
  {
      struct zx_hrxml_TravelDirections_s* e;
      for (e = x->TravelDirections; e; e = (struct zx_hrxml_TravelDirections_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_TravelDirections(c, e, p);
  }
  {
      struct zx_hrxml_Area_s* e;
      for (e = x->Area; e; e = (struct zx_hrxml_Area_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Area(c, e, p);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PostalAddress(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SEPPhysicalLocation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SEPPhysicalLocation", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SEPPhysicalLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SEPPhysicalLocation", sizeof("SEPPhysicalLocation")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SEPPhysicalLocation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SEPPhysicalLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SEPPhysicalLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SEPPhysicalLocation(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SEPPhysicalLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SEPPhysicalLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SEPPhysicalLocation(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SafetyEquipment
#define EL_STRUCT zx_hrxml_SafetyEquipment_s
#define EL_NS     hrxml
#define EL_TAG    SafetyEquipment

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SafetyEquipment) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SafetyEquipment")-1 + 1 + sizeof("</hrxml:SafetyEquipment>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->suppliedByOrganization, sizeof("suppliedByOrganization")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SafetyEquipment", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SafetyEquipment) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SafetyEquipment")-1 + 1 + 2 + sizeof("SafetyEquipment")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->suppliedByOrganization, sizeof("suppliedByOrganization")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SafetyEquipment", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SafetyEquipment) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SafetyEquipment");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->suppliedByOrganization, " suppliedByOrganization=\"", sizeof(" suppliedByOrganization=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SafetyEquipment>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SafetyEquipment", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SafetyEquipment) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SafetyEquipment", sizeof("SafetyEquipment")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->suppliedByOrganization, "suppliedByOrganization=\"", sizeof("suppliedByOrganization=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SafetyEquipment", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SafetyEquipment) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SafetyEquipment(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SafetyEquipment(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SafetyEquipment) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SafetyEquipment(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SafetyEquipment(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_School
#define EL_STRUCT zx_hrxml_School_s
#define EL_NS     hrxml
#define EL_TAG    School

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_School) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:School")-1 + 1 + sizeof("</hrxml:School>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_InternetDomainName_s* e;
      for (e = x->InternetDomainName; e; e = (struct zx_hrxml_InternetDomainName_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_InternetDomainName(c, e);
  }
  {
      struct zx_hrxml_SchoolId_s* e;
      for (e = x->SchoolId; e; e = (struct zx_hrxml_SchoolId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SchoolId(c, e);
  }
  for (se = x->SchoolName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SchoolName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:School", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_School) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("School")-1 + 1 + 2 + sizeof("School")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_InternetDomainName_s* e;
      for (e = x->InternetDomainName; e; e = (struct zx_hrxml_InternetDomainName_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_InternetDomainName(c, e);
  }
  {
      struct zx_hrxml_SchoolId_s* e;
      for (e = x->SchoolId; e; e = (struct zx_hrxml_SchoolId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SchoolId(c, e);
  }
  for (se = x->SchoolName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SchoolName")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:School", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_School) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:School");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_InternetDomainName_s* e;
      for (e = x->InternetDomainName; e; e = (struct zx_hrxml_InternetDomainName_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_InternetDomainName(c, e, p);
  }
  {
      struct zx_hrxml_SchoolId_s* e;
      for (e = x->SchoolId; e; e = (struct zx_hrxml_SchoolId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SchoolId(c, e, p);
  }
  for (se = x->SchoolName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SchoolName", sizeof("hrxml:SchoolName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:School>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:School", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_School) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "School", sizeof("School")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:School", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_School) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_School(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_School(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_School) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_School(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_School(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SchoolId
#define EL_STRUCT zx_hrxml_SchoolId_s
#define EL_NS     hrxml
#define EL_TAG    SchoolId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SchoolId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SchoolId")-1 + 1 + sizeof("</hrxml:SchoolId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SchoolId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SchoolId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SchoolId")-1 + 1 + 2 + sizeof("SchoolId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SchoolId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SchoolId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SchoolId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SchoolId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SchoolId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SchoolId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SchoolId", sizeof("SchoolId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SchoolId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SchoolId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SchoolId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SchoolId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SchoolId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SchoolId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SchoolId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SchoolOrInstitution
#define EL_STRUCT zx_hrxml_SchoolOrInstitution_s
#define EL_NS     hrxml
#define EL_TAG    SchoolOrInstitution

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SchoolOrInstitution) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SchoolOrInstitution")-1 + 1 + sizeof("</hrxml:SchoolOrInstitution>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->schoolType, sizeof("schoolType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->SchoolName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SchoolName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_School_s* e;
      for (e = x->School; e; e = (struct zx_hrxml_School_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_School(c, e);
  }
  {
      struct zx_hrxml_LocationSummary_s* e;
      for (e = x->LocationSummary; e; e = (struct zx_hrxml_LocationSummary_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LocationSummary(c, e);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PostalAddress(c, e);
  }
  {
      struct zx_hrxml_OrganizationUnit_s* e;
      for (e = x->OrganizationUnit; e; e = (struct zx_hrxml_OrganizationUnit_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_OrganizationUnit(c, e);
  }
  {
      struct zx_hrxml_Degree_s* e;
      for (e = x->Degree; e; e = (struct zx_hrxml_Degree_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Degree(c, e);
  }
  for (se = x->Major; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Major")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Minor; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Minor")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Measure_s* e;
      for (e = x->Measure; e; e = (struct zx_hrxml_Measure_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Measure(c, e);
  }
  {
      struct zx_hrxml_DatesOfAttendance_s* e;
      for (e = x->DatesOfAttendance; e; e = (struct zx_hrxml_DatesOfAttendance_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DatesOfAttendance(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISCEDInstitutionClassification; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISCEDInstitutionClassification")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_LocalInstitutionClassification_s* e;
      for (e = x->LocalInstitutionClassification; e; e = (struct zx_hrxml_LocalInstitutionClassification_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LocalInstitutionClassification(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SchoolOrInstitution", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SchoolOrInstitution) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SchoolOrInstitution")-1 + 1 + 2 + sizeof("SchoolOrInstitution")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->schoolType, sizeof("schoolType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->SchoolName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SchoolName")-1);
  {
      struct zx_hrxml_School_s* e;
      for (e = x->School; e; e = (struct zx_hrxml_School_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_School(c, e);
  }
  {
      struct zx_hrxml_LocationSummary_s* e;
      for (e = x->LocationSummary; e; e = (struct zx_hrxml_LocationSummary_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LocationSummary(c, e);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PostalAddress(c, e);
  }
  {
      struct zx_hrxml_OrganizationUnit_s* e;
      for (e = x->OrganizationUnit; e; e = (struct zx_hrxml_OrganizationUnit_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_OrganizationUnit(c, e);
  }
  {
      struct zx_hrxml_Degree_s* e;
      for (e = x->Degree; e; e = (struct zx_hrxml_Degree_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Degree(c, e);
  }
  for (se = x->Major; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Major")-1);
  for (se = x->Minor; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Minor")-1);
  {
      struct zx_hrxml_Measure_s* e;
      for (e = x->Measure; e; e = (struct zx_hrxml_Measure_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Measure(c, e);
  }
  {
      struct zx_hrxml_DatesOfAttendance_s* e;
      for (e = x->DatesOfAttendance; e; e = (struct zx_hrxml_DatesOfAttendance_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DatesOfAttendance(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  for (se = x->ISCEDInstitutionClassification; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ISCEDInstitutionClassification")-1);
  {
      struct zx_hrxml_LocalInstitutionClassification_s* e;
      for (e = x->LocalInstitutionClassification; e; e = (struct zx_hrxml_LocalInstitutionClassification_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LocalInstitutionClassification(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SchoolOrInstitution", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SchoolOrInstitution) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SchoolOrInstitution");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->schoolType, " schoolType=\"", sizeof(" schoolType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->SchoolName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SchoolName", sizeof("hrxml:SchoolName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_School_s* e;
      for (e = x->School; e; e = (struct zx_hrxml_School_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_School(c, e, p);
  }
  {
      struct zx_hrxml_LocationSummary_s* e;
      for (e = x->LocationSummary; e; e = (struct zx_hrxml_LocationSummary_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LocationSummary(c, e, p);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PostalAddress(c, e, p);
  }
  {
      struct zx_hrxml_OrganizationUnit_s* e;
      for (e = x->OrganizationUnit; e; e = (struct zx_hrxml_OrganizationUnit_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_OrganizationUnit(c, e, p);
  }
  {
      struct zx_hrxml_Degree_s* e;
      for (e = x->Degree; e; e = (struct zx_hrxml_Degree_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Degree(c, e, p);
  }
  for (se = x->Major; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Major", sizeof("hrxml:Major")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Minor; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Minor", sizeof("hrxml:Minor")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Measure_s* e;
      for (e = x->Measure; e; e = (struct zx_hrxml_Measure_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Measure(c, e, p);
  }
  {
      struct zx_hrxml_DatesOfAttendance_s* e;
      for (e = x->DatesOfAttendance; e; e = (struct zx_hrxml_DatesOfAttendance_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DatesOfAttendance(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->ISCEDInstitutionClassification; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISCEDInstitutionClassification", sizeof("hrxml:ISCEDInstitutionClassification")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_LocalInstitutionClassification_s* e;
      for (e = x->LocalInstitutionClassification; e; e = (struct zx_hrxml_LocalInstitutionClassification_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LocalInstitutionClassification(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SchoolOrInstitution>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SchoolOrInstitution", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SchoolOrInstitution) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SchoolOrInstitution", sizeof("SchoolOrInstitution")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->schoolType, "schoolType=\"", sizeof("schoolType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SchoolOrInstitution", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SchoolOrInstitution) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SchoolOrInstitution(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SchoolOrInstitution(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SchoolOrInstitution) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SchoolOrInstitution(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SchoolOrInstitution(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Score
#define EL_STRUCT zx_hrxml_Score_s
#define EL_NS     hrxml
#define EL_TAG    Score

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Score) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Score")-1 + 1 + sizeof("</hrxml:Score>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Score", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Score) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Score")-1 + 1 + 2 + sizeof("Score")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Score", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Score) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Score");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->unitOfMeasure, " unitOfMeasure=\"", sizeof(" unitOfMeasure=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Score>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Score", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Score) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Score", sizeof("Score")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->unitOfMeasure, "unitOfMeasure=\"", sizeof("unitOfMeasure=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Score", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Score) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Score(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Score(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Score) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Score(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Score(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchCriteria
#define EL_STRUCT zx_hrxml_SearchCriteria_s
#define EL_NS     hrxml
#define EL_TAG    SearchCriteria

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchCriteria) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchCriteria")-1 + 1 + sizeof("</hrxml:SearchCriteria>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SearchCriteriaId_s* e;
      for (e = x->SearchCriteriaId; e; e = (struct zx_hrxml_SearchCriteriaId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SearchCriteriaId(c, e);
  }
  for (se = x->SearchTarget; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchTarget")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_UserId_s* e;
      for (e = x->UserId; e; e = (struct zx_hrxml_UserId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserId(c, e);
  }
  for (se = x->SearchTimeStamp; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchTimeStamp")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->SearchString; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchString")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_SearchCriterion_s* e;
      for (e = x->SearchCriterion; e; e = (struct zx_hrxml_SearchCriterion_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SearchCriterion(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteria", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SearchCriteria) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SearchCriteria")-1 + 1 + 2 + sizeof("SearchCriteria")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SearchCriteriaId_s* e;
      for (e = x->SearchCriteriaId; e; e = (struct zx_hrxml_SearchCriteriaId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SearchCriteriaId(c, e);
  }
  for (se = x->SearchTarget; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SearchTarget")-1);
  {
      struct zx_hrxml_UserId_s* e;
      for (e = x->UserId; e; e = (struct zx_hrxml_UserId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserId(c, e);
  }
  for (se = x->SearchTimeStamp; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SearchTimeStamp")-1);
  for (se = x->SearchString; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SearchString")-1);
  {
      struct zx_hrxml_SearchCriterion_s* e;
      for (e = x->SearchCriterion; e; e = (struct zx_hrxml_SearchCriterion_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SearchCriterion(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteria", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchCriteria) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchCriteria");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_SearchCriteriaId_s* e;
      for (e = x->SearchCriteriaId; e; e = (struct zx_hrxml_SearchCriteriaId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SearchCriteriaId(c, e, p);
  }
  for (se = x->SearchTarget; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchTarget", sizeof("hrxml:SearchTarget")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_UserId_s* e;
      for (e = x->UserId; e; e = (struct zx_hrxml_UserId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserId(c, e, p);
  }
  for (se = x->SearchTimeStamp; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchTimeStamp", sizeof("hrxml:SearchTimeStamp")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->SearchString; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchString", sizeof("hrxml:SearchString")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_SearchCriterion_s* e;
      for (e = x->SearchCriterion; e; e = (struct zx_hrxml_SearchCriterion_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SearchCriterion(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchCriteria>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteria", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SearchCriteria) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SearchCriteria", sizeof("SearchCriteria")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteria", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchCriteria) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchCriteria(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchCriteria(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SearchCriteria) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SearchCriteria(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SearchCriteria(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchCriteriaId
#define EL_STRUCT zx_hrxml_SearchCriteriaId_s
#define EL_NS     hrxml
#define EL_TAG    SearchCriteriaId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchCriteriaId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchCriteriaId")-1 + 1 + sizeof("</hrxml:SearchCriteriaId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteriaId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SearchCriteriaId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SearchCriteriaId")-1 + 1 + 2 + sizeof("SearchCriteriaId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteriaId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchCriteriaId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchCriteriaId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchCriteriaId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteriaId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SearchCriteriaId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SearchCriteriaId", sizeof("SearchCriteriaId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteriaId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchCriteriaId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchCriteriaId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchCriteriaId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SearchCriteriaId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SearchCriteriaId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SearchCriteriaId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchCriterion
#define EL_STRUCT zx_hrxml_SearchCriterion_s
#define EL_NS     hrxml
#define EL_TAG    SearchCriterion

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchCriterion) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchCriterion")-1 + 1 + sizeof("</hrxml:SearchCriterion>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CriterionName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CriterionName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CriterionValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CriterionValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Weight_s* e;
      for (e = x->Weight; e; e = (struct zx_hrxml_Weight_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Weight(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchCriterion", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SearchCriterion) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SearchCriterion")-1 + 1 + 2 + sizeof("SearchCriterion")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CriterionName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CriterionName")-1);
  for (se = x->CriterionValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("CriterionValue")-1);
  {
      struct zx_hrxml_Weight_s* e;
      for (e = x->Weight; e; e = (struct zx_hrxml_Weight_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Weight(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchCriterion", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchCriterion) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchCriterion");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->CriterionName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CriterionName", sizeof("hrxml:CriterionName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->CriterionValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CriterionValue", sizeof("hrxml:CriterionValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Weight_s* e;
      for (e = x->Weight; e; e = (struct zx_hrxml_Weight_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Weight(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchCriterion>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchCriterion", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SearchCriterion) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SearchCriterion", sizeof("SearchCriterion")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchCriterion", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchCriterion) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchCriterion(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchCriterion(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SearchCriterion) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SearchCriterion(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SearchCriterion(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchRelevanceScore
#define EL_STRUCT zx_hrxml_SearchRelevanceScore_s
#define EL_NS     hrxml
#define EL_TAG    SearchRelevanceScore

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchRelevanceScore) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchRelevanceScore")-1 + 1 + sizeof("</hrxml:SearchRelevanceScore>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchRelevanceScore", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SearchRelevanceScore) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SearchRelevanceScore")-1 + 1 + 2 + sizeof("SearchRelevanceScore")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchRelevanceScore", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchRelevanceScore) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchRelevanceScore");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->unitOfMeasure, " unitOfMeasure=\"", sizeof(" unitOfMeasure=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchRelevanceScore>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchRelevanceScore", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SearchRelevanceScore) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SearchRelevanceScore", sizeof("SearchRelevanceScore")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->unitOfMeasure, "unitOfMeasure=\"", sizeof("unitOfMeasure=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchRelevanceScore", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchRelevanceScore) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchRelevanceScore(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchRelevanceScore(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SearchRelevanceScore) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SearchRelevanceScore(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SearchRelevanceScore(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchResult
#define EL_STRUCT zx_hrxml_SearchResult_s
#define EL_NS     hrxml
#define EL_TAG    SearchResult

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchResult) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchResult")-1 + 1 + sizeof("</hrxml:SearchResult>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SearchResultId_s* e;
      for (e = x->SearchResultId; e; e = (struct zx_hrxml_SearchResultId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SearchResultId(c, e);
  }
  for (se = x->SearchTarget; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchTarget")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_UserId_s* e;
      for (e = x->UserId; e; e = (struct zx_hrxml_UserId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserId(c, e);
  }
  for (se = x->SearchTimeStamp; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchTimeStamp")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_MatchedObjectId_s* e;
      for (e = x->MatchedObjectId; e; e = (struct zx_hrxml_MatchedObjectId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_MatchedObjectId(c, e);
  }
  {
      struct zx_hrxml_SearchRelevanceScore_s* e;
      for (e = x->SearchRelevanceScore; e; e = (struct zx_hrxml_SearchRelevanceScore_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SearchRelevanceScore(c, e);
  }
  for (se = x->SearchRelevanceRank; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchRelevanceRank")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->SearchResultCount; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchResultCount")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_RankedSearchResults_s* e;
      for (e = x->RankedSearchResults; e; e = (struct zx_hrxml_RankedSearchResults_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RankedSearchResults(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchResult", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SearchResult) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SearchResult")-1 + 1 + 2 + sizeof("SearchResult")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SearchResultId_s* e;
      for (e = x->SearchResultId; e; e = (struct zx_hrxml_SearchResultId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SearchResultId(c, e);
  }
  for (se = x->SearchTarget; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SearchTarget")-1);
  {
      struct zx_hrxml_UserId_s* e;
      for (e = x->UserId; e; e = (struct zx_hrxml_UserId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserId(c, e);
  }
  for (se = x->SearchTimeStamp; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SearchTimeStamp")-1);
  {
      struct zx_hrxml_MatchedObjectId_s* e;
      for (e = x->MatchedObjectId; e; e = (struct zx_hrxml_MatchedObjectId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_MatchedObjectId(c, e);
  }
  {
      struct zx_hrxml_SearchRelevanceScore_s* e;
      for (e = x->SearchRelevanceScore; e; e = (struct zx_hrxml_SearchRelevanceScore_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SearchRelevanceScore(c, e);
  }
  for (se = x->SearchRelevanceRank; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SearchRelevanceRank")-1);
  for (se = x->SearchResultCount; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("SearchResultCount")-1);
  {
      struct zx_hrxml_RankedSearchResults_s* e;
      for (e = x->RankedSearchResults; e; e = (struct zx_hrxml_RankedSearchResults_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RankedSearchResults(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchResult", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchResult) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchResult");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_SearchResultId_s* e;
      for (e = x->SearchResultId; e; e = (struct zx_hrxml_SearchResultId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SearchResultId(c, e, p);
  }
  for (se = x->SearchTarget; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchTarget", sizeof("hrxml:SearchTarget")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_UserId_s* e;
      for (e = x->UserId; e; e = (struct zx_hrxml_UserId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserId(c, e, p);
  }
  for (se = x->SearchTimeStamp; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchTimeStamp", sizeof("hrxml:SearchTimeStamp")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_MatchedObjectId_s* e;
      for (e = x->MatchedObjectId; e; e = (struct zx_hrxml_MatchedObjectId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_MatchedObjectId(c, e, p);
  }
  {
      struct zx_hrxml_SearchRelevanceScore_s* e;
      for (e = x->SearchRelevanceScore; e; e = (struct zx_hrxml_SearchRelevanceScore_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SearchRelevanceScore(c, e, p);
  }
  for (se = x->SearchRelevanceRank; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchRelevanceRank", sizeof("hrxml:SearchRelevanceRank")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->SearchResultCount; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchResultCount", sizeof("hrxml:SearchResultCount")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_RankedSearchResults_s* e;
      for (e = x->RankedSearchResults; e; e = (struct zx_hrxml_RankedSearchResults_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RankedSearchResults(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchResult>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchResult", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SearchResult) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SearchResult", sizeof("SearchResult")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchResult", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchResult) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchResult(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchResult(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SearchResult) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SearchResult(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SearchResult(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchResultId
#define EL_STRUCT zx_hrxml_SearchResultId_s
#define EL_NS     hrxml
#define EL_TAG    SearchResultId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchResultId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchResultId")-1 + 1 + sizeof("</hrxml:SearchResultId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchResultId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SearchResultId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SearchResultId")-1 + 1 + 2 + sizeof("SearchResultId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchResultId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchResultId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchResultId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchResultId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchResultId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SearchResultId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SearchResultId", sizeof("SearchResultId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchResultId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchResultId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchResultId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchResultId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SearchResultId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SearchResultId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SearchResultId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SecurityCredential
#define EL_STRUCT zx_hrxml_SecurityCredential_s
#define EL_NS     hrxml
#define EL_TAG    SecurityCredential

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SecurityCredential) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SecurityCredential")-1 + 1 + sizeof("</hrxml:SecurityCredential>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IssuingAuthority(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EffectiveDate(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredential", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SecurityCredential) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SecurityCredential")-1 + 1 + 2 + sizeof("SecurityCredential")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IssuingAuthority(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EffectiveDate(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredential", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SecurityCredential) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SecurityCredential");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  {
      struct zx_hrxml_IssuingAuthority_s* e;
      for (e = x->IssuingAuthority; e; e = (struct zx_hrxml_IssuingAuthority_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IssuingAuthority(c, e, p);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }
  {
      struct zx_hrxml_EffectiveDate_s* e;
      for (e = x->EffectiveDate; e; e = (struct zx_hrxml_EffectiveDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EffectiveDate(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SecurityCredential>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredential", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SecurityCredential) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SecurityCredential", sizeof("SecurityCredential")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredential", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SecurityCredential) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SecurityCredential(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SecurityCredential(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SecurityCredential) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SecurityCredential(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SecurityCredential(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SecurityCredentials
#define EL_STRUCT zx_hrxml_SecurityCredentials_s
#define EL_NS     hrxml
#define EL_TAG    SecurityCredentials

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SecurityCredentials) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SecurityCredentials")-1 + 1 + sizeof("</hrxml:SecurityCredentials>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SecurityCredential_s* e;
      for (e = x->SecurityCredential; e; e = (struct zx_hrxml_SecurityCredential_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SecurityCredential(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredentials", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SecurityCredentials) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SecurityCredentials")-1 + 1 + 2 + sizeof("SecurityCredentials")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SecurityCredential_s* e;
      for (e = x->SecurityCredential; e; e = (struct zx_hrxml_SecurityCredential_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SecurityCredential(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredentials", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SecurityCredentials) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SecurityCredentials");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_SecurityCredential_s* e;
      for (e = x->SecurityCredential; e; e = (struct zx_hrxml_SecurityCredential_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SecurityCredential(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SecurityCredentials>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredentials", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SecurityCredentials) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SecurityCredentials", sizeof("SecurityCredentials")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredentials", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SecurityCredentials) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SecurityCredentials(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SecurityCredentials(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SecurityCredentials) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SecurityCredentials(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SecurityCredentials(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ServiceDetail
#define EL_STRUCT zx_hrxml_ServiceDetail_s
#define EL_NS     hrxml
#define EL_TAG    ServiceDetail

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ServiceDetail) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ServiceDetail")-1 + 1 + sizeof("</hrxml:ServiceDetail>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->branch, sizeof("branch")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->UnitOrDivision; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:UnitOrDivision")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_RankAchieved_s* e;
      for (e = x->RankAchieved; e; e = (struct zx_hrxml_RankAchieved_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_RankAchieved(c, e);
  }
  {
      struct zx_hrxml_DatesOfService_s* e;
      for (e = x->DatesOfService; e; e = (struct zx_hrxml_DatesOfService_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_DatesOfService(c, e);
  }
  for (se = x->Campaign; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Campaign")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AreaOfExpertise; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AreaOfExpertise")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->RecognitionAchieved; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:RecognitionAchieved")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->DisciplinaryAction; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DisciplinaryAction")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->DischargeStatus; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DischargeStatus")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ServiceDetail", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ServiceDetail) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ServiceDetail")-1 + 1 + 2 + sizeof("ServiceDetail")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->branch, sizeof("branch")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->UnitOrDivision; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("UnitOrDivision")-1);
  {
      struct zx_hrxml_RankAchieved_s* e;
      for (e = x->RankAchieved; e; e = (struct zx_hrxml_RankAchieved_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_RankAchieved(c, e);
  }
  {
      struct zx_hrxml_DatesOfService_s* e;
      for (e = x->DatesOfService; e; e = (struct zx_hrxml_DatesOfService_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_DatesOfService(c, e);
  }
  for (se = x->Campaign; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Campaign")-1);
  for (se = x->AreaOfExpertise; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AreaOfExpertise")-1);
  for (se = x->RecognitionAchieved; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("RecognitionAchieved")-1);
  for (se = x->DisciplinaryAction; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("DisciplinaryAction")-1);
  for (se = x->DischargeStatus; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("DischargeStatus")-1);
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ServiceDetail", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ServiceDetail) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ServiceDetail");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->branch, " branch=\"", sizeof(" branch=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->UnitOrDivision; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:UnitOrDivision", sizeof("hrxml:UnitOrDivision")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_RankAchieved_s* e;
      for (e = x->RankAchieved; e; e = (struct zx_hrxml_RankAchieved_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_RankAchieved(c, e, p);
  }
  {
      struct zx_hrxml_DatesOfService_s* e;
      for (e = x->DatesOfService; e; e = (struct zx_hrxml_DatesOfService_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_DatesOfService(c, e, p);
  }
  for (se = x->Campaign; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Campaign", sizeof("hrxml:Campaign")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AreaOfExpertise; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AreaOfExpertise", sizeof("hrxml:AreaOfExpertise")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->RecognitionAchieved; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:RecognitionAchieved", sizeof("hrxml:RecognitionAchieved")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->DisciplinaryAction; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DisciplinaryAction", sizeof("hrxml:DisciplinaryAction")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->DischargeStatus; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DischargeStatus", sizeof("hrxml:DischargeStatus")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ServiceDetail>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ServiceDetail", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ServiceDetail) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ServiceDetail", sizeof("ServiceDetail")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->branch, "branch=\"", sizeof("branch=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ServiceDetail", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ServiceDetail) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ServiceDetail(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ServiceDetail(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ServiceDetail) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ServiceDetail(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ServiceDetail(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ServiceNumber
#define EL_STRUCT zx_hrxml_ServiceNumber_s
#define EL_NS     hrxml
#define EL_TAG    ServiceNumber

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ServiceNumber) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ServiceNumber")-1 + 1 + sizeof("</hrxml:ServiceNumber>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ServiceNumber", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ServiceNumber) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ServiceNumber")-1 + 1 + 2 + sizeof("ServiceNumber")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ServiceNumber", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ServiceNumber) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ServiceNumber");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ServiceNumber>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ServiceNumber", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ServiceNumber) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ServiceNumber", sizeof("ServiceNumber")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ServiceNumber", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ServiceNumber) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ServiceNumber(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ServiceNumber(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ServiceNumber) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ServiceNumber(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ServiceNumber(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Shift
#define EL_STRUCT zx_hrxml_Shift_s
#define EL_NS     hrxml
#define EL_TAG    Shift

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Shift) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Shift")-1 + 1 + sizeof("</hrxml:Shift>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->shiftPeriod, sizeof("shiftPeriod")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Hours; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Hours")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StartTime; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StartTime")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->EndTime; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EndTime")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PayTypeHours; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PayTypeHours")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Shift", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Shift) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Shift")-1 + 1 + 2 + sizeof("Shift")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->shiftPeriod, sizeof("shiftPeriod")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Name")-1);
  for (se = x->Hours; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Hours")-1);
  for (se = x->StartTime; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StartTime")-1);
  for (se = x->EndTime; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("EndTime")-1);
  for (se = x->PayTypeHours; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PayTypeHours")-1);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Shift", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Shift) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Shift");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->shiftPeriod, " shiftPeriod=\"", sizeof(" shiftPeriod=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Hours; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Hours", sizeof("hrxml:Hours")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StartTime; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StartTime", sizeof("hrxml:StartTime")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->EndTime; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EndTime", sizeof("hrxml:EndTime")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PayTypeHours; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PayTypeHours", sizeof("hrxml:PayTypeHours")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Shift>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Shift", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Shift) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Shift", sizeof("Shift")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->shiftPeriod, "shiftPeriod=\"", sizeof("shiftPeriod=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Shift", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Shift) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Shift(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Shift(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Shift) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Shift(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Shift(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SourceType
#define EL_STRUCT zx_hrxml_SourceType_s
#define EL_NS     hrxml
#define EL_TAG    SourceType

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SourceType) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SourceType")-1 + 1 + sizeof("</hrxml:SourceType>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->StandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StandardValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->NonStandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:NonStandardValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SourceType", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SourceType) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SourceType")-1 + 1 + 2 + sizeof("SourceType")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->StandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StandardValue")-1);
  for (se = x->NonStandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("NonStandardValue")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SourceType", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SourceType) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SourceType");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->StandardValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StandardValue", sizeof("hrxml:StandardValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->NonStandardValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:NonStandardValue", sizeof("hrxml:NonStandardValue")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SourceType>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SourceType", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SourceType) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SourceType", sizeof("SourceType")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SourceType", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SourceType) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SourceType(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SourceType(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SourceType) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SourceType(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SourceType(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpatialLocation
#define EL_STRUCT zx_hrxml_SpatialLocation_s
#define EL_NS     hrxml
#define EL_TAG    SpatialLocation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SpatialLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SpatialLocation")-1 + 1 + sizeof("</hrxml:SpatialLocation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Latitude_s* e;
      for (e = x->Latitude; e; e = (struct zx_hrxml_Latitude_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Latitude(c, e);
  }
  {
      struct zx_hrxml_Longitude_s* e;
      for (e = x->Longitude; e; e = (struct zx_hrxml_Longitude_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Longitude(c, e);
  }
  for (se = x->Altitude; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Altitude")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AltitudeMeanSeaLevel; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AltitudeMeanSeaLevel")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_HorizontalAccuracy_s* e;
      for (e = x->HorizontalAccuracy; e; e = (struct zx_hrxml_HorizontalAccuracy_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_HorizontalAccuracy(c, e);
  }
  {
      struct zx_hrxml_VerticalAccuracy_s* e;
      for (e = x->VerticalAccuracy; e; e = (struct zx_hrxml_VerticalAccuracy_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_VerticalAccuracy(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpatialLocation", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SpatialLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SpatialLocation")-1 + 1 + 2 + sizeof("SpatialLocation")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Latitude_s* e;
      for (e = x->Latitude; e; e = (struct zx_hrxml_Latitude_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Latitude(c, e);
  }
  {
      struct zx_hrxml_Longitude_s* e;
      for (e = x->Longitude; e; e = (struct zx_hrxml_Longitude_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Longitude(c, e);
  }
  for (se = x->Altitude; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Altitude")-1);
  for (se = x->AltitudeMeanSeaLevel; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AltitudeMeanSeaLevel")-1);
  {
      struct zx_hrxml_HorizontalAccuracy_s* e;
      for (e = x->HorizontalAccuracy; e; e = (struct zx_hrxml_HorizontalAccuracy_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_HorizontalAccuracy(c, e);
  }
  {
      struct zx_hrxml_VerticalAccuracy_s* e;
      for (e = x->VerticalAccuracy; e; e = (struct zx_hrxml_VerticalAccuracy_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_VerticalAccuracy(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpatialLocation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SpatialLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SpatialLocation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Latitude_s* e;
      for (e = x->Latitude; e; e = (struct zx_hrxml_Latitude_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Latitude(c, e, p);
  }
  {
      struct zx_hrxml_Longitude_s* e;
      for (e = x->Longitude; e; e = (struct zx_hrxml_Longitude_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Longitude(c, e, p);
  }
  for (se = x->Altitude; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Altitude", sizeof("hrxml:Altitude")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AltitudeMeanSeaLevel; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AltitudeMeanSeaLevel", sizeof("hrxml:AltitudeMeanSeaLevel")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_HorizontalAccuracy_s* e;
      for (e = x->HorizontalAccuracy; e; e = (struct zx_hrxml_HorizontalAccuracy_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_HorizontalAccuracy(c, e, p);
  }
  {
      struct zx_hrxml_VerticalAccuracy_s* e;
      for (e = x->VerticalAccuracy; e; e = (struct zx_hrxml_VerticalAccuracy_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_VerticalAccuracy(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SpatialLocation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpatialLocation", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SpatialLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SpatialLocation", sizeof("SpatialLocation")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpatialLocation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SpatialLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SpatialLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SpatialLocation(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SpatialLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SpatialLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SpatialLocation(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpeakingEvent
#define EL_STRUCT zx_hrxml_SpeakingEvent_s
#define EL_NS     hrxml
#define EL_TAG    SpeakingEvent

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SpeakingEvent) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SpeakingEvent")-1 + 1 + sizeof("</hrxml:SpeakingEvent>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Role; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Role")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EndDate(c, e);
  }
  for (se = x->EventName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EventName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->EventType; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EventType")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Location; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Location")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }
  for (se = x->AffiliatedOrganization; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AffiliatedOrganization")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEvent", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SpeakingEvent) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SpeakingEvent")-1 + 1 + 2 + sizeof("SpeakingEvent")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Title")-1);
  for (se = x->Role; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Role")-1);
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_StartDate(c, e);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EndDate(c, e);
  }
  for (se = x->EventName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("EventName")-1);
  for (se = x->EventType; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("EventType")-1);
  for (se = x->Location; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Location")-1);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }
  for (se = x->AffiliatedOrganization; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AffiliatedOrganization")-1);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Link")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEvent", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SpeakingEvent) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SpeakingEvent");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Role; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Role", sizeof("hrxml:Role")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_StartDate_s* e;
      for (e = x->StartDate; e; e = (struct zx_hrxml_StartDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_StartDate(c, e, p);
  }
  {
      struct zx_hrxml_EndDate_s* e;
      for (e = x->EndDate; e; e = (struct zx_hrxml_EndDate_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EndDate(c, e, p);
  }
  for (se = x->EventName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EventName", sizeof("hrxml:EventName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->EventType; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EventType", sizeof("hrxml:EventType")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Location; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Location", sizeof("hrxml:Location")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }
  for (se = x->AffiliatedOrganization; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AffiliatedOrganization", sizeof("hrxml:AffiliatedOrganization")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SpeakingEvent>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEvent", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SpeakingEvent) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SpeakingEvent", sizeof("SpeakingEvent")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->type, "type=\"", sizeof("type=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEvent", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SpeakingEvent) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SpeakingEvent(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SpeakingEvent(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SpeakingEvent) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SpeakingEvent(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SpeakingEvent(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpeakingEventsHistory
#define EL_STRUCT zx_hrxml_SpeakingEventsHistory_s
#define EL_NS     hrxml
#define EL_TAG    SpeakingEventsHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SpeakingEventsHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SpeakingEventsHistory")-1 + 1 + sizeof("</hrxml:SpeakingEventsHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SpeakingEvent_s* e;
      for (e = x->SpeakingEvent; e; e = (struct zx_hrxml_SpeakingEvent_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SpeakingEvent(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEventsHistory", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SpeakingEventsHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SpeakingEventsHistory")-1 + 1 + 2 + sizeof("SpeakingEventsHistory")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_SpeakingEvent_s* e;
      for (e = x->SpeakingEvent; e; e = (struct zx_hrxml_SpeakingEvent_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SpeakingEvent(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEventsHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SpeakingEventsHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SpeakingEventsHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_SpeakingEvent_s* e;
      for (e = x->SpeakingEvent; e; e = (struct zx_hrxml_SpeakingEvent_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SpeakingEvent(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SpeakingEventsHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEventsHistory", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SpeakingEventsHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SpeakingEventsHistory", sizeof("SpeakingEventsHistory")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEventsHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SpeakingEventsHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SpeakingEventsHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SpeakingEventsHistory(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SpeakingEventsHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SpeakingEventsHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SpeakingEventsHistory(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpecifiedCompetencyReference
#define EL_STRUCT zx_hrxml_SpecifiedCompetencyReference_s
#define EL_NS     hrxml
#define EL_TAG    SpecifiedCompetencyReference

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SpecifiedCompetencyReference) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SpecifiedCompetencyReference")-1 + 1 + sizeof("</hrxml:SpecifiedCompetencyReference>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_CompetencyId_s* e;
      for (e = x->CompetencyId; e; e = (struct zx_hrxml_CompetencyId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_CompetencyId(c, e);
  }
  for (se = x->ProficencyLevel; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ProficencyLevel")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpecifiedCompetencyReference", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SpecifiedCompetencyReference) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SpecifiedCompetencyReference")-1 + 1 + 2 + sizeof("SpecifiedCompetencyReference")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_CompetencyId_s* e;
      for (e = x->CompetencyId; e; e = (struct zx_hrxml_CompetencyId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_CompetencyId(c, e);
  }
  for (se = x->ProficencyLevel; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ProficencyLevel")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpecifiedCompetencyReference", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SpecifiedCompetencyReference) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SpecifiedCompetencyReference");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_CompetencyId_s* e;
      for (e = x->CompetencyId; e; e = (struct zx_hrxml_CompetencyId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_CompetencyId(c, e, p);
  }
  for (se = x->ProficencyLevel; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ProficencyLevel", sizeof("hrxml:ProficencyLevel")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SpecifiedCompetencyReference>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpecifiedCompetencyReference", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SpecifiedCompetencyReference) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SpecifiedCompetencyReference", sizeof("SpecifiedCompetencyReference")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpecifiedCompetencyReference", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SpecifiedCompetencyReference) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SpecifiedCompetencyReference(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SpecifiedCompetencyReference(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SpecifiedCompetencyReference) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SpecifiedCompetencyReference(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SpecifiedCompetencyReference(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StartDate
#define EL_STRUCT zx_hrxml_StartDate_s
#define EL_NS     hrxml
#define EL_TAG    StartDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_StartDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:StartDate")-1 + 1 + sizeof("</hrxml:StartDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StartDate", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_StartDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("StartDate")-1 + 1 + 2 + sizeof("StartDate")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AnyDate")-1);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("YearMonth")-1);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Year")-1);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDay")-1);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StringDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StartDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_StartDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:StartDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:StartDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StartDate", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_StartDate) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "StartDate", sizeof("StartDate")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateDescription, "dateDescription=\"", sizeof("dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StartDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_StartDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_StartDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_StartDate(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_StartDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_StartDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_StartDate(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StartingCompensation
#define EL_STRUCT zx_hrxml_StartingCompensation_s
#define EL_NS     hrxml
#define EL_TAG    StartingCompensation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_StartingCompensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:StartingCompensation")-1 + 1 + sizeof("</hrxml:StartingCompensation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->currency, sizeof("currency")-1, &pop_seen);
  len += zx_attr_so_len(c, x->intervalType, sizeof("intervalType")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StartingCompensation", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_StartingCompensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("StartingCompensation")-1 + 1 + 2 + sizeof("StartingCompensation")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->currency, sizeof("currency")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->intervalType, sizeof("intervalType")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StartingCompensation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_StartingCompensation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:StartingCompensation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->currency, " currency=\"", sizeof(" currency=\"")-1);
  p = zx_attr_so_enc(p, x->intervalType, " intervalType=\"", sizeof(" intervalType=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:StartingCompensation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StartingCompensation", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_StartingCompensation) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "StartingCompensation", sizeof("StartingCompensation")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->currency, "currency=\"", sizeof("currency=\"")-1);
  p = zx_attr_wo_enc(p, x->intervalType, "intervalType=\"", sizeof("intervalType=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StartingCompensation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_StartingCompensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_StartingCompensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_StartingCompensation(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_StartingCompensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_StartingCompensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_StartingCompensation(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Status
#define EL_STRUCT zx_hrxml_Status_s
#define EL_NS     hrxml
#define EL_TAG    Status

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Status) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Status")-1 + 1 + sizeof("</hrxml:Status>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Status", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Status) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Status")-1 + 1 + 2 + sizeof("Status")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Status", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Status) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Status");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Status>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Status", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Status) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Status", sizeof("Status")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Status", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Status) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Status(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Status(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Status) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Status(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Status(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Stock
#define EL_STRUCT zx_hrxml_Stock_s
#define EL_NS     hrxml
#define EL_TAG    Stock

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Stock) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Stock")-1 + 1 + sizeof("</hrxml:Stock>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Id(c, e);
  }
  for (se = x->Symbol; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Symbol")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Exchange; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Exchange")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Stock", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Stock) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Stock")-1 + 1 + 2 + sizeof("Stock")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Id(c, e);
  }
  for (se = x->Symbol; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Symbol")-1);
  for (se = x->Exchange; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Exchange")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Stock", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Stock) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Stock");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Id_s* e;
      for (e = x->Id; e; e = (struct zx_hrxml_Id_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Id(c, e, p);
  }
  for (se = x->Symbol; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Symbol", sizeof("hrxml:Symbol")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Exchange; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Exchange", sizeof("hrxml:Exchange")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Stock>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Stock", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Stock) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Stock", sizeof("Stock")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Stock", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Stock) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Stock(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Stock(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Stock) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Stock(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Stock(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StringValue
#define EL_STRUCT zx_hrxml_StringValue_s
#define EL_NS     hrxml
#define EL_TAG    StringValue

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_StringValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:StringValue")-1 + 1 + sizeof("</hrxml:StringValue>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->maxValue, sizeof("maxValue")-1, &pop_seen);
  len += zx_attr_so_len(c, x->minValue, sizeof("minValue")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StringValue", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_StringValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("StringValue")-1 + 1 + 2 + sizeof("StringValue")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->maxValue, sizeof("maxValue")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->minValue, sizeof("minValue")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StringValue", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_StringValue) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:StringValue");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->maxValue, " maxValue=\"", sizeof(" maxValue=\"")-1);
  p = zx_attr_so_enc(p, x->minValue, " minValue=\"", sizeof(" minValue=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:StringValue>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StringValue", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_StringValue) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "StringValue", sizeof("StringValue")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->description, "description=\"", sizeof("description=\"")-1);
  p = zx_attr_wo_enc(p, x->maxValue, "maxValue=\"", sizeof("maxValue=\"")-1);
  p = zx_attr_wo_enc(p, x->minValue, "minValue=\"", sizeof("minValue=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StringValue", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_StringValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_StringValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_StringValue(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_StringValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_StringValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_StringValue(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StructuredXMLResume
#define EL_STRUCT zx_hrxml_StructuredXMLResume_s
#define EL_NS     hrxml
#define EL_TAG    StructuredXMLResume

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_StructuredXMLResume) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:StructuredXMLResume")-1 + 1 + sizeof("</hrxml:StructuredXMLResume>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ContactInfo_s* e;
      for (e = x->ContactInfo; e; e = (struct zx_hrxml_ContactInfo_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactInfo(c, e);
  }
  for (se = x->ExecutiveSummary; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ExecutiveSummary")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Objective; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Objective")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_EmploymentHistory_s* e;
      for (e = x->EmploymentHistory; e; e = (struct zx_hrxml_EmploymentHistory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EmploymentHistory(c, e);
  }
  {
      struct zx_hrxml_EducationHistory_s* e;
      for (e = x->EducationHistory; e; e = (struct zx_hrxml_EducationHistory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EducationHistory(c, e);
  }
  {
      struct zx_hrxml_LicensesAndCertifications_s* e;
      for (e = x->LicensesAndCertifications; e; e = (struct zx_hrxml_LicensesAndCertifications_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_LicensesAndCertifications(c, e);
  }
  {
      struct zx_hrxml_MilitaryHistory_s* e;
      for (e = x->MilitaryHistory; e; e = (struct zx_hrxml_MilitaryHistory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_MilitaryHistory(c, e);
  }
  {
      struct zx_hrxml_PatentHistory_s* e;
      for (e = x->PatentHistory; e; e = (struct zx_hrxml_PatentHistory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PatentHistory(c, e);
  }
  {
      struct zx_hrxml_PublicationHistory_s* e;
      for (e = x->PublicationHistory; e; e = (struct zx_hrxml_PublicationHistory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PublicationHistory(c, e);
  }
  {
      struct zx_hrxml_SpeakingEventsHistory_s* e;
      for (e = x->SpeakingEventsHistory; e; e = (struct zx_hrxml_SpeakingEventsHistory_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SpeakingEventsHistory(c, e);
  }
  {
      struct zx_hrxml_Qualifications_s* e;
      for (e = x->Qualifications; e; e = (struct zx_hrxml_Qualifications_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Qualifications(c, e);
  }
  {
      struct zx_hrxml_Languages_s* e;
      for (e = x->Languages; e; e = (struct zx_hrxml_Languages_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Languages(c, e);
  }
  {
      struct zx_hrxml_Achievements_s* e;
      for (e = x->Achievements; e; e = (struct zx_hrxml_Achievements_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Achievements(c, e);
  }
  {
      struct zx_hrxml_Associations_s* e;
      for (e = x->Associations; e; e = (struct zx_hrxml_Associations_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Associations(c, e);
  }
  {
      struct zx_hrxml_References_s* e;
      for (e = x->References; e; e = (struct zx_hrxml_References_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_References(c, e);
  }
  {
      struct zx_hrxml_SecurityCredentials_s* e;
      for (e = x->SecurityCredentials; e; e = (struct zx_hrxml_SecurityCredentials_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SecurityCredentials(c, e);
  }
  {
      struct zx_hrxml_ResumeAdditionalItems_s* e;
      for (e = x->ResumeAdditionalItems; e; e = (struct zx_hrxml_ResumeAdditionalItems_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ResumeAdditionalItems(c, e);
  }
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_SupportingMaterials(c, e);
  }
  {
      struct zx_hrxml_ProfessionalAssociations_s* e;
      for (e = x->ProfessionalAssociations; e; e = (struct zx_hrxml_ProfessionalAssociations_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ProfessionalAssociations(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->RevisionDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:RevisionDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StructuredXMLResume", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_StructuredXMLResume) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("StructuredXMLResume")-1 + 1 + 2 + sizeof("StructuredXMLResume")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ContactInfo_s* e;
      for (e = x->ContactInfo; e; e = (struct zx_hrxml_ContactInfo_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactInfo(c, e);
  }
  for (se = x->ExecutiveSummary; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ExecutiveSummary")-1);
  for (se = x->Objective; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Objective")-1);
  {
      struct zx_hrxml_EmploymentHistory_s* e;
      for (e = x->EmploymentHistory; e; e = (struct zx_hrxml_EmploymentHistory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EmploymentHistory(c, e);
  }
  {
      struct zx_hrxml_EducationHistory_s* e;
      for (e = x->EducationHistory; e; e = (struct zx_hrxml_EducationHistory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EducationHistory(c, e);
  }
  {
      struct zx_hrxml_LicensesAndCertifications_s* e;
      for (e = x->LicensesAndCertifications; e; e = (struct zx_hrxml_LicensesAndCertifications_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_LicensesAndCertifications(c, e);
  }
  {
      struct zx_hrxml_MilitaryHistory_s* e;
      for (e = x->MilitaryHistory; e; e = (struct zx_hrxml_MilitaryHistory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_MilitaryHistory(c, e);
  }
  {
      struct zx_hrxml_PatentHistory_s* e;
      for (e = x->PatentHistory; e; e = (struct zx_hrxml_PatentHistory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PatentHistory(c, e);
  }
  {
      struct zx_hrxml_PublicationHistory_s* e;
      for (e = x->PublicationHistory; e; e = (struct zx_hrxml_PublicationHistory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PublicationHistory(c, e);
  }
  {
      struct zx_hrxml_SpeakingEventsHistory_s* e;
      for (e = x->SpeakingEventsHistory; e; e = (struct zx_hrxml_SpeakingEventsHistory_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SpeakingEventsHistory(c, e);
  }
  {
      struct zx_hrxml_Qualifications_s* e;
      for (e = x->Qualifications; e; e = (struct zx_hrxml_Qualifications_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Qualifications(c, e);
  }
  {
      struct zx_hrxml_Languages_s* e;
      for (e = x->Languages; e; e = (struct zx_hrxml_Languages_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Languages(c, e);
  }
  {
      struct zx_hrxml_Achievements_s* e;
      for (e = x->Achievements; e; e = (struct zx_hrxml_Achievements_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Achievements(c, e);
  }
  {
      struct zx_hrxml_Associations_s* e;
      for (e = x->Associations; e; e = (struct zx_hrxml_Associations_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Associations(c, e);
  }
  {
      struct zx_hrxml_References_s* e;
      for (e = x->References; e; e = (struct zx_hrxml_References_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_References(c, e);
  }
  {
      struct zx_hrxml_SecurityCredentials_s* e;
      for (e = x->SecurityCredentials; e; e = (struct zx_hrxml_SecurityCredentials_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SecurityCredentials(c, e);
  }
  {
      struct zx_hrxml_ResumeAdditionalItems_s* e;
      for (e = x->ResumeAdditionalItems; e; e = (struct zx_hrxml_ResumeAdditionalItems_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ResumeAdditionalItems(c, e);
  }
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_SupportingMaterials(c, e);
  }
  {
      struct zx_hrxml_ProfessionalAssociations_s* e;
      for (e = x->ProfessionalAssociations; e; e = (struct zx_hrxml_ProfessionalAssociations_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ProfessionalAssociations(c, e);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Comments")-1);
  for (se = x->RevisionDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("RevisionDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StructuredXMLResume", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_StructuredXMLResume) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:StructuredXMLResume");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_ContactInfo_s* e;
      for (e = x->ContactInfo; e; e = (struct zx_hrxml_ContactInfo_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactInfo(c, e, p);
  }
  for (se = x->ExecutiveSummary; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ExecutiveSummary", sizeof("hrxml:ExecutiveSummary")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Objective; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Objective", sizeof("hrxml:Objective")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_EmploymentHistory_s* e;
      for (e = x->EmploymentHistory; e; e = (struct zx_hrxml_EmploymentHistory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EmploymentHistory(c, e, p);
  }
  {
      struct zx_hrxml_EducationHistory_s* e;
      for (e = x->EducationHistory; e; e = (struct zx_hrxml_EducationHistory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EducationHistory(c, e, p);
  }
  {
      struct zx_hrxml_LicensesAndCertifications_s* e;
      for (e = x->LicensesAndCertifications; e; e = (struct zx_hrxml_LicensesAndCertifications_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_LicensesAndCertifications(c, e, p);
  }
  {
      struct zx_hrxml_MilitaryHistory_s* e;
      for (e = x->MilitaryHistory; e; e = (struct zx_hrxml_MilitaryHistory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_MilitaryHistory(c, e, p);
  }
  {
      struct zx_hrxml_PatentHistory_s* e;
      for (e = x->PatentHistory; e; e = (struct zx_hrxml_PatentHistory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PatentHistory(c, e, p);
  }
  {
      struct zx_hrxml_PublicationHistory_s* e;
      for (e = x->PublicationHistory; e; e = (struct zx_hrxml_PublicationHistory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PublicationHistory(c, e, p);
  }
  {
      struct zx_hrxml_SpeakingEventsHistory_s* e;
      for (e = x->SpeakingEventsHistory; e; e = (struct zx_hrxml_SpeakingEventsHistory_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SpeakingEventsHistory(c, e, p);
  }
  {
      struct zx_hrxml_Qualifications_s* e;
      for (e = x->Qualifications; e; e = (struct zx_hrxml_Qualifications_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Qualifications(c, e, p);
  }
  {
      struct zx_hrxml_Languages_s* e;
      for (e = x->Languages; e; e = (struct zx_hrxml_Languages_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Languages(c, e, p);
  }
  {
      struct zx_hrxml_Achievements_s* e;
      for (e = x->Achievements; e; e = (struct zx_hrxml_Achievements_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Achievements(c, e, p);
  }
  {
      struct zx_hrxml_Associations_s* e;
      for (e = x->Associations; e; e = (struct zx_hrxml_Associations_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Associations(c, e, p);
  }
  {
      struct zx_hrxml_References_s* e;
      for (e = x->References; e; e = (struct zx_hrxml_References_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_References(c, e, p);
  }
  {
      struct zx_hrxml_SecurityCredentials_s* e;
      for (e = x->SecurityCredentials; e; e = (struct zx_hrxml_SecurityCredentials_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SecurityCredentials(c, e, p);
  }
  {
      struct zx_hrxml_ResumeAdditionalItems_s* e;
      for (e = x->ResumeAdditionalItems; e; e = (struct zx_hrxml_ResumeAdditionalItems_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ResumeAdditionalItems(c, e, p);
  }
  {
      struct zx_hrxml_SupportingMaterials_s* e;
      for (e = x->SupportingMaterials; e; e = (struct zx_hrxml_SupportingMaterials_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_SupportingMaterials(c, e, p);
  }
  {
      struct zx_hrxml_ProfessionalAssociations_s* e;
      for (e = x->ProfessionalAssociations; e; e = (struct zx_hrxml_ProfessionalAssociations_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ProfessionalAssociations(c, e, p);
  }
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->RevisionDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:RevisionDate", sizeof("hrxml:RevisionDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:StructuredXMLResume>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StructuredXMLResume", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_StructuredXMLResume) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "StructuredXMLResume", sizeof("StructuredXMLResume")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StructuredXMLResume", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_StructuredXMLResume) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_StructuredXMLResume(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_StructuredXMLResume(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_StructuredXMLResume) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_StructuredXMLResume(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_StructuredXMLResume(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SupplierId
#define EL_STRUCT zx_hrxml_SupplierId_s
#define EL_NS     hrxml
#define EL_TAG    SupplierId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SupplierId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SupplierId")-1 + 1 + sizeof("</hrxml:SupplierId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SupplierId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SupplierId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SupplierId")-1 + 1 + 2 + sizeof("SupplierId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SupplierId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SupplierId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SupplierId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SupplierId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SupplierId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SupplierId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SupplierId", sizeof("SupplierId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SupplierId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SupplierId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SupplierId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SupplierId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SupplierId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SupplierId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SupplierId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SupportingMaterials
#define EL_STRUCT zx_hrxml_SupportingMaterials_s
#define EL_NS     hrxml
#define EL_TAG    SupportingMaterials

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SupportingMaterials) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SupportingMaterials")-1 + 1 + sizeof("</hrxml:SupportingMaterials>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_AttachmentReference_s* e;
      for (e = x->AttachmentReference; e; e = (struct zx_hrxml_AttachmentReference_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_AttachmentReference(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SupportingMaterials", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_SupportingMaterials) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("SupportingMaterials")-1 + 1 + 2 + sizeof("SupportingMaterials")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Link")-1);
  {
      struct zx_hrxml_AttachmentReference_s* e;
      for (e = x->AttachmentReference; e; e = (struct zx_hrxml_AttachmentReference_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_AttachmentReference(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SupportingMaterials", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SupportingMaterials) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SupportingMaterials");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_AttachmentReference_s* e;
      for (e = x->AttachmentReference; e; e = (struct zx_hrxml_AttachmentReference_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_AttachmentReference(c, e, p);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SupportingMaterials>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SupportingMaterials", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_SupportingMaterials) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "SupportingMaterials", sizeof("SupportingMaterials")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SupportingMaterials", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SupportingMaterials) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SupportingMaterials(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SupportingMaterials(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_SupportingMaterials) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_SupportingMaterials(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_SupportingMaterials(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TTYTDD
#define EL_STRUCT zx_hrxml_TTYTDD_s
#define EL_NS     hrxml
#define EL_TAG    TTYTDD

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TTYTDD) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TTYTDD")-1 + 1 + sizeof("</hrxml:TTYTDD>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TTYTDD", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_TTYTDD) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("TTYTDD")-1 + 1 + 2 + sizeof("TTYTDD")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("FormattedNumber")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TTYTDD", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TTYTDD) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TTYTDD");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedNumber", sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TTYTDD>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TTYTDD", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_TTYTDD) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "TTYTDD", sizeof("TTYTDD")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TTYTDD", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TTYTDD) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TTYTDD(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TTYTDD(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_TTYTDD) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_TTYTDD(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_TTYTDD(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TaxId
#define EL_STRUCT zx_hrxml_TaxId_s
#define EL_NS     hrxml
#define EL_TAG    TaxId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TaxId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TaxId")-1 + 1 + sizeof("</hrxml:TaxId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TaxId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_TaxId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("TaxId")-1 + 1 + 2 + sizeof("TaxId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TaxId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TaxId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TaxId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TaxId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TaxId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_TaxId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "TaxId", sizeof("TaxId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TaxId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TaxId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TaxId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TaxId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_TaxId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_TaxId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_TaxId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TaxonomyId
#define EL_STRUCT zx_hrxml_TaxonomyId_s
#define EL_NS     hrxml
#define EL_TAG    TaxonomyId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TaxonomyId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TaxonomyId")-1 + 1 + sizeof("</hrxml:TaxonomyId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_TaxonomyId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("TaxonomyId")-1 + 1 + 2 + sizeof("TaxonomyId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->id, sizeof("id")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TaxonomyId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TaxonomyId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->id, " id=\"", sizeof(" id=\"")-1);
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TaxonomyId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_TaxonomyId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "TaxonomyId", sizeof("TaxonomyId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->description, "description=\"", sizeof("description=\"")-1);
  p = zx_attr_wo_enc(p, x->id, "id=\"", sizeof("id=\"")-1);
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TaxonomyId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TaxonomyId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TaxonomyId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_TaxonomyId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_TaxonomyId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_TaxonomyId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TaxonomyName
#define EL_STRUCT zx_hrxml_TaxonomyName_s
#define EL_NS     hrxml
#define EL_TAG    TaxonomyName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TaxonomyName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TaxonomyName")-1 + 1 + sizeof("</hrxml:TaxonomyName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->version, sizeof("version")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyName", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_TaxonomyName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("TaxonomyName")-1 + 1 + 2 + sizeof("TaxonomyName")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->version, sizeof("version")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TaxonomyName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TaxonomyName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->version, " version=\"", sizeof(" version=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TaxonomyName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyName", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_TaxonomyName) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "TaxonomyName", sizeof("TaxonomyName")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->version, "version=\"", sizeof("version=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TaxonomyName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TaxonomyName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TaxonomyName(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_TaxonomyName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_TaxonomyName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_TaxonomyName(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Telephone
#define EL_STRUCT zx_hrxml_Telephone_s
#define EL_NS     hrxml
#define EL_TAG    Telephone

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Telephone) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Telephone")-1 + 1 + sizeof("</hrxml:Telephone>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Telephone", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Telephone) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Telephone")-1 + 1 + 2 + sizeof("Telephone")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("FormattedNumber")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Telephone", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Telephone) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Telephone");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedNumber", sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Telephone>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Telephone", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Telephone) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Telephone", sizeof("Telephone")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Telephone", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Telephone) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Telephone(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Telephone(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Telephone) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Telephone(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Telephone(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TermOfNotice
#define EL_STRUCT zx_hrxml_TermOfNotice_s
#define EL_NS     hrxml
#define EL_TAG    TermOfNotice

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TermOfNotice) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TermOfNotice")-1 + 1 + sizeof("</hrxml:TermOfNotice>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Value")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Interval; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Interval")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TermOfNotice", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_TermOfNotice) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("TermOfNotice")-1 + 1 + 2 + sizeof("TermOfNotice")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Value")-1);
  for (se = x->Interval; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Interval")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TermOfNotice", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TermOfNotice) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TermOfNotice");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Value", sizeof("hrxml:Value")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Interval; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Interval", sizeof("hrxml:Interval")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TermOfNotice>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TermOfNotice", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_TermOfNotice) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "TermOfNotice", sizeof("TermOfNotice")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TermOfNotice", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TermOfNotice) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TermOfNotice(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TermOfNotice(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_TermOfNotice) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_TermOfNotice(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_TermOfNotice(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TimeMax
#define EL_STRUCT zx_hrxml_TimeMax_s
#define EL_NS     hrxml
#define EL_TAG    TimeMax

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TimeMax) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TimeMax")-1 + 1 + sizeof("</hrxml:TimeMax>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TimeMax", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_TimeMax) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("TimeMax")-1 + 1 + 2 + sizeof("TimeMax")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TimeMax", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TimeMax) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TimeMax");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->unitOfMeasure, " unitOfMeasure=\"", sizeof(" unitOfMeasure=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TimeMax>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TimeMax", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_TimeMax) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "TimeMax", sizeof("TimeMax")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->unitOfMeasure, "unitOfMeasure=\"", sizeof("unitOfMeasure=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TimeMax", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TimeMax) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TimeMax(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TimeMax(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_TimeMax) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_TimeMax(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_TimeMax(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TimeOffAllowance
#define EL_STRUCT zx_hrxml_TimeOffAllowance_s
#define EL_NS     hrxml
#define EL_TAG    TimeOffAllowance

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TimeOffAllowance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TimeOffAllowance")-1 + 1 + sizeof("</hrxml:TimeOffAllowance>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->timeOffType, sizeof("timeOffType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TimeOffAllowance", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_TimeOffAllowance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("TimeOffAllowance")-1 + 1 + 2 + sizeof("TimeOffAllowance")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->timeOffType, sizeof("timeOffType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TimeOffAllowance", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TimeOffAllowance) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TimeOffAllowance");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->timeOffType, " timeOffType=\"", sizeof(" timeOffType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TimeOffAllowance>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TimeOffAllowance", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_TimeOffAllowance) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "TimeOffAllowance", sizeof("TimeOffAllowance")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->timeOffType, "timeOffType=\"", sizeof("timeOffType=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TimeOffAllowance", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TimeOffAllowance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TimeOffAllowance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TimeOffAllowance(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_TimeOffAllowance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_TimeOffAllowance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_TimeOffAllowance(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Travel
#define EL_STRUCT zx_hrxml_Travel_s
#define EL_NS     hrxml
#define EL_TAG    Travel

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Travel) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Travel")-1 + 1 + sizeof("</hrxml:Travel>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Applicable; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Applicable")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->TravelFrequency; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:TravelFrequency")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->TravelConsiderations; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:TravelConsiderations")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Travel", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Travel) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Travel")-1 + 1 + 2 + sizeof("Travel")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Applicable; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Applicable")-1);
  for (se = x->TravelFrequency; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("TravelFrequency")-1);
  for (se = x->TravelConsiderations; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("TravelConsiderations")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Travel", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Travel) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Travel");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Applicable; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Applicable", sizeof("hrxml:Applicable")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->TravelFrequency; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:TravelFrequency", sizeof("hrxml:TravelFrequency")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->TravelConsiderations; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:TravelConsiderations", sizeof("hrxml:TravelConsiderations")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Travel>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Travel", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Travel) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Travel", sizeof("Travel")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Travel", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Travel) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Travel(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Travel(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Travel) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Travel(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Travel(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TravelDirections
#define EL_STRUCT zx_hrxml_TravelDirections_s
#define EL_NS     hrxml
#define EL_TAG    TravelDirections

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TravelDirections) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TravelDirections")-1 + 1 + sizeof("</hrxml:TravelDirections>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TravelDirections", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_TravelDirections) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("TravelDirections")-1 + 1 + 2 + sizeof("TravelDirections")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->lang, sizeof("lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TravelDirections", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TravelDirections) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TravelDirections");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_xml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TravelDirections>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TravelDirections", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_TravelDirections) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "TravelDirections", sizeof("TravelDirections")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, x->lang->g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->lang, "lang=\"", sizeof("lang=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TravelDirections", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TravelDirections) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TravelDirections(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TravelDirections(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_TravelDirections) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_TravelDirections(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_TravelDirections(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_UserArea
#define EL_STRUCT zx_hrxml_UserArea_s
#define EL_NS     hrxml
#define EL_TAG    UserArea

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_UserArea) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:UserArea")-1 + 1 + sizeof("</hrxml:UserArea>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:UserArea", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_UserArea) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("UserArea")-1 + 1 + 2 + sizeof("UserArea")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:UserArea", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_UserArea) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:UserArea");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:UserArea>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:UserArea", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_UserArea) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "UserArea", sizeof("UserArea")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:UserArea", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_UserArea) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_UserArea(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_UserArea(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_UserArea) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_UserArea(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_UserArea(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_UserId
#define EL_STRUCT zx_hrxml_UserId_s
#define EL_NS     hrxml
#define EL_TAG    UserId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_UserId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:UserId")-1 + 1 + sizeof("</hrxml:UserId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:UserId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_UserId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("UserId")-1 + 1 + 2 + sizeof("UserId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:UserId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_UserId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:UserId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:UserId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:UserId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_UserId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "UserId", sizeof("UserId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:UserId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_UserId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_UserId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_UserId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_UserId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_UserId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_UserId(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ValidFrom
#define EL_STRUCT zx_hrxml_ValidFrom_s
#define EL_NS     hrxml
#define EL_TAG    ValidFrom

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ValidFrom) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ValidFrom")-1 + 1 + sizeof("</hrxml:ValidFrom>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ValidFrom", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ValidFrom) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ValidFrom")-1 + 1 + 2 + sizeof("ValidFrom")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AnyDate")-1);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("YearMonth")-1);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Year")-1);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDay")-1);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StringDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ValidFrom", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ValidFrom) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ValidFrom");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ValidFrom>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ValidFrom", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ValidFrom) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ValidFrom", sizeof("ValidFrom")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateDescription, "dateDescription=\"", sizeof("dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ValidFrom", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ValidFrom) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ValidFrom(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ValidFrom(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ValidFrom) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ValidFrom(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ValidFrom(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ValidTo
#define EL_STRUCT zx_hrxml_ValidTo_s
#define EL_NS     hrxml
#define EL_TAG    ValidTo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ValidTo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ValidTo")-1 + 1 + sizeof("</hrxml:ValidTo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ValidTo", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_ValidTo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("ValidTo")-1 + 1 + 2 + sizeof("ValidTo")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AnyDate")-1);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("YearMonth")-1);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("Year")-1);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("MonthDay")-1);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("StringDate")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ValidTo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ValidTo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ValidTo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ValidTo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ValidTo", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_ValidTo) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "ValidTo", sizeof("ValidTo")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->dateDescription, "dateDescription=\"", sizeof("dateDescription=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ValidTo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ValidTo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ValidTo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ValidTo(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_ValidTo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_ValidTo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_ValidTo(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Verification
#define EL_STRUCT zx_hrxml_Verification_s
#define EL_NS     hrxml
#define EL_TAG    Verification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Verification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Verification")-1 + 1 + sizeof("</hrxml:Verification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ContactInfo_s* e;
      for (e = x->ContactInfo; e; e = (struct zx_hrxml_ContactInfo_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ContactInfo(c, e);
  }
  for (se = x->ReasonForLeaving; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ReasonForLeaving")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PermissionToContact; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PermissionToContact")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->VerifyEmployment; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:VerifyEmployment")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->EligibleForRehire; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EligibleForRehire")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AttendanceRating; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AttendanceRating")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->OverallPerformanceRating; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OverallPerformanceRating")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->QuestionAnswerPair; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:QuestionAnswerPair")-1, zx_ns_tab+zx_xmlns_ix_hrxml);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Verification", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Verification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Verification")-1 + 1 + 2 + sizeof("Verification")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_ContactInfo_s* e;
      for (e = x->ContactInfo; e; e = (struct zx_hrxml_ContactInfo_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ContactInfo(c, e);
  }
  for (se = x->ReasonForLeaving; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("ReasonForLeaving")-1);
  for (se = x->PermissionToContact; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("PermissionToContact")-1);
  for (se = x->VerifyEmployment; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("VerifyEmployment")-1);
  for (se = x->EligibleForRehire; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("EligibleForRehire")-1);
  for (se = x->AttendanceRating; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("AttendanceRating")-1);
  for (se = x->OverallPerformanceRating; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("OverallPerformanceRating")-1);
  for (se = x->QuestionAnswerPair; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("QuestionAnswerPair")-1);


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Verification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Verification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Verification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_ContactInfo_s* e;
      for (e = x->ContactInfo; e; e = (struct zx_hrxml_ContactInfo_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ContactInfo(c, e, p);
  }
  for (se = x->ReasonForLeaving; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ReasonForLeaving", sizeof("hrxml:ReasonForLeaving")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->PermissionToContact; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PermissionToContact", sizeof("hrxml:PermissionToContact")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->VerifyEmployment; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:VerifyEmployment", sizeof("hrxml:VerifyEmployment")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->EligibleForRehire; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EligibleForRehire", sizeof("hrxml:EligibleForRehire")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->AttendanceRating; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AttendanceRating", sizeof("hrxml:AttendanceRating")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->OverallPerformanceRating; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OverallPerformanceRating", sizeof("hrxml:OverallPerformanceRating")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  for (se = x->QuestionAnswerPair; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:QuestionAnswerPair", sizeof("hrxml:QuestionAnswerPair")-1, zx_ns_tab+zx_xmlns_ix_hrxml);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Verification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Verification", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Verification) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Verification", sizeof("Verification")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Verification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Verification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Verification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Verification(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Verification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Verification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Verification(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_VerticalAccuracy
#define EL_STRUCT zx_hrxml_VerticalAccuracy_s
#define EL_NS     hrxml
#define EL_TAG    VerticalAccuracy

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_VerticalAccuracy) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:VerticalAccuracy")-1 + 1 + sizeof("</hrxml:VerticalAccuracy>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:VerticalAccuracy", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_VerticalAccuracy) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("VerticalAccuracy")-1 + 1 + 2 + sizeof("VerticalAccuracy")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:VerticalAccuracy", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_VerticalAccuracy) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:VerticalAccuracy");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:VerticalAccuracy>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:VerticalAccuracy", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_VerticalAccuracy) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "VerticalAccuracy", sizeof("VerticalAccuracy")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:VerticalAccuracy", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_VerticalAccuracy) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_VerticalAccuracy(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_VerticalAccuracy(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_VerticalAccuracy) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_VerticalAccuracy(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_VerticalAccuracy(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_VisaStatus
#define EL_STRUCT zx_hrxml_VisaStatus_s
#define EL_NS     hrxml
#define EL_TAG    VisaStatus

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_VisaStatus) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:VisaStatus")-1 + 1 + sizeof("</hrxml:VisaStatus>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:VisaStatus", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_VisaStatus) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("VisaStatus")-1 + 1 + 2 + sizeof("VisaStatus")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:VisaStatus", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_VisaStatus) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:VisaStatus");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->countryCode, " countryCode=\"", sizeof(" countryCode=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:VisaStatus>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:VisaStatus", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_VisaStatus) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "VisaStatus", sizeof("VisaStatus")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->countryCode, "countryCode=\"", sizeof("countryCode=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:VisaStatus", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_VisaStatus) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_VisaStatus(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_VisaStatus(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_VisaStatus) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_VisaStatus(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_VisaStatus(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Weight
#define EL_STRUCT zx_hrxml_Weight_s
#define EL_NS     hrxml
#define EL_TAG    Weight

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Weight) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Weight")-1 + 1 + sizeof("</hrxml:Weight>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->interval, sizeof("interval")-1, &pop_seen);
  len += zx_attr_so_len(c, x->maxValue, sizeof("maxValue")-1, &pop_seen);
  len += zx_attr_so_len(c, x->minValue, sizeof("minValue")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Weight", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_Weight) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("Weight")-1 + 1 + 2 + sizeof("Weight")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->interval, sizeof("interval")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->maxValue, sizeof("maxValue")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->minValue, sizeof("minValue")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Weight", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Weight) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Weight");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->interval, " interval=\"", sizeof(" interval=\"")-1);
  p = zx_attr_so_enc(p, x->maxValue, " maxValue=\"", sizeof(" maxValue=\"")-1);
  p = zx_attr_so_enc(p, x->minValue, " minValue=\"", sizeof(" minValue=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Weight>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Weight", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_Weight) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "Weight", sizeof("Weight")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->description, "description=\"", sizeof("description=\"")-1);
  p = zx_attr_wo_enc(p, x->interval, "interval=\"", sizeof("interval=\"")-1);
  p = zx_attr_wo_enc(p, x->maxValue, "maxValue=\"", sizeof("maxValue=\"")-1);
  p = zx_attr_wo_enc(p, x->minValue, "minValue=\"", sizeof("minValue=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Weight", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Weight) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Weight(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Weight(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_Weight) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_Weight(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_Weight(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_WorkSite
#define EL_STRUCT zx_hrxml_WorkSite_s
#define EL_NS     hrxml
#define EL_TAG    WorkSite

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_WorkSite) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:WorkSite")-1 + 1 + sizeof("</hrxml:WorkSite>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->WorkSiteName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:WorkSiteName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_WorkSiteId_s* e;
      for (e = x->WorkSiteId; e; e = (struct zx_hrxml_WorkSiteId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_WorkSiteId(c, e);
  }
  {
      struct zx_hrxml_Details_s* e;
      for (e = x->Details; e; e = (struct zx_hrxml_Details_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Details(c, e);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_PostalAddress(c, e);
  }
  {
      struct zx_hrxml_TravelDirections_s* e;
      for (e = x->TravelDirections; e; e = (struct zx_hrxml_TravelDirections_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_TravelDirections(c, e);
  }
  {
      struct zx_hrxml_ParkingInstructions_s* e;
      for (e = x->ParkingInstructions; e; e = (struct zx_hrxml_ParkingInstructions_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_ParkingInstructions(c, e);
  }
  {
      struct zx_hrxml_WorkSiteEnvironment_s* e;
      for (e = x->WorkSiteEnvironment; e; e = (struct zx_hrxml_WorkSiteEnvironment_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_WorkSiteEnvironment(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:WorkSite", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_WorkSite) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("WorkSite")-1 + 1 + 2 + sizeof("WorkSite")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->WorkSiteName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("WorkSiteName")-1);
  {
      struct zx_hrxml_WorkSiteId_s* e;
      for (e = x->WorkSiteId; e; e = (struct zx_hrxml_WorkSiteId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_WorkSiteId(c, e);
  }
  {
      struct zx_hrxml_Details_s* e;
      for (e = x->Details; e; e = (struct zx_hrxml_Details_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Details(c, e);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_PostalAddress(c, e);
  }
  {
      struct zx_hrxml_TravelDirections_s* e;
      for (e = x->TravelDirections; e; e = (struct zx_hrxml_TravelDirections_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_TravelDirections(c, e);
  }
  {
      struct zx_hrxml_ParkingInstructions_s* e;
      for (e = x->ParkingInstructions; e; e = (struct zx_hrxml_ParkingInstructions_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_ParkingInstructions(c, e);
  }
  {
      struct zx_hrxml_WorkSiteEnvironment_s* e;
      for (e = x->WorkSiteEnvironment; e; e = (struct zx_hrxml_WorkSiteEnvironment_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_WorkSiteEnvironment(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:WorkSite", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_WorkSite) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:WorkSite");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->WorkSiteName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:WorkSiteName", sizeof("hrxml:WorkSiteName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_WorkSiteId_s* e;
      for (e = x->WorkSiteId; e; e = (struct zx_hrxml_WorkSiteId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_WorkSiteId(c, e, p);
  }
  {
      struct zx_hrxml_Details_s* e;
      for (e = x->Details; e; e = (struct zx_hrxml_Details_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Details(c, e, p);
  }
  {
      struct zx_hrxml_PostalAddress_s* e;
      for (e = x->PostalAddress; e; e = (struct zx_hrxml_PostalAddress_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_PostalAddress(c, e, p);
  }
  {
      struct zx_hrxml_TravelDirections_s* e;
      for (e = x->TravelDirections; e; e = (struct zx_hrxml_TravelDirections_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_TravelDirections(c, e, p);
  }
  {
      struct zx_hrxml_ParkingInstructions_s* e;
      for (e = x->ParkingInstructions; e; e = (struct zx_hrxml_ParkingInstructions_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_ParkingInstructions(c, e, p);
  }
  {
      struct zx_hrxml_WorkSiteEnvironment_s* e;
      for (e = x->WorkSiteEnvironment; e; e = (struct zx_hrxml_WorkSiteEnvironment_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_WorkSiteEnvironment(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:WorkSite>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:WorkSite", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_WorkSite) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "WorkSite", sizeof("WorkSite")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:WorkSite", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_WorkSite) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_WorkSite(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_WorkSite(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_WorkSite) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_WorkSite(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_WorkSite(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_WorkSiteEnvironment
#define EL_STRUCT zx_hrxml_WorkSiteEnvironment_s
#define EL_NS     hrxml
#define EL_TAG    WorkSiteEnvironment

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_WorkSiteEnvironment) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:WorkSiteEnvironment")-1 + 1 + sizeof("</hrxml:WorkSiteEnvironment>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->EnvironmentName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EnvironmentName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_EnvironmentId_s* e;
      for (e = x->EnvironmentId; e; e = (struct zx_hrxml_EnvironmentId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_EnvironmentId(c, e);
  }
  {
      struct zx_hrxml_WorkSiteId_s* e;
      for (e = x->WorkSiteId; e; e = (struct zx_hrxml_WorkSiteId_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_WorkSiteId(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_Considerations_s* e;
      for (e = x->Considerations; e; e = (struct zx_hrxml_Considerations_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_Considerations(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_UserArea(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteEnvironment", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_WorkSiteEnvironment) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("WorkSiteEnvironment")-1 + 1 + 2 + sizeof("WorkSiteEnvironment")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->EnvironmentName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_WO_simple_elem(c, se, sizeof("EnvironmentName")-1);
  {
      struct zx_hrxml_EnvironmentId_s* e;
      for (e = x->EnvironmentId; e; e = (struct zx_hrxml_EnvironmentId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_EnvironmentId(c, e);
  }
  {
      struct zx_hrxml_WorkSiteId_s* e;
      for (e = x->WorkSiteId; e; e = (struct zx_hrxml_WorkSiteId_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_WorkSiteId(c, e);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Description(c, e);
  }
  {
      struct zx_hrxml_Considerations_s* e;
      for (e = x->Considerations; e; e = (struct zx_hrxml_Considerations_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_Considerations(c, e);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_UserArea(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteEnvironment", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_WorkSiteEnvironment) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:WorkSiteEnvironment");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->EnvironmentName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EnvironmentName", sizeof("hrxml:EnvironmentName")-1, zx_ns_tab+zx_xmlns_ix_hrxml);
  {
      struct zx_hrxml_EnvironmentId_s* e;
      for (e = x->EnvironmentId; e; e = (struct zx_hrxml_EnvironmentId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_EnvironmentId(c, e, p);
  }
  {
      struct zx_hrxml_WorkSiteId_s* e;
      for (e = x->WorkSiteId; e; e = (struct zx_hrxml_WorkSiteId_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_WorkSiteId(c, e, p);
  }
  {
      struct zx_hrxml_Description_s* e;
      for (e = x->Description; e; e = (struct zx_hrxml_Description_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Description(c, e, p);
  }
  {
      struct zx_hrxml_Considerations_s* e;
      for (e = x->Considerations; e; e = (struct zx_hrxml_Considerations_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_Considerations(c, e, p);
  }
  {
      struct zx_hrxml_UserArea_s* e;
      for (e = x->UserArea; e; e = (struct zx_hrxml_UserArea_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_UserArea(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:WorkSiteEnvironment>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteEnvironment", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_WorkSiteEnvironment) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "WorkSiteEnvironment", sizeof("WorkSiteEnvironment")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteEnvironment", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_WorkSiteEnvironment) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_WorkSiteEnvironment(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_WorkSiteEnvironment(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_WorkSiteEnvironment) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_WorkSiteEnvironment(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_WorkSiteEnvironment(c, x, buf ), buf, len);
}






#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_WorkSiteId
#define EL_STRUCT zx_hrxml_WorkSiteId_s
#define EL_NS     hrxml
#define EL_TAG    WorkSiteId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_WorkSiteId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:WorkSiteId")-1 + 1 + sizeof("</hrxml:WorkSiteId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_SO_hrxml_IdValue(c, e);
  }


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteId", len);
  return len;
}

/* FUNC(zx_LEN_WO_hrxml_WorkSiteId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in wire order and no assumptions
 * are made about namespace prefixes. */

/* Called by: */
int zx_LEN_WO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  int len = 1 + sizeof("WorkSiteId")-1 + 1 + 2 + sizeof("WorkSiteId")-1 + 1;
  
  if (x->gg.g.ns && x->gg.g.ns->prefix_len)
    len += (x->gg.g.ns->prefix_len + 1) * 2;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  len += zx_attr_wo_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_wo_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  len += zx_LEN_WO_hrxml_IdValue(c, e);
  }


  len += zx_len_wo_common(c, &x->gg, &pop_seen); 
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_WorkSiteId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:WorkSiteId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xmlns_ix_hrxml, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  {
      struct zx_hrxml_IdValue_s* e;
      for (e = x->IdValue; e; e = (struct zx_hrxml_IdValue_s*)e->gg.g.n)
	  p = zx_ENC_SO_hrxml_IdValue(c, e, p);
  }

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:WorkSiteId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteId", p-enc_base);
  return p;
}

/* FUNC(zx_ENC_WO_hrxml_WorkSiteId) */

/* Render element into string. The XML attributes and elements are
 * processed in wire order by chasing wo pointers. This is what you want for
 * validating signatures on other people's XML documents. */

/* Called by: */
char* zx_ENC_WO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x, char* p )
{
  struct zx_elem_s* kid;
  struct zx_ns_s* pop_seen = 0;
  char* q;
  char* qq;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  q = p;
  if (x->gg.g.ns && x->gg.g.ns->prefix_len) {
    ZX_OUT_MEM(p, x->gg.g.ns->prefix, x->gg.g.ns->prefix_len);
    ZX_OUT_CH(p, ':');
  }
  ZX_OUT_MEM(p, "WorkSiteId", sizeof("WorkSiteId")-1);
  qq = p;

  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, x->gg.g.ns, &pop_seen);

  zx_see_unknown_attrs_ns(c, x->gg.any_attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_wo_enc(p, x->idOwner, "idOwner=\"", sizeof("idOwner=\"")-1);
  p = zx_attr_wo_enc(p, x->validFrom, "validFrom=\"", sizeof("validFrom=\"")-1);
  p = zx_attr_wo_enc(p, x->validTo, "validTo=\"", sizeof("validTo=\"")-1);

  p = zx_enc_unknown_attrs(p, x->gg.any_attr);
#else
  /* root node has no begin tag */
#endif
  
  for (kid = x->gg.kids; kid; kid = ((struct zx_elem_s*)(kid->g.wo)))
    p = zx_ENC_WO_any_elem(c, kid, p);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CH(p, '<');
  ZX_OUT_CH(p, '/');
  ZX_OUT_MEM(p, q, qq-q);
  ZX_OUT_CH(p, '>');
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_WorkSiteId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_WorkSiteId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_WorkSiteId(c, x, buf ), buf, len);
}

/* FUNC(zx_EASY_ENC_WO_hrxml_WorkSiteId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_WO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_WO_hrxml_WorkSiteId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_WO_hrxml_WorkSiteId(c, x, buf ), buf, len);
}




/* EOF -- c/zx-hrxml-enc.c */
