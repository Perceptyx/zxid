/* c/zx-hrxml-enc.c - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** enc-templ.c  -  XML encoder template, used in code generation
 ** Copyright (c) 2010 Sampo Kellomaki (sampo@iki.fi), All Rights Reserved.
 ** Copyright (c) 2006-2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: enc-templ.c,v 1.27 2007-10-05 22:24:28 sampo Exp $
 **
 ** 30.5.2006, created, Sampo Kellomaki (sampo@iki.fi)
 ** 6.8.2006,  factored data structure walking to aux-templ.c --Sampo
 ** 8.8.2006,  reworked namespace handling --Sampo
 ** 26.8.2006, some CSE --Sampo
 ** 23.9.2006, added WO logic --Sampo
 ** 30.9.2007, improvements to WO encoding --Sampo
 ** 8.2.2010,  better handling of schema order encoding of unknown namespace prefixes --Sampo
 ** 27.10.2010, re-engineered namespace handling --Sampo
 **
 ** N.B: wo=wire order (needed for exc-c14n), so=schema order
 ** N.B2: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/

#include <memory.h>
#include "errmac.h"
#include "zx.h"
#include "c/zx-const.h"
#include "c/zx-data.h"
#include "c/zx-hrxml-data.h"
#include "c/zx-ns.h"



#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AccountingCode
#define EL_STRUCT zx_hrxml_AccountingCode_s
#define EL_NS     hrxml
#define EL_TAG    AccountingCode

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AccountingCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AccountingCode")-1 + 1 + sizeof("</hrxml:AccountingCode>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AccountingCode", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AccountingCode) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AccountingCode");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AccountingCode>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AccountingCode", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AccountingCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AccountingCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AccountingCode(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Achievement
#define EL_STRUCT zx_hrxml_Achievement_s
#define EL_NS     hrxml
#define EL_TAG    Achievement

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Achievement) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Achievement")-1 + 1 + sizeof("</hrxml:Achievement>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Date; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Date")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->IssuingAuthority->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Achievement", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Achievement) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Achievement");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Date; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Date", sizeof("hrxml:Date")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);
  for (se = &x->IssuingAuthority->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Achievement>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Achievement", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Achievement) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Achievement(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Achievement(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Achievements
#define EL_STRUCT zx_hrxml_Achievements_s
#define EL_NS     hrxml
#define EL_TAG    Achievements

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Achievements) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Achievements")-1 + 1 + sizeof("</hrxml:Achievements>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Achievement->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Achievement(c, (struct zx_hrxml_Achievement_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Achievements", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Achievements) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Achievements");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Achievement->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Achievement(c, (struct zx_hrxml_Achievement_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Achievements>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Achievements", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Achievements) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Achievements(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Achievements(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AffirmativeActionPlanJobGroupId
#define EL_STRUCT zx_hrxml_AffirmativeActionPlanJobGroupId_s
#define EL_NS     hrxml
#define EL_TAG    AffirmativeActionPlanJobGroupId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AffirmativeActionPlanJobGroupId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AffirmativeActionPlanJobGroupId")-1 + 1 + sizeof("</hrxml:AffirmativeActionPlanJobGroupId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AffirmativeActionPlanJobGroupId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AffirmativeActionPlanJobGroupId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AffirmativeActionPlanJobGroupId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AffirmativeActionPlanJobGroupId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AffirmativeActionPlanJobGroupId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AffirmativeActionPlanJobGroupId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AffirmativeActionPlanJobGroupId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AffirmativeActionPlanJobGroupId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Affix
#define EL_STRUCT zx_hrxml_Affix_s
#define EL_NS     hrxml
#define EL_TAG    Affix

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Affix) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Affix")-1 + 1 + sizeof("</hrxml:Affix>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Affix", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Affix) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Affix");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Affix>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Affix", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Affix) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Affix(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Affix(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AlternateScript
#define EL_STRUCT zx_hrxml_AlternateScript_s
#define EL_NS     hrxml
#define EL_TAG    AlternateScript

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AlternateScript) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AlternateScript")-1 + 1 + sizeof("</hrxml:AlternateScript>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->script, sizeof("script")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->FamilyName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)se);
  for (se = &x->Affix->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AlternateScript", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AlternateScript) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AlternateScript");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->script, " script=\"", sizeof(" script=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedName", sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:LegalName", sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:GivenName", sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PreferredGivenName", sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MiddleName", sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->FamilyName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)se, p);
  for (se = &x->Affix->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AlternateScript>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AlternateScript", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AlternateScript) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AlternateScript(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AlternateScript(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Area
#define EL_STRUCT zx_hrxml_Area_s
#define EL_NS     hrxml
#define EL_TAG    Area

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Area) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Area")-1 + 1 + sizeof("</hrxml:Area>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Value")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Area->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Area(c, (struct zx_hrxml_Area_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Area", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Area) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Area");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Value", sizeof("hrxml:Value")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Area->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Area(c, (struct zx_hrxml_Area_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Area>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Area", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Area) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Area(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Area(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Article
#define EL_STRUCT zx_hrxml_Article_s
#define EL_NS     hrxml
#define EL_TAG    Article

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Article) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Article")-1 + 1 + sizeof("</hrxml:Article>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PublicationDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Copyright->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->JournalOrSerialName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:JournalOrSerialName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Volume; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Volume")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Issue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Issue")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PageNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PageNumber")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PublicationLanguage->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PublicationLanguage(c, (struct zx_hrxml_PublicationLanguage_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Article", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Article) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Article");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PublicationDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se, p);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Abstract", sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Copyright->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->JournalOrSerialName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:JournalOrSerialName", sizeof("hrxml:JournalOrSerialName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISSN", sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Volume; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Volume", sizeof("hrxml:Volume")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Issue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Issue", sizeof("hrxml:Issue")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PageNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PageNumber", sizeof("hrxml:PageNumber")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PublicationLanguage->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PublicationLanguage(c, (struct zx_hrxml_PublicationLanguage_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Article>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Article", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Article) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Article(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Article(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Association
#define EL_STRUCT zx_hrxml_Association_s
#define EL_NS     hrxml
#define EL_TAG    Association

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Association) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Association")-1 + 1 + sizeof("</hrxml:Association>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);
  for (se = x->Role; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Role")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Association", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Association) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Association");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se, p);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se, p);
  for (se = x->Role; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Role", sizeof("hrxml:Role")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Association>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Association", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Association) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Association(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Association(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Associations
#define EL_STRUCT zx_hrxml_Associations_s
#define EL_NS     hrxml
#define EL_TAG    Associations

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Associations) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Associations")-1 + 1 + sizeof("</hrxml:Associations>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Association->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Association(c, (struct zx_hrxml_Association_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Associations", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Associations) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Associations");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Association->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Association(c, (struct zx_hrxml_Association_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Associations>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Associations", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Associations) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Associations(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Associations(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AttachmentReference
#define EL_STRUCT zx_hrxml_AttachmentReference_s
#define EL_NS     hrxml
#define EL_TAG    AttachmentReference

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AttachmentReference) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AttachmentReference")-1 + 1 + sizeof("</hrxml:AttachmentReference>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->context, sizeof("context")-1, &pop_seen);
  len += zx_attr_so_len(c, x->mimeType, sizeof("mimeType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AttachmentReference", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AttachmentReference) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AttachmentReference");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->context, " context=\"", sizeof(" context=\"")-1);
  p = zx_attr_so_enc(p, x->mimeType, " mimeType=\"", sizeof(" mimeType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AttachmentReference>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AttachmentReference", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AttachmentReference) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AttachmentReference(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AttachmentReference(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AvailabilityDates
#define EL_STRUCT zx_hrxml_AvailabilityDates_s
#define EL_NS     hrxml
#define EL_TAG    AvailabilityDates

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AvailabilityDates) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AvailabilityDates")-1 + 1 + sizeof("</hrxml:AvailabilityDates>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityDates", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AvailabilityDates) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AvailabilityDates");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se, p);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AvailabilityDates>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityDates", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AvailabilityDates) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AvailabilityDates(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AvailabilityDates(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AvailabilityInfo
#define EL_STRUCT zx_hrxml_AvailabilityInfo_s
#define EL_NS     hrxml
#define EL_TAG    AvailabilityInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_AvailabilityInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:AvailabilityInfo")-1 + 1 + sizeof("</hrxml:AvailabilityInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->AvailabilityDates->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_AvailabilityDates(c, (struct zx_hrxml_AvailabilityDates_s*)se);
  for (se = &x->TermOfNotice->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_TermOfNotice(c, (struct zx_hrxml_TermOfNotice_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_AvailabilityInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:AvailabilityInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->AvailabilityDates->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_AvailabilityDates(c, (struct zx_hrxml_AvailabilityDates_s*)se, p);
  for (se = &x->TermOfNotice->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_TermOfNotice(c, (struct zx_hrxml_TermOfNotice_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:AvailabilityInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:AvailabilityInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_AvailabilityInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_AvailabilityInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_AvailabilityInfo(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BKZClassification
#define EL_STRUCT zx_hrxml_BKZClassification_s
#define EL_NS     hrxml
#define EL_TAG    BKZClassification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_BKZClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:BKZClassification")-1 + 1 + sizeof("</hrxml:BKZClassification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->BKZId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_BKZId(c, (struct zx_hrxml_BKZId_s*)se);
  for (se = x->BKZName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:BKZName")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BKZClassification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_BKZClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:BKZClassification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->BKZId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_BKZId(c, (struct zx_hrxml_BKZId_s*)se, p);
  for (se = x->BKZName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:BKZName", sizeof("hrxml:BKZName")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:BKZClassification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BKZClassification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_BKZClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_BKZClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_BKZClassification(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BKZId
#define EL_STRUCT zx_hrxml_BKZId_s
#define EL_NS     hrxml
#define EL_TAG    BKZId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_BKZId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:BKZId")-1 + 1 + sizeof("</hrxml:BKZId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BKZId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_BKZId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:BKZId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:BKZId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BKZId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_BKZId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_BKZId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_BKZId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BasePay
#define EL_STRUCT zx_hrxml_BasePay_s
#define EL_NS     hrxml
#define EL_TAG    BasePay

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_BasePay) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:BasePay")-1 + 1 + sizeof("</hrxml:BasePay>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->baseInterval, sizeof("baseInterval")-1, &pop_seen);
  len += zx_attr_so_len(c, x->currencyCode, sizeof("currencyCode")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->BasePayAmountMin; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:BasePayAmountMin")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->BasePayAmountMax; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:BasePayAmountMax")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BasePay", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_BasePay) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:BasePay");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->baseInterval, " baseInterval=\"", sizeof(" baseInterval=\"")-1);
  p = zx_attr_so_enc(p, x->currencyCode, " currencyCode=\"", sizeof(" currencyCode=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->BasePayAmountMin; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:BasePayAmountMin", sizeof("hrxml:BasePayAmountMin")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->BasePayAmountMax; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:BasePayAmountMax", sizeof("hrxml:BasePayAmountMax")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:BasePay>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BasePay", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_BasePay) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_BasePay(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_BasePay(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Benefits
#define EL_STRUCT zx_hrxml_Benefits_s
#define EL_NS     hrxml
#define EL_TAG    Benefits

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Benefits) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Benefits")-1 + 1 + sizeof("</hrxml:Benefits>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Insurance->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Insurance(c, (struct zx_hrxml_Insurance_s*)se);
  for (se = x->RetirementOrSavingsPlan; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:RetirementOrSavingsPlan")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->CompanyVehicle->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_CompanyVehicle(c, (struct zx_hrxml_CompanyVehicle_s*)se);
  for (se = &x->RelocationAssistance->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RelocationAssistance(c, (struct zx_hrxml_RelocationAssistance_s*)se);
  for (se = x->VisaSponsorship; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:VisaSponsorship")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->TimeOffAllowance->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_TimeOffAllowance(c, (struct zx_hrxml_TimeOffAllowance_s*)se);
  for (se = &x->ExpatriateBenefits->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ExpatriateBenefits(c, (struct zx_hrxml_ExpatriateBenefits_s*)se);
  for (se = &x->OtherBenefits->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OtherBenefits(c, (struct zx_hrxml_OtherBenefits_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Benefits", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Benefits) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Benefits");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Insurance->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Insurance(c, (struct zx_hrxml_Insurance_s*)se, p);
  for (se = x->RetirementOrSavingsPlan; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:RetirementOrSavingsPlan", sizeof("hrxml:RetirementOrSavingsPlan")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->CompanyVehicle->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_CompanyVehicle(c, (struct zx_hrxml_CompanyVehicle_s*)se, p);
  for (se = &x->RelocationAssistance->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RelocationAssistance(c, (struct zx_hrxml_RelocationAssistance_s*)se, p);
  for (se = x->VisaSponsorship; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:VisaSponsorship", sizeof("hrxml:VisaSponsorship")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->TimeOffAllowance->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_TimeOffAllowance(c, (struct zx_hrxml_TimeOffAllowance_s*)se, p);
  for (se = &x->ExpatriateBenefits->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ExpatriateBenefits(c, (struct zx_hrxml_ExpatriateBenefits_s*)se, p);
  for (se = &x->OtherBenefits->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OtherBenefits(c, (struct zx_hrxml_OtherBenefits_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Benefits>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Benefits", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Benefits) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Benefits(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Benefits(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BiologicalDescriptors
#define EL_STRUCT zx_hrxml_BiologicalDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    BiologicalDescriptors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_BiologicalDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:BiologicalDescriptors")-1 + 1 + sizeof("</hrxml:BiologicalDescriptors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->DateOfBirth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DateOfBirth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDayOfBirth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDayOfBirth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Age; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Age")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->GenderCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:GenderCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->EyeColor; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EyeColor")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->HairColor; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:HairColor")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Height->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Height(c, (struct zx_hrxml_Height_s*)se);
  for (se = &x->Weight->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)se);
  for (se = x->IdentifyingMarks; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:IdentifyingMarks")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DisabilityInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DisabilityInfo(c, (struct zx_hrxml_DisabilityInfo_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:BiologicalDescriptors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_BiologicalDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:BiologicalDescriptors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->DateOfBirth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DateOfBirth", sizeof("hrxml:DateOfBirth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDayOfBirth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDayOfBirth", sizeof("hrxml:MonthDayOfBirth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Age; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Age", sizeof("hrxml:Age")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->GenderCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:GenderCode", sizeof("hrxml:GenderCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->EyeColor; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EyeColor", sizeof("hrxml:EyeColor")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->HairColor; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:HairColor", sizeof("hrxml:HairColor")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Height->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Height(c, (struct zx_hrxml_Height_s*)se, p);
  for (se = &x->Weight->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)se, p);
  for (se = x->IdentifyingMarks; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:IdentifyingMarks", sizeof("hrxml:IdentifyingMarks")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DisabilityInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DisabilityInfo(c, (struct zx_hrxml_DisabilityInfo_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:BiologicalDescriptors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:BiologicalDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_BiologicalDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_BiologicalDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_BiologicalDescriptors(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Book
#define EL_STRUCT zx_hrxml_Book_s
#define EL_NS     hrxml
#define EL_TAG    Book

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Book) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Book")-1 + 1 + sizeof("</hrxml:Book>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PublicationDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Copyright->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Edition; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Edition")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Chapter; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Chapter")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISBN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISBN")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->NumberOfPages; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:NumberOfPages")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PublisherName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PublisherName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PublisherLocation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PublisherLocation")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Book", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Book) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Book");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PublicationDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se, p);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Abstract", sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Copyright->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Edition; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Edition", sizeof("hrxml:Edition")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Chapter; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Chapter", sizeof("hrxml:Chapter")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISSN", sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISBN; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISBN", sizeof("hrxml:ISBN")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->NumberOfPages; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:NumberOfPages", sizeof("hrxml:NumberOfPages")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PublisherName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PublisherName", sizeof("hrxml:PublisherName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PublisherLocation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PublisherLocation", sizeof("hrxml:PublisherLocation")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Book>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Book", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Book) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Book(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Book(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Candidate
#define EL_STRUCT zx_hrxml_Candidate_s
#define EL_NS     hrxml
#define EL_TAG    Candidate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Candidate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Candidate")-1 + 1 + sizeof("</hrxml:Candidate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->CandidateRecordInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_CandidateRecordInfo(c, (struct zx_hrxml_CandidateRecordInfo_s*)se);
  for (se = &x->RelatedPositionPostings->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RelatedPositionPostings(c, (struct zx_hrxml_RelatedPositionPostings_s*)se);
  for (se = &x->CandidateSupplier->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_CandidateSupplier(c, (struct zx_hrxml_CandidateSupplier_s*)se);
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->CandidateProfile->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_CandidateProfile(c, (struct zx_hrxml_CandidateProfile_s*)se);
  for (se = &x->Resume->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Resume(c, (struct zx_hrxml_Resume_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Candidate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Candidate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Candidate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->CandidateRecordInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_CandidateRecordInfo(c, (struct zx_hrxml_CandidateRecordInfo_s*)se, p);
  for (se = &x->RelatedPositionPostings->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RelatedPositionPostings(c, (struct zx_hrxml_RelatedPositionPostings_s*)se, p);
  for (se = &x->CandidateSupplier->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_CandidateSupplier(c, (struct zx_hrxml_CandidateSupplier_s*)se, p);
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DistributionGuidelines", sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->CandidateProfile->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_CandidateProfile(c, (struct zx_hrxml_CandidateProfile_s*)se, p);
  for (se = &x->Resume->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Resume(c, (struct zx_hrxml_Resume_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Candidate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Candidate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Candidate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Candidate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Candidate(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CandidateProfile
#define EL_STRUCT zx_hrxml_CandidateProfile_s
#define EL_NS     hrxml
#define EL_TAG    CandidateProfile

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CandidateProfile) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CandidateProfile")-1 + 1 + sizeof("</hrxml:CandidateProfile>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->ProfileId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ProfileId(c, (struct zx_hrxml_ProfileId_s*)se);
  for (se = x->ProfileName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ProfileName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->AvailabilityInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_AvailabilityInfo(c, (struct zx_hrxml_AvailabilityInfo_s*)se);
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PersonalData->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonalData(c, (struct zx_hrxml_PersonalData_s*)se);
  for (se = &x->PreferredPosition->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PreferredPosition(c, (struct zx_hrxml_PreferredPosition_s*)se);
  for (se = &x->EmploymentHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EmploymentHistory(c, (struct zx_hrxml_EmploymentHistory_s*)se);
  for (se = &x->EducationHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EducationHistory(c, (struct zx_hrxml_EducationHistory_s*)se);
  for (se = &x->MilitaryHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_MilitaryHistory(c, (struct zx_hrxml_MilitaryHistory_s*)se);
  for (se = &x->Associations->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Associations(c, (struct zx_hrxml_Associations_s*)se);
  for (se = &x->SupportingMaterials->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CandidateProfile", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CandidateProfile) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CandidateProfile");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->ProfileId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ProfileId(c, (struct zx_hrxml_ProfileId_s*)se, p);
  for (se = x->ProfileName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ProfileName", sizeof("hrxml:ProfileName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->AvailabilityInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_AvailabilityInfo(c, (struct zx_hrxml_AvailabilityInfo_s*)se, p);
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DistributionGuidelines", sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PersonalData->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonalData(c, (struct zx_hrxml_PersonalData_s*)se, p);
  for (se = &x->PreferredPosition->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PreferredPosition(c, (struct zx_hrxml_PreferredPosition_s*)se, p);
  for (se = &x->EmploymentHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EmploymentHistory(c, (struct zx_hrxml_EmploymentHistory_s*)se, p);
  for (se = &x->EducationHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EducationHistory(c, (struct zx_hrxml_EducationHistory_s*)se, p);
  for (se = &x->MilitaryHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_MilitaryHistory(c, (struct zx_hrxml_MilitaryHistory_s*)se, p);
  for (se = &x->Associations->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Associations(c, (struct zx_hrxml_Associations_s*)se, p);
  for (se = &x->SupportingMaterials->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CandidateProfile>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CandidateProfile", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CandidateProfile) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CandidateProfile(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CandidateProfile(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CandidateRecordInfo
#define EL_STRUCT zx_hrxml_CandidateRecordInfo_s
#define EL_NS     hrxml
#define EL_TAG    CandidateRecordInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CandidateRecordInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CandidateRecordInfo")-1 + 1 + sizeof("</hrxml:CandidateRecordInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->Status->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Status(c, (struct zx_hrxml_Status_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CandidateRecordInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CandidateRecordInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CandidateRecordInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = &x->Status->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Status(c, (struct zx_hrxml_Status_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CandidateRecordInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CandidateRecordInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CandidateRecordInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CandidateRecordInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CandidateRecordInfo(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CandidateSupplier
#define EL_STRUCT zx_hrxml_CandidateSupplier_s
#define EL_NS     hrxml
#define EL_TAG    CandidateSupplier

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CandidateSupplier) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CandidateSupplier")-1 + 1 + sizeof("</hrxml:CandidateSupplier>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->relationship, sizeof("relationship")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->SupplierId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SupplierId(c, (struct zx_hrxml_SupplierId_s*)se);
  for (se = x->EntityName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EntityName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ContactName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactName(c, (struct zx_hrxml_ContactName_s*)se);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);
  for (se = &x->SourceType->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SourceType(c, (struct zx_hrxml_SourceType_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CandidateSupplier", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CandidateSupplier) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CandidateSupplier");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->relationship, " relationship=\"", sizeof(" relationship=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->SupplierId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SupplierId(c, (struct zx_hrxml_SupplierId_s*)se, p);
  for (se = x->EntityName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EntityName", sizeof("hrxml:EntityName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ContactName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactName(c, (struct zx_hrxml_ContactName_s*)se, p);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se, p);
  for (se = &x->SourceType->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SourceType(c, (struct zx_hrxml_SourceType_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CandidateSupplier>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CandidateSupplier", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CandidateSupplier) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CandidateSupplier(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CandidateSupplier(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ChildrenInfo
#define EL_STRUCT zx_hrxml_ChildrenInfo_s
#define EL_NS     hrxml
#define EL_TAG    ChildrenInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ChildrenInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ChildrenInfo")-1 + 1 + sizeof("</hrxml:ChildrenInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->NumberOfChildren; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:NumberOfChildren")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ChildrenInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ChildrenInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ChildrenInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->NumberOfChildren; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:NumberOfChildren", sizeof("hrxml:NumberOfChildren")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ChildrenInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ChildrenInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ChildrenInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ChildrenInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ChildrenInfo(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ClassRank
#define EL_STRUCT zx_hrxml_ClassRank_s
#define EL_NS     hrxml
#define EL_TAG    ClassRank

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ClassRank) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ClassRank")-1 + 1 + sizeof("</hrxml:ClassRank>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->numberOfStudents, sizeof("numberOfStudents")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ClassRank", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ClassRank) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ClassRank");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->numberOfStudents, " numberOfStudents=\"", sizeof(" numberOfStudents=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ClassRank>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ClassRank", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ClassRank) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ClassRank(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ClassRank(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Commute
#define EL_STRUCT zx_hrxml_Commute_s
#define EL_NS     hrxml
#define EL_TAG    Commute

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Commute) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Commute")-1 + 1 + sizeof("</hrxml:Commute>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->TimeMax->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_TimeMax(c, (struct zx_hrxml_TimeMax_s*)se);
  for (se = &x->DistanceMax->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DistanceMax(c, (struct zx_hrxml_DistanceMax_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Commute", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Commute) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Commute");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->TimeMax->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_TimeMax(c, (struct zx_hrxml_TimeMax_s*)se, p);
  for (se = &x->DistanceMax->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DistanceMax(c, (struct zx_hrxml_DistanceMax_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Commute>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Commute", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Commute) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Commute(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Commute(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Company
#define EL_STRUCT zx_hrxml_Company_s
#define EL_NS     hrxml
#define EL_TAG    Company

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Company) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Company")-1 + 1 + sizeof("</hrxml:Company>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Company", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Company) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Company");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Company>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Company", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Company) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Company(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Company(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompanyVehicle
#define EL_STRUCT zx_hrxml_CompanyVehicle_s
#define EL_NS     hrxml
#define EL_TAG    CompanyVehicle

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CompanyVehicle) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CompanyVehicle")-1 + 1 + sizeof("</hrxml:CompanyVehicle>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->companyOffered, sizeof("companyOffered")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompanyVehicle", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CompanyVehicle) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CompanyVehicle");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->companyOffered, " companyOffered=\"", sizeof(" companyOffered=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CompanyVehicle>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompanyVehicle", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CompanyVehicle) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CompanyVehicle(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CompanyVehicle(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Compensation
#define EL_STRUCT zx_hrxml_Compensation_s
#define EL_NS     hrxml
#define EL_TAG    Compensation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Compensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Compensation")-1 + 1 + sizeof("</hrxml:Compensation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->StartingCompensation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StartingCompensation(c, (struct zx_hrxml_StartingCompensation_s*)se);
  for (se = &x->EndingCompensation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EndingCompensation(c, (struct zx_hrxml_EndingCompensation_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OtherCompensation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OtherCompensation(c, (struct zx_hrxml_OtherCompensation_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Compensation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Compensation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Compensation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->StartingCompensation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StartingCompensation(c, (struct zx_hrxml_StartingCompensation_s*)se, p);
  for (se = &x->EndingCompensation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EndingCompensation(c, (struct zx_hrxml_EndingCompensation_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OtherCompensation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OtherCompensation(c, (struct zx_hrxml_OtherCompensation_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Compensation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Compensation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Compensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Compensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Compensation(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Competency
#define EL_STRUCT zx_hrxml_Competency_s
#define EL_NS     hrxml
#define EL_TAG    Competency

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Competency) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Competency")-1 + 1 + sizeof("</hrxml:Competency>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->name, sizeof("name")-1, &pop_seen);
  len += zx_attr_so_len(c, x->required, sizeof("required")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->CompetencyId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_CompetencyId(c, (struct zx_hrxml_CompetencyId_s*)se);
  for (se = &x->TaxonomyId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_TaxonomyId(c, (struct zx_hrxml_TaxonomyId_s*)se);
  for (se = &x->CompetencyEvidence->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_CompetencyEvidence(c, (struct zx_hrxml_CompetencyEvidence_s*)se);
  for (se = &x->CompetencyWeight->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_CompetencyWeight(c, (struct zx_hrxml_CompetencyWeight_s*)se);
  for (se = &x->Competency->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Competency", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Competency) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Competency");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->name, " name=\"", sizeof(" name=\"")-1);
  p = zx_attr_so_enc(p, x->required, " required=\"", sizeof(" required=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->CompetencyId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_CompetencyId(c, (struct zx_hrxml_CompetencyId_s*)se, p);
  for (se = &x->TaxonomyId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_TaxonomyId(c, (struct zx_hrxml_TaxonomyId_s*)se, p);
  for (se = &x->CompetencyEvidence->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_CompetencyEvidence(c, (struct zx_hrxml_CompetencyEvidence_s*)se, p);
  for (se = &x->CompetencyWeight->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_CompetencyWeight(c, (struct zx_hrxml_CompetencyWeight_s*)se, p);
  for (se = &x->Competency->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Competency>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Competency", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Competency) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Competency(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Competency(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompetencyEvidence
#define EL_STRUCT zx_hrxml_CompetencyEvidence_s
#define EL_NS     hrxml
#define EL_TAG    CompetencyEvidence

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CompetencyEvidence) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CompetencyEvidence")-1 + 1 + sizeof("</hrxml:CompetencyEvidence>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateOfIncident, sizeof("dateOfIncident")-1, &pop_seen);
  len += zx_attr_so_len(c, x->expirationDate, sizeof("expirationDate")-1, &pop_seen);
  len += zx_attr_so_len(c, x->lastUsed, sizeof("lastUsed")-1, &pop_seen);
  len += zx_attr_so_len(c, x->name, sizeof("name")-1, &pop_seen);
  len += zx_attr_so_len(c, x->required, sizeof("required")-1, &pop_seen);
  len += zx_attr_so_len(c, x->typeDescription, sizeof("typeDescription")-1, &pop_seen);
  len += zx_attr_so_len(c, x->typeId, sizeof("typeId")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->EvidenceId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EvidenceId(c, (struct zx_hrxml_EvidenceId_s*)se);
  for (se = &x->NumericValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se);
  for (se = &x->StringValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se);
  for (se = x->SupportingInformation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SupportingInformation")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompetencyEvidence", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CompetencyEvidence) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CompetencyEvidence");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateOfIncident, " dateOfIncident=\"", sizeof(" dateOfIncident=\"")-1);
  p = zx_attr_so_enc(p, x->expirationDate, " expirationDate=\"", sizeof(" expirationDate=\"")-1);
  p = zx_attr_so_enc(p, x->lastUsed, " lastUsed=\"", sizeof(" lastUsed=\"")-1);
  p = zx_attr_so_enc(p, x->name, " name=\"", sizeof(" name=\"")-1);
  p = zx_attr_so_enc(p, x->required, " required=\"", sizeof(" required=\"")-1);
  p = zx_attr_so_enc(p, x->typeDescription, " typeDescription=\"", sizeof(" typeDescription=\"")-1);
  p = zx_attr_so_enc(p, x->typeId, " typeId=\"", sizeof(" typeId=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->EvidenceId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EvidenceId(c, (struct zx_hrxml_EvidenceId_s*)se, p);
  for (se = &x->NumericValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se, p);
  for (se = &x->StringValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se, p);
  for (se = x->SupportingInformation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SupportingInformation", sizeof("hrxml:SupportingInformation")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CompetencyEvidence>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompetencyEvidence", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CompetencyEvidence) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CompetencyEvidence(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CompetencyEvidence(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompetencyId
#define EL_STRUCT zx_hrxml_CompetencyId_s
#define EL_NS     hrxml
#define EL_TAG    CompetencyId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CompetencyId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CompetencyId")-1 + 1 + sizeof("</hrxml:CompetencyId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompetencyId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CompetencyId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CompetencyId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CompetencyId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompetencyId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CompetencyId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CompetencyId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CompetencyId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompetencyWeight
#define EL_STRUCT zx_hrxml_CompetencyWeight_s
#define EL_NS     hrxml
#define EL_TAG    CompetencyWeight

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CompetencyWeight) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CompetencyWeight")-1 + 1 + sizeof("</hrxml:CompetencyWeight>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->NumericValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se);
  for (se = &x->StringValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se);
  for (se = x->SupportingInformation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SupportingInformation")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CompetencyWeight", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CompetencyWeight) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CompetencyWeight");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->NumericValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se, p);
  for (se = &x->StringValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se, p);
  for (se = x->SupportingInformation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SupportingInformation", sizeof("hrxml:SupportingInformation")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CompetencyWeight>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CompetencyWeight", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CompetencyWeight) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CompetencyWeight(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CompetencyWeight(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ConferenceDate
#define EL_STRUCT zx_hrxml_ConferenceDate_s
#define EL_NS     hrxml
#define EL_TAG    ConferenceDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ConferenceDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ConferenceDate")-1 + 1 + sizeof("</hrxml:ConferenceDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ConferenceDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ConferenceDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ConferenceDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ConferenceDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ConferenceDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ConferenceDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ConferenceDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ConferenceDate(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ConferencePaper
#define EL_STRUCT zx_hrxml_ConferencePaper_s
#define EL_NS     hrxml
#define EL_TAG    ConferencePaper

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ConferencePaper) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ConferencePaper")-1 + 1 + sizeof("</hrxml:ConferencePaper>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PublicationDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Copyright->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->EventName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EventName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ConferenceDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ConferenceDate(c, (struct zx_hrxml_ConferenceDate_s*)se);
  for (se = x->ConferenceLocation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ConferenceLocation")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ConferencePaper", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ConferencePaper) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ConferencePaper");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PublicationDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se, p);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Abstract", sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Copyright->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->EventName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EventName", sizeof("hrxml:EventName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ConferenceDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ConferenceDate(c, (struct zx_hrxml_ConferenceDate_s*)se, p);
  for (se = x->ConferenceLocation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ConferenceLocation", sizeof("hrxml:ConferenceLocation")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ConferencePaper>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ConferencePaper", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ConferencePaper) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ConferencePaper(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ConferencePaper(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Considerations
#define EL_STRUCT zx_hrxml_Considerations_s
#define EL_NS     hrxml
#define EL_TAG    Considerations

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Considerations) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Considerations")-1 + 1 + sizeof("</hrxml:Considerations>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->General; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:General")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Physical; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Physical")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->SafetyEquipment->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SafetyEquipment(c, (struct zx_hrxml_SafetyEquipment_s*)se);
  for (se = &x->DressCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Considerations", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Considerations) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Considerations");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->General; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:General", sizeof("hrxml:General")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Physical; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Physical", sizeof("hrxml:Physical")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->SafetyEquipment->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SafetyEquipment(c, (struct zx_hrxml_SafetyEquipment_s*)se, p);
  for (se = &x->DressCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Considerations>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Considerations", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Considerations) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Considerations(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Considerations(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactId
#define EL_STRUCT zx_hrxml_ContactId_s
#define EL_NS     hrxml
#define EL_TAG    ContactId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ContactId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ContactId")-1 + 1 + sizeof("</hrxml:ContactId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ContactId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ContactId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ContactId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ContactId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ContactId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ContactId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactInfo
#define EL_STRUCT zx_hrxml_ContactInfo_s
#define EL_NS     hrxml
#define EL_TAG    ContactInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ContactInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ContactInfo")-1 + 1 + sizeof("</hrxml:ContactInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ContactInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ContactInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se, p);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ContactInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ContactInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ContactInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ContactInfo(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactMethod
#define EL_STRUCT zx_hrxml_ContactMethod_s
#define EL_NS     hrxml
#define EL_TAG    ContactMethod

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ContactMethod) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ContactMethod")-1 + 1 + sizeof("</hrxml:ContactMethod>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Use; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Use")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Location; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Location")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->WhenAvailable; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:WhenAvailable")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Telephone->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Telephone(c, (struct zx_hrxml_Telephone_s*)se);
  for (se = &x->Mobile->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Mobile(c, (struct zx_hrxml_Mobile_s*)se);
  for (se = &x->Fax->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Fax(c, (struct zx_hrxml_Fax_s*)se);
  for (se = &x->Pager->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Pager(c, (struct zx_hrxml_Pager_s*)se);
  for (se = &x->TTYTDD->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_TTYTDD(c, (struct zx_hrxml_TTYTDD_s*)se);
  for (se = x->InternetEmailAddress; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:InternetEmailAddress")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->InternetWebAddress; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:InternetWebAddress")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PostalAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactMethod", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ContactMethod) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ContactMethod");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Use; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Use", sizeof("hrxml:Use")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Location; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Location", sizeof("hrxml:Location")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->WhenAvailable; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:WhenAvailable", sizeof("hrxml:WhenAvailable")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Telephone->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Telephone(c, (struct zx_hrxml_Telephone_s*)se, p);
  for (se = &x->Mobile->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Mobile(c, (struct zx_hrxml_Mobile_s*)se, p);
  for (se = &x->Fax->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Fax(c, (struct zx_hrxml_Fax_s*)se, p);
  for (se = &x->Pager->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Pager(c, (struct zx_hrxml_Pager_s*)se, p);
  for (se = &x->TTYTDD->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_TTYTDD(c, (struct zx_hrxml_TTYTDD_s*)se, p);
  for (se = x->InternetEmailAddress; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:InternetEmailAddress", sizeof("hrxml:InternetEmailAddress")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->InternetWebAddress; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:InternetWebAddress", sizeof("hrxml:InternetWebAddress")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PostalAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ContactMethod>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactMethod", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ContactMethod) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ContactMethod(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ContactMethod(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactName
#define EL_STRUCT zx_hrxml_ContactName_s
#define EL_NS     hrxml
#define EL_TAG    ContactName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ContactName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ContactName")-1 + 1 + sizeof("</hrxml:ContactName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->script, sizeof("script")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->FamilyName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)se);
  for (se = &x->Affix->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)se);
  for (se = &x->AlternateScript->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_AlternateScript(c, (struct zx_hrxml_AlternateScript_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ContactName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ContactName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ContactName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->script, " script=\"", sizeof(" script=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedName", sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:LegalName", sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:GivenName", sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PreferredGivenName", sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MiddleName", sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->FamilyName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)se, p);
  for (se = &x->Affix->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)se, p);
  for (se = &x->AlternateScript->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_AlternateScript(c, (struct zx_hrxml_AlternateScript_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ContactName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ContactName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ContactName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ContactName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ContactName(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Copyright
#define EL_STRUCT zx_hrxml_Copyright_s
#define EL_NS     hrxml
#define EL_TAG    Copyright

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Copyright) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Copyright")-1 + 1 + sizeof("</hrxml:Copyright>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->CopyrightDates->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_CopyrightDates(c, (struct zx_hrxml_CopyrightDates_s*)se);
  for (se = x->CopyrightText; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CopyrightText")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Copyright", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Copyright) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Copyright");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->CopyrightDates->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_CopyrightDates(c, (struct zx_hrxml_CopyrightDates_s*)se, p);
  for (se = x->CopyrightText; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CopyrightText", sizeof("hrxml:CopyrightText")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Copyright>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Copyright", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Copyright) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Copyright(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Copyright(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CopyrightDates
#define EL_STRUCT zx_hrxml_CopyrightDates_s
#define EL_NS     hrxml
#define EL_TAG    CopyrightDates

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_CopyrightDates) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:CopyrightDates")-1 + 1 + sizeof("</hrxml:CopyrightDates>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->OriginalDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OriginalDate(c, (struct zx_hrxml_OriginalDate_s*)se);
  for (se = &x->MostRecentDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_MostRecentDate(c, (struct zx_hrxml_MostRecentDate_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:CopyrightDates", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_CopyrightDates) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:CopyrightDates");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->OriginalDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OriginalDate(c, (struct zx_hrxml_OriginalDate_s*)se, p);
  for (se = &x->MostRecentDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_MostRecentDate(c, (struct zx_hrxml_MostRecentDate_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:CopyrightDates>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:CopyrightDates", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_CopyrightDates) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_CopyrightDates(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_CopyrightDates(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DatesOfAttendance
#define EL_STRUCT zx_hrxml_DatesOfAttendance_s
#define EL_NS     hrxml
#define EL_TAG    DatesOfAttendance

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DatesOfAttendance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DatesOfAttendance")-1 + 1 + sizeof("</hrxml:DatesOfAttendance>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->currentlyEnrolled, sizeof("currentlyEnrolled")-1, &pop_seen);
  len += zx_attr_so_len(c, x->enrollmentStatus, sizeof("enrollmentStatus")-1, &pop_seen);
  len += zx_attr_so_len(c, x->studentInGoodStanding, sizeof("studentInGoodStanding")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DatesOfAttendance", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DatesOfAttendance) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DatesOfAttendance");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->currentlyEnrolled, " currentlyEnrolled=\"", sizeof(" currentlyEnrolled=\"")-1);
  p = zx_attr_so_enc(p, x->enrollmentStatus, " enrollmentStatus=\"", sizeof(" enrollmentStatus=\"")-1);
  p = zx_attr_so_enc(p, x->studentInGoodStanding, " studentInGoodStanding=\"", sizeof(" studentInGoodStanding=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se, p);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DatesOfAttendance>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DatesOfAttendance", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DatesOfAttendance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DatesOfAttendance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DatesOfAttendance(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DatesOfService
#define EL_STRUCT zx_hrxml_DatesOfService_s
#define EL_NS     hrxml
#define EL_TAG    DatesOfService

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DatesOfService) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DatesOfService")-1 + 1 + sizeof("</hrxml:DatesOfService>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DatesOfService", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DatesOfService) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DatesOfService");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se, p);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DatesOfService>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DatesOfService", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DatesOfService) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DatesOfService(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DatesOfService(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Degree
#define EL_STRUCT zx_hrxml_Degree_s
#define EL_NS     hrxml
#define EL_TAG    Degree

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Degree) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Degree")-1 + 1 + sizeof("</hrxml:Degree>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->degreeType, sizeof("degreeType")-1, &pop_seen);
  len += zx_attr_so_len(c, x->examPassed, sizeof("examPassed")-1, &pop_seen);
  len += zx_attr_so_len(c, x->graduatingDegree, sizeof("graduatingDegree")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->DegreeName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DegreeName(c, (struct zx_hrxml_DegreeName_s*)se);
  for (se = &x->DegreeDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DegreeDate(c, (struct zx_hrxml_DegreeDate_s*)se);
  for (se = &x->OtherHonors->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OtherHonors(c, (struct zx_hrxml_OtherHonors_s*)se);
  for (se = &x->DegreeMajor->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DegreeMajor(c, (struct zx_hrxml_DegreeMajor_s*)se);
  for (se = &x->DegreeMinor->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DegreeMinor(c, (struct zx_hrxml_DegreeMinor_s*)se);
  for (se = &x->DegreeMeasure->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DegreeMeasure(c, (struct zx_hrxml_DegreeMeasure_s*)se);
  for (se = &x->DatesOfAttendance->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DatesOfAttendance(c, (struct zx_hrxml_DatesOfAttendance_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DegreeClassification->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DegreeClassification(c, (struct zx_hrxml_DegreeClassification_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Degree", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Degree) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Degree");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->degreeType, " degreeType=\"", sizeof(" degreeType=\"")-1);
  p = zx_attr_so_enc(p, x->examPassed, " examPassed=\"", sizeof(" examPassed=\"")-1);
  p = zx_attr_so_enc(p, x->graduatingDegree, " graduatingDegree=\"", sizeof(" graduatingDegree=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->DegreeName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DegreeName(c, (struct zx_hrxml_DegreeName_s*)se, p);
  for (se = &x->DegreeDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DegreeDate(c, (struct zx_hrxml_DegreeDate_s*)se, p);
  for (se = &x->OtherHonors->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OtherHonors(c, (struct zx_hrxml_OtherHonors_s*)se, p);
  for (se = &x->DegreeMajor->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DegreeMajor(c, (struct zx_hrxml_DegreeMajor_s*)se, p);
  for (se = &x->DegreeMinor->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DegreeMinor(c, (struct zx_hrxml_DegreeMinor_s*)se, p);
  for (se = &x->DegreeMeasure->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DegreeMeasure(c, (struct zx_hrxml_DegreeMeasure_s*)se, p);
  for (se = &x->DatesOfAttendance->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DatesOfAttendance(c, (struct zx_hrxml_DatesOfAttendance_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DegreeClassification->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DegreeClassification(c, (struct zx_hrxml_DegreeClassification_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Degree>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Degree", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Degree) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Degree(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Degree(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeClassification
#define EL_STRUCT zx_hrxml_DegreeClassification_s
#define EL_NS     hrxml
#define EL_TAG    DegreeClassification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeClassification")-1 + 1 + sizeof("</hrxml:DegreeClassification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeClassification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeClassification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeClassification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeClassification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeClassification(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeDate
#define EL_STRUCT zx_hrxml_DegreeDate_s
#define EL_NS     hrxml
#define EL_TAG    DegreeDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeDate")-1 + 1 + sizeof("</hrxml:DegreeDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeDate(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeMajor
#define EL_STRUCT zx_hrxml_DegreeMajor_s
#define EL_NS     hrxml
#define EL_TAG    DegreeMajor

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeMajor) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeMajor")-1 + 1 + sizeof("</hrxml:DegreeMajor>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->ProgramId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ProgramId(c, (struct zx_hrxml_ProgramId_s*)se);
  for (se = x->DegreeConcentration; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DegreeConcentration")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Option; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Option")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeMajor", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeMajor) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeMajor");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->ProgramId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ProgramId(c, (struct zx_hrxml_ProgramId_s*)se, p);
  for (se = x->DegreeConcentration; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DegreeConcentration", sizeof("hrxml:DegreeConcentration")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Option; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Option", sizeof("hrxml:Option")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeMajor>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeMajor", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeMajor) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeMajor(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeMajor(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeMeasure
#define EL_STRUCT zx_hrxml_DegreeMeasure_s
#define EL_NS     hrxml
#define EL_TAG    DegreeMeasure

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeMeasure) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeMeasure")-1 + 1 + sizeof("</hrxml:DegreeMeasure>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->measureType, sizeof("measureType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->EducationalMeasure->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EducationalMeasure(c, (struct zx_hrxml_EducationalMeasure_s*)se);
  for (se = x->AcademicCreditCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AcademicCreditCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CourseLevelCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CourseLevelCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CumulativeSummaryIndicator; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CumulativeSummaryIndicator")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AcademicCreditHoursIncluded; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AcademicCreditHoursIncluded")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AcademicCreditHoursAttempted; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AcademicCreditHoursAttempted")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AcademicCreditHoursEarned; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AcademicCreditHoursEarned")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ClassRank->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ClassRank(c, (struct zx_hrxml_ClassRank_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeMeasure", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeMeasure) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeMeasure");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->measureType, " measureType=\"", sizeof(" measureType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->EducationalMeasure->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EducationalMeasure(c, (struct zx_hrxml_EducationalMeasure_s*)se, p);
  for (se = x->AcademicCreditCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AcademicCreditCode", sizeof("hrxml:AcademicCreditCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CourseLevelCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CourseLevelCode", sizeof("hrxml:CourseLevelCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CumulativeSummaryIndicator; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CumulativeSummaryIndicator", sizeof("hrxml:CumulativeSummaryIndicator")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AcademicCreditHoursIncluded; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AcademicCreditHoursIncluded", sizeof("hrxml:AcademicCreditHoursIncluded")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AcademicCreditHoursAttempted; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AcademicCreditHoursAttempted", sizeof("hrxml:AcademicCreditHoursAttempted")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AcademicCreditHoursEarned; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AcademicCreditHoursEarned", sizeof("hrxml:AcademicCreditHoursEarned")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ClassRank->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ClassRank(c, (struct zx_hrxml_ClassRank_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeMeasure>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeMeasure", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeMeasure) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeMeasure(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeMeasure(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeMinor
#define EL_STRUCT zx_hrxml_DegreeMinor_s
#define EL_NS     hrxml
#define EL_TAG    DegreeMinor

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeMinor) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeMinor")-1 + 1 + sizeof("</hrxml:DegreeMinor>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->ProgramId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ProgramId(c, (struct zx_hrxml_ProgramId_s*)se);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeMinor", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeMinor) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeMinor");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->ProgramId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ProgramId(c, (struct zx_hrxml_ProgramId_s*)se, p);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeMinor>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeMinor", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeMinor) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeMinor(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeMinor(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeName
#define EL_STRUCT zx_hrxml_DegreeName_s
#define EL_NS     hrxml
#define EL_TAG    DegreeName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DegreeName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DegreeName")-1 + 1 + sizeof("</hrxml:DegreeName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->academicHonors, sizeof("academicHonors")-1, &pop_seen);
  len += zx_attr_so_len(c, x->honorsProgram, sizeof("honorsProgram")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DegreeName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DegreeName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DegreeName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->academicHonors, " academicHonors=\"", sizeof(" academicHonors=\"")-1);
  p = zx_attr_so_enc(p, x->honorsProgram, " honorsProgram=\"", sizeof(" honorsProgram=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DegreeName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DegreeName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DegreeName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DegreeName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DegreeName(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DeliveryAddress
#define EL_STRUCT zx_hrxml_DeliveryAddress_s
#define EL_NS     hrxml
#define EL_TAG    DeliveryAddress

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DeliveryAddress) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DeliveryAddress")-1 + 1 + sizeof("</hrxml:DeliveryAddress>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AddressLine; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AddressLine")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StreetName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StreetName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->BuildingNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:BuildingNumber")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Unit; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Unit")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PostOfficeBox; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PostOfficeBox")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DeliveryAddress", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DeliveryAddress) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DeliveryAddress");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AddressLine; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AddressLine", sizeof("hrxml:AddressLine")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StreetName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StreetName", sizeof("hrxml:StreetName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->BuildingNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:BuildingNumber", sizeof("hrxml:BuildingNumber")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Unit; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Unit", sizeof("hrxml:Unit")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PostOfficeBox; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PostOfficeBox", sizeof("hrxml:PostOfficeBox")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DeliveryAddress>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DeliveryAddress", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DeliveryAddress) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DeliveryAddress(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DeliveryAddress(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DemographicDescriptors
#define EL_STRUCT zx_hrxml_DemographicDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    DemographicDescriptors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DemographicDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DemographicDescriptors")-1 + 1 + sizeof("</hrxml:DemographicDescriptors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Race; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Race")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Ethnicity; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Ethnicity")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Nationality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Nationality")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PrimaryLanguage->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PrimaryLanguage(c, (struct zx_hrxml_PrimaryLanguage_s*)se);
  for (se = x->BirthPlace; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:BirthPlace")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Religion; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Religion")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MaritalStatus; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MaritalStatus")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ChildrenInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ChildrenInfo(c, (struct zx_hrxml_ChildrenInfo_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DemographicDescriptors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DemographicDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DemographicDescriptors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Race; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Race", sizeof("hrxml:Race")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Ethnicity; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Ethnicity", sizeof("hrxml:Ethnicity")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Nationality; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Nationality", sizeof("hrxml:Nationality")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PrimaryLanguage->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PrimaryLanguage(c, (struct zx_hrxml_PrimaryLanguage_s*)se, p);
  for (se = x->BirthPlace; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:BirthPlace", sizeof("hrxml:BirthPlace")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Religion; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Religion", sizeof("hrxml:Religion")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MaritalStatus; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MaritalStatus", sizeof("hrxml:MaritalStatus")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ChildrenInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ChildrenInfo(c, (struct zx_hrxml_ChildrenInfo_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DemographicDescriptors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DemographicDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DemographicDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DemographicDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DemographicDescriptors(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Description
#define EL_STRUCT zx_hrxml_Description_s
#define EL_NS     hrxml
#define EL_TAG    Description

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Description) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Description")-1 + 1 + sizeof("</hrxml:Description>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Description", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Description) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Description");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Description>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Description", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Description) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Description(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Description(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Details
#define EL_STRUCT zx_hrxml_Details_s
#define EL_NS     hrxml
#define EL_TAG    Details

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Details) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Details")-1 + 1 + sizeof("</hrxml:Details>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);
  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Details", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Details) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Details");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Details>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Details", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Details) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Details(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Details(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DisabilityInfo
#define EL_STRUCT zx_hrxml_DisabilityInfo_s
#define EL_NS     hrxml
#define EL_TAG    DisabilityInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DisabilityInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DisabilityInfo")-1 + 1 + sizeof("</hrxml:DisabilityInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->LevelOfDisability; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:LevelOfDisability")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Percentage; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Percentage")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Type; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Type")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AccommodationsNeeded; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AccommodationsNeeded")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DisabilityInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DisabilityInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DisabilityInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->LevelOfDisability; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:LevelOfDisability", sizeof("hrxml:LevelOfDisability")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Percentage; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Percentage", sizeof("hrxml:Percentage")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Type; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Type", sizeof("hrxml:Type")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AccommodationsNeeded; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AccommodationsNeeded", sizeof("hrxml:AccommodationsNeeded")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DisabilityInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DisabilityInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DisabilityInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DisabilityInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DisabilityInfo(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DistanceMax
#define EL_STRUCT zx_hrxml_DistanceMax_s
#define EL_NS     hrxml
#define EL_TAG    DistanceMax

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DistanceMax) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DistanceMax")-1 + 1 + sizeof("</hrxml:DistanceMax>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DistanceMax", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DistanceMax) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DistanceMax");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->unitOfMeasure, " unitOfMeasure=\"", sizeof(" unitOfMeasure=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DistanceMax>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DistanceMax", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DistanceMax) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DistanceMax(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DistanceMax(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DistributeTo
#define EL_STRUCT zx_hrxml_DistributeTo_s
#define EL_NS     hrxml
#define EL_TAG    DistributeTo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DistributeTo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DistributeTo")-1 + 1 + sizeof("</hrxml:DistributeTo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DistributeTo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DistributeTo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DistributeTo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DistributeTo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DistributeTo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DistributeTo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DistributeTo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DistributeTo(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DoingBusinessAs
#define EL_STRUCT zx_hrxml_DoingBusinessAs_s
#define EL_NS     hrxml
#define EL_TAG    DoingBusinessAs

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DoingBusinessAs) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DoingBusinessAs")-1 + 1 + sizeof("</hrxml:DoingBusinessAs>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DoingBusinessAs", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DoingBusinessAs) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DoingBusinessAs");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DoingBusinessAs>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DoingBusinessAs", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DoingBusinessAs) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DoingBusinessAs(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DoingBusinessAs(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DressCode
#define EL_STRUCT zx_hrxml_DressCode_s
#define EL_NS     hrxml
#define EL_TAG    DressCode

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DressCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DressCode")-1 + 1 + sizeof("</hrxml:DressCode>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->suppliedByOrganization, sizeof("suppliedByOrganization")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DressCode", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DressCode) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DressCode");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->suppliedByOrganization, " suppliedByOrganization=\"", sizeof(" suppliedByOrganization=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DressCode>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DressCode", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DressCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DressCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DressCode(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DunsNumber
#define EL_STRUCT zx_hrxml_DunsNumber_s
#define EL_NS     hrxml
#define EL_TAG    DunsNumber

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_DunsNumber) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:DunsNumber")-1 + 1 + sizeof("</hrxml:DunsNumber>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dunsNumberType, sizeof("dunsNumberType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:DunsNumber", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_DunsNumber) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:DunsNumber");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dunsNumberType, " dunsNumberType=\"", sizeof(" dunsNumberType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:DunsNumber>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:DunsNumber", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_DunsNumber) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_DunsNumber(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_DunsNumber(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EEOCJobCategory
#define EL_STRUCT zx_hrxml_EEOCJobCategory_s
#define EL_NS     hrxml
#define EL_TAG    EEOCJobCategory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EEOCJobCategory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EEOCJobCategory")-1 + 1 + sizeof("</hrxml:EEOCJobCategory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->StandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StandardValue")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->NonStandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:NonStandardValue")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EEOCJobCategory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EEOCJobCategory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EEOCJobCategory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->StandardValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StandardValue", sizeof("hrxml:StandardValue")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->NonStandardValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:NonStandardValue", sizeof("hrxml:NonStandardValue")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EEOCJobCategory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EEOCJobCategory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EEOCJobCategory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EEOCJobCategory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EEOCJobCategory(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EducationHistory
#define EL_STRUCT zx_hrxml_EducationHistory_s
#define EL_NS     hrxml
#define EL_TAG    EducationHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EducationHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EducationHistory")-1 + 1 + sizeof("</hrxml:EducationHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->SchoolOrInstitution->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SchoolOrInstitution(c, (struct zx_hrxml_SchoolOrInstitution_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EducationHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EducationHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EducationHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->SchoolOrInstitution->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SchoolOrInstitution(c, (struct zx_hrxml_SchoolOrInstitution_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EducationHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EducationHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EducationHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EducationHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EducationHistory(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EducationalMeasure
#define EL_STRUCT zx_hrxml_EducationalMeasure_s
#define EL_NS     hrxml
#define EL_TAG    EducationalMeasure

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EducationalMeasure) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EducationalMeasure")-1 + 1 + sizeof("</hrxml:EducationalMeasure>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->MeasureSystem; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MeasureSystem")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MeasureValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MeasureValue")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->LowestPossibleValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LowestPossibleValue(c, (struct zx_hrxml_LowestPossibleValue_s*)se);
  for (se = &x->HighestPossibleValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_HighestPossibleValue(c, (struct zx_hrxml_HighestPossibleValue_s*)se);
  for (se = x->ExcessiveValueIndicator; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ExcessiveValueIndicator")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->GoodStudentIndicator; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:GoodStudentIndicator")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EducationalMeasure", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EducationalMeasure) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EducationalMeasure");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->MeasureSystem; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MeasureSystem", sizeof("hrxml:MeasureSystem")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MeasureValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MeasureValue", sizeof("hrxml:MeasureValue")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->LowestPossibleValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LowestPossibleValue(c, (struct zx_hrxml_LowestPossibleValue_s*)se, p);
  for (se = &x->HighestPossibleValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_HighestPossibleValue(c, (struct zx_hrxml_HighestPossibleValue_s*)se, p);
  for (se = x->ExcessiveValueIndicator; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ExcessiveValueIndicator", sizeof("hrxml:ExcessiveValueIndicator")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->GoodStudentIndicator; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:GoodStudentIndicator", sizeof("hrxml:GoodStudentIndicator")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EducationalMeasure>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EducationalMeasure", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EducationalMeasure) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EducationalMeasure(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EducationalMeasure(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EffectiveDate
#define EL_STRUCT zx_hrxml_EffectiveDate_s
#define EL_NS     hrxml
#define EL_TAG    EffectiveDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EffectiveDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EffectiveDate")-1 + 1 + sizeof("</hrxml:EffectiveDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EffectiveDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EffectiveDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EffectiveDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se, p);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EffectiveDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EffectiveDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EffectiveDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EffectiveDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EffectiveDate(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EmployerContactInfo
#define EL_STRUCT zx_hrxml_EmployerContactInfo_s
#define EL_NS     hrxml
#define EL_TAG    EmployerContactInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EmployerContactInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EmployerContactInfo")-1 + 1 + sizeof("</hrxml:EmployerContactInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->contactType, sizeof("contactType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);
  for (se = &x->LocationSummary->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)se);
  for (se = &x->InternetDomainName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EmployerContactInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EmployerContactInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EmployerContactInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->contactType, " contactType=\"", sizeof(" contactType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se, p);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se, p);
  for (se = &x->LocationSummary->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)se, p);
  for (se = &x->InternetDomainName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EmployerContactInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EmployerContactInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EmployerContactInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EmployerContactInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EmployerContactInfo(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EmployerOrg
#define EL_STRUCT zx_hrxml_EmployerOrg_s
#define EL_NS     hrxml
#define EL_TAG    EmployerOrg

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EmployerOrg) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EmployerOrg")-1 + 1 + sizeof("</hrxml:EmployerOrg>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->employerOrgType, sizeof("employerOrgType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->EmployerOrgName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EmployerOrgName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->EmployerContactInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EmployerContactInfo(c, (struct zx_hrxml_EmployerContactInfo_s*)se);
  for (se = &x->PositionHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PositionHistory(c, (struct zx_hrxml_PositionHistory_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EmployerOrg", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EmployerOrg) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EmployerOrg");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->employerOrgType, " employerOrgType=\"", sizeof(" employerOrgType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->EmployerOrgName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EmployerOrgName", sizeof("hrxml:EmployerOrgName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->EmployerContactInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EmployerContactInfo(c, (struct zx_hrxml_EmployerContactInfo_s*)se, p);
  for (se = &x->PositionHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PositionHistory(c, (struct zx_hrxml_PositionHistory_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EmployerOrg>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EmployerOrg", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EmployerOrg) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EmployerOrg(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EmployerOrg(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EmploymentHistory
#define EL_STRUCT zx_hrxml_EmploymentHistory_s
#define EL_NS     hrxml
#define EL_TAG    EmploymentHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EmploymentHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EmploymentHistory")-1 + 1 + sizeof("</hrxml:EmploymentHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->EmployerOrg->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EmployerOrg(c, (struct zx_hrxml_EmployerOrg_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EmploymentHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EmploymentHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EmploymentHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->EmployerOrg->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EmployerOrg(c, (struct zx_hrxml_EmployerOrg_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EmploymentHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EmploymentHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EmploymentHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EmploymentHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EmploymentHistory(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EndDate
#define EL_STRUCT zx_hrxml_EndDate_s
#define EL_NS     hrxml
#define EL_TAG    EndDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EndDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EndDate")-1 + 1 + sizeof("</hrxml:EndDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EndDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EndDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EndDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EndDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EndDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EndDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EndDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EndDate(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EndingCompensation
#define EL_STRUCT zx_hrxml_EndingCompensation_s
#define EL_NS     hrxml
#define EL_TAG    EndingCompensation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EndingCompensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EndingCompensation")-1 + 1 + sizeof("</hrxml:EndingCompensation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->currency, sizeof("currency")-1, &pop_seen);
  len += zx_attr_so_len(c, x->intervalType, sizeof("intervalType")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EndingCompensation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EndingCompensation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EndingCompensation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->currency, " currency=\"", sizeof(" currency=\"")-1);
  p = zx_attr_so_enc(p, x->intervalType, " intervalType=\"", sizeof(" intervalType=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EndingCompensation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EndingCompensation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EndingCompensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EndingCompensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EndingCompensation(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EnvironmentId
#define EL_STRUCT zx_hrxml_EnvironmentId_s
#define EL_NS     hrxml
#define EL_TAG    EnvironmentId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EnvironmentId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EnvironmentId")-1 + 1 + sizeof("</hrxml:EnvironmentId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EnvironmentId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EnvironmentId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EnvironmentId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EnvironmentId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EnvironmentId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EnvironmentId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EnvironmentId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EnvironmentId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EvidenceId
#define EL_STRUCT zx_hrxml_EvidenceId_s
#define EL_NS     hrxml
#define EL_TAG    EvidenceId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_EvidenceId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:EvidenceId")-1 + 1 + sizeof("</hrxml:EvidenceId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:EvidenceId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_EvidenceId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:EvidenceId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->id, " id=\"", sizeof(" id=\"")-1);
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:EvidenceId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:EvidenceId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_EvidenceId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_EvidenceId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_EvidenceId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ExpatriateBenefits
#define EL_STRUCT zx_hrxml_ExpatriateBenefits_s
#define EL_NS     hrxml
#define EL_TAG    ExpatriateBenefits

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ExpatriateBenefits) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ExpatriateBenefits")-1 + 1 + sizeof("</hrxml:ExpatriateBenefits>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->ExpatriateBenefitsOffered; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ExpatriateBenefitsOffered")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ExpatriateBenefitList; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ExpatriateBenefitList")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ExpatriateBenefits", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ExpatriateBenefits) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ExpatriateBenefits");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->ExpatriateBenefitsOffered; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ExpatriateBenefitsOffered", sizeof("hrxml:ExpatriateBenefitsOffered")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ExpatriateBenefitList; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ExpatriateBenefitList", sizeof("hrxml:ExpatriateBenefitList")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ExpatriateBenefits>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ExpatriateBenefits", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ExpatriateBenefits) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ExpatriateBenefits(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ExpatriateBenefits(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_FamilyName
#define EL_STRUCT zx_hrxml_FamilyName_s
#define EL_NS     hrxml
#define EL_TAG    FamilyName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_FamilyName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:FamilyName")-1 + 1 + sizeof("</hrxml:FamilyName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->prefix, sizeof("prefix")-1, &pop_seen);
  len += zx_attr_so_len(c, x->primary, sizeof("primary")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:FamilyName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_FamilyName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:FamilyName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->prefix, " prefix=\"", sizeof(" prefix=\"")-1);
  p = zx_attr_so_enc(p, x->primary, " primary=\"", sizeof(" primary=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:FamilyName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:FamilyName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_FamilyName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_FamilyName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_FamilyName(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Fax
#define EL_STRUCT zx_hrxml_Fax_s
#define EL_NS     hrxml
#define EL_TAG    Fax

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Fax) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Fax")-1 + 1 + sizeof("</hrxml:Fax>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Fax", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Fax) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Fax");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedNumber", sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Fax>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Fax", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Fax) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Fax(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Fax(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_FirstIssuedDate
#define EL_STRUCT zx_hrxml_FirstIssuedDate_s
#define EL_NS     hrxml
#define EL_TAG    FirstIssuedDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_FirstIssuedDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:FirstIssuedDate")-1 + 1 + sizeof("</hrxml:FirstIssuedDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:FirstIssuedDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_FirstIssuedDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:FirstIssuedDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:FirstIssuedDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:FirstIssuedDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_FirstIssuedDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_FirstIssuedDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_FirstIssuedDate(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_FormattedPublicationDescription
#define EL_STRUCT zx_hrxml_FormattedPublicationDescription_s
#define EL_NS     hrxml
#define EL_TAG    FormattedPublicationDescription

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_FormattedPublicationDescription) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:FormattedPublicationDescription")-1 + 1 + sizeof("</hrxml:FormattedPublicationDescription>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:FormattedPublicationDescription", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_FormattedPublicationDescription) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:FormattedPublicationDescription");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:FormattedPublicationDescription>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:FormattedPublicationDescription", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_FormattedPublicationDescription) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_FormattedPublicationDescription(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_FormattedPublicationDescription(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Height
#define EL_STRUCT zx_hrxml_Height_s
#define EL_NS     hrxml
#define EL_TAG    Height

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Height) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Height")-1 + 1 + sizeof("</hrxml:Height>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Height", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Height) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Height");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->unitOfMeasure, " unitOfMeasure=\"", sizeof(" unitOfMeasure=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Height>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Height", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Height) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Height(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Height(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_HighestPossibleValue
#define EL_STRUCT zx_hrxml_HighestPossibleValue_s
#define EL_NS     hrxml
#define EL_TAG    HighestPossibleValue

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_HighestPossibleValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:HighestPossibleValue")-1 + 1 + sizeof("</hrxml:HighestPossibleValue>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->NumericValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se);
  for (se = &x->StringValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:HighestPossibleValue", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_HighestPossibleValue) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:HighestPossibleValue");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->NumericValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se, p);
  for (se = &x->StringValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:HighestPossibleValue>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:HighestPossibleValue", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_HighestPossibleValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_HighestPossibleValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_HighestPossibleValue(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_HorizontalAccuracy
#define EL_STRUCT zx_hrxml_HorizontalAccuracy_s
#define EL_NS     hrxml
#define EL_TAG    HorizontalAccuracy

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_HorizontalAccuracy) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:HorizontalAccuracy")-1 + 1 + sizeof("</hrxml:HorizontalAccuracy>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:HorizontalAccuracy", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_HorizontalAccuracy) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:HorizontalAccuracy");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:HorizontalAccuracy>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:HorizontalAccuracy", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_HorizontalAccuracy) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_HorizontalAccuracy(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_HorizontalAccuracy(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Id
#define EL_STRUCT zx_hrxml_Id_s
#define EL_NS     hrxml
#define EL_TAG    Id

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Id) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Id")-1 + 1 + sizeof("</hrxml:Id>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Id", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Id) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Id");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Id>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Id", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Id) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Id(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Id(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_IdValue
#define EL_STRUCT zx_hrxml_IdValue_s
#define EL_NS     hrxml
#define EL_TAG    IdValue

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_IdValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:IdValue")-1 + 1 + sizeof("</hrxml:IdValue>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->name, sizeof("name")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:IdValue", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_IdValue) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:IdValue");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->name, " name=\"", sizeof(" name=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:IdValue>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:IdValue", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_IdValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_IdValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_IdValue(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_IndustryCode
#define EL_STRUCT zx_hrxml_IndustryCode_s
#define EL_NS     hrxml
#define EL_TAG    IndustryCode

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_IndustryCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:IndustryCode")-1 + 1 + sizeof("</hrxml:IndustryCode>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->classificationName, sizeof("classificationName")-1, &pop_seen);
  len += zx_attr_so_len(c, x->primaryIndicator, sizeof("primaryIndicator")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:IndustryCode", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_IndustryCode) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:IndustryCode");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->classificationName, " classificationName=\"", sizeof(" classificationName=\"")-1);
  p = zx_attr_so_enc(p, x->primaryIndicator, " primaryIndicator=\"", sizeof(" primaryIndicator=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:IndustryCode>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:IndustryCode", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_IndustryCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_IndustryCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_IndustryCode(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Insurance
#define EL_STRUCT zx_hrxml_Insurance_s
#define EL_NS     hrxml
#define EL_TAG    Insurance

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Insurance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Insurance")-1 + 1 + sizeof("</hrxml:Insurance>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Insurance", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Insurance) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Insurance");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Insurance>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Insurance", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Insurance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Insurance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Insurance(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_InternetDomainName
#define EL_STRUCT zx_hrxml_InternetDomainName_s
#define EL_NS     hrxml
#define EL_TAG    InternetDomainName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_InternetDomainName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:InternetDomainName")-1 + 1 + sizeof("</hrxml:InternetDomainName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->primaryIndicator, sizeof("primaryIndicator")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:InternetDomainName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_InternetDomainName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:InternetDomainName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->primaryIndicator, " primaryIndicator=\"", sizeof(" primaryIndicator=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:InternetDomainName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:InternetDomainName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_InternetDomainName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_InternetDomainName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_InternetDomainName(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Inventors
#define EL_STRUCT zx_hrxml_Inventors_s
#define EL_NS     hrxml
#define EL_TAG    Inventors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Inventors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Inventors")-1 + 1 + sizeof("</hrxml:Inventors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->InventorName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:InventorName")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Inventors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Inventors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Inventors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->InventorName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:InventorName", sizeof("hrxml:InventorName")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Inventors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Inventors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Inventors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Inventors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Inventors(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_IssuingAuthority
#define EL_STRUCT zx_hrxml_IssuingAuthority_s
#define EL_NS     hrxml
#define EL_TAG    IssuingAuthority

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_IssuingAuthority) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:IssuingAuthority")-1 + 1 + sizeof("</hrxml:IssuingAuthority>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:IssuingAuthority", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_IssuingAuthority) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:IssuingAuthority");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->countryCode, " countryCode=\"", sizeof(" countryCode=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:IssuingAuthority>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:IssuingAuthority", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_IssuingAuthority) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_IssuingAuthority(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_IssuingAuthority(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_JobCategory
#define EL_STRUCT zx_hrxml_JobCategory_s
#define EL_NS     hrxml
#define EL_TAG    JobCategory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_JobCategory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:JobCategory")-1 + 1 + sizeof("</hrxml:JobCategory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->TaxonomyName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_TaxonomyName(c, (struct zx_hrxml_TaxonomyName_s*)se);
  for (se = x->CategoryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CategoryCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CategoryDescription; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CategoryDescription")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->JobCategory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:JobCategory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_JobCategory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:JobCategory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->TaxonomyName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_TaxonomyName(c, (struct zx_hrxml_TaxonomyName_s*)se, p);
  for (se = x->CategoryCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CategoryCode", sizeof("hrxml:CategoryCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CategoryDescription; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CategoryDescription", sizeof("hrxml:CategoryDescription")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->JobCategory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:JobCategory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:JobCategory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_JobCategory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_JobCategory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_JobCategory(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_JobLevelInfo
#define EL_STRUCT zx_hrxml_JobLevelInfo_s
#define EL_NS     hrxml
#define EL_TAG    JobLevelInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_JobLevelInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:JobLevelInfo")-1 + 1 + sizeof("</hrxml:JobLevelInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->JobPlan; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:JobPlan")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->JobGrade; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:JobGrade")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->JobStep; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:JobStep")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:JobLevelInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_JobLevelInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:JobLevelInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->JobPlan; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:JobPlan", sizeof("hrxml:JobPlan")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->JobGrade; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:JobGrade", sizeof("hrxml:JobGrade")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->JobStep; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:JobStep", sizeof("hrxml:JobStep")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:JobLevelInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:JobLevelInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_JobLevelInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_JobLevelInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_JobLevelInfo(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Language
#define EL_STRUCT zx_hrxml_Language_s
#define EL_NS     hrxml
#define EL_TAG    Language

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Language) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Language")-1 + 1 + sizeof("</hrxml:Language>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->LanguageCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LanguageCode(c, (struct zx_hrxml_LanguageCode_s*)se);
  for (se = x->Read; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Read")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Write; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Write")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Speak; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Speak")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Language", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Language) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Language");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->LanguageCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LanguageCode(c, (struct zx_hrxml_LanguageCode_s*)se, p);
  for (se = x->Read; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Read", sizeof("hrxml:Read")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Write; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Write", sizeof("hrxml:Write")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Speak; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Speak", sizeof("hrxml:Speak")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Language>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Language", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Language) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Language(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Language(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LanguageCode
#define EL_STRUCT zx_hrxml_LanguageCode_s
#define EL_NS     hrxml
#define EL_TAG    LanguageCode

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LanguageCode) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LanguageCode")-1 + 1 + sizeof("</hrxml:LanguageCode>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LanguageCode", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LanguageCode) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LanguageCode");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LanguageCode>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LanguageCode", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LanguageCode) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LanguageCode(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LanguageCode(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Languages
#define EL_STRUCT zx_hrxml_Languages_s
#define EL_NS     hrxml
#define EL_TAG    Languages

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Languages) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Languages")-1 + 1 + sizeof("</hrxml:Languages>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Language->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Language(c, (struct zx_hrxml_Language_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Languages", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Languages) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Languages");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Language->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Language(c, (struct zx_hrxml_Language_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Languages>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Languages", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Languages) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Languages(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Languages(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Latitude
#define EL_STRUCT zx_hrxml_Latitude_s
#define EL_NS     hrxml
#define EL_TAG    Latitude

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Latitude) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Latitude")-1 + 1 + sizeof("</hrxml:Latitude>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Latitude", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Latitude) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Latitude");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Latitude>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Latitude", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Latitude) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Latitude(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Latitude(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LegalClassification
#define EL_STRUCT zx_hrxml_LegalClassification_s
#define EL_NS     hrxml
#define EL_TAG    LegalClassification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LegalClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LegalClassification")-1 + 1 + sizeof("</hrxml:LegalClassification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);
  len += zx_attr_so_len(c, x->ownership, sizeof("ownership")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LegalClassification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LegalClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LegalClassification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->countryCode, " countryCode=\"", sizeof(" countryCode=\"")-1);
  p = zx_attr_so_enc(p, x->ownership, " ownership=\"", sizeof(" ownership=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LegalClassification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LegalClassification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LegalClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LegalClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LegalClassification(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LegalId
#define EL_STRUCT zx_hrxml_LegalId_s
#define EL_NS     hrxml
#define EL_TAG    LegalId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LegalId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LegalId")-1 + 1 + sizeof("</hrxml:LegalId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LegalId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LegalId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LegalId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LegalId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LegalId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LegalId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LegalId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LegalId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LegalIdentifiers
#define EL_STRUCT zx_hrxml_LegalIdentifiers_s
#define EL_NS     hrxml
#define EL_TAG    LegalIdentifiers

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LegalIdentifiers) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LegalIdentifiers")-1 + 1 + sizeof("</hrxml:LegalIdentifiers>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->PersonLegalId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonLegalId(c, (struct zx_hrxml_PersonLegalId_s*)se);
  for (se = &x->MilitaryStatus->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_MilitaryStatus(c, (struct zx_hrxml_MilitaryStatus_s*)se);
  for (se = &x->VisaStatus->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_VisaStatus(c, (struct zx_hrxml_VisaStatus_s*)se);
  for (se = x->Citizenship; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Citizenship")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Residency; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Residency")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LegalIdentifiers", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LegalIdentifiers) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LegalIdentifiers");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->PersonLegalId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonLegalId(c, (struct zx_hrxml_PersonLegalId_s*)se, p);
  for (se = &x->MilitaryStatus->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_MilitaryStatus(c, (struct zx_hrxml_MilitaryStatus_s*)se, p);
  for (se = &x->VisaStatus->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_VisaStatus(c, (struct zx_hrxml_VisaStatus_s*)se, p);
  for (se = x->Citizenship; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Citizenship", sizeof("hrxml:Citizenship")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Residency; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Residency", sizeof("hrxml:Residency")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LegalIdentifiers>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LegalIdentifiers", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LegalIdentifiers) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LegalIdentifiers(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LegalIdentifiers(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LicenseOrCertification
#define EL_STRUCT zx_hrxml_LicenseOrCertification_s
#define EL_NS     hrxml
#define EL_TAG    LicenseOrCertification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LicenseOrCertification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LicenseOrCertification")-1 + 1 + sizeof("</hrxml:LicenseOrCertification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->IssuingAuthority->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->EffectiveDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LicenseOrCertification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LicenseOrCertification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LicenseOrCertification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = &x->IssuingAuthority->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se, p);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);
  for (se = &x->EffectiveDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LicenseOrCertification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LicenseOrCertification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LicenseOrCertification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LicenseOrCertification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LicenseOrCertification(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LicensesAndCertifications
#define EL_STRUCT zx_hrxml_LicensesAndCertifications_s
#define EL_NS     hrxml
#define EL_TAG    LicensesAndCertifications

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LicensesAndCertifications) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LicensesAndCertifications")-1 + 1 + sizeof("</hrxml:LicensesAndCertifications>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->LicenseOrCertification->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LicenseOrCertification(c, (struct zx_hrxml_LicenseOrCertification_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LicensesAndCertifications", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LicensesAndCertifications) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LicensesAndCertifications");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->LicenseOrCertification->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LicenseOrCertification(c, (struct zx_hrxml_LicenseOrCertification_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LicensesAndCertifications>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LicensesAndCertifications", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LicensesAndCertifications) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LicensesAndCertifications(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LicensesAndCertifications(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_List
#define EL_STRUCT zx_hrxml_List_s
#define EL_NS     hrxml
#define EL_TAG    List

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_List) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:List")-1 + 1 + sizeof("</hrxml:List>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Item; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Item")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:List", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_List) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:List");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Item; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Item", sizeof("hrxml:Item")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:List>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:List", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_List) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_List(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_List(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LocalInstitutionClassification
#define EL_STRUCT zx_hrxml_LocalInstitutionClassification_s
#define EL_NS     hrxml
#define EL_TAG    LocalInstitutionClassification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LocalInstitutionClassification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LocalInstitutionClassification")-1 + 1 + sizeof("</hrxml:LocalInstitutionClassification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LocalInstitutionClassification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LocalInstitutionClassification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LocalInstitutionClassification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LocalInstitutionClassification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LocalInstitutionClassification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LocalInstitutionClassification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LocalInstitutionClassification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LocalInstitutionClassification(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LocationSummary
#define EL_STRUCT zx_hrxml_LocationSummary_s
#define EL_NS     hrxml
#define EL_TAG    LocationSummary

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LocationSummary) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LocationSummary")-1 + 1 + sizeof("</hrxml:LocationSummary>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Region")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LocationSummary", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LocationSummary) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LocationSummary");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Municipality", sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Region", sizeof("hrxml:Region")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CountryCode", sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PostalCode", sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LocationSummary>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LocationSummary", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LocationSummary) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LocationSummary(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LocationSummary(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Longitude
#define EL_STRUCT zx_hrxml_Longitude_s
#define EL_NS     hrxml
#define EL_TAG    Longitude

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Longitude) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Longitude")-1 + 1 + sizeof("</hrxml:Longitude>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Longitude", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Longitude) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Longitude");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Longitude>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Longitude", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Longitude) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Longitude(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Longitude(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LowestPossibleValue
#define EL_STRUCT zx_hrxml_LowestPossibleValue_s
#define EL_NS     hrxml
#define EL_TAG    LowestPossibleValue

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_LowestPossibleValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:LowestPossibleValue")-1 + 1 + sizeof("</hrxml:LowestPossibleValue>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->NumericValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se);
  for (se = &x->StringValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:LowestPossibleValue", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_LowestPossibleValue) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:LowestPossibleValue");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->NumericValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se, p);
  for (se = &x->StringValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:LowestPossibleValue>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:LowestPossibleValue", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_LowestPossibleValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_LowestPossibleValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_LowestPossibleValue(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MatchedObjectId
#define EL_STRUCT zx_hrxml_MatchedObjectId_s
#define EL_NS     hrxml
#define EL_TAG    MatchedObjectId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_MatchedObjectId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:MatchedObjectId")-1 + 1 + sizeof("</hrxml:MatchedObjectId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MatchedObjectId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_MatchedObjectId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:MatchedObjectId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:MatchedObjectId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MatchedObjectId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_MatchedObjectId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_MatchedObjectId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_MatchedObjectId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Measure
#define EL_STRUCT zx_hrxml_Measure_s
#define EL_NS     hrxml
#define EL_TAG    Measure

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Measure) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Measure")-1 + 1 + sizeof("</hrxml:Measure>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->measureType, sizeof("measureType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->MeasureSystem; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MeasureSystem")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MeasureValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MeasureValue")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Measure", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Measure) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Measure");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->measureType, " measureType=\"", sizeof(" measureType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->MeasureSystem; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MeasureSystem", sizeof("hrxml:MeasureSystem")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MeasureValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MeasureValue", sizeof("hrxml:MeasureValue")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Measure>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Measure", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Measure) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Measure(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Measure(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MilitaryHistory
#define EL_STRUCT zx_hrxml_MilitaryHistory_s
#define EL_NS     hrxml
#define EL_TAG    MilitaryHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_MilitaryHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:MilitaryHistory")-1 + 1 + sizeof("</hrxml:MilitaryHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CountryServed; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CountryServed")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ServiceNumber->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ServiceNumber(c, (struct zx_hrxml_ServiceNumber_s*)se);
  for (se = &x->ServiceDetail->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ServiceDetail(c, (struct zx_hrxml_ServiceDetail_s*)se);
  for (se = x->ServiceStatus; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ServiceStatus")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MilitaryHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_MilitaryHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:MilitaryHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->CountryServed; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CountryServed", sizeof("hrxml:CountryServed")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ServiceNumber->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ServiceNumber(c, (struct zx_hrxml_ServiceNumber_s*)se, p);
  for (se = &x->ServiceDetail->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ServiceDetail(c, (struct zx_hrxml_ServiceDetail_s*)se, p);
  for (se = x->ServiceStatus; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ServiceStatus", sizeof("hrxml:ServiceStatus")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:MilitaryHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MilitaryHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_MilitaryHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_MilitaryHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_MilitaryHistory(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MilitaryStatus
#define EL_STRUCT zx_hrxml_MilitaryStatus_s
#define EL_NS     hrxml
#define EL_TAG    MilitaryStatus

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_MilitaryStatus) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:MilitaryStatus")-1 + 1 + sizeof("</hrxml:MilitaryStatus>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MilitaryStatus", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_MilitaryStatus) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:MilitaryStatus");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:MilitaryStatus>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MilitaryStatus", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_MilitaryStatus) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_MilitaryStatus(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_MilitaryStatus(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Mobile
#define EL_STRUCT zx_hrxml_Mobile_s
#define EL_NS     hrxml
#define EL_TAG    Mobile

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Mobile) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Mobile")-1 + 1 + sizeof("</hrxml:Mobile>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->smsEnabled, sizeof("smsEnabled")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Mobile", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Mobile) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Mobile");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->smsEnabled, " smsEnabled=\"", sizeof(" smsEnabled=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedNumber", sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Mobile>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Mobile", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Mobile) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Mobile(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Mobile(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MostRecentDate
#define EL_STRUCT zx_hrxml_MostRecentDate_s
#define EL_NS     hrxml
#define EL_TAG    MostRecentDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_MostRecentDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:MostRecentDate")-1 + 1 + sizeof("</hrxml:MostRecentDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:MostRecentDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_MostRecentDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:MostRecentDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:MostRecentDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:MostRecentDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_MostRecentDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_MostRecentDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_MostRecentDate(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_NonXMLResume
#define EL_STRUCT zx_hrxml_NonXMLResume_s
#define EL_NS     hrxml
#define EL_TAG    NonXMLResume

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_NonXMLResume) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:NonXMLResume")-1 + 1 + sizeof("</hrxml:NonXMLResume>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->TextResume; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:TextResume")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->LinkToResume; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:LinkToResume")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->SupportingMaterials->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->RevisionDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:RevisionDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:NonXMLResume", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_NonXMLResume) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:NonXMLResume");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->TextResume; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:TextResume", sizeof("hrxml:TextResume")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->LinkToResume; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:LinkToResume", sizeof("hrxml:LinkToResume")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->SupportingMaterials->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->RevisionDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:RevisionDate", sizeof("hrxml:RevisionDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:NonXMLResume>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:NonXMLResume", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_NonXMLResume) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_NonXMLResume(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_NonXMLResume(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_NumericValue
#define EL_STRUCT zx_hrxml_NumericValue_s
#define EL_NS     hrxml
#define EL_TAG    NumericValue

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_NumericValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:NumericValue")-1 + 1 + sizeof("</hrxml:NumericValue>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->interval, sizeof("interval")-1, &pop_seen);
  len += zx_attr_so_len(c, x->maxValue, sizeof("maxValue")-1, &pop_seen);
  len += zx_attr_so_len(c, x->minValue, sizeof("minValue")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:NumericValue", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_NumericValue) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:NumericValue");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->interval, " interval=\"", sizeof(" interval=\"")-1);
  p = zx_attr_so_enc(p, x->maxValue, " maxValue=\"", sizeof(" maxValue=\"")-1);
  p = zx_attr_so_enc(p, x->minValue, " minValue=\"", sizeof(" minValue=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:NumericValue>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:NumericValue", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_NumericValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_NumericValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_NumericValue(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrgIndustry
#define EL_STRUCT zx_hrxml_OrgIndustry_s
#define EL_NS     hrxml
#define EL_TAG    OrgIndustry

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrgIndustry) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrgIndustry")-1 + 1 + sizeof("</hrxml:OrgIndustry>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->primaryIndicator, sizeof("primaryIndicator")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->IndustryDescription; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:IndustryDescription")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrgIndustry", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrgIndustry) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrgIndustry");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->primaryIndicator, " primaryIndicator=\"", sizeof(" primaryIndicator=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->IndustryDescription; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:IndustryDescription", sizeof("hrxml:IndustryDescription")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrgIndustry>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrgIndustry", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrgIndustry) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrgIndustry(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrgIndustry(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrgInfo
#define EL_STRUCT zx_hrxml_OrgInfo_s
#define EL_NS     hrxml
#define EL_TAG    OrgInfo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrgInfo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrgInfo")-1 + 1 + sizeof("</hrxml:OrgInfo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->PositionLocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PositionLocation(c, (struct zx_hrxml_PositionLocation_s*)se);
  for (se = x->WebSite; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:WebSite")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->LocationSummary->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrgInfo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrgInfo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrgInfo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->PositionLocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PositionLocation(c, (struct zx_hrxml_PositionLocation_s*)se, p);
  for (se = x->WebSite; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:WebSite", sizeof("hrxml:WebSite")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->LocationSummary->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrgInfo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrgInfo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrgInfo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrgInfo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrgInfo(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrgName
#define EL_STRUCT zx_hrxml_OrgName_s
#define EL_NS     hrxml
#define EL_TAG    OrgName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrgName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrgName")-1 + 1 + sizeof("</hrxml:OrgName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->organizationType, sizeof("organizationType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OrgName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrgName(c, (struct zx_hrxml_OrgName_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrgName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrgName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrgName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->organizationType, " organizationType=\"", sizeof(" organizationType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrganizationName", sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OrgName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrgName(c, (struct zx_hrxml_OrgName_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrgName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrgName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrgName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrgName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrgName(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Organization
#define EL_STRUCT zx_hrxml_Organization_s
#define EL_NS     hrxml
#define EL_TAG    Organization

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Organization) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Organization")-1 + 1 + sizeof("</hrxml:Organization>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Organization", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Organization) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Organization");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Organization>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Organization", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Organization) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Organization(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Organization(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationId
#define EL_STRUCT zx_hrxml_OrganizationId_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrganizationId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrganizationId")-1 + 1 + sizeof("</hrxml:OrganizationId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrganizationId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrganizationId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrganizationId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrganizationId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrganizationId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrganizationId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationUnit
#define EL_STRUCT zx_hrxml_OrganizationUnit_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationUnit

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrganizationUnit) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrganizationUnit")-1 + 1 + sizeof("</hrxml:OrganizationUnit>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->attendanceStatus, sizeof("attendanceStatus")-1, &pop_seen);
  len += zx_attr_so_len(c, x->organizationType, sizeof("organizationType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationUnit", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrganizationUnit) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrganizationUnit");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->attendanceStatus, " attendanceStatus=\"", sizeof(" attendanceStatus=\"")-1);
  p = zx_attr_so_enc(p, x->organizationType, " organizationType=\"", sizeof(" organizationType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrganizationUnit>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationUnit", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrganizationUnit) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrganizationUnit(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrganizationUnit(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationalUnit
#define EL_STRUCT zx_hrxml_OrganizationalUnit_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationalUnit

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrganizationalUnit) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrganizationalUnit")-1 + 1 + sizeof("</hrxml:OrganizationalUnit>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->hierarchicalRole, sizeof("hierarchicalRole")-1, &pop_seen);
  len += zx_attr_so_len(c, x->typeOfGroup, sizeof("typeOfGroup")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationalUnitName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrganizationalUnitName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OrganizationalUnitId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrganizationalUnitId(c, (struct zx_hrxml_OrganizationalUnitId_s*)se);
  for (se = &x->OrganizationId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)se);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);
  for (se = &x->AccountingCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_AccountingCode(c, (struct zx_hrxml_AccountingCode_s*)se);
  for (se = &x->WorkSite->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)se);
  for (se = &x->RelatedOrganizationalUnit->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RelatedOrganizationalUnit(c, (struct zx_hrxml_RelatedOrganizationalUnit_s*)se);
  for (se = &x->PersonMember->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonMember(c, (struct zx_hrxml_PersonMember_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnit", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrganizationalUnit) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrganizationalUnit");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->hierarchicalRole, " hierarchicalRole=\"", sizeof(" hierarchicalRole=\"")-1);
  p = zx_attr_so_enc(p, x->typeOfGroup, " typeOfGroup=\"", sizeof(" typeOfGroup=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->OrganizationalUnitName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrganizationalUnitName", sizeof("hrxml:OrganizationalUnitName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OrganizationalUnitId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrganizationalUnitId(c, (struct zx_hrxml_OrganizationalUnitId_s*)se, p);
  for (se = &x->OrganizationId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)se, p);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se, p);
  for (se = &x->AccountingCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_AccountingCode(c, (struct zx_hrxml_AccountingCode_s*)se, p);
  for (se = &x->WorkSite->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)se, p);
  for (se = &x->RelatedOrganizationalUnit->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RelatedOrganizationalUnit(c, (struct zx_hrxml_RelatedOrganizationalUnit_s*)se, p);
  for (se = &x->PersonMember->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonMember(c, (struct zx_hrxml_PersonMember_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrganizationalUnit>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnit", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrganizationalUnit) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrganizationalUnit(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrganizationalUnit(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationalUnitId
#define EL_STRUCT zx_hrxml_OrganizationalUnitId_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationalUnitId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OrganizationalUnitId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OrganizationalUnitId")-1 + 1 + sizeof("</hrxml:OrganizationalUnitId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnitId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OrganizationalUnitId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OrganizationalUnitId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OrganizationalUnitId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OrganizationalUnitId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OrganizationalUnitId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OrganizationalUnitId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OrganizationalUnitId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OriginalDate
#define EL_STRUCT zx_hrxml_OriginalDate_s
#define EL_NS     hrxml
#define EL_TAG    OriginalDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OriginalDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OriginalDate")-1 + 1 + sizeof("</hrxml:OriginalDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OriginalDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OriginalDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OriginalDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OriginalDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OriginalDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OriginalDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OriginalDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OriginalDate(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherBenefits
#define EL_STRUCT zx_hrxml_OtherBenefits_s
#define EL_NS     hrxml
#define EL_TAG    OtherBenefits

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherBenefits) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherBenefits")-1 + 1 + sizeof("</hrxml:OtherBenefits>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherBenefits", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherBenefits) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherBenefits");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherBenefits>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherBenefits", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherBenefits) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherBenefits(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherBenefits(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherCompensation
#define EL_STRUCT zx_hrxml_OtherCompensation_s
#define EL_NS     hrxml
#define EL_TAG    OtherCompensation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherCompensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherCompensation")-1 + 1 + sizeof("</hrxml:OtherCompensation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherCompensation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherCompensation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherCompensation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherCompensation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherCompensation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherCompensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherCompensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherCompensation(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherDescriptors
#define EL_STRUCT zx_hrxml_OtherDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    OtherDescriptors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherDescriptors")-1 + 1 + sizeof("</hrxml:OtherDescriptors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Applicable; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Applicable")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Value")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->List->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_List(c, (struct zx_hrxml_List_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherDescriptors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherDescriptors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Applicable; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Applicable", sizeof("hrxml:Applicable")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Value", sizeof("hrxml:Value")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->List->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_List(c, (struct zx_hrxml_List_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherDescriptors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherDescriptors(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherHonors
#define EL_STRUCT zx_hrxml_OtherHonors_s
#define EL_NS     hrxml
#define EL_TAG    OtherHonors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherHonors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherHonors")-1 + 1 + sizeof("</hrxml:OtherHonors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherHonors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherHonors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherHonors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherHonors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherHonors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherHonors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherHonors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherHonors(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherPay
#define EL_STRUCT zx_hrxml_OtherPay_s
#define EL_NS     hrxml
#define EL_TAG    OtherPay

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherPay) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherPay")-1 + 1 + sizeof("</hrxml:OtherPay>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->currencyCode, sizeof("currencyCode")-1, &pop_seen);
  len += zx_attr_so_len(c, x->otherInterval, sizeof("otherInterval")-1, &pop_seen);
  len += zx_attr_so_len(c, x->otherPayType, sizeof("otherPayType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OtherPayAmountMin; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OtherPayAmountMin")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->OtherPayAmountMax; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OtherPayAmountMax")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->OtherPayCalculation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OtherPayCalculation")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherPay", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherPay) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherPay");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->currencyCode, " currencyCode=\"", sizeof(" currencyCode=\"")-1);
  p = zx_attr_so_enc(p, x->otherInterval, " otherInterval=\"", sizeof(" otherInterval=\"")-1);
  p = zx_attr_so_enc(p, x->otherPayType, " otherPayType=\"", sizeof(" otherPayType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->OtherPayAmountMin; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OtherPayAmountMin", sizeof("hrxml:OtherPayAmountMin")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->OtherPayAmountMax; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OtherPayAmountMax", sizeof("hrxml:OtherPayAmountMax")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->OtherPayCalculation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OtherPayCalculation", sizeof("hrxml:OtherPayCalculation")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherPay>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherPay", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherPay) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherPay(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherPay(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherPublication
#define EL_STRUCT zx_hrxml_OtherPublication_s
#define EL_NS     hrxml
#define EL_TAG    OtherPublication

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_OtherPublication) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:OtherPublication")-1 + 1 + sizeof("</hrxml:OtherPublication>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PublicationDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Copyright->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISBN; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISBN")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->NumberOfPages; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:NumberOfPages")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PublisherName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PublisherName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PublisherLocation; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PublisherLocation")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:OtherPublication", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_OtherPublication) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:OtherPublication");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PublicationDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se, p);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Abstract; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Abstract", sizeof("hrxml:Abstract")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Copyright->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISSN; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISSN", sizeof("hrxml:ISSN")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISBN; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISBN", sizeof("hrxml:ISBN")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->NumberOfPages; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:NumberOfPages", sizeof("hrxml:NumberOfPages")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PublisherName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PublisherName", sizeof("hrxml:PublisherName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PublisherLocation; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PublisherLocation", sizeof("hrxml:PublisherLocation")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:OtherPublication>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:OtherPublication", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_OtherPublication) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_OtherPublication(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_OtherPublication(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Pager
#define EL_STRUCT zx_hrxml_Pager_s
#define EL_NS     hrxml
#define EL_TAG    Pager

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Pager) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Pager")-1 + 1 + sizeof("</hrxml:Pager>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Pager", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Pager) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Pager");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedNumber", sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Pager>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Pager", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Pager) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Pager(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Pager(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ParkingInstructions
#define EL_STRUCT zx_hrxml_ParkingInstructions_s
#define EL_NS     hrxml
#define EL_TAG    ParkingInstructions

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ParkingInstructions) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ParkingInstructions")-1 + 1 + sizeof("</hrxml:ParkingInstructions>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ParkingInstructions", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ParkingInstructions) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ParkingInstructions");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ParkingInstructions>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ParkingInstructions", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ParkingInstructions) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ParkingInstructions(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ParkingInstructions(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Patent
#define EL_STRUCT zx_hrxml_Patent_s
#define EL_NS     hrxml
#define EL_TAG    Patent

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Patent) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Patent")-1 + 1 + sizeof("</hrxml:Patent>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->PatentTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PatentTitle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->Inventors->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Inventors(c, (struct zx_hrxml_Inventors_s*)se);
  for (se = &x->PatentDetail->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PatentDetail(c, (struct zx_hrxml_PatentDetail_s*)se);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Patent", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Patent) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Patent");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->PatentTitle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PatentTitle", sizeof("hrxml:PatentTitle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);
  for (se = &x->Inventors->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Inventors(c, (struct zx_hrxml_Inventors_s*)se, p);
  for (se = &x->PatentDetail->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PatentDetail(c, (struct zx_hrxml_PatentDetail_s*)se, p);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Patent>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Patent", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Patent) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Patent(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Patent(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PatentDetail
#define EL_STRUCT zx_hrxml_PatentDetail_s
#define EL_NS     hrxml
#define EL_TAG    PatentDetail

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PatentDetail) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PatentDetail")-1 + 1 + sizeof("</hrxml:PatentDetail>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IssuingAuthority->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se);
  for (se = &x->PatentMilestone->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PatentMilestone(c, (struct zx_hrxml_PatentMilestone_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PatentDetail", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PatentDetail) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PatentDetail");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IssuingAuthority->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se, p);
  for (se = &x->PatentMilestone->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PatentMilestone(c, (struct zx_hrxml_PatentMilestone_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PatentDetail>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PatentDetail", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PatentDetail) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PatentDetail(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PatentDetail(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PatentHistory
#define EL_STRUCT zx_hrxml_PatentHistory_s
#define EL_NS     hrxml
#define EL_TAG    PatentHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PatentHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PatentHistory")-1 + 1 + sizeof("</hrxml:PatentHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Patent->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Patent(c, (struct zx_hrxml_Patent_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PatentHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PatentHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PatentHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Patent->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Patent(c, (struct zx_hrxml_Patent_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PatentHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PatentHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PatentHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PatentHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PatentHistory(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PatentMilestone
#define EL_STRUCT zx_hrxml_PatentMilestone_s
#define EL_NS     hrxml
#define EL_TAG    PatentMilestone

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PatentMilestone) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PatentMilestone")-1 + 1 + sizeof("</hrxml:PatentMilestone>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->Status->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Status(c, (struct zx_hrxml_Status_s*)se);
  for (se = x->Date; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Date")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PatentMilestone", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PatentMilestone) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PatentMilestone");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = &x->Status->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Status(c, (struct zx_hrxml_Status_s*)se, p);
  for (se = x->Date; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Date", sizeof("hrxml:Date")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PatentMilestone>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PatentMilestone", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PatentMilestone) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PatentMilestone(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PatentMilestone(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonDescriptors
#define EL_STRUCT zx_hrxml_PersonDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    PersonDescriptors

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonDescriptors) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonDescriptors")-1 + 1 + sizeof("</hrxml:PersonDescriptors>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->LegalIdentifiers->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LegalIdentifiers(c, (struct zx_hrxml_LegalIdentifiers_s*)se);
  for (se = &x->DemographicDescriptors->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DemographicDescriptors(c, (struct zx_hrxml_DemographicDescriptors_s*)se);
  for (se = &x->BiologicalDescriptors->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_BiologicalDescriptors(c, (struct zx_hrxml_BiologicalDescriptors_s*)se);
  for (se = &x->SupportingMaterials->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se);
  for (se = &x->OtherDescriptors->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OtherDescriptors(c, (struct zx_hrxml_OtherDescriptors_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonDescriptors", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonDescriptors) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonDescriptors");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->LegalIdentifiers->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LegalIdentifiers(c, (struct zx_hrxml_LegalIdentifiers_s*)se, p);
  for (se = &x->DemographicDescriptors->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DemographicDescriptors(c, (struct zx_hrxml_DemographicDescriptors_s*)se, p);
  for (se = &x->BiologicalDescriptors->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_BiologicalDescriptors(c, (struct zx_hrxml_BiologicalDescriptors_s*)se, p);
  for (se = &x->SupportingMaterials->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se, p);
  for (se = &x->OtherDescriptors->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OtherDescriptors(c, (struct zx_hrxml_OtherDescriptors_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonDescriptors>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonDescriptors", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonDescriptors) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonDescriptors(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonDescriptors(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonId
#define EL_STRUCT zx_hrxml_PersonId_s
#define EL_NS     hrxml
#define EL_TAG    PersonId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonId")-1 + 1 + sizeof("</hrxml:PersonId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonLegalId
#define EL_STRUCT zx_hrxml_PersonLegalId_s
#define EL_NS     hrxml
#define EL_TAG    PersonLegalId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonLegalId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonLegalId")-1 + 1 + sizeof("</hrxml:PersonLegalId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);
  len += zx_attr_so_len(c, x->documentType, sizeof("documentType")-1, &pop_seen);
  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->idSource, sizeof("idSource")-1, &pop_seen);
  len += zx_attr_so_len(c, x->issuingRegion, sizeof("issuingRegion")-1, &pop_seen);
  len += zx_attr_so_len(c, x->jurisdiction, sizeof("jurisdiction")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonLegalId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonLegalId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonLegalId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->countryCode, " countryCode=\"", sizeof(" countryCode=\"")-1);
  p = zx_attr_so_enc(p, x->documentType, " documentType=\"", sizeof(" documentType=\"")-1);
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->idSource, " idSource=\"", sizeof(" idSource=\"")-1);
  p = zx_attr_so_enc(p, x->issuingRegion, " issuingRegion=\"", sizeof(" issuingRegion=\"")-1);
  p = zx_attr_so_enc(p, x->jurisdiction, " jurisdiction=\"", sizeof(" jurisdiction=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonLegalId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonLegalId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonLegalId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonLegalId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonLegalId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonMember
#define EL_STRUCT zx_hrxml_PersonMember_s
#define EL_NS     hrxml
#define EL_TAG    PersonMember

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonMember) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonMember")-1 + 1 + sizeof("</hrxml:PersonMember>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  for (se = &x->PersonId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonId(c, (struct zx_hrxml_PersonId_s*)se);
  for (se = &x->PersonRole->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonRole(c, (struct zx_hrxml_PersonRole_s*)se);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonMember", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonMember) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonMember");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se, p);
  for (se = &x->PersonId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonId(c, (struct zx_hrxml_PersonId_s*)se, p);
  for (se = &x->PersonRole->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonRole(c, (struct zx_hrxml_PersonRole_s*)se, p);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonMember>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonMember", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonMember) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonMember(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonMember(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonName
#define EL_STRUCT zx_hrxml_PersonName_s
#define EL_NS     hrxml
#define EL_TAG    PersonName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonName")-1 + 1 + sizeof("</hrxml:PersonName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->script, sizeof("script")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->FamilyName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)se);
  for (se = &x->Affix->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)se);
  for (se = &x->AlternateScript->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_AlternateScript(c, (struct zx_hrxml_AlternateScript_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->script, " script=\"", sizeof(" script=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedName", sizeof("hrxml:FormattedName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->LegalName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:LegalName", sizeof("hrxml:LegalName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->GivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:GivenName", sizeof("hrxml:GivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PreferredGivenName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PreferredGivenName", sizeof("hrxml:PreferredGivenName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MiddleName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MiddleName", sizeof("hrxml:MiddleName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->FamilyName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)se, p);
  for (se = &x->Affix->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)se, p);
  for (se = &x->AlternateScript->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_AlternateScript(c, (struct zx_hrxml_AlternateScript_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonName(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonRole
#define EL_STRUCT zx_hrxml_PersonRole_s
#define EL_NS     hrxml
#define EL_TAG    PersonRole

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonRole) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonRole")-1 + 1 + sizeof("</hrxml:PersonRole>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->leader, sizeof("leader")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->RoleName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:RoleName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->RoleId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RoleId(c, (struct zx_hrxml_RoleId_s*)se);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonRole", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonRole) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonRole");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->leader, " leader=\"", sizeof(" leader=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->RoleName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:RoleName", sizeof("hrxml:RoleName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->RoleId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RoleId(c, (struct zx_hrxml_RoleId_s*)se, p);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonRole>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonRole", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonRole) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonRole(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonRole(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonalData
#define EL_STRUCT zx_hrxml_PersonalData_s
#define EL_NS     hrxml
#define EL_TAG    PersonalData

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PersonalData) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PersonalData")-1 + 1 + sizeof("</hrxml:PersonalData>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->PersonId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonId(c, (struct zx_hrxml_PersonId_s*)se);
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);
  for (se = &x->PersonDescriptors->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonDescriptors(c, (struct zx_hrxml_PersonDescriptors_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PersonalData", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PersonalData) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PersonalData");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->PersonId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonId(c, (struct zx_hrxml_PersonId_s*)se, p);
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se, p);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se, p);
  for (se = &x->PersonDescriptors->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonDescriptors(c, (struct zx_hrxml_PersonDescriptors_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PersonalData>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PersonalData", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PersonalData) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PersonalData(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PersonalData(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PhysicalLocation
#define EL_STRUCT zx_hrxml_PhysicalLocation_s
#define EL_NS     hrxml
#define EL_TAG    PhysicalLocation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PhysicalLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PhysicalLocation")-1 + 1 + sizeof("</hrxml:PhysicalLocation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->EffectiveDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se);
  for (se = &x->SpatialLocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SpatialLocation(c, (struct zx_hrxml_SpatialLocation_s*)se);
  for (se = &x->TravelDirections->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)se);
  for (se = &x->PostalAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se);
  for (se = &x->Area->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Area(c, (struct zx_hrxml_Area_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PhysicalLocation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PhysicalLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PhysicalLocation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->EffectiveDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se, p);
  for (se = &x->SpatialLocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SpatialLocation(c, (struct zx_hrxml_SpatialLocation_s*)se, p);
  for (se = &x->TravelDirections->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)se, p);
  for (se = &x->PostalAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se, p);
  for (se = &x->Area->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Area(c, (struct zx_hrxml_Area_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PhysicalLocation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PhysicalLocation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PhysicalLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PhysicalLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PhysicalLocation(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionHistory
#define EL_STRUCT zx_hrxml_PositionHistory_s
#define EL_NS     hrxml
#define EL_TAG    PositionHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PositionHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PositionHistory")-1 + 1 + sizeof("</hrxml:PositionHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->currentEmployer, sizeof("currentEmployer")-1, &pop_seen);
  len += zx_attr_so_len(c, x->positionType, sizeof("positionType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OrgName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrgName(c, (struct zx_hrxml_OrgName_s*)se);
  for (se = &x->OrgInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrgInfo(c, (struct zx_hrxml_OrgInfo_s*)se);
  for (se = &x->OrgIndustry->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrgIndustry(c, (struct zx_hrxml_OrgIndustry_s*)se);
  for (se = x->OrgSize; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrgSize")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);
  for (se = &x->Compensation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Compensation(c, (struct zx_hrxml_Compensation_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Verification->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Verification(c, (struct zx_hrxml_Verification_s*)se);
  for (se = &x->JobLevelInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_JobLevelInfo(c, (struct zx_hrxml_JobLevelInfo_s*)se);
  for (se = &x->JobCategory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se);
  for (se = &x->Competency->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PositionHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PositionHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->currentEmployer, " currentEmployer=\"", sizeof(" currentEmployer=\"")-1);
  p = zx_attr_so_enc(p, x->positionType, " positionType=\"", sizeof(" positionType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OrgName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrgName(c, (struct zx_hrxml_OrgName_s*)se, p);
  for (se = &x->OrgInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrgInfo(c, (struct zx_hrxml_OrgInfo_s*)se, p);
  for (se = &x->OrgIndustry->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrgIndustry(c, (struct zx_hrxml_OrgIndustry_s*)se, p);
  for (se = x->OrgSize; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrgSize", sizeof("hrxml:OrgSize")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se, p);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se, p);
  for (se = &x->Compensation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Compensation(c, (struct zx_hrxml_Compensation_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Verification->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Verification(c, (struct zx_hrxml_Verification_s*)se, p);
  for (se = &x->JobLevelInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_JobLevelInfo(c, (struct zx_hrxml_JobLevelInfo_s*)se, p);
  for (se = &x->JobCategory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se, p);
  for (se = &x->Competency->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PositionHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PositionHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PositionHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PositionHistory(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionLocation
#define EL_STRUCT zx_hrxml_PositionLocation_s
#define EL_NS     hrxml
#define EL_TAG    PositionLocation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PositionLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PositionLocation")-1 + 1 + sizeof("</hrxml:PositionLocation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Region")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DeliveryAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DeliveryAddress(c, (struct zx_hrxml_DeliveryAddress_s*)se);
  for (se = &x->Recipient->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Recipient(c, (struct zx_hrxml_Recipient_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionLocation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PositionLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PositionLocation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CountryCode", sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PostalCode", sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Region", sizeof("hrxml:Region")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Municipality", sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DeliveryAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DeliveryAddress(c, (struct zx_hrxml_DeliveryAddress_s*)se, p);
  for (se = &x->Recipient->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Recipient(c, (struct zx_hrxml_Recipient_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PositionLocation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionLocation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PositionLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PositionLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PositionLocation(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionMatching
#define EL_STRUCT zx_hrxml_PositionMatching_s
#define EL_NS     hrxml
#define EL_TAG    PositionMatching

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PositionMatching) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PositionMatching")-1 + 1 + sizeof("</hrxml:PositionMatching>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Company->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Company(c, (struct zx_hrxml_Company_s*)se);
  for (se = x->CompanyScale; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CompanyScale")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);
  for (se = &x->PhysicalLocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PhysicalLocation(c, (struct zx_hrxml_PhysicalLocation_s*)se);
  for (se = &x->JobCategory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se);
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PositionClassification; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PositionClassification")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PositionSchedule->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PositionSchedule(c, (struct zx_hrxml_PositionSchedule_s*)se);
  for (se = &x->Shift->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Shift(c, (struct zx_hrxml_Shift_s*)se);
  for (se = &x->Competency->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se);
  for (se = &x->RemunerationPackage->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RemunerationPackage(c, (struct zx_hrxml_RemunerationPackage_s*)se);
  for (se = x->WorkStyle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:WorkStyle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DressCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)se);
  for (se = &x->Travel->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Travel(c, (struct zx_hrxml_Travel_s*)se);
  for (se = &x->Relocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Relocation(c, (struct zx_hrxml_Relocation_s*)se);
  for (se = &x->PreferredLanguage->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PreferredLanguage(c, (struct zx_hrxml_PreferredLanguage_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionMatching", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PositionMatching) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PositionMatching");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Company->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Company(c, (struct zx_hrxml_Company_s*)se, p);
  for (se = x->CompanyScale; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CompanyScale", sizeof("hrxml:CompanyScale")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se, p);
  for (se = &x->PhysicalLocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PhysicalLocation(c, (struct zx_hrxml_PhysicalLocation_s*)se, p);
  for (se = &x->JobCategory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se, p);
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PositionTitle", sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PositionClassification; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PositionClassification", sizeof("hrxml:PositionClassification")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PositionSchedule->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PositionSchedule(c, (struct zx_hrxml_PositionSchedule_s*)se, p);
  for (se = &x->Shift->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Shift(c, (struct zx_hrxml_Shift_s*)se, p);
  for (se = &x->Competency->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se, p);
  for (se = &x->RemunerationPackage->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RemunerationPackage(c, (struct zx_hrxml_RemunerationPackage_s*)se, p);
  for (se = x->WorkStyle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:WorkStyle", sizeof("hrxml:WorkStyle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DressCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)se, p);
  for (se = &x->Travel->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Travel(c, (struct zx_hrxml_Travel_s*)se, p);
  for (se = &x->Relocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Relocation(c, (struct zx_hrxml_Relocation_s*)se, p);
  for (se = &x->PreferredLanguage->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PreferredLanguage(c, (struct zx_hrxml_PreferredLanguage_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PositionMatching>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionMatching", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PositionMatching) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PositionMatching(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PositionMatching(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionPosting
#define EL_STRUCT zx_hrxml_PositionPosting_s
#define EL_NS     hrxml
#define EL_TAG    PositionPosting

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PositionPosting) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PositionPosting")-1 + 1 + sizeof("</hrxml:PositionPosting>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->SearchCriteria->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SearchCriteria(c, (struct zx_hrxml_SearchCriteria_s*)se);
  for (se = &x->SearchResult->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SearchResult(c, (struct zx_hrxml_SearchResult_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionPosting", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PositionPosting) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PositionPosting");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->SearchCriteria->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SearchCriteria(c, (struct zx_hrxml_SearchCriteria_s*)se, p);
  for (se = &x->SearchResult->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SearchResult(c, (struct zx_hrxml_SearchResult_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PositionPosting>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionPosting", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PositionPosting) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PositionPosting(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PositionPosting(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionSchedule
#define EL_STRUCT zx_hrxml_PositionSchedule_s
#define EL_NS     hrxml
#define EL_TAG    PositionSchedule

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PositionSchedule) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PositionSchedule")-1 + 1 + sizeof("</hrxml:PositionSchedule>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->percentage, sizeof("percentage")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PositionSchedule", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PositionSchedule) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PositionSchedule");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->percentage, " percentage=\"", sizeof(" percentage=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PositionSchedule>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PositionSchedule", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PositionSchedule) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PositionSchedule(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PositionSchedule(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PostalAddress
#define EL_STRUCT zx_hrxml_PostalAddress_s
#define EL_NS     hrxml
#define EL_TAG    PostalAddress

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PostalAddress) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PostalAddress")-1 + 1 + sizeof("</hrxml:PostalAddress>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Region")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DeliveryAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DeliveryAddress(c, (struct zx_hrxml_DeliveryAddress_s*)se);
  for (se = &x->Recipient->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Recipient(c, (struct zx_hrxml_Recipient_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PostalAddress", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PostalAddress) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PostalAddress");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->CountryCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CountryCode", sizeof("hrxml:CountryCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PostalCode; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PostalCode", sizeof("hrxml:PostalCode")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Region; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Region", sizeof("hrxml:Region")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Municipality; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Municipality", sizeof("hrxml:Municipality")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DeliveryAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DeliveryAddress(c, (struct zx_hrxml_DeliveryAddress_s*)se, p);
  for (se = &x->Recipient->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Recipient(c, (struct zx_hrxml_Recipient_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PostalAddress>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PostalAddress", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PostalAddress) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PostalAddress(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PostalAddress(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PreferredLanguage
#define EL_STRUCT zx_hrxml_PreferredLanguage_s
#define EL_NS     hrxml
#define EL_TAG    PreferredLanguage

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PreferredLanguage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PreferredLanguage")-1 + 1 + sizeof("</hrxml:PreferredLanguage>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PreferredLanguage", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PreferredLanguage) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PreferredLanguage");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PreferredLanguage>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PreferredLanguage", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PreferredLanguage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PreferredLanguage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PreferredLanguage(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PreferredPosition
#define EL_STRUCT zx_hrxml_PreferredPosition_s
#define EL_NS     hrxml
#define EL_TAG    PreferredPosition

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PreferredPosition) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PreferredPosition")-1 + 1 + sizeof("</hrxml:PreferredPosition>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Company->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Company(c, (struct zx_hrxml_Company_s*)se);
  for (se = x->CompanyScale; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CompanyScale")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);
  for (se = &x->PhysicalLocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PhysicalLocation(c, (struct zx_hrxml_PhysicalLocation_s*)se);
  for (se = &x->JobCategory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se);
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PositionClassification; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PositionClassification")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PositionSchedule->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PositionSchedule(c, (struct zx_hrxml_PositionSchedule_s*)se);
  for (se = &x->Shift->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Shift(c, (struct zx_hrxml_Shift_s*)se);
  for (se = &x->Competency->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se);
  for (se = &x->RemunerationPackage->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RemunerationPackage(c, (struct zx_hrxml_RemunerationPackage_s*)se);
  for (se = x->WorkStyle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:WorkStyle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DressCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)se);
  for (se = &x->Travel->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Travel(c, (struct zx_hrxml_Travel_s*)se);
  for (se = &x->Relocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Relocation(c, (struct zx_hrxml_Relocation_s*)se);
  for (se = &x->PreferredLanguage->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PreferredLanguage(c, (struct zx_hrxml_PreferredLanguage_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);
  for (se = &x->Commute->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Commute(c, (struct zx_hrxml_Commute_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PreferredPosition", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PreferredPosition) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PreferredPosition");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Company->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Company(c, (struct zx_hrxml_Company_s*)se, p);
  for (se = x->CompanyScale; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CompanyScale", sizeof("hrxml:CompanyScale")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se, p);
  for (se = &x->PhysicalLocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PhysicalLocation(c, (struct zx_hrxml_PhysicalLocation_s*)se, p);
  for (se = &x->JobCategory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se, p);
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PositionTitle", sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PositionClassification; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PositionClassification", sizeof("hrxml:PositionClassification")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->PositionSchedule->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PositionSchedule(c, (struct zx_hrxml_PositionSchedule_s*)se, p);
  for (se = &x->Shift->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Shift(c, (struct zx_hrxml_Shift_s*)se, p);
  for (se = &x->Competency->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se, p);
  for (se = &x->RemunerationPackage->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RemunerationPackage(c, (struct zx_hrxml_RemunerationPackage_s*)se, p);
  for (se = x->WorkStyle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:WorkStyle", sizeof("hrxml:WorkStyle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->DressCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)se, p);
  for (se = &x->Travel->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Travel(c, (struct zx_hrxml_Travel_s*)se, p);
  for (se = &x->Relocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Relocation(c, (struct zx_hrxml_Relocation_s*)se, p);
  for (se = &x->PreferredLanguage->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PreferredLanguage(c, (struct zx_hrxml_PreferredLanguage_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);
  for (se = &x->Commute->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Commute(c, (struct zx_hrxml_Commute_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PreferredPosition>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PreferredPosition", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PreferredPosition) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PreferredPosition(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PreferredPosition(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PrehireRemuneration
#define EL_STRUCT zx_hrxml_PrehireRemuneration_s
#define EL_NS     hrxml
#define EL_TAG    PrehireRemuneration

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PrehireRemuneration) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PrehireRemuneration")-1 + 1 + sizeof("</hrxml:PrehireRemuneration>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->BasePay->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_BasePay(c, (struct zx_hrxml_BasePay_s*)se);
  for (se = &x->OtherPay->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OtherPay(c, (struct zx_hrxml_OtherPay_s*)se);
  for (se = &x->Benefits->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Benefits(c, (struct zx_hrxml_Benefits_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PrehireRemuneration", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PrehireRemuneration) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PrehireRemuneration");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->BasePay->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_BasePay(c, (struct zx_hrxml_BasePay_s*)se, p);
  for (se = &x->OtherPay->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OtherPay(c, (struct zx_hrxml_OtherPay_s*)se, p);
  for (se = &x->Benefits->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Benefits(c, (struct zx_hrxml_Benefits_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PrehireRemuneration>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PrehireRemuneration", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PrehireRemuneration) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PrehireRemuneration(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PrehireRemuneration(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PrimaryLanguage
#define EL_STRUCT zx_hrxml_PrimaryLanguage_s
#define EL_NS     hrxml
#define EL_TAG    PrimaryLanguage

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PrimaryLanguage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PrimaryLanguage")-1 + 1 + sizeof("</hrxml:PrimaryLanguage>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PrimaryLanguage", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PrimaryLanguage) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PrimaryLanguage");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PrimaryLanguage>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PrimaryLanguage", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PrimaryLanguage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PrimaryLanguage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PrimaryLanguage(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ProfessionalAssociations
#define EL_STRUCT zx_hrxml_ProfessionalAssociations_s
#define EL_NS     hrxml
#define EL_TAG    ProfessionalAssociations

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ProfessionalAssociations) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ProfessionalAssociations")-1 + 1 + sizeof("</hrxml:ProfessionalAssociations>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Association->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Association(c, (struct zx_hrxml_Association_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ProfessionalAssociations", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ProfessionalAssociations) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ProfessionalAssociations");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Association->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Association(c, (struct zx_hrxml_Association_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ProfessionalAssociations>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ProfessionalAssociations", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ProfessionalAssociations) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ProfessionalAssociations(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ProfessionalAssociations(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ProfileId
#define EL_STRUCT zx_hrxml_ProfileId_s
#define EL_NS     hrxml
#define EL_TAG    ProfileId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ProfileId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ProfileId")-1 + 1 + sizeof("</hrxml:ProfileId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ProfileId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ProfileId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ProfileId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ProfileId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ProfileId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ProfileId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ProfileId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ProfileId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ProgramId
#define EL_STRUCT zx_hrxml_ProgramId_s
#define EL_NS     hrxml
#define EL_TAG    ProgramId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ProgramId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ProgramId")-1 + 1 + sizeof("</hrxml:ProgramId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ProgramId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ProgramId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ProgramId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ProgramId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ProgramId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ProgramId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ProgramId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ProgramId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PublicationDate
#define EL_STRUCT zx_hrxml_PublicationDate_s
#define EL_NS     hrxml
#define EL_TAG    PublicationDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PublicationDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PublicationDate")-1 + 1 + sizeof("</hrxml:PublicationDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PublicationDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PublicationDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PublicationDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PublicationDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PublicationDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PublicationDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PublicationDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PublicationDate(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PublicationHistory
#define EL_STRUCT zx_hrxml_PublicationHistory_s
#define EL_NS     hrxml
#define EL_TAG    PublicationHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PublicationHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PublicationHistory")-1 + 1 + sizeof("</hrxml:PublicationHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->FormattedPublicationDescription->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_FormattedPublicationDescription(c, (struct zx_hrxml_FormattedPublicationDescription_s*)se);
  for (se = &x->Article->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Article(c, (struct zx_hrxml_Article_s*)se);
  for (se = &x->Book->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Book(c, (struct zx_hrxml_Book_s*)se);
  for (se = &x->ConferencePaper->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ConferencePaper(c, (struct zx_hrxml_ConferencePaper_s*)se);
  for (se = &x->OtherPublication->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OtherPublication(c, (struct zx_hrxml_OtherPublication_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PublicationHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PublicationHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PublicationHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->FormattedPublicationDescription->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_FormattedPublicationDescription(c, (struct zx_hrxml_FormattedPublicationDescription_s*)se, p);
  for (se = &x->Article->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Article(c, (struct zx_hrxml_Article_s*)se, p);
  for (se = &x->Book->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Book(c, (struct zx_hrxml_Book_s*)se, p);
  for (se = &x->ConferencePaper->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ConferencePaper(c, (struct zx_hrxml_ConferencePaper_s*)se, p);
  for (se = &x->OtherPublication->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OtherPublication(c, (struct zx_hrxml_OtherPublication_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PublicationHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PublicationHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PublicationHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PublicationHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PublicationHistory(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PublicationLanguage
#define EL_STRUCT zx_hrxml_PublicationLanguage_s
#define EL_NS     hrxml
#define EL_TAG    PublicationLanguage

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_PublicationLanguage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:PublicationLanguage")-1 + 1 + sizeof("</hrxml:PublicationLanguage>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:PublicationLanguage", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_PublicationLanguage) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:PublicationLanguage");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:PublicationLanguage>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:PublicationLanguage", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_PublicationLanguage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_PublicationLanguage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_PublicationLanguage(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Qualifications
#define EL_STRUCT zx_hrxml_Qualifications_s
#define EL_NS     hrxml
#define EL_TAG    Qualifications

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Qualifications) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Qualifications")-1 + 1 + sizeof("</hrxml:Qualifications>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->QualificationSummary; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:QualificationSummary")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Competency->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Qualifications", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Qualifications) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Qualifications");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->QualificationSummary; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:QualificationSummary", sizeof("hrxml:QualificationSummary")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Competency->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Qualifications>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Qualifications", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Qualifications) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Qualifications(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Qualifications(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RankAchieved
#define EL_STRUCT zx_hrxml_RankAchieved_s
#define EL_NS     hrxml
#define EL_TAG    RankAchieved

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RankAchieved) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RankAchieved")-1 + 1 + sizeof("</hrxml:RankAchieved>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->StartRank; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StartRank")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CurrentOrEndRank; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CurrentOrEndRank")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RankAchieved", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RankAchieved) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RankAchieved");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->StartRank; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StartRank", sizeof("hrxml:StartRank")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CurrentOrEndRank; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CurrentOrEndRank", sizeof("hrxml:CurrentOrEndRank")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RankAchieved>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RankAchieved", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RankAchieved) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RankAchieved(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RankAchieved(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RankedResult
#define EL_STRUCT zx_hrxml_RankedResult_s
#define EL_NS     hrxml
#define EL_TAG    RankedResult

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RankedResult) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RankedResult")-1 + 1 + sizeof("</hrxml:RankedResult>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CriterionName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CriterionName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Requested; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Requested")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Offered; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Offered")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Score->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Score(c, (struct zx_hrxml_Score_s*)se);
  for (se = &x->Weight->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);
  for (se = &x->RankedResult->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RankedResult(c, (struct zx_hrxml_RankedResult_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RankedResult", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RankedResult) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RankedResult");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->CriterionName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CriterionName", sizeof("hrxml:CriterionName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Requested; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Requested", sizeof("hrxml:Requested")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Offered; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Offered", sizeof("hrxml:Offered")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Score->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Score(c, (struct zx_hrxml_Score_s*)se, p);
  for (se = &x->Weight->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);
  for (se = &x->RankedResult->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RankedResult(c, (struct zx_hrxml_RankedResult_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RankedResult>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RankedResult", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RankedResult) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RankedResult(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RankedResult(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RankedSearchResults
#define EL_STRUCT zx_hrxml_RankedSearchResults_s
#define EL_NS     hrxml
#define EL_TAG    RankedSearchResults

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RankedSearchResults) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RankedSearchResults")-1 + 1 + sizeof("</hrxml:RankedSearchResults>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->RankedResult->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RankedResult(c, (struct zx_hrxml_RankedResult_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RankedSearchResults", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RankedSearchResults) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RankedSearchResults");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->RankedResult->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RankedResult(c, (struct zx_hrxml_RankedResult_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RankedSearchResults>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RankedSearchResults", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RankedSearchResults) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RankedSearchResults(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RankedSearchResults(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Recipient
#define EL_STRUCT zx_hrxml_Recipient_s
#define EL_NS     hrxml
#define EL_TAG    Recipient

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Recipient) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Recipient")-1 + 1 + sizeof("</hrxml:Recipient>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  for (se = x->AdditionalText; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AdditionalText")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Organization->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Organization(c, (struct zx_hrxml_Organization_s*)se);
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Recipient", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Recipient) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Recipient");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se, p);
  for (se = x->AdditionalText; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AdditionalText", sizeof("hrxml:AdditionalText")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Organization->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Organization(c, (struct zx_hrxml_Organization_s*)se, p);
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrganizationName", sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Recipient>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Recipient", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Recipient) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Recipient(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Recipient(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Reference
#define EL_STRUCT zx_hrxml_Reference_s
#define EL_NS     hrxml
#define EL_TAG    Reference

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Reference) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Reference")-1 + 1 + sizeof("</hrxml:Reference>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Reference", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Reference) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Reference");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->PersonName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se, p);
  for (se = x->PositionTitle; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PositionTitle", sizeof("hrxml:PositionTitle")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->ContactMethod->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Reference>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Reference", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Reference) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Reference(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Reference(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_References
#define EL_STRUCT zx_hrxml_References_s
#define EL_NS     hrxml
#define EL_TAG    References

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_References) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:References")-1 + 1 + sizeof("</hrxml:References>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Reference->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Reference(c, (struct zx_hrxml_Reference_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:References", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_References) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:References");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Reference->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Reference(c, (struct zx_hrxml_Reference_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:References>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:References", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_References) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_References(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_References(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelatedOrganization
#define EL_STRUCT zx_hrxml_RelatedOrganization_s
#define EL_NS     hrxml
#define EL_TAG    RelatedOrganization

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RelatedOrganization) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RelatedOrganization")-1 + 1 + sizeof("</hrxml:RelatedOrganization>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->relationship, sizeof("relationship")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OrganizationId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)se);
  for (se = &x->TaxId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_TaxId(c, (struct zx_hrxml_TaxId_s*)se);
  for (se = &x->LegalId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LegalId(c, (struct zx_hrxml_LegalId_s*)se);
  for (se = &x->DunsNumber->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DunsNumber(c, (struct zx_hrxml_DunsNumber_s*)se);
  for (se = x->IsPublicCompany; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:IsPublicCompany")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Stock->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Stock(c, (struct zx_hrxml_Stock_s*)se);
  for (se = x->MissionStatement; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MissionStatement")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ValueStatement; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ValueStatement")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->InternetDomainName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)se);
  for (se = &x->DoingBusinessAs->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DoingBusinessAs(c, (struct zx_hrxml_DoingBusinessAs_s*)se);
  for (se = &x->LegalClassification->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LegalClassification(c, (struct zx_hrxml_LegalClassification_s*)se);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);
  for (se = x->Headcount; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Headcount")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->WorkSite->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)se);
  for (se = &x->ContactInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)se);
  for (se = &x->RelatedOrganization->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RelatedOrganization(c, (struct zx_hrxml_RelatedOrganization_s*)se);
  for (se = &x->OrganizationalUnit->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrganizationalUnit(c, (struct zx_hrxml_OrganizationalUnit_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganization", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RelatedOrganization) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RelatedOrganization");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->relationship, " relationship=\"", sizeof(" relationship=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->OrganizationName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrganizationName", sizeof("hrxml:OrganizationName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OrganizationId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)se, p);
  for (se = &x->TaxId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_TaxId(c, (struct zx_hrxml_TaxId_s*)se, p);
  for (se = &x->LegalId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LegalId(c, (struct zx_hrxml_LegalId_s*)se, p);
  for (se = &x->DunsNumber->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DunsNumber(c, (struct zx_hrxml_DunsNumber_s*)se, p);
  for (se = x->IsPublicCompany; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:IsPublicCompany", sizeof("hrxml:IsPublicCompany")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Stock->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Stock(c, (struct zx_hrxml_Stock_s*)se, p);
  for (se = x->MissionStatement; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MissionStatement", sizeof("hrxml:MissionStatement")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ValueStatement; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ValueStatement", sizeof("hrxml:ValueStatement")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->InternetDomainName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)se, p);
  for (se = &x->DoingBusinessAs->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DoingBusinessAs(c, (struct zx_hrxml_DoingBusinessAs_s*)se, p);
  for (se = &x->LegalClassification->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LegalClassification(c, (struct zx_hrxml_LegalClassification_s*)se, p);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se, p);
  for (se = x->Headcount; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Headcount", sizeof("hrxml:Headcount")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);
  for (se = &x->WorkSite->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)se, p);
  for (se = &x->ContactInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)se, p);
  for (se = &x->RelatedOrganization->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RelatedOrganization(c, (struct zx_hrxml_RelatedOrganization_s*)se, p);
  for (se = &x->OrganizationalUnit->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrganizationalUnit(c, (struct zx_hrxml_OrganizationalUnit_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RelatedOrganization>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganization", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RelatedOrganization) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RelatedOrganization(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RelatedOrganization(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelatedOrganizationalUnit
#define EL_STRUCT zx_hrxml_RelatedOrganizationalUnit_s
#define EL_NS     hrxml
#define EL_TAG    RelatedOrganizationalUnit

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RelatedOrganizationalUnit) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RelatedOrganizationalUnit")-1 + 1 + sizeof("</hrxml:RelatedOrganizationalUnit>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->hierarchicalRole, sizeof("hierarchicalRole")-1, &pop_seen);
  len += zx_attr_so_len(c, x->natureOfRelationship, sizeof("natureOfRelationship")-1, &pop_seen);
  len += zx_attr_so_len(c, x->relationship, sizeof("relationship")-1, &pop_seen);
  len += zx_attr_so_len(c, x->typeOfGroup, sizeof("typeOfGroup")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->OrganizationalUnitName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OrganizationalUnitName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OrganizationalUnitId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrganizationalUnitId(c, (struct zx_hrxml_OrganizationalUnitId_s*)se);
  for (se = &x->OrganizationId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)se);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);
  for (se = &x->AccountingCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_AccountingCode(c, (struct zx_hrxml_AccountingCode_s*)se);
  for (se = &x->WorkSite->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)se);
  for (se = &x->RelatedOrganizationalUnit->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RelatedOrganizationalUnit(c, (struct zx_hrxml_RelatedOrganizationalUnit_s*)se);
  for (se = &x->PersonMember->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PersonMember(c, (struct zx_hrxml_PersonMember_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganizationalUnit", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RelatedOrganizationalUnit) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RelatedOrganizationalUnit");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->hierarchicalRole, " hierarchicalRole=\"", sizeof(" hierarchicalRole=\"")-1);
  p = zx_attr_so_enc(p, x->natureOfRelationship, " natureOfRelationship=\"", sizeof(" natureOfRelationship=\"")-1);
  p = zx_attr_so_enc(p, x->relationship, " relationship=\"", sizeof(" relationship=\"")-1);
  p = zx_attr_so_enc(p, x->typeOfGroup, " typeOfGroup=\"", sizeof(" typeOfGroup=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->OrganizationalUnitName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OrganizationalUnitName", sizeof("hrxml:OrganizationalUnitName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->OrganizationalUnitId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrganizationalUnitId(c, (struct zx_hrxml_OrganizationalUnitId_s*)se, p);
  for (se = &x->OrganizationId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)se, p);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);
  for (se = &x->IndustryCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se, p);
  for (se = &x->AccountingCode->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_AccountingCode(c, (struct zx_hrxml_AccountingCode_s*)se, p);
  for (se = &x->WorkSite->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)se, p);
  for (se = &x->RelatedOrganizationalUnit->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RelatedOrganizationalUnit(c, (struct zx_hrxml_RelatedOrganizationalUnit_s*)se, p);
  for (se = &x->PersonMember->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PersonMember(c, (struct zx_hrxml_PersonMember_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RelatedOrganizationalUnit>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelatedOrganizationalUnit", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RelatedOrganizationalUnit) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RelatedOrganizationalUnit(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RelatedOrganizationalUnit(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelatedPositionPostings
#define EL_STRUCT zx_hrxml_RelatedPositionPostings_s
#define EL_NS     hrxml
#define EL_TAG    RelatedPositionPostings

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RelatedPositionPostings) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RelatedPositionPostings")-1 + 1 + sizeof("</hrxml:RelatedPositionPostings>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->PositionPosting->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PositionPosting(c, (struct zx_hrxml_PositionPosting_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelatedPositionPostings", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RelatedPositionPostings) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RelatedPositionPostings");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->PositionPosting->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PositionPosting(c, (struct zx_hrxml_PositionPosting_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RelatedPositionPostings>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelatedPositionPostings", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RelatedPositionPostings) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RelatedPositionPostings(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RelatedPositionPostings(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Relocation
#define EL_STRUCT zx_hrxml_Relocation_s
#define EL_NS     hrxml
#define EL_TAG    Relocation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Relocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Relocation")-1 + 1 + sizeof("</hrxml:Relocation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->relocationConsidered, sizeof("relocationConsidered")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Relocation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Relocation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Relocation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->relocationConsidered, " relocationConsidered=\"", sizeof(" relocationConsidered=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Relocation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Relocation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Relocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Relocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Relocation(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelocationAssistance
#define EL_STRUCT zx_hrxml_RelocationAssistance_s
#define EL_NS     hrxml
#define EL_TAG    RelocationAssistance

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RelocationAssistance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RelocationAssistance")-1 + 1 + sizeof("</hrxml:RelocationAssistance>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->companyOffered, sizeof("companyOffered")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RelocationAssistance", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RelocationAssistance) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RelocationAssistance");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->companyOffered, " companyOffered=\"", sizeof(" companyOffered=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RelocationAssistance>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RelocationAssistance", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RelocationAssistance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RelocationAssistance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RelocationAssistance(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RemunerationPackage
#define EL_STRUCT zx_hrxml_RemunerationPackage_s
#define EL_NS     hrxml
#define EL_TAG    RemunerationPackage

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RemunerationPackage) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RemunerationPackage")-1 + 1 + sizeof("</hrxml:RemunerationPackage>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->BasePay->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_BasePay(c, (struct zx_hrxml_BasePay_s*)se);
  for (se = &x->OtherPay->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OtherPay(c, (struct zx_hrxml_OtherPay_s*)se);
  for (se = &x->Benefits->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Benefits(c, (struct zx_hrxml_Benefits_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RemunerationPackage", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RemunerationPackage) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RemunerationPackage");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->BasePay->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_BasePay(c, (struct zx_hrxml_BasePay_s*)se, p);
  for (se = &x->OtherPay->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OtherPay(c, (struct zx_hrxml_OtherPay_s*)se, p);
  for (se = &x->Benefits->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Benefits(c, (struct zx_hrxml_Benefits_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RemunerationPackage>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RemunerationPackage", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RemunerationPackage) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RemunerationPackage(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RemunerationPackage(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Resume
#define EL_STRUCT zx_hrxml_Resume_s
#define EL_NS     hrxml
#define EL_TAG    Resume

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Resume) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Resume")-1 + 1 + sizeof("</hrxml:Resume>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->ResumeId; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ResumeId")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->StructuredXMLResume->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StructuredXMLResume(c, (struct zx_hrxml_StructuredXMLResume_s*)se);
  for (se = &x->NonXMLResume->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_NonXMLResume(c, (struct zx_hrxml_NonXMLResume_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Resume", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Resume) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Resume");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->ResumeId; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ResumeId", sizeof("hrxml:ResumeId")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->DistributionGuidelines; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DistributionGuidelines", sizeof("hrxml:DistributionGuidelines")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->StructuredXMLResume->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StructuredXMLResume(c, (struct zx_hrxml_StructuredXMLResume_s*)se, p);
  for (se = &x->NonXMLResume->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_NonXMLResume(c, (struct zx_hrxml_NonXMLResume_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Resume>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Resume", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Resume) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Resume(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Resume(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ResumeAdditionalItem
#define EL_STRUCT zx_hrxml_ResumeAdditionalItem_s
#define EL_NS     hrxml
#define EL_TAG    ResumeAdditionalItem

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ResumeAdditionalItem) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ResumeAdditionalItem")-1 + 1 + sizeof("</hrxml:ResumeAdditionalItem>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->EffectiveDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItem", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ResumeAdditionalItem) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ResumeAdditionalItem");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->EffectiveDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se, p);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ResumeAdditionalItem>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItem", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ResumeAdditionalItem) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ResumeAdditionalItem(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ResumeAdditionalItem(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ResumeAdditionalItems
#define EL_STRUCT zx_hrxml_ResumeAdditionalItems_s
#define EL_NS     hrxml
#define EL_TAG    ResumeAdditionalItems

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ResumeAdditionalItems) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ResumeAdditionalItems")-1 + 1 + sizeof("</hrxml:ResumeAdditionalItems>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->ResumeAdditionalItem->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ResumeAdditionalItem(c, (struct zx_hrxml_ResumeAdditionalItem_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItems", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ResumeAdditionalItems) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ResumeAdditionalItems");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->ResumeAdditionalItem->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ResumeAdditionalItem(c, (struct zx_hrxml_ResumeAdditionalItem_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ResumeAdditionalItems>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ResumeAdditionalItems", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ResumeAdditionalItems) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ResumeAdditionalItems(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ResumeAdditionalItems(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RoleId
#define EL_STRUCT zx_hrxml_RoleId_s
#define EL_NS     hrxml
#define EL_TAG    RoleId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_RoleId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:RoleId")-1 + 1 + sizeof("</hrxml:RoleId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:RoleId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_RoleId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:RoleId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:RoleId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:RoleId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_RoleId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_RoleId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_RoleId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SEPPhysicalLocation
#define EL_STRUCT zx_hrxml_SEPPhysicalLocation_s
#define EL_NS     hrxml
#define EL_TAG    SEPPhysicalLocation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SEPPhysicalLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SEPPhysicalLocation")-1 + 1 + sizeof("</hrxml:SEPPhysicalLocation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->SpatialLocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SpatialLocation(c, (struct zx_hrxml_SpatialLocation_s*)se);
  for (se = &x->TravelDirections->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)se);
  for (se = &x->Area->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Area(c, (struct zx_hrxml_Area_s*)se);
  for (se = &x->PostalAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SEPPhysicalLocation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SEPPhysicalLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SEPPhysicalLocation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->SpatialLocation->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SpatialLocation(c, (struct zx_hrxml_SpatialLocation_s*)se, p);
  for (se = &x->TravelDirections->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)se, p);
  for (se = &x->Area->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Area(c, (struct zx_hrxml_Area_s*)se, p);
  for (se = &x->PostalAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SEPPhysicalLocation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SEPPhysicalLocation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SEPPhysicalLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SEPPhysicalLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SEPPhysicalLocation(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SafetyEquipment
#define EL_STRUCT zx_hrxml_SafetyEquipment_s
#define EL_NS     hrxml
#define EL_TAG    SafetyEquipment

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SafetyEquipment) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SafetyEquipment")-1 + 1 + sizeof("</hrxml:SafetyEquipment>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->suppliedByOrganization, sizeof("suppliedByOrganization")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SafetyEquipment", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SafetyEquipment) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SafetyEquipment");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->suppliedByOrganization, " suppliedByOrganization=\"", sizeof(" suppliedByOrganization=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SafetyEquipment>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SafetyEquipment", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SafetyEquipment) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SafetyEquipment(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SafetyEquipment(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_School
#define EL_STRUCT zx_hrxml_School_s
#define EL_NS     hrxml
#define EL_TAG    School

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_School) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:School")-1 + 1 + sizeof("</hrxml:School>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->InternetDomainName->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)se);
  for (se = &x->SchoolId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SchoolId(c, (struct zx_hrxml_SchoolId_s*)se);
  for (se = x->SchoolName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SchoolName")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:School", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_School) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:School");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->InternetDomainName->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)se, p);
  for (se = &x->SchoolId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SchoolId(c, (struct zx_hrxml_SchoolId_s*)se, p);
  for (se = x->SchoolName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SchoolName", sizeof("hrxml:SchoolName")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:School>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:School", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_School) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_School(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_School(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SchoolId
#define EL_STRUCT zx_hrxml_SchoolId_s
#define EL_NS     hrxml
#define EL_TAG    SchoolId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SchoolId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SchoolId")-1 + 1 + sizeof("</hrxml:SchoolId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SchoolId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SchoolId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SchoolId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SchoolId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SchoolId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SchoolId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SchoolId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SchoolId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SchoolOrInstitution
#define EL_STRUCT zx_hrxml_SchoolOrInstitution_s
#define EL_NS     hrxml
#define EL_TAG    SchoolOrInstitution

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SchoolOrInstitution) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SchoolOrInstitution")-1 + 1 + sizeof("</hrxml:SchoolOrInstitution>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->schoolType, sizeof("schoolType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->SchoolName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SchoolName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->School->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_School(c, (struct zx_hrxml_School_s*)se);
  for (se = &x->LocationSummary->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)se);
  for (se = &x->PostalAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se);
  for (se = &x->OrganizationUnit->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_OrganizationUnit(c, (struct zx_hrxml_OrganizationUnit_s*)se);
  for (se = &x->Degree->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Degree(c, (struct zx_hrxml_Degree_s*)se);
  for (se = x->Major; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Major")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Minor; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Minor")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Measure->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Measure(c, (struct zx_hrxml_Measure_s*)se);
  for (se = &x->DatesOfAttendance->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DatesOfAttendance(c, (struct zx_hrxml_DatesOfAttendance_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISCEDInstitutionClassification; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ISCEDInstitutionClassification")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->LocalInstitutionClassification->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LocalInstitutionClassification(c, (struct zx_hrxml_LocalInstitutionClassification_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SchoolOrInstitution", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SchoolOrInstitution) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SchoolOrInstitution");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->schoolType, " schoolType=\"", sizeof(" schoolType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->SchoolName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SchoolName", sizeof("hrxml:SchoolName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->School->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_School(c, (struct zx_hrxml_School_s*)se, p);
  for (se = &x->LocationSummary->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)se, p);
  for (se = &x->PostalAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se, p);
  for (se = &x->OrganizationUnit->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_OrganizationUnit(c, (struct zx_hrxml_OrganizationUnit_s*)se, p);
  for (se = &x->Degree->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Degree(c, (struct zx_hrxml_Degree_s*)se, p);
  for (se = x->Major; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Major", sizeof("hrxml:Major")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Minor; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Minor", sizeof("hrxml:Minor")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Measure->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Measure(c, (struct zx_hrxml_Measure_s*)se, p);
  for (se = &x->DatesOfAttendance->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DatesOfAttendance(c, (struct zx_hrxml_DatesOfAttendance_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->ISCEDInstitutionClassification; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ISCEDInstitutionClassification", sizeof("hrxml:ISCEDInstitutionClassification")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->LocalInstitutionClassification->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LocalInstitutionClassification(c, (struct zx_hrxml_LocalInstitutionClassification_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SchoolOrInstitution>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SchoolOrInstitution", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SchoolOrInstitution) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SchoolOrInstitution(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SchoolOrInstitution(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Score
#define EL_STRUCT zx_hrxml_Score_s
#define EL_NS     hrxml
#define EL_TAG    Score

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Score) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Score")-1 + 1 + sizeof("</hrxml:Score>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Score", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Score) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Score");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->unitOfMeasure, " unitOfMeasure=\"", sizeof(" unitOfMeasure=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Score>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Score", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Score) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Score(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Score(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchCriteria
#define EL_STRUCT zx_hrxml_SearchCriteria_s
#define EL_NS     hrxml
#define EL_TAG    SearchCriteria

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchCriteria) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchCriteria")-1 + 1 + sizeof("</hrxml:SearchCriteria>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->SearchCriteriaId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SearchCriteriaId(c, (struct zx_hrxml_SearchCriteriaId_s*)se);
  for (se = x->SearchTarget; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchTarget")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->UserId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserId(c, (struct zx_hrxml_UserId_s*)se);
  for (se = x->SearchTimeStamp; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchTimeStamp")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->SearchString; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchString")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->SearchCriterion->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SearchCriterion(c, (struct zx_hrxml_SearchCriterion_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteria", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchCriteria) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchCriteria");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->SearchCriteriaId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SearchCriteriaId(c, (struct zx_hrxml_SearchCriteriaId_s*)se, p);
  for (se = x->SearchTarget; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchTarget", sizeof("hrxml:SearchTarget")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->UserId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserId(c, (struct zx_hrxml_UserId_s*)se, p);
  for (se = x->SearchTimeStamp; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchTimeStamp", sizeof("hrxml:SearchTimeStamp")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->SearchString; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchString", sizeof("hrxml:SearchString")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->SearchCriterion->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SearchCriterion(c, (struct zx_hrxml_SearchCriterion_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchCriteria>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteria", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchCriteria) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchCriteria(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchCriteria(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchCriteriaId
#define EL_STRUCT zx_hrxml_SearchCriteriaId_s
#define EL_NS     hrxml
#define EL_TAG    SearchCriteriaId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchCriteriaId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchCriteriaId")-1 + 1 + sizeof("</hrxml:SearchCriteriaId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteriaId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchCriteriaId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchCriteriaId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchCriteriaId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchCriteriaId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchCriteriaId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchCriteriaId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchCriteriaId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchCriterion
#define EL_STRUCT zx_hrxml_SearchCriterion_s
#define EL_NS     hrxml
#define EL_TAG    SearchCriterion

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchCriterion) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchCriterion")-1 + 1 + sizeof("</hrxml:SearchCriterion>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->CriterionName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CriterionName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CriterionValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:CriterionValue")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Weight->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchCriterion", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchCriterion) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchCriterion");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->CriterionName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CriterionName", sizeof("hrxml:CriterionName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->CriterionValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:CriterionValue", sizeof("hrxml:CriterionValue")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Weight->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchCriterion>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchCriterion", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchCriterion) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchCriterion(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchCriterion(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchRelevanceScore
#define EL_STRUCT zx_hrxml_SearchRelevanceScore_s
#define EL_NS     hrxml
#define EL_TAG    SearchRelevanceScore

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchRelevanceScore) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchRelevanceScore")-1 + 1 + sizeof("</hrxml:SearchRelevanceScore>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchRelevanceScore", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchRelevanceScore) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchRelevanceScore");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->unitOfMeasure, " unitOfMeasure=\"", sizeof(" unitOfMeasure=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchRelevanceScore>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchRelevanceScore", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchRelevanceScore) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchRelevanceScore(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchRelevanceScore(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchResult
#define EL_STRUCT zx_hrxml_SearchResult_s
#define EL_NS     hrxml
#define EL_TAG    SearchResult

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchResult) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchResult")-1 + 1 + sizeof("</hrxml:SearchResult>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->SearchResultId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SearchResultId(c, (struct zx_hrxml_SearchResultId_s*)se);
  for (se = x->SearchTarget; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchTarget")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->UserId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserId(c, (struct zx_hrxml_UserId_s*)se);
  for (se = x->SearchTimeStamp; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchTimeStamp")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->MatchedObjectId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_MatchedObjectId(c, (struct zx_hrxml_MatchedObjectId_s*)se);
  for (se = &x->SearchRelevanceScore->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SearchRelevanceScore(c, (struct zx_hrxml_SearchRelevanceScore_s*)se);
  for (se = x->SearchRelevanceRank; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchRelevanceRank")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->SearchResultCount; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:SearchResultCount")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->RankedSearchResults->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RankedSearchResults(c, (struct zx_hrxml_RankedSearchResults_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchResult", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchResult) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchResult");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->SearchResultId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SearchResultId(c, (struct zx_hrxml_SearchResultId_s*)se, p);
  for (se = x->SearchTarget; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchTarget", sizeof("hrxml:SearchTarget")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->UserId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserId(c, (struct zx_hrxml_UserId_s*)se, p);
  for (se = x->SearchTimeStamp; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchTimeStamp", sizeof("hrxml:SearchTimeStamp")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->MatchedObjectId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_MatchedObjectId(c, (struct zx_hrxml_MatchedObjectId_s*)se, p);
  for (se = &x->SearchRelevanceScore->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SearchRelevanceScore(c, (struct zx_hrxml_SearchRelevanceScore_s*)se, p);
  for (se = x->SearchRelevanceRank; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchRelevanceRank", sizeof("hrxml:SearchRelevanceRank")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->SearchResultCount; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:SearchResultCount", sizeof("hrxml:SearchResultCount")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->RankedSearchResults->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RankedSearchResults(c, (struct zx_hrxml_RankedSearchResults_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchResult>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchResult", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchResult) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchResult(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchResult(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchResultId
#define EL_STRUCT zx_hrxml_SearchResultId_s
#define EL_NS     hrxml
#define EL_TAG    SearchResultId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SearchResultId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SearchResultId")-1 + 1 + sizeof("</hrxml:SearchResultId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SearchResultId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SearchResultId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SearchResultId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SearchResultId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SearchResultId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SearchResultId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SearchResultId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SearchResultId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SecurityCredential
#define EL_STRUCT zx_hrxml_SecurityCredential_s
#define EL_NS     hrxml
#define EL_TAG    SecurityCredential

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SecurityCredential) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SecurityCredential")-1 + 1 + sizeof("</hrxml:SecurityCredential>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->IssuingAuthority->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->EffectiveDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredential", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SecurityCredential) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SecurityCredential");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = &x->IssuingAuthority->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se, p);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);
  for (se = &x->EffectiveDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SecurityCredential>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredential", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SecurityCredential) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SecurityCredential(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SecurityCredential(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SecurityCredentials
#define EL_STRUCT zx_hrxml_SecurityCredentials_s
#define EL_NS     hrxml
#define EL_TAG    SecurityCredentials

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SecurityCredentials) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SecurityCredentials")-1 + 1 + sizeof("</hrxml:SecurityCredentials>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->SecurityCredential->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SecurityCredential(c, (struct zx_hrxml_SecurityCredential_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredentials", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SecurityCredentials) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SecurityCredentials");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->SecurityCredential->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SecurityCredential(c, (struct zx_hrxml_SecurityCredential_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SecurityCredentials>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SecurityCredentials", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SecurityCredentials) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SecurityCredentials(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SecurityCredentials(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ServiceDetail
#define EL_STRUCT zx_hrxml_ServiceDetail_s
#define EL_NS     hrxml
#define EL_TAG    ServiceDetail

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ServiceDetail) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ServiceDetail")-1 + 1 + sizeof("</hrxml:ServiceDetail>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->branch, sizeof("branch")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->UnitOrDivision; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:UnitOrDivision")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->RankAchieved->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_RankAchieved(c, (struct zx_hrxml_RankAchieved_s*)se);
  for (se = &x->DatesOfService->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_DatesOfService(c, (struct zx_hrxml_DatesOfService_s*)se);
  for (se = x->Campaign; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Campaign")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AreaOfExpertise; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AreaOfExpertise")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->RecognitionAchieved; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:RecognitionAchieved")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->DisciplinaryAction; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DisciplinaryAction")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->DischargeStatus; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:DischargeStatus")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ServiceDetail", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ServiceDetail) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ServiceDetail");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->branch, " branch=\"", sizeof(" branch=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->UnitOrDivision; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:UnitOrDivision", sizeof("hrxml:UnitOrDivision")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->RankAchieved->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_RankAchieved(c, (struct zx_hrxml_RankAchieved_s*)se, p);
  for (se = &x->DatesOfService->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_DatesOfService(c, (struct zx_hrxml_DatesOfService_s*)se, p);
  for (se = x->Campaign; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Campaign", sizeof("hrxml:Campaign")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AreaOfExpertise; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AreaOfExpertise", sizeof("hrxml:AreaOfExpertise")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->RecognitionAchieved; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:RecognitionAchieved", sizeof("hrxml:RecognitionAchieved")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->DisciplinaryAction; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DisciplinaryAction", sizeof("hrxml:DisciplinaryAction")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->DischargeStatus; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:DischargeStatus", sizeof("hrxml:DischargeStatus")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ServiceDetail>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ServiceDetail", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ServiceDetail) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ServiceDetail(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ServiceDetail(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ServiceNumber
#define EL_STRUCT zx_hrxml_ServiceNumber_s
#define EL_NS     hrxml
#define EL_TAG    ServiceNumber

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ServiceNumber) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ServiceNumber")-1 + 1 + sizeof("</hrxml:ServiceNumber>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ServiceNumber", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ServiceNumber) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ServiceNumber");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ServiceNumber>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ServiceNumber", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ServiceNumber) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ServiceNumber(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ServiceNumber(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Shift
#define EL_STRUCT zx_hrxml_Shift_s
#define EL_NS     hrxml
#define EL_TAG    Shift

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Shift) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Shift")-1 + 1 + sizeof("</hrxml:Shift>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->shiftPeriod, sizeof("shiftPeriod")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Hours; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Hours")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StartTime; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StartTime")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->EndTime; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EndTime")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PayTypeHours; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PayTypeHours")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Shift", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Shift) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Shift");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->shiftPeriod, " shiftPeriod=\"", sizeof(" shiftPeriod=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = x->Name; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Name", sizeof("hrxml:Name")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Hours; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Hours", sizeof("hrxml:Hours")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StartTime; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StartTime", sizeof("hrxml:StartTime")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->EndTime; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EndTime", sizeof("hrxml:EndTime")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PayTypeHours; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PayTypeHours", sizeof("hrxml:PayTypeHours")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Shift>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Shift", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Shift) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Shift(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Shift(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SourceType
#define EL_STRUCT zx_hrxml_SourceType_s
#define EL_NS     hrxml
#define EL_TAG    SourceType

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SourceType) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SourceType")-1 + 1 + sizeof("</hrxml:SourceType>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->StandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StandardValue")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->NonStandardValue; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:NonStandardValue")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SourceType", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SourceType) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SourceType");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->StandardValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StandardValue", sizeof("hrxml:StandardValue")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->NonStandardValue; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:NonStandardValue", sizeof("hrxml:NonStandardValue")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SourceType>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SourceType", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SourceType) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SourceType(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SourceType(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpatialLocation
#define EL_STRUCT zx_hrxml_SpatialLocation_s
#define EL_NS     hrxml
#define EL_TAG    SpatialLocation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SpatialLocation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SpatialLocation")-1 + 1 + sizeof("</hrxml:SpatialLocation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Latitude->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Latitude(c, (struct zx_hrxml_Latitude_s*)se);
  for (se = &x->Longitude->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Longitude(c, (struct zx_hrxml_Longitude_s*)se);
  for (se = x->Altitude; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Altitude")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AltitudeMeanSeaLevel; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AltitudeMeanSeaLevel")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->HorizontalAccuracy->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_HorizontalAccuracy(c, (struct zx_hrxml_HorizontalAccuracy_s*)se);
  for (se = &x->VerticalAccuracy->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_VerticalAccuracy(c, (struct zx_hrxml_VerticalAccuracy_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpatialLocation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SpatialLocation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SpatialLocation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Latitude->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Latitude(c, (struct zx_hrxml_Latitude_s*)se, p);
  for (se = &x->Longitude->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Longitude(c, (struct zx_hrxml_Longitude_s*)se, p);
  for (se = x->Altitude; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Altitude", sizeof("hrxml:Altitude")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AltitudeMeanSeaLevel; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AltitudeMeanSeaLevel", sizeof("hrxml:AltitudeMeanSeaLevel")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->HorizontalAccuracy->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_HorizontalAccuracy(c, (struct zx_hrxml_HorizontalAccuracy_s*)se, p);
  for (se = &x->VerticalAccuracy->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_VerticalAccuracy(c, (struct zx_hrxml_VerticalAccuracy_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SpatialLocation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpatialLocation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SpatialLocation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SpatialLocation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SpatialLocation(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpeakingEvent
#define EL_STRUCT zx_hrxml_SpeakingEvent_s
#define EL_NS     hrxml
#define EL_TAG    SpeakingEvent

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SpeakingEvent) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SpeakingEvent")-1 + 1 + sizeof("</hrxml:SpeakingEvent>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->type, sizeof("type")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Role; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Role")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);
  for (se = x->EventName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EventName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->EventType; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EventType")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Location; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Location")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = x->AffiliatedOrganization; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AffiliatedOrganization")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEvent", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SpeakingEvent) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SpeakingEvent");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->type, " type=\"", sizeof(" type=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Title; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Title", sizeof("hrxml:Title")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Role; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Role", sizeof("hrxml:Role")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->StartDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se, p);
  for (se = &x->EndDate->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se, p);
  for (se = x->EventName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EventName", sizeof("hrxml:EventName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->EventType; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EventType", sizeof("hrxml:EventType")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Location; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Location", sizeof("hrxml:Location")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);
  for (se = x->AffiliatedOrganization; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AffiliatedOrganization", sizeof("hrxml:AffiliatedOrganization")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SpeakingEvent>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEvent", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SpeakingEvent) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SpeakingEvent(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SpeakingEvent(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpeakingEventsHistory
#define EL_STRUCT zx_hrxml_SpeakingEventsHistory_s
#define EL_NS     hrxml
#define EL_TAG    SpeakingEventsHistory

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SpeakingEventsHistory) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SpeakingEventsHistory")-1 + 1 + sizeof("</hrxml:SpeakingEventsHistory>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->SpeakingEvent->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SpeakingEvent(c, (struct zx_hrxml_SpeakingEvent_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEventsHistory", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SpeakingEventsHistory) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SpeakingEventsHistory");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->SpeakingEvent->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SpeakingEvent(c, (struct zx_hrxml_SpeakingEvent_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SpeakingEventsHistory>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpeakingEventsHistory", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SpeakingEventsHistory) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SpeakingEventsHistory(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SpeakingEventsHistory(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpecifiedCompetencyReference
#define EL_STRUCT zx_hrxml_SpecifiedCompetencyReference_s
#define EL_NS     hrxml
#define EL_TAG    SpecifiedCompetencyReference

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SpecifiedCompetencyReference) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SpecifiedCompetencyReference")-1 + 1 + sizeof("</hrxml:SpecifiedCompetencyReference>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->CompetencyId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_CompetencyId(c, (struct zx_hrxml_CompetencyId_s*)se);
  for (se = x->ProficencyLevel; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ProficencyLevel")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SpecifiedCompetencyReference", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SpecifiedCompetencyReference) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SpecifiedCompetencyReference");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->CompetencyId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_CompetencyId(c, (struct zx_hrxml_CompetencyId_s*)se, p);
  for (se = x->ProficencyLevel; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ProficencyLevel", sizeof("hrxml:ProficencyLevel")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SpecifiedCompetencyReference>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SpecifiedCompetencyReference", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SpecifiedCompetencyReference) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SpecifiedCompetencyReference(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SpecifiedCompetencyReference(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StartDate
#define EL_STRUCT zx_hrxml_StartDate_s
#define EL_NS     hrxml
#define EL_TAG    StartDate

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_StartDate) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:StartDate")-1 + 1 + sizeof("</hrxml:StartDate>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StartDate", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_StartDate) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:StartDate");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:StartDate>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StartDate", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_StartDate) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_StartDate(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_StartDate(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StartingCompensation
#define EL_STRUCT zx_hrxml_StartingCompensation_s
#define EL_NS     hrxml
#define EL_TAG    StartingCompensation

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_StartingCompensation) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:StartingCompensation")-1 + 1 + sizeof("</hrxml:StartingCompensation>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->currency, sizeof("currency")-1, &pop_seen);
  len += zx_attr_so_len(c, x->intervalType, sizeof("intervalType")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StartingCompensation", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_StartingCompensation) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:StartingCompensation");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->currency, " currency=\"", sizeof(" currency=\"")-1);
  p = zx_attr_so_enc(p, x->intervalType, " intervalType=\"", sizeof(" intervalType=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:StartingCompensation>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StartingCompensation", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_StartingCompensation) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_StartingCompensation(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_StartingCompensation(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Status
#define EL_STRUCT zx_hrxml_Status_s
#define EL_NS     hrxml
#define EL_TAG    Status

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Status) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Status")-1 + 1 + sizeof("</hrxml:Status>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Status", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Status) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Status");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Status>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Status", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Status) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Status(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Status(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Stock
#define EL_STRUCT zx_hrxml_Stock_s
#define EL_NS     hrxml
#define EL_TAG    Stock

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Stock) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Stock")-1 + 1 + sizeof("</hrxml:Stock>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = x->Symbol; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Symbol")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Exchange; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Exchange")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Stock", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Stock) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Stock");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Id->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)se, p);
  for (se = x->Symbol; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Symbol", sizeof("hrxml:Symbol")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Exchange; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Exchange", sizeof("hrxml:Exchange")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Stock>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Stock", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Stock) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Stock(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Stock(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StringValue
#define EL_STRUCT zx_hrxml_StringValue_s
#define EL_NS     hrxml
#define EL_TAG    StringValue

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_StringValue) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:StringValue")-1 + 1 + sizeof("</hrxml:StringValue>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->maxValue, sizeof("maxValue")-1, &pop_seen);
  len += zx_attr_so_len(c, x->minValue, sizeof("minValue")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StringValue", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_StringValue) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:StringValue");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->maxValue, " maxValue=\"", sizeof(" maxValue=\"")-1);
  p = zx_attr_so_enc(p, x->minValue, " minValue=\"", sizeof(" minValue=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:StringValue>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StringValue", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_StringValue) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_StringValue(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_StringValue(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StructuredXMLResume
#define EL_STRUCT zx_hrxml_StructuredXMLResume_s
#define EL_NS     hrxml
#define EL_TAG    StructuredXMLResume

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_StructuredXMLResume) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:StructuredXMLResume")-1 + 1 + sizeof("</hrxml:StructuredXMLResume>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->ContactInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)se);
  for (se = x->ExecutiveSummary; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ExecutiveSummary")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Objective; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Objective")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->EmploymentHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EmploymentHistory(c, (struct zx_hrxml_EmploymentHistory_s*)se);
  for (se = &x->EducationHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EducationHistory(c, (struct zx_hrxml_EducationHistory_s*)se);
  for (se = &x->LicensesAndCertifications->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_LicensesAndCertifications(c, (struct zx_hrxml_LicensesAndCertifications_s*)se);
  for (se = &x->MilitaryHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_MilitaryHistory(c, (struct zx_hrxml_MilitaryHistory_s*)se);
  for (se = &x->PatentHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PatentHistory(c, (struct zx_hrxml_PatentHistory_s*)se);
  for (se = &x->PublicationHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PublicationHistory(c, (struct zx_hrxml_PublicationHistory_s*)se);
  for (se = &x->SpeakingEventsHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SpeakingEventsHistory(c, (struct zx_hrxml_SpeakingEventsHistory_s*)se);
  for (se = &x->Qualifications->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Qualifications(c, (struct zx_hrxml_Qualifications_s*)se);
  for (se = &x->Languages->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Languages(c, (struct zx_hrxml_Languages_s*)se);
  for (se = &x->Achievements->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Achievements(c, (struct zx_hrxml_Achievements_s*)se);
  for (se = &x->Associations->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Associations(c, (struct zx_hrxml_Associations_s*)se);
  for (se = &x->References->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_References(c, (struct zx_hrxml_References_s*)se);
  for (se = &x->SecurityCredentials->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SecurityCredentials(c, (struct zx_hrxml_SecurityCredentials_s*)se);
  for (se = &x->ResumeAdditionalItems->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ResumeAdditionalItems(c, (struct zx_hrxml_ResumeAdditionalItems_s*)se);
  for (se = &x->SupportingMaterials->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se);
  for (se = &x->ProfessionalAssociations->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ProfessionalAssociations(c, (struct zx_hrxml_ProfessionalAssociations_s*)se);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->RevisionDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:RevisionDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:StructuredXMLResume", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_StructuredXMLResume) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:StructuredXMLResume");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->ContactInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)se, p);
  for (se = x->ExecutiveSummary; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ExecutiveSummary", sizeof("hrxml:ExecutiveSummary")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Objective; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Objective", sizeof("hrxml:Objective")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->EmploymentHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EmploymentHistory(c, (struct zx_hrxml_EmploymentHistory_s*)se, p);
  for (se = &x->EducationHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EducationHistory(c, (struct zx_hrxml_EducationHistory_s*)se, p);
  for (se = &x->LicensesAndCertifications->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_LicensesAndCertifications(c, (struct zx_hrxml_LicensesAndCertifications_s*)se, p);
  for (se = &x->MilitaryHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_MilitaryHistory(c, (struct zx_hrxml_MilitaryHistory_s*)se, p);
  for (se = &x->PatentHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PatentHistory(c, (struct zx_hrxml_PatentHistory_s*)se, p);
  for (se = &x->PublicationHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PublicationHistory(c, (struct zx_hrxml_PublicationHistory_s*)se, p);
  for (se = &x->SpeakingEventsHistory->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SpeakingEventsHistory(c, (struct zx_hrxml_SpeakingEventsHistory_s*)se, p);
  for (se = &x->Qualifications->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Qualifications(c, (struct zx_hrxml_Qualifications_s*)se, p);
  for (se = &x->Languages->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Languages(c, (struct zx_hrxml_Languages_s*)se, p);
  for (se = &x->Achievements->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Achievements(c, (struct zx_hrxml_Achievements_s*)se, p);
  for (se = &x->Associations->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Associations(c, (struct zx_hrxml_Associations_s*)se, p);
  for (se = &x->References->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_References(c, (struct zx_hrxml_References_s*)se, p);
  for (se = &x->SecurityCredentials->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SecurityCredentials(c, (struct zx_hrxml_SecurityCredentials_s*)se, p);
  for (se = &x->ResumeAdditionalItems->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ResumeAdditionalItems(c, (struct zx_hrxml_ResumeAdditionalItems_s*)se, p);
  for (se = &x->SupportingMaterials->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se, p);
  for (se = &x->ProfessionalAssociations->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ProfessionalAssociations(c, (struct zx_hrxml_ProfessionalAssociations_s*)se, p);
  for (se = x->Comments; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Comments", sizeof("hrxml:Comments")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->RevisionDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:RevisionDate", sizeof("hrxml:RevisionDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:StructuredXMLResume>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:StructuredXMLResume", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_StructuredXMLResume) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_StructuredXMLResume(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_StructuredXMLResume(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SupplierId
#define EL_STRUCT zx_hrxml_SupplierId_s
#define EL_NS     hrxml
#define EL_TAG    SupplierId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SupplierId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SupplierId")-1 + 1 + sizeof("</hrxml:SupplierId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SupplierId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SupplierId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SupplierId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SupplierId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SupplierId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SupplierId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SupplierId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SupplierId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SupportingMaterials
#define EL_STRUCT zx_hrxml_SupportingMaterials_s
#define EL_NS     hrxml
#define EL_TAG    SupportingMaterials

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_SupportingMaterials) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:SupportingMaterials")-1 + 1 + sizeof("</hrxml:SupportingMaterials>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->AttachmentReference->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_AttachmentReference(c, (struct zx_hrxml_AttachmentReference_s*)se);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:SupportingMaterials", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_SupportingMaterials) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:SupportingMaterials");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Link; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Link", sizeof("hrxml:Link")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->AttachmentReference->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_AttachmentReference(c, (struct zx_hrxml_AttachmentReference_s*)se, p);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:SupportingMaterials>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:SupportingMaterials", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_SupportingMaterials) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_SupportingMaterials(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_SupportingMaterials(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TTYTDD
#define EL_STRUCT zx_hrxml_TTYTDD_s
#define EL_NS     hrxml
#define EL_TAG    TTYTDD

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TTYTDD) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TTYTDD")-1 + 1 + sizeof("</hrxml:TTYTDD>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TTYTDD", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TTYTDD) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TTYTDD");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedNumber", sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TTYTDD>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TTYTDD", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TTYTDD) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TTYTDD(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TTYTDD(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TaxId
#define EL_STRUCT zx_hrxml_TaxId_s
#define EL_NS     hrxml
#define EL_TAG    TaxId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TaxId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TaxId")-1 + 1 + sizeof("</hrxml:TaxId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TaxId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TaxId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TaxId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TaxId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TaxId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TaxId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TaxId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TaxId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TaxonomyId
#define EL_STRUCT zx_hrxml_TaxonomyId_s
#define EL_NS     hrxml
#define EL_TAG    TaxonomyId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TaxonomyId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TaxonomyId")-1 + 1 + sizeof("</hrxml:TaxonomyId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->id, sizeof("id")-1, &pop_seen);
  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TaxonomyId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TaxonomyId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->id, " id=\"", sizeof(" id=\"")-1);
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TaxonomyId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TaxonomyId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TaxonomyId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TaxonomyId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TaxonomyName
#define EL_STRUCT zx_hrxml_TaxonomyName_s
#define EL_NS     hrxml
#define EL_TAG    TaxonomyName

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TaxonomyName) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TaxonomyName")-1 + 1 + sizeof("</hrxml:TaxonomyName>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->version, sizeof("version")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyName", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TaxonomyName) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TaxonomyName");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->version, " version=\"", sizeof(" version=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TaxonomyName>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TaxonomyName", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TaxonomyName) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TaxonomyName(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TaxonomyName(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Telephone
#define EL_STRUCT zx_hrxml_Telephone_s
#define EL_NS     hrxml
#define EL_TAG    Telephone

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Telephone) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Telephone")-1 + 1 + sizeof("</hrxml:Telephone>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Telephone", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Telephone) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Telephone");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->FormattedNumber; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:FormattedNumber", sizeof("hrxml:FormattedNumber")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Telephone>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Telephone", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Telephone) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Telephone(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Telephone(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TermOfNotice
#define EL_STRUCT zx_hrxml_TermOfNotice_s
#define EL_NS     hrxml
#define EL_TAG    TermOfNotice

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TermOfNotice) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TermOfNotice")-1 + 1 + sizeof("</hrxml:TermOfNotice>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Value")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Interval; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Interval")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TermOfNotice", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TermOfNotice) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TermOfNotice");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Value; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Value", sizeof("hrxml:Value")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Interval; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Interval", sizeof("hrxml:Interval")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TermOfNotice>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TermOfNotice", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TermOfNotice) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TermOfNotice(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TermOfNotice(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TimeMax
#define EL_STRUCT zx_hrxml_TimeMax_s
#define EL_NS     hrxml
#define EL_TAG    TimeMax

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TimeMax) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TimeMax")-1 + 1 + sizeof("</hrxml:TimeMax>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->unitOfMeasure, sizeof("unitOfMeasure")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TimeMax", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TimeMax) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TimeMax");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->unitOfMeasure, " unitOfMeasure=\"", sizeof(" unitOfMeasure=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TimeMax>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TimeMax", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TimeMax) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TimeMax(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TimeMax(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TimeOffAllowance
#define EL_STRUCT zx_hrxml_TimeOffAllowance_s
#define EL_NS     hrxml
#define EL_TAG    TimeOffAllowance

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TimeOffAllowance) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TimeOffAllowance")-1 + 1 + sizeof("</hrxml:TimeOffAllowance>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->timeOffType, sizeof("timeOffType")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TimeOffAllowance", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TimeOffAllowance) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TimeOffAllowance");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->timeOffType, " timeOffType=\"", sizeof(" timeOffType=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TimeOffAllowance>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TimeOffAllowance", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TimeOffAllowance) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TimeOffAllowance(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TimeOffAllowance(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Travel
#define EL_STRUCT zx_hrxml_Travel_s
#define EL_NS     hrxml
#define EL_TAG    Travel

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Travel) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Travel")-1 + 1 + sizeof("</hrxml:Travel>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->Applicable; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Applicable")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->TravelFrequency; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:TravelFrequency")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->TravelConsiderations; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:TravelConsiderations")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Travel", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Travel) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Travel");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->Applicable; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Applicable", sizeof("hrxml:Applicable")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->TravelFrequency; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:TravelFrequency", sizeof("hrxml:TravelFrequency")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->TravelConsiderations; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:TravelConsiderations", sizeof("hrxml:TravelConsiderations")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Travel>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Travel", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Travel) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Travel(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Travel(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TravelDirections
#define EL_STRUCT zx_hrxml_TravelDirections_s
#define EL_NS     hrxml
#define EL_TAG    TravelDirections

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_TravelDirections) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:TravelDirections")-1 + 1 + sizeof("</hrxml:TravelDirections>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->lang, sizeof("xml:lang")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:TravelDirections", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_TravelDirections) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:TravelDirections");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);
  if (x->lang)
    zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_xml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->lang, " xml:lang=\"", sizeof(" xml:lang=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:TravelDirections>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:TravelDirections", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_TravelDirections) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_TravelDirections(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_TravelDirections(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_UserArea
#define EL_STRUCT zx_hrxml_UserArea_s
#define EL_NS     hrxml
#define EL_TAG    UserArea

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_UserArea) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:UserArea")-1 + 1 + sizeof("</hrxml:UserArea>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:UserArea", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_UserArea) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:UserArea");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:UserArea>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:UserArea", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_UserArea) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_UserArea(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_UserArea(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_UserId
#define EL_STRUCT zx_hrxml_UserId_s
#define EL_NS     hrxml
#define EL_TAG    UserId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_UserId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:UserId")-1 + 1 + sizeof("</hrxml:UserId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:UserId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_UserId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:UserId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:UserId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:UserId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_UserId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_UserId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_UserId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ValidFrom
#define EL_STRUCT zx_hrxml_ValidFrom_s
#define EL_NS     hrxml
#define EL_TAG    ValidFrom

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ValidFrom) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ValidFrom")-1 + 1 + sizeof("</hrxml:ValidFrom>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ValidFrom", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ValidFrom) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ValidFrom");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ValidFrom>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ValidFrom", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ValidFrom) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ValidFrom(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ValidFrom(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ValidTo
#define EL_STRUCT zx_hrxml_ValidTo_s
#define EL_NS     hrxml
#define EL_TAG    ValidTo

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_ValidTo) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:ValidTo")-1 + 1 + sizeof("</hrxml:ValidTo>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->dateDescription, sizeof("dateDescription")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:ValidTo", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_ValidTo) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:ValidTo");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->dateDescription, " dateDescription=\"", sizeof(" dateDescription=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->AnyDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AnyDate", sizeof("hrxml:AnyDate")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->YearMonth; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:YearMonth", sizeof("hrxml:YearMonth")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->Year; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:Year", sizeof("hrxml:Year")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->MonthDay; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:MonthDay", sizeof("hrxml:MonthDay")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->StringDate; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:StringDate", sizeof("hrxml:StringDate")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:ValidTo>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:ValidTo", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_ValidTo) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_ValidTo(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_ValidTo(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Verification
#define EL_STRUCT zx_hrxml_Verification_s
#define EL_NS     hrxml
#define EL_TAG    Verification

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Verification) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Verification")-1 + 1 + sizeof("</hrxml:Verification>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->ContactInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)se);
  for (se = x->ReasonForLeaving; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:ReasonForLeaving")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PermissionToContact; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:PermissionToContact")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->VerifyEmployment; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:VerifyEmployment")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->EligibleForRehire; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EligibleForRehire")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AttendanceRating; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:AttendanceRating")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->OverallPerformanceRating; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:OverallPerformanceRating")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->QuestionAnswerPair; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:QuestionAnswerPair")-1, zx_ns_tab+zx_hrxml_NS);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Verification", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Verification) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Verification");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->ContactInfo->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)se, p);
  for (se = x->ReasonForLeaving; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:ReasonForLeaving", sizeof("hrxml:ReasonForLeaving")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->PermissionToContact; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:PermissionToContact", sizeof("hrxml:PermissionToContact")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->VerifyEmployment; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:VerifyEmployment", sizeof("hrxml:VerifyEmployment")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->EligibleForRehire; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EligibleForRehire", sizeof("hrxml:EligibleForRehire")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->AttendanceRating; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:AttendanceRating", sizeof("hrxml:AttendanceRating")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->OverallPerformanceRating; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:OverallPerformanceRating", sizeof("hrxml:OverallPerformanceRating")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = x->QuestionAnswerPair; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:QuestionAnswerPair", sizeof("hrxml:QuestionAnswerPair")-1, zx_ns_tab+zx_hrxml_NS);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Verification>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Verification", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Verification) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Verification(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Verification(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_VerticalAccuracy
#define EL_STRUCT zx_hrxml_VerticalAccuracy_s
#define EL_NS     hrxml
#define EL_TAG    VerticalAccuracy

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_VerticalAccuracy) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:VerticalAccuracy")-1 + 1 + sizeof("</hrxml:VerticalAccuracy>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:VerticalAccuracy", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_VerticalAccuracy) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:VerticalAccuracy");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:VerticalAccuracy>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:VerticalAccuracy", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_VerticalAccuracy) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_VerticalAccuracy(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_VerticalAccuracy(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_VisaStatus
#define EL_STRUCT zx_hrxml_VisaStatus_s
#define EL_NS     hrxml
#define EL_TAG    VisaStatus

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_VisaStatus) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:VisaStatus")-1 + 1 + sizeof("</hrxml:VisaStatus>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->countryCode, sizeof("countryCode")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:VisaStatus", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_VisaStatus) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:VisaStatus");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->countryCode, " countryCode=\"", sizeof(" countryCode=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:VisaStatus>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:VisaStatus", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_VisaStatus) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_VisaStatus(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_VisaStatus(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Weight
#define EL_STRUCT zx_hrxml_Weight_s
#define EL_NS     hrxml
#define EL_TAG    Weight

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_Weight) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:Weight")-1 + 1 + sizeof("</hrxml:Weight>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->description, sizeof("description")-1, &pop_seen);
  len += zx_attr_so_len(c, x->interval, sizeof("interval")-1, &pop_seen);
  len += zx_attr_so_len(c, x->maxValue, sizeof("maxValue")-1, &pop_seen);
  len += zx_attr_so_len(c, x->minValue, sizeof("minValue")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:Weight", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_Weight) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:Weight");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->description, " description=\"", sizeof(" description=\"")-1);
  p = zx_attr_so_enc(p, x->interval, " interval=\"", sizeof(" interval=\"")-1);
  p = zx_attr_so_enc(p, x->maxValue, " maxValue=\"", sizeof(" maxValue=\"")-1);
  p = zx_attr_so_enc(p, x->minValue, " minValue=\"", sizeof(" minValue=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:Weight>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:Weight", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_Weight) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_Weight(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_Weight(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_WorkSite
#define EL_STRUCT zx_hrxml_WorkSite_s
#define EL_NS     hrxml
#define EL_TAG    WorkSite

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_WorkSite) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:WorkSite")-1 + 1 + sizeof("</hrxml:WorkSite>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->WorkSiteName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:WorkSiteName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->WorkSiteId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_WorkSiteId(c, (struct zx_hrxml_WorkSiteId_s*)se);
  for (se = &x->Details->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Details(c, (struct zx_hrxml_Details_s*)se);
  for (se = &x->PostalAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se);
  for (se = &x->TravelDirections->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)se);
  for (se = &x->ParkingInstructions->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_ParkingInstructions(c, (struct zx_hrxml_ParkingInstructions_s*)se);
  for (se = &x->WorkSiteEnvironment->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_WorkSiteEnvironment(c, (struct zx_hrxml_WorkSiteEnvironment_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:WorkSite", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_WorkSite) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:WorkSite");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->WorkSiteName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:WorkSiteName", sizeof("hrxml:WorkSiteName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->WorkSiteId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_WorkSiteId(c, (struct zx_hrxml_WorkSiteId_s*)se, p);
  for (se = &x->Details->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Details(c, (struct zx_hrxml_Details_s*)se, p);
  for (se = &x->PostalAddress->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se, p);
  for (se = &x->TravelDirections->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)se, p);
  for (se = &x->ParkingInstructions->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_ParkingInstructions(c, (struct zx_hrxml_ParkingInstructions_s*)se, p);
  for (se = &x->WorkSiteEnvironment->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_WorkSiteEnvironment(c, (struct zx_hrxml_WorkSiteEnvironment_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:WorkSite>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:WorkSite", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_WorkSite) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_WorkSite(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_WorkSite(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_WorkSiteEnvironment
#define EL_STRUCT zx_hrxml_WorkSiteEnvironment_s
#define EL_NS     hrxml
#define EL_TAG    WorkSiteEnvironment

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_WorkSiteEnvironment) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:WorkSiteEnvironment")-1 + 1 + sizeof("</hrxml:WorkSiteEnvironment>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);


#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = x->EnvironmentName; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_simple_elem(c,se, sizeof("hrxml:EnvironmentName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->EnvironmentId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_EnvironmentId(c, (struct zx_hrxml_EnvironmentId_s*)se);
  for (se = &x->WorkSiteId->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_WorkSiteId(c, (struct zx_hrxml_WorkSiteId_s*)se);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->Considerations->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_Considerations(c, (struct zx_hrxml_Considerations_s*)se);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteEnvironment", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_WorkSiteEnvironment) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:WorkSiteEnvironment");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = x->EnvironmentName; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_simple_elem(c, se, p, "hrxml:EnvironmentName", sizeof("hrxml:EnvironmentName")-1, zx_ns_tab+zx_hrxml_NS);
  for (se = &x->EnvironmentId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_EnvironmentId(c, (struct zx_hrxml_EnvironmentId_s*)se, p);
  for (se = &x->WorkSiteId->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_WorkSiteId(c, (struct zx_hrxml_WorkSiteId_s*)se, p);
  for (se = &x->Description->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)se, p);
  for (se = &x->Considerations->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_Considerations(c, (struct zx_hrxml_Considerations_s*)se, p);
  for (se = &x->UserArea->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:WorkSiteEnvironment>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteEnvironment", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_WorkSiteEnvironment) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_WorkSiteEnvironment(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_WorkSiteEnvironment(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_WorkSiteId
#define EL_STRUCT zx_hrxml_WorkSiteId_s
#define EL_NS     hrxml
#define EL_TAG    WorkSiteId

#ifndef MAYBE_UNUSED
#define MAYBE_UNUSED   /* May appear as unused variable, but is needed by some generated code. */
#endif

#if 0
#define ENC_LEN_DEBUG(x,tag,len) D("x=%p tag(%s) len=%d",(x),(tag),(len))
#define ENC_LEN_DEBUG_BASE char* enc_base = p
#else
#define ENC_LEN_DEBUG(x,tag,len)
#define ENC_LEN_DEBUG_BASE
#endif

/* FUNC(zx_LEN_SO_hrxml_WorkSiteId) */

/* Compute length of an element (and its subelements). The XML attributes
 * and elements are processed in schema order. */

/* Called by: */
int zx_LEN_SO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x )
{
  struct zx_ns_s* pop_seen = 0;
  struct zx_elem_s* se MAYBE_UNUSED;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  int len = sizeof("<hrxml:WorkSiteId")-1 + 1 + sizeof("</hrxml:WorkSiteId>")-1;
  if (c->inc_ns_len)
    len += zx_len_inc_ns(c, &pop_seen);
  len += zx_len_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  len += zx_attr_so_len(c, x->idOwner, sizeof("idOwner")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validFrom, sizeof("validFrom")-1, &pop_seen);
  len += zx_attr_so_len(c, x->validTo, sizeof("validTo")-1, &pop_seen);

#else
  /* root node has no begin tag */
  int len = 0;
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    len += zx_LEN_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);


  len += zx_len_so_common(c, &x->gg, &pop_seen);
  zx_pop_seen(pop_seen);
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteId", len);
  return len;
}

/* FUNC(zx_ENC_SO_hrxml_WorkSiteId) */

/* Render element into string. The XML attributes and elements are
 * processed in schema order. This is what you generally want for
 * rendering new data structure to a string. The wo pointers are not used. */

/* Called by: */
char* zx_ENC_SO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x, char* p )
{
  struct zx_elem_s* se MAYBE_UNUSED;
  struct zx_attr_s* attr MAYBE_UNUSED;
  struct zx_ns_s* pop_seen = 0;
  ENC_LEN_DEBUG_BASE;
#if 1 /* NORMALMODE */
  /* *** in simple_elem case should output ns prefix from ns node. */
  ZX_OUT_TAG(p, "<hrxml:WorkSiteId");
  if (c->inc_ns)
    zx_add_inc_ns(c, &pop_seen);
  zx_add_xmlns_if_not_seen(c, zx_ns_tab+zx_hrxml_NS, &pop_seen);

  zx_see_attr_ns(c, x->gg.attr, &pop_seen);
  p = zx_enc_seen(p, pop_seen); 
  p = zx_attr_so_enc(p, x->idOwner, " idOwner=\"", sizeof(" idOwner=\"")-1);
  p = zx_attr_so_enc(p, x->validFrom, " validFrom=\"", sizeof(" validFrom=\"")-1);
  p = zx_attr_so_enc(p, x->validTo, " validTo=\"", sizeof(" validTo=\"")-1);

  for (attr = x->gg.attr; attr; attr = (struct zx_attr_s*)attr->g.n)
    p = zx_attr_wo_enc(p, attr);
  ZX_OUT_CH(p, '>');
#else
  /* root node has no begin tag */
#endif
  
  for (se = &x->IdValue->gg; se; se = (struct zx_elem_s*)se->g.n)
    p = zx_ENC_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se, p);

  p = zx_enc_so_unknown_elems_and_content(c, p, &x->gg);
  
#if 1 /* NORMALMODE */
  ZX_OUT_CLOSE_TAG(p, "</hrxml:WorkSiteId>");
  zx_pop_seen(pop_seen);
#else
  /* root node has no end tag either */
#endif
  ENC_LEN_DEBUG(x, "hrxml:WorkSiteId", p-enc_base);
  return p;
}

/* FUNC(zx_EASY_ENC_SO_hrxml_WorkSiteId) */

/* Called by: */
struct zx_str* zx_EASY_ENC_SO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x )
{
  int len;
  char* buf;
  c->ns_tab = ZX_ALLOC(c, sizeof(zx_ns_tab));
  memcpy(c->ns_tab, zx_ns_tab, sizeof(zx_ns_tab));
  len = zx_LEN_SO_hrxml_WorkSiteId(c, x );
  buf = ZX_ALLOC(c, len+1);
  return zx_easy_enc_common(c, zx_ENC_SO_hrxml_WorkSiteId(c, x, buf ), buf, len);
}

#if 1 /* ENC_WO_SUBTEMPL */
/* Empty ENC_WO_SUBTEMPL */
#endif


/* EOF -- c/zx-hrxml-enc.c */
