/* c/zx-b.ds - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** ds-templ.c  -  DirectoryScript template, used in code generation
 ** Copyright (c) 2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: ds-templ.c,v 1.1 2007-08-10 17:44:49 sampo Exp $
 **
 ** 6.6.2007, created, Sampo Kellomaki (sampo@iki.fi)
 **
 ** N.B: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/



function parse_b_ApplicationEPR(data, x) {
  POPATTR(x[1], 'ID', data.ID);
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'notOnOrAfter', data.notOnOrAfter);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  tag = find_xml_local(x[2], 'Address', 1);
  h =  hash [];
  parse_a_Address(h, aux1);
  data{'Address'} = h;
  tag = find_xml_local(x[2], 'ReferenceParameters', 1);
  h =  hash [];
  parse_a_ReferenceParameters(h, aux1);
  data{'ReferenceParameters'} = h;
  tag = find_xml_local(x[2], 'Metadata', 1);
  h =  hash [];
  parse_a_Metadata(h, aux1);
  data{'Metadata'} = h;

}

function build_b_ApplicationEPR(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'ID', data.ID);
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'notOnOrAfter', data.notOnOrAfter);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  push body, build_a_Address(data{'Address'});
  push body, build_a_ReferenceParameters(data{'ReferenceParameters'});
  push body, build_a_Metadata(data{'Metadata'});

  return TAG('b:ApplicationEPR', attr, body);
}




function parse_b_Consent(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'timestamp', data.timestamp);
  POPATTR(x[1], 'uri', data.uri);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);


}

function build_b_Consent(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'timestamp', data.timestamp);
  PUSHATTR(attr, 'uri', data.uri);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);


  return TAG('b:Consent', attr, body);
}




function parse_b_CredentialsContext(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  tag = find_xml_local(x[2], 'RequestedAuthnContext', 1);
  h =  hash [];
  parse_sp_RequestedAuthnContext(h, aux1);
  data{'RequestedAuthnContext'} = h;
  for (i=1; tag = find_xml_local(x[2], 'SecurityMechID', i); ++i)
    push data{'SecurityMechID'}, tag[2];

}

function build_b_CredentialsContext(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  push body, build_sp_RequestedAuthnContext(data{'RequestedAuthnContext'});
  for d(data{'SecurityMechID'})PUSHTAG_RAW(body,'SecurityMechID',d);

  return TAG('b:CredentialsContext', attr, body);
}




function parse_b_EndpointUpdate(data, x) {
  POPATTR(x[1], 'ID', data.ID);
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'notOnOrAfter', data.notOnOrAfter);
  POPATTR(x[1], 'updateType', data.updateType);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  tag = find_xml_local(x[2], 'Address', 1);
  h =  hash [];
  parse_a_Address(h, aux1);
  data{'Address'} = h;
  tag = find_xml_local(x[2], 'ReferenceParameters', 1);
  h =  hash [];
  parse_a_ReferenceParameters(h, aux1);
  data{'ReferenceParameters'} = h;
  tag = find_xml_local(x[2], 'Metadata', 1);
  h =  hash [];
  parse_a_Metadata(h, aux1);
  data{'Metadata'} = h;

}

function build_b_EndpointUpdate(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'ID', data.ID);
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'notOnOrAfter', data.notOnOrAfter);
  PUSHATTR(attr, 'updateType', data.updateType);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  push body, build_a_Address(data{'Address'});
  push body, build_a_ReferenceParameters(data{'ReferenceParameters'});
  push body, build_a_Metadata(data{'Metadata'});

  return TAG('b:EndpointUpdate', attr, body);
}




function parse_b_Framework(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'version', data.version);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);


}

function build_b_Framework(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'version', data.version);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);


  return TAG('b:Framework', attr, body);
}




function parse_b_InteractionService(data, x) {
  POPATTR(x[1], 'ID', data.ID);
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'notOnOrAfter', data.notOnOrAfter);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  tag = find_xml_local(x[2], 'Address', 1);
  h =  hash [];
  parse_a_Address(h, aux1);
  data{'Address'} = h;
  tag = find_xml_local(x[2], 'ReferenceParameters', 1);
  h =  hash [];
  parse_a_ReferenceParameters(h, aux1);
  data{'ReferenceParameters'} = h;
  tag = find_xml_local(x[2], 'Metadata', 1);
  h =  hash [];
  parse_a_Metadata(h, aux1);
  data{'Metadata'} = h;

}

function build_b_InteractionService(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'ID', data.ID);
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'notOnOrAfter', data.notOnOrAfter);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  push body, build_a_Address(data{'Address'});
  push body, build_a_ReferenceParameters(data{'ReferenceParameters'});
  push body, build_a_Metadata(data{'Metadata'});

  return TAG('b:InteractionService', attr, body);
}




function parse_b_ProcessingContext(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);


}

function build_b_ProcessingContext(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);


  return TAG('b:ProcessingContext', attr, body);
}




function parse_b_RedirectRequest(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'redirectURL', data.redirectURL);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);


}

function build_b_RedirectRequest(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'redirectURL', data.redirectURL);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);


  return TAG('b:RedirectRequest', attr, body);
}




function parse_b_Sender(data, x) {
  POPATTR(x[1], 'affiliationID', data.affiliationID);
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'providerID', data.providerID);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);


}

function build_b_Sender(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'affiliationID', data.affiliationID);
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'providerID', data.providerID);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);


  return TAG('b:Sender', attr, body);
}




function parse_b_TargetIdentity(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  tag = find_xml_local(x[2], 'Assertion', 1);
  h =  hash [];
  parse_sa_Assertion(h, aux1);
  data{'Assertion'} = h;
  tag = find_xml_local(x[2], 'EncryptedAssertion', 1);
  h =  hash [];
  parse_sa_EncryptedAssertion(h, aux1);
  data{'EncryptedAssertion'} = h;
  tag = find_xml_local(x[2], 'sa11_Assertion', 1);
  h =  hash [];
  parse_sa11_Assertion(h, aux1);
  data{'sa11_Assertion'} = h;
  tag = find_xml_local(x[2], 'ff12_Assertion', 1);
  h =  hash [];
  parse_ff12_Assertion(h, aux1);
  data{'ff12_Assertion'} = h;

}

function build_b_TargetIdentity(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  push body, build_sa_Assertion(data{'Assertion'});
  push body, build_sa_EncryptedAssertion(data{'EncryptedAssertion'});
  push body, build_sa11_Assertion(data{'sa11_Assertion'});
  push body, build_ff12_Assertion(data{'ff12_Assertion'});

  return TAG('b:TargetIdentity', attr, body);
}




function parse_b_Timeout(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'maxProcessingTime', data.maxProcessingTime);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);


}

function build_b_Timeout(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'maxProcessingTime', data.maxProcessingTime);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);


  return TAG('b:Timeout', attr, body);
}




function parse_b_UsageDirective(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'ref', data.ref);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  for (i=1; tag = find_xml_local(x[2], 'Obligation', i); ++i) {
    h =  hash [];
    parse_xa_Obligation(h, tag);
    push data{'Obligation'}, h;
  }
  tag = find_xml_local(x[2], 'Dict', 1);
  h =  hash [];
  parse_tas3sol_Dict(h, aux1);
  data{'Dict'} = h;

}

function build_b_UsageDirective(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'ref', data.ref);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  for d(data{'Obligation'}) push body,build_xa_Obligation(d);
  push body, build_tas3sol_Dict(data{'Dict'});

  return TAG('b:UsageDirective', attr, body);
}




function parse_b_UserInteraction(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'interact', data.interact);
  POPATTR(x[1], 'language', data.language);
  POPATTR(x[1], 'maxInteractTime', data.maxInteractTime);
  POPATTR(x[1], 'redirect', data.redirect);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  for (i=1; tag = find_xml_local(x[2], 'InteractionService', i); ++i) {
    h =  hash [];
    parse_b_InteractionService(h, tag);
    push data{'InteractionService'}, h;
  }

}

function build_b_UserInteraction(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'interact', data.interact);
  PUSHATTR(attr, 'language', data.language);
  PUSHATTR(attr, 'maxInteractTime', data.maxInteractTime);
  PUSHATTR(attr, 'redirect', data.redirect);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  for d(data{'InteractionService'}) push body,build_b_InteractionService(d);

  return TAG('b:UserInteraction', attr, body);
}


/* EOF -- c/zx-b.ds */
