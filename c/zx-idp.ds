/* c/zx-idp.ds - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** ds-templ.c  -  DirectoryScript template, used in code generation
 ** Copyright (c) 2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: ds-templ.c,v 1.1 2007-08-10 17:44:49 sampo Exp $
 **
 ** 6.6.2007, created, Sampo Kellomaki (sampo@iki.fi)
 **
 ** N.B: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/



function parse_idp_AssertionItem(data, x) {
  POPATTR(x[1], 'created', data.created);
  POPATTR(x[1], 'id', data.id);

  tag = find_xml_local(x[2], 'MEDInfo', 1);
  h =  hash [];
  parse_idp_MEDInfo(h, aux1);
  data{'MEDInfo'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Assertion', i); ++i) {
    h =  hash [];
    parse_sa_Assertion(h, tag);
    push data{'Assertion'}, h;
  }

}

function build_idp_AssertionItem(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'created', data.created);
  PUSHATTR(attr, 'id', data.id);

  push body, build_idp_MEDInfo(data{'MEDInfo'});
  for d(data{'Assertion'}) push body,build_sa_Assertion(d);

  return TAG('idp:AssertionItem', attr, body);
}




function parse_idp_AuthnContextRestriction(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'AuthnContext', i); ++i) {
    h =  hash [];
    parse_sa_AuthnContext(h, tag);
    push data{'AuthnContext'}, h;
  }

}

function build_idp_AuthnContextRestriction(data) {
  attr = [];
  body = [];

  for d(data{'AuthnContext'}) push body,build_sa_AuthnContext(d);

  return TAG('idp:AuthnContextRestriction', attr, body);
}




function parse_idp_CreatedStatus(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'CreatedStatusItem', i); ++i) {
    h =  hash [];
    parse_idp_CreatedStatusItem(h, tag);
    push data{'CreatedStatusItem'}, h;
  }

}

function build_idp_CreatedStatus(data) {
  attr = [];
  body = [];

  for d(data{'CreatedStatusItem'}) push body,build_idp_CreatedStatusItem(d);

  return TAG('idp:CreatedStatus', attr, body);
}




function parse_idp_CreatedStatusItem(data, x) {
  POPATTR(x[1], 'firstUsed', data.firstUsed);
  POPATTR(x[1], 'ref', data.ref);
  POPATTR(x[1], 'used', data.used);


}

function build_idp_CreatedStatusItem(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'firstUsed', data.firstUsed);
  PUSHATTR(attr, 'ref', data.ref);
  PUSHATTR(attr, 'used', data.used);


  return TAG('idp:CreatedStatusItem', attr, body);
}




function parse_idp_CreatedStatusResponse(data, x) {

  tag = find_xml_local(x[2], 'Status', 1);
  h =  hash [];
  parse_lu_Status(h, aux1);
  data{'Status'} = h;

}

function build_idp_CreatedStatusResponse(data) {
  attr = [];
  body = [];

  push body, build_lu_Status(data{'Status'});

  return TAG('idp:CreatedStatusResponse', attr, body);
}




function parse_idp_GetAssertion(data, x) {
  POPATTR(x[1], 'purpose', data.purpose);

  for (i=1; tag = find_xml_local(x[2], 'AuthnRequest', i); ++i) {
    h =  hash [];
    parse_sp_AuthnRequest(h, tag);
    push data{'AuthnRequest'}, h;
  }

}

function build_idp_GetAssertion(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'purpose', data.purpose);

  for d(data{'AuthnRequest'}) push body,build_sp_AuthnRequest(d);

  return TAG('idp:GetAssertion', attr, body);
}




function parse_idp_GetAssertionResponse(data, x) {

  tag = find_xml_local(x[2], 'Status', 1);
  h =  hash [];
  parse_lu_Status(h, aux1);
  data{'Status'} = h;
  for (i=1; tag = find_xml_local(x[2], 'GetAssertionResponseItem', i); ++i) {
    h =  hash [];
    parse_idp_GetAssertionResponseItem(h, tag);
    push data{'GetAssertionResponseItem'}, h;
  }

}

function build_idp_GetAssertionResponse(data) {
  attr = [];
  body = [];

  push body, build_lu_Status(data{'Status'});
  for d(data{'GetAssertionResponseItem'}) push body,build_idp_GetAssertionResponseItem(d);

  return TAG('idp:GetAssertionResponse', attr, body);
}




function parse_idp_GetAssertionResponseItem(data, x) {
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'ref', data.ref);

  for (i=1; tag = find_xml_local(x[2], 'AssertionItem', i); ++i) {
    h =  hash [];
    parse_idp_AssertionItem(h, tag);
    push data{'AssertionItem'}, h;
  }

}

function build_idp_GetAssertionResponseItem(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'ref', data.ref);

  for d(data{'AssertionItem'}) push body,build_idp_AssertionItem(d);

  return TAG('idp:GetAssertionResponseItem', attr, body);
}




function parse_idp_GetProviderInfo(data, x) {
  POPATTR(x[1], 'all', data.all);

  for (i=1; tag = find_xml_local(x[2], 'ProviderID', i); ++i)
    push data{'ProviderID'}, tag[2];

}

function build_idp_GetProviderInfo(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'all', data.all);

  for d(data{'ProviderID'})PUSHTAG_RAW(body,'ProviderID',d);

  return TAG('idp:GetProviderInfo', attr, body);
}




function parse_idp_GetProviderInfoResponse(data, x) {

  tag = find_xml_local(x[2], 'Status', 1);
  h =  hash [];
  parse_lu_Status(h, aux1);
  data{'Status'} = h;
  for (i=1; tag = find_xml_local(x[2], 'ProviderInfo', i); ++i) {
    h =  hash [];
    parse_idp_ProviderInfo(h, tag);
    push data{'ProviderInfo'}, h;
  }

}

function build_idp_GetProviderInfoResponse(data) {
  attr = [];
  body = [];

  push body, build_lu_Status(data{'Status'});
  for d(data{'ProviderInfo'}) push body,build_idp_ProviderInfo(d);

  return TAG('idp:GetProviderInfoResponse', attr, body);
}




function parse_idp_MEDInfo(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'NameID', i); ++i) {
    h =  hash [];
    parse_sa_NameID(h, tag);
    push data{'NameID'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'AttributeStatement', i); ++i) {
    h =  hash [];
    parse_sa_AttributeStatement(h, tag);
    push data{'AttributeStatement'}, h;
  }

}

function build_idp_MEDInfo(data) {
  attr = [];
  body = [];

  for d(data{'NameID'}) push body,build_sa_NameID(d);
  for d(data{'AttributeStatement'}) push body,build_sa_AttributeStatement(d);

  return TAG('idp:MEDInfo', attr, body);
}




function parse_idp_ProviderInfo(data, x) {
  POPATTR(x[1], 'name', data.name);
  POPATTR(x[1], 'providerID', data.providerID);


}

function build_idp_ProviderInfo(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'name', data.name);
  PUSHATTR(attr, 'providerID', data.providerID);


  return TAG('idp:ProviderInfo', attr, body);
}




function parse_idp_SubjectRestriction(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'Subject', i); ++i) {
    h =  hash [];
    parse_sa_Subject(h, tag);
    push data{'Subject'}, h;
  }

}

function build_idp_SubjectRestriction(data) {
  attr = [];
  body = [];

  for d(data{'Subject'}) push body,build_sa_Subject(d);

  return TAG('idp:SubjectRestriction', attr, body);
}


/* EOF -- c/zx-idp.ds */
