/* c/zx-xa-aux.c - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** aux-templ.c  -  Auxiliary functions template: cloning, freeing, walking data
 ** Copyright (c) 2010 Sampo Kellomaki (sampo@iki.fi), All Rights Reserved.
 ** Copyright (c) 2006 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: aux-templ.c,v 1.12 2008-10-04 23:42:14 sampo Exp $
 **
 ** 30.5.2006, created, Sampo Kellomaki (sampo@iki.fi)
 ** 6.8.2006, factored from enc-templ.c to separate file --Sampo
 **
 ** N.B: wo=wire order (needed for exc-c14n), so=schema order
 **/

#include <memory.h>
#include "errmac.h"
#include "zx.h"
#include "c/zx-const.h"
#include "c/zx-data.h"
#include "c/zx-xa-data.h"



#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Action
#define EL_STRUCT zx_xa_Action_s
#define EL_NS     xa
#define EL_TAG    Action

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Action) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Action(struct zx_ctx* c, struct zx_xa_Action_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ActionMatch->gg;
       se && se->g.tok == zx_xa_ActionMatch_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_ActionMatch(c, (struct zx_xa_ActionMatch_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Action) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Action_s* zx_DEEP_CLONE_xa_Action(struct zx_ctx* c, struct zx_xa_Action_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Action_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Action_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ActionMatch->gg;
       e && e->g.tok == zx_xa_ActionMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_ActionMatch(c,(struct zx_xa_ActionMatch_s*)e,dup_strs);
  	  if (!enn)
  	      x->ActionMatch = (struct zx_xa_ActionMatch_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Action) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Action(struct zx_ctx* c, struct zx_xa_Action_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ActionMatch->gg;
       e && e->g.tok == zx_xa_ActionMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_ActionMatch(c, (struct zx_xa_ActionMatch_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Action) */

int zx_WALK_WO_xa_Action(struct zx_ctx* c, struct zx_xa_Action_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_ActionAttributeDesignator
#define EL_STRUCT zx_xa_ActionAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    ActionAttributeDesignator

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_ActionAttributeDesignator) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_ActionAttributeDesignator(struct zx_ctx* c, struct zx_xa_ActionAttributeDesignator_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->AttributeId);
  zx_dup_attr(c, x->DataType);
  zx_dup_attr(c, x->Issuer);
  zx_dup_attr(c, x->MustBePresent);


}

/* FUNC(zx_DEEP_CLONE_xa_ActionAttributeDesignator) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_ActionAttributeDesignator_s* zx_DEEP_CLONE_xa_ActionAttributeDesignator(struct zx_ctx* c, struct zx_xa_ActionAttributeDesignator_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_ActionAttributeDesignator_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_ActionAttributeDesignator_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->AttributeId = zx_clone_attr(c, x->AttributeId);
  x->DataType = zx_clone_attr(c, x->DataType);
  x->Issuer = zx_clone_attr(c, x->Issuer);
  x->MustBePresent = zx_clone_attr(c, x->MustBePresent);


  return x;
}

/* FUNC(zx_WALK_SO_xa_ActionAttributeDesignator) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_ActionAttributeDesignator(struct zx_ctx* c, struct zx_xa_ActionAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_ActionAttributeDesignator) */

int zx_WALK_WO_xa_ActionAttributeDesignator(struct zx_ctx* c, struct zx_xa_ActionAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_ActionMatch
#define EL_STRUCT zx_xa_ActionMatch_s
#define EL_NS     xa
#define EL_TAG    ActionMatch

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_ActionMatch) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_ActionMatch(struct zx_ctx* c, struct zx_xa_ActionMatch_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->MatchId);

  for (se = &x->AttributeValue->gg;
       se && se->g.tok == zx_xa_AttributeValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)se);
  for (se = &x->ActionAttributeDesignator->gg;
       se && se->g.tok == zx_xa_ActionAttributeDesignator_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_ActionAttributeDesignator(c, (struct zx_xa_ActionAttributeDesignator_s*)se);
  for (se = &x->AttributeSelector->gg;
       se && se->g.tok == zx_xa_AttributeSelector_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_ActionMatch) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_ActionMatch_s* zx_DEEP_CLONE_xa_ActionMatch(struct zx_ctx* c, struct zx_xa_ActionMatch_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_ActionMatch_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_ActionMatch_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->MatchId = zx_clone_attr(c, x->MatchId);

  for (enn = 0, e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeValue(c,(struct zx_xa_AttributeValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeValue = (struct zx_xa_AttributeValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ActionAttributeDesignator->gg;
       e && e->g.tok == zx_xa_ActionAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_ActionAttributeDesignator(c,(struct zx_xa_ActionAttributeDesignator_s*)e,dup_strs);
  	  if (!enn)
  	      x->ActionAttributeDesignator = (struct zx_xa_ActionAttributeDesignator_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeSelector(c,(struct zx_xa_AttributeSelector_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_ActionMatch) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_ActionMatch(struct zx_ctx* c, struct zx_xa_ActionMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ActionAttributeDesignator->gg;
       e && e->g.tok == zx_xa_ActionAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_ActionAttributeDesignator(c, (struct zx_xa_ActionAttributeDesignator_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_ActionMatch) */

int zx_WALK_WO_xa_ActionMatch(struct zx_ctx* c, struct zx_xa_ActionMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Actions
#define EL_STRUCT zx_xa_Actions_s
#define EL_NS     xa
#define EL_TAG    Actions

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Actions) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Actions(struct zx_ctx* c, struct zx_xa_Actions_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Action->gg;
       se && se->g.tok == zx_xa_Action_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Action(c, (struct zx_xa_Action_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Actions) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Actions_s* zx_DEEP_CLONE_xa_Actions(struct zx_ctx* c, struct zx_xa_Actions_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Actions_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Actions_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Action->gg;
       e && e->g.tok == zx_xa_Action_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Action(c,(struct zx_xa_Action_s*)e,dup_strs);
  	  if (!enn)
  	      x->Action = (struct zx_xa_Action_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Actions) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Actions(struct zx_ctx* c, struct zx_xa_Actions_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Action->gg;
       e && e->g.tok == zx_xa_Action_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Action(c, (struct zx_xa_Action_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Actions) */

int zx_WALK_WO_xa_Actions(struct zx_ctx* c, struct zx_xa_Actions_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Apply
#define EL_STRUCT zx_xa_Apply_s
#define EL_NS     xa
#define EL_TAG    Apply

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Apply) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Apply(struct zx_ctx* c, struct zx_xa_Apply_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->FunctionId);

  zx_dup_strs_simple_elems(c, x->Expression);

}

/* FUNC(zx_DEEP_CLONE_xa_Apply) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Apply_s* zx_DEEP_CLONE_xa_Apply(struct zx_ctx* c, struct zx_xa_Apply_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Apply_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Apply_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->FunctionId = zx_clone_attr(c, x->FunctionId);

  x->Expression = zx_deep_clone_simple_elems(c,x->Expression, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_xa_Apply) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Apply(struct zx_ctx* c, struct zx_xa_Apply_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Expression, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Apply) */

int zx_WALK_WO_xa_Apply(struct zx_ctx* c, struct zx_xa_Apply_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_AttributeAssignment
#define EL_STRUCT zx_xa_AttributeAssignment_s
#define EL_NS     xa
#define EL_TAG    AttributeAssignment

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_AttributeAssignment) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_AttributeAssignment(struct zx_ctx* c, struct zx_xa_AttributeAssignment_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->AttributeId);
  zx_dup_attr(c, x->DataType);


}

/* FUNC(zx_DEEP_CLONE_xa_AttributeAssignment) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_AttributeAssignment_s* zx_DEEP_CLONE_xa_AttributeAssignment(struct zx_ctx* c, struct zx_xa_AttributeAssignment_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_AttributeAssignment_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_AttributeAssignment_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->AttributeId = zx_clone_attr(c, x->AttributeId);
  x->DataType = zx_clone_attr(c, x->DataType);


  return x;
}

/* FUNC(zx_WALK_SO_xa_AttributeAssignment) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_AttributeAssignment(struct zx_ctx* c, struct zx_xa_AttributeAssignment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_AttributeAssignment) */

int zx_WALK_WO_xa_AttributeAssignment(struct zx_ctx* c, struct zx_xa_AttributeAssignment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_AttributeSelector
#define EL_STRUCT zx_xa_AttributeSelector_s
#define EL_NS     xa
#define EL_TAG    AttributeSelector

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_AttributeSelector) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_AttributeSelector(struct zx_ctx* c, struct zx_xa_AttributeSelector_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->DataType);
  zx_dup_attr(c, x->MustBePresent);
  zx_dup_attr(c, x->RequestContextPath);


}

/* FUNC(zx_DEEP_CLONE_xa_AttributeSelector) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_AttributeSelector_s* zx_DEEP_CLONE_xa_AttributeSelector(struct zx_ctx* c, struct zx_xa_AttributeSelector_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_AttributeSelector_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_AttributeSelector_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->DataType = zx_clone_attr(c, x->DataType);
  x->MustBePresent = zx_clone_attr(c, x->MustBePresent);
  x->RequestContextPath = zx_clone_attr(c, x->RequestContextPath);


  return x;
}

/* FUNC(zx_WALK_SO_xa_AttributeSelector) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_AttributeSelector(struct zx_ctx* c, struct zx_xa_AttributeSelector_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_AttributeSelector) */

int zx_WALK_WO_xa_AttributeSelector(struct zx_ctx* c, struct zx_xa_AttributeSelector_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_AttributeValue
#define EL_STRUCT zx_xa_AttributeValue_s
#define EL_NS     xa
#define EL_TAG    AttributeValue

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_AttributeValue) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_AttributeValue(struct zx_ctx* c, struct zx_xa_AttributeValue_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->DataType);


}

/* FUNC(zx_DEEP_CLONE_xa_AttributeValue) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_AttributeValue_s* zx_DEEP_CLONE_xa_AttributeValue(struct zx_ctx* c, struct zx_xa_AttributeValue_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_AttributeValue_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_AttributeValue_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->DataType = zx_clone_attr(c, x->DataType);


  return x;
}

/* FUNC(zx_WALK_SO_xa_AttributeValue) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_AttributeValue(struct zx_ctx* c, struct zx_xa_AttributeValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_AttributeValue) */

int zx_WALK_WO_xa_AttributeValue(struct zx_ctx* c, struct zx_xa_AttributeValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_CombinerParameter
#define EL_STRUCT zx_xa_CombinerParameter_s
#define EL_NS     xa
#define EL_TAG    CombinerParameter

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_CombinerParameter) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_CombinerParameter(struct zx_ctx* c, struct zx_xa_CombinerParameter_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->ParameterName);

  for (se = &x->AttributeValue->gg;
       se && se->g.tok == zx_xa_AttributeValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_CombinerParameter) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_CombinerParameter_s* zx_DEEP_CLONE_xa_CombinerParameter(struct zx_ctx* c, struct zx_xa_CombinerParameter_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_CombinerParameter_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_CombinerParameter_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->ParameterName = zx_clone_attr(c, x->ParameterName);

  for (enn = 0, e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeValue(c,(struct zx_xa_AttributeValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeValue = (struct zx_xa_AttributeValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_CombinerParameter) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_CombinerParameter(struct zx_ctx* c, struct zx_xa_CombinerParameter_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_CombinerParameter) */

int zx_WALK_WO_xa_CombinerParameter(struct zx_ctx* c, struct zx_xa_CombinerParameter_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_CombinerParameters
#define EL_STRUCT zx_xa_CombinerParameters_s
#define EL_NS     xa
#define EL_TAG    CombinerParameters

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_CombinerParameters) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_CombinerParameters(struct zx_ctx* c, struct zx_xa_CombinerParameters_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->CombinerParameter->gg;
       se && se->g.tok == zx_xa_CombinerParameter_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_CombinerParameters) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_CombinerParameters_s* zx_DEEP_CLONE_xa_CombinerParameters(struct zx_ctx* c, struct zx_xa_CombinerParameters_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_CombinerParameters_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_CombinerParameters_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameter(c,(struct zx_xa_CombinerParameter_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_CombinerParameters) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_CombinerParameters(struct zx_ctx* c, struct zx_xa_CombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_CombinerParameters) */

int zx_WALK_WO_xa_CombinerParameters(struct zx_ctx* c, struct zx_xa_CombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Condition
#define EL_STRUCT zx_xa_Condition_s
#define EL_NS     xa
#define EL_TAG    Condition

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Condition) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Condition(struct zx_ctx* c, struct zx_xa_Condition_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Expression);

}

/* FUNC(zx_DEEP_CLONE_xa_Condition) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Condition_s* zx_DEEP_CLONE_xa_Condition(struct zx_ctx* c, struct zx_xa_Condition_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Condition_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Condition_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Expression = zx_deep_clone_simple_elems(c,x->Expression, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_xa_Condition) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Condition(struct zx_ctx* c, struct zx_xa_Condition_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Expression, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Condition) */

int zx_WALK_WO_xa_Condition(struct zx_ctx* c, struct zx_xa_Condition_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Environment
#define EL_STRUCT zx_xa_Environment_s
#define EL_NS     xa
#define EL_TAG    Environment

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Environment) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Environment(struct zx_ctx* c, struct zx_xa_Environment_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->EnvironmentMatch->gg;
       se && se->g.tok == zx_xa_EnvironmentMatch_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_EnvironmentMatch(c, (struct zx_xa_EnvironmentMatch_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Environment) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Environment_s* zx_DEEP_CLONE_xa_Environment(struct zx_ctx* c, struct zx_xa_Environment_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Environment_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Environment_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->EnvironmentMatch->gg;
       e && e->g.tok == zx_xa_EnvironmentMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_EnvironmentMatch(c,(struct zx_xa_EnvironmentMatch_s*)e,dup_strs);
  	  if (!enn)
  	      x->EnvironmentMatch = (struct zx_xa_EnvironmentMatch_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Environment) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Environment(struct zx_ctx* c, struct zx_xa_Environment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->EnvironmentMatch->gg;
       e && e->g.tok == zx_xa_EnvironmentMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_EnvironmentMatch(c, (struct zx_xa_EnvironmentMatch_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Environment) */

int zx_WALK_WO_xa_Environment(struct zx_ctx* c, struct zx_xa_Environment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_EnvironmentAttributeDesignator
#define EL_STRUCT zx_xa_EnvironmentAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    EnvironmentAttributeDesignator

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_EnvironmentAttributeDesignator) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_EnvironmentAttributeDesignator(struct zx_ctx* c, struct zx_xa_EnvironmentAttributeDesignator_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->AttributeId);
  zx_dup_attr(c, x->DataType);
  zx_dup_attr(c, x->Issuer);
  zx_dup_attr(c, x->MustBePresent);


}

/* FUNC(zx_DEEP_CLONE_xa_EnvironmentAttributeDesignator) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_EnvironmentAttributeDesignator_s* zx_DEEP_CLONE_xa_EnvironmentAttributeDesignator(struct zx_ctx* c, struct zx_xa_EnvironmentAttributeDesignator_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_EnvironmentAttributeDesignator_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_EnvironmentAttributeDesignator_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->AttributeId = zx_clone_attr(c, x->AttributeId);
  x->DataType = zx_clone_attr(c, x->DataType);
  x->Issuer = zx_clone_attr(c, x->Issuer);
  x->MustBePresent = zx_clone_attr(c, x->MustBePresent);


  return x;
}

/* FUNC(zx_WALK_SO_xa_EnvironmentAttributeDesignator) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_EnvironmentAttributeDesignator(struct zx_ctx* c, struct zx_xa_EnvironmentAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_EnvironmentAttributeDesignator) */

int zx_WALK_WO_xa_EnvironmentAttributeDesignator(struct zx_ctx* c, struct zx_xa_EnvironmentAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_EnvironmentMatch
#define EL_STRUCT zx_xa_EnvironmentMatch_s
#define EL_NS     xa
#define EL_TAG    EnvironmentMatch

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_EnvironmentMatch) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_EnvironmentMatch(struct zx_ctx* c, struct zx_xa_EnvironmentMatch_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->MatchId);

  for (se = &x->AttributeValue->gg;
       se && se->g.tok == zx_xa_AttributeValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)se);
  for (se = &x->EnvironmentAttributeDesignator->gg;
       se && se->g.tok == zx_xa_EnvironmentAttributeDesignator_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_EnvironmentAttributeDesignator(c, (struct zx_xa_EnvironmentAttributeDesignator_s*)se);
  for (se = &x->AttributeSelector->gg;
       se && se->g.tok == zx_xa_AttributeSelector_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_EnvironmentMatch) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_EnvironmentMatch_s* zx_DEEP_CLONE_xa_EnvironmentMatch(struct zx_ctx* c, struct zx_xa_EnvironmentMatch_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_EnvironmentMatch_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_EnvironmentMatch_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->MatchId = zx_clone_attr(c, x->MatchId);

  for (enn = 0, e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeValue(c,(struct zx_xa_AttributeValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeValue = (struct zx_xa_AttributeValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EnvironmentAttributeDesignator->gg;
       e && e->g.tok == zx_xa_EnvironmentAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_EnvironmentAttributeDesignator(c,(struct zx_xa_EnvironmentAttributeDesignator_s*)e,dup_strs);
  	  if (!enn)
  	      x->EnvironmentAttributeDesignator = (struct zx_xa_EnvironmentAttributeDesignator_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeSelector(c,(struct zx_xa_AttributeSelector_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_EnvironmentMatch) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_EnvironmentMatch(struct zx_ctx* c, struct zx_xa_EnvironmentMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EnvironmentAttributeDesignator->gg;
       e && e->g.tok == zx_xa_EnvironmentAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_EnvironmentAttributeDesignator(c, (struct zx_xa_EnvironmentAttributeDesignator_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_EnvironmentMatch) */

int zx_WALK_WO_xa_EnvironmentMatch(struct zx_ctx* c, struct zx_xa_EnvironmentMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Environments
#define EL_STRUCT zx_xa_Environments_s
#define EL_NS     xa
#define EL_TAG    Environments

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Environments) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Environments(struct zx_ctx* c, struct zx_xa_Environments_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Environment->gg;
       se && se->g.tok == zx_xa_Environment_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Environment(c, (struct zx_xa_Environment_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Environments) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Environments_s* zx_DEEP_CLONE_xa_Environments(struct zx_ctx* c, struct zx_xa_Environments_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Environments_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Environments_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Environment->gg;
       e && e->g.tok == zx_xa_Environment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Environment(c,(struct zx_xa_Environment_s*)e,dup_strs);
  	  if (!enn)
  	      x->Environment = (struct zx_xa_Environment_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Environments) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Environments(struct zx_ctx* c, struct zx_xa_Environments_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Environment->gg;
       e && e->g.tok == zx_xa_Environment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Environment(c, (struct zx_xa_Environment_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Environments) */

int zx_WALK_WO_xa_Environments(struct zx_ctx* c, struct zx_xa_Environments_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Function
#define EL_STRUCT zx_xa_Function_s
#define EL_NS     xa
#define EL_TAG    Function

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Function) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Function(struct zx_ctx* c, struct zx_xa_Function_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->FunctionId);


}

/* FUNC(zx_DEEP_CLONE_xa_Function) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Function_s* zx_DEEP_CLONE_xa_Function(struct zx_ctx* c, struct zx_xa_Function_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Function_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Function_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->FunctionId = zx_clone_attr(c, x->FunctionId);


  return x;
}

/* FUNC(zx_WALK_SO_xa_Function) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Function(struct zx_ctx* c, struct zx_xa_Function_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Function) */

int zx_WALK_WO_xa_Function(struct zx_ctx* c, struct zx_xa_Function_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Obligation
#define EL_STRUCT zx_xa_Obligation_s
#define EL_NS     xa
#define EL_TAG    Obligation

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Obligation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Obligation(struct zx_ctx* c, struct zx_xa_Obligation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->FulfillOn);
  zx_dup_attr(c, x->ObligationId);

  for (se = &x->AttributeAssignment->gg;
       se && se->g.tok == zx_xa_AttributeAssignment_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeAssignment(c, (struct zx_xa_AttributeAssignment_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Obligation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Obligation_s* zx_DEEP_CLONE_xa_Obligation(struct zx_ctx* c, struct zx_xa_Obligation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Obligation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Obligation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->FulfillOn = zx_clone_attr(c, x->FulfillOn);
  x->ObligationId = zx_clone_attr(c, x->ObligationId);

  for (enn = 0, e = &x->AttributeAssignment->gg;
       e && e->g.tok == zx_xa_AttributeAssignment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeAssignment(c,(struct zx_xa_AttributeAssignment_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeAssignment = (struct zx_xa_AttributeAssignment_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Obligation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Obligation(struct zx_ctx* c, struct zx_xa_Obligation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeAssignment->gg;
       e && e->g.tok == zx_xa_AttributeAssignment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeAssignment(c, (struct zx_xa_AttributeAssignment_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Obligation) */

int zx_WALK_WO_xa_Obligation(struct zx_ctx* c, struct zx_xa_Obligation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Obligations
#define EL_STRUCT zx_xa_Obligations_s
#define EL_NS     xa
#define EL_TAG    Obligations

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Obligations) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Obligations(struct zx_ctx* c, struct zx_xa_Obligations_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Obligation->gg;
       se && se->g.tok == zx_xa_Obligation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Obligation(c, (struct zx_xa_Obligation_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Obligations) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Obligations_s* zx_DEEP_CLONE_xa_Obligations(struct zx_ctx* c, struct zx_xa_Obligations_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Obligations_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Obligations_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Obligation->gg;
       e && e->g.tok == zx_xa_Obligation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Obligation(c,(struct zx_xa_Obligation_s*)e,dup_strs);
  	  if (!enn)
  	      x->Obligation = (struct zx_xa_Obligation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Obligations) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Obligations(struct zx_ctx* c, struct zx_xa_Obligations_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Obligation->gg;
       e && e->g.tok == zx_xa_Obligation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Obligation(c, (struct zx_xa_Obligation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Obligations) */

int zx_WALK_WO_xa_Obligations(struct zx_ctx* c, struct zx_xa_Obligations_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Policy
#define EL_STRUCT zx_xa_Policy_s
#define EL_NS     xa
#define EL_TAG    Policy

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Policy) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Policy(struct zx_ctx* c, struct zx_xa_Policy_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->PolicyId);
  zx_dup_attr(c, x->RuleCombiningAlgId);
  zx_dup_attr(c, x->Version);

  zx_dup_strs_simple_elems(c, x->Description);
  for (se = &x->PolicyDefaults->gg;
       se && se->g.tok == zx_xa_PolicyDefaults_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicyDefaults(c, (struct zx_xa_PolicyDefaults_s*)se);
  for (se = &x->Target->gg;
       se && se->g.tok == zx_xa_Target_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Target(c, (struct zx_xa_Target_s*)se);
  for (se = &x->CombinerParameters->gg;
       se && se->g.tok == zx_xa_CombinerParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)se);
  for (se = &x->RuleCombinerParameters->gg;
       se && se->g.tok == zx_xa_RuleCombinerParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_RuleCombinerParameters(c, (struct zx_xa_RuleCombinerParameters_s*)se);
  for (se = &x->VariableDefinition->gg;
       se && se->g.tok == zx_xa_VariableDefinition_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_VariableDefinition(c, (struct zx_xa_VariableDefinition_s*)se);
  for (se = &x->Rule->gg;
       se && se->g.tok == zx_xa_Rule_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Rule(c, (struct zx_xa_Rule_s*)se);
  for (se = &x->Obligations->gg;
       se && se->g.tok == zx_xa_Obligations_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Obligations(c, (struct zx_xa_Obligations_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Policy) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Policy_s* zx_DEEP_CLONE_xa_Policy(struct zx_ctx* c, struct zx_xa_Policy_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Policy_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Policy_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->PolicyId = zx_clone_attr(c, x->PolicyId);
  x->RuleCombiningAlgId = zx_clone_attr(c, x->RuleCombiningAlgId);
  x->Version = zx_clone_attr(c, x->Version);

  x->Description = zx_deep_clone_simple_elems(c,x->Description, dup_strs);
  for (enn = 0, e = &x->PolicyDefaults->gg;
       e && e->g.tok == zx_xa_PolicyDefaults_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicyDefaults(c,(struct zx_xa_PolicyDefaults_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicyDefaults = (struct zx_xa_PolicyDefaults_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Target(c,(struct zx_xa_Target_s*)e,dup_strs);
  	  if (!enn)
  	      x->Target = (struct zx_xa_Target_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CombinerParameters->gg;
       e && e->g.tok == zx_xa_CombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameters(c,(struct zx_xa_CombinerParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameters = (struct zx_xa_CombinerParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RuleCombinerParameters->gg;
       e && e->g.tok == zx_xa_RuleCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_RuleCombinerParameters(c,(struct zx_xa_RuleCombinerParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->RuleCombinerParameters = (struct zx_xa_RuleCombinerParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->VariableDefinition->gg;
       e && e->g.tok == zx_xa_VariableDefinition_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_VariableDefinition(c,(struct zx_xa_VariableDefinition_s*)e,dup_strs);
  	  if (!enn)
  	      x->VariableDefinition = (struct zx_xa_VariableDefinition_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Rule->gg;
       e && e->g.tok == zx_xa_Rule_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Rule(c,(struct zx_xa_Rule_s*)e,dup_strs);
  	  if (!enn)
  	      x->Rule = (struct zx_xa_Rule_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Obligations->gg;
       e && e->g.tok == zx_xa_Obligations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Obligations(c,(struct zx_xa_Obligations_s*)e,dup_strs);
  	  if (!enn)
  	      x->Obligations = (struct zx_xa_Obligations_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Policy) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Policy(struct zx_ctx* c, struct zx_xa_Policy_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Description, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PolicyDefaults->gg;
       e && e->g.tok == zx_xa_PolicyDefaults_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicyDefaults(c, (struct zx_xa_PolicyDefaults_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Target(c, (struct zx_xa_Target_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CombinerParameters->gg;
       e && e->g.tok == zx_xa_CombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RuleCombinerParameters->gg;
       e && e->g.tok == zx_xa_RuleCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_RuleCombinerParameters(c, (struct zx_xa_RuleCombinerParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->VariableDefinition->gg;
       e && e->g.tok == zx_xa_VariableDefinition_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_VariableDefinition(c, (struct zx_xa_VariableDefinition_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Rule->gg;
       e && e->g.tok == zx_xa_Rule_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Rule(c, (struct zx_xa_Rule_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Obligations->gg;
       e && e->g.tok == zx_xa_Obligations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Obligations(c, (struct zx_xa_Obligations_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Policy) */

int zx_WALK_WO_xa_Policy(struct zx_ctx* c, struct zx_xa_Policy_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicyCombinerParameters
#define EL_STRUCT zx_xa_PolicyCombinerParameters_s
#define EL_NS     xa
#define EL_TAG    PolicyCombinerParameters

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicyCombinerParameters) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicyCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicyCombinerParameters_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->PolicyIdRef);

  for (se = &x->CombinerParameter->gg;
       se && se->g.tok == zx_xa_CombinerParameter_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_PolicyCombinerParameters) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicyCombinerParameters_s* zx_DEEP_CLONE_xa_PolicyCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicyCombinerParameters_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicyCombinerParameters_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicyCombinerParameters_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->PolicyIdRef = zx_clone_attr(c, x->PolicyIdRef);

  for (enn = 0, e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameter(c,(struct zx_xa_CombinerParameter_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicyCombinerParameters) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicyCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicyCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicyCombinerParameters) */

int zx_WALK_WO_xa_PolicyCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicyCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicyDefaults
#define EL_STRUCT zx_xa_PolicyDefaults_s
#define EL_NS     xa
#define EL_TAG    PolicyDefaults

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicyDefaults) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicyDefaults(struct zx_ctx* c, struct zx_xa_PolicyDefaults_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->XPathVersion);

}

/* FUNC(zx_DEEP_CLONE_xa_PolicyDefaults) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicyDefaults_s* zx_DEEP_CLONE_xa_PolicyDefaults(struct zx_ctx* c, struct zx_xa_PolicyDefaults_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicyDefaults_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicyDefaults_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->XPathVersion = zx_deep_clone_simple_elems(c,x->XPathVersion, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicyDefaults) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicyDefaults(struct zx_ctx* c, struct zx_xa_PolicyDefaults_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->XPathVersion, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicyDefaults) */

int zx_WALK_WO_xa_PolicyDefaults(struct zx_ctx* c, struct zx_xa_PolicyDefaults_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicyIdReference
#define EL_STRUCT zx_xa_PolicyIdReference_s
#define EL_NS     xa
#define EL_TAG    PolicyIdReference

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicyIdReference) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicyIdReference(struct zx_ctx* c, struct zx_xa_PolicyIdReference_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->EarliestVersion);
  zx_dup_attr(c, x->LatestVersion);
  zx_dup_attr(c, x->Version);


}

/* FUNC(zx_DEEP_CLONE_xa_PolicyIdReference) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicyIdReference_s* zx_DEEP_CLONE_xa_PolicyIdReference(struct zx_ctx* c, struct zx_xa_PolicyIdReference_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicyIdReference_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicyIdReference_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->EarliestVersion = zx_clone_attr(c, x->EarliestVersion);
  x->LatestVersion = zx_clone_attr(c, x->LatestVersion);
  x->Version = zx_clone_attr(c, x->Version);


  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicyIdReference) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicyIdReference(struct zx_ctx* c, struct zx_xa_PolicyIdReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicyIdReference) */

int zx_WALK_WO_xa_PolicyIdReference(struct zx_ctx* c, struct zx_xa_PolicyIdReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicySet
#define EL_STRUCT zx_xa_PolicySet_s
#define EL_NS     xa
#define EL_TAG    PolicySet

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicySet) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicySet(struct zx_ctx* c, struct zx_xa_PolicySet_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->PolicyCombiningAlgId);
  zx_dup_attr(c, x->PolicySetId);
  zx_dup_attr(c, x->Version);

  zx_dup_strs_simple_elems(c, x->Description);
  for (se = &x->PolicySetDefaults->gg;
       se && se->g.tok == zx_xa_PolicySetDefaults_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicySetDefaults(c, (struct zx_xa_PolicySetDefaults_s*)se);
  for (se = &x->Target->gg;
       se && se->g.tok == zx_xa_Target_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Target(c, (struct zx_xa_Target_s*)se);
  for (se = &x->PolicySet->gg;
       se && se->g.tok == zx_xa_PolicySet_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicySet(c, (struct zx_xa_PolicySet_s*)se);
  for (se = &x->Policy->gg;
       se && se->g.tok == zx_xa_Policy_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Policy(c, (struct zx_xa_Policy_s*)se);
  for (se = &x->PolicySetIdReference->gg;
       se && se->g.tok == zx_xa_PolicySetIdReference_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicySetIdReference(c, (struct zx_xa_PolicySetIdReference_s*)se);
  for (se = &x->PolicyIdReference->gg;
       se && se->g.tok == zx_xa_PolicyIdReference_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicyIdReference(c, (struct zx_xa_PolicyIdReference_s*)se);
  for (se = &x->CombinerParameters->gg;
       se && se->g.tok == zx_xa_CombinerParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)se);
  for (se = &x->PolicyCombinerParameters->gg;
       se && se->g.tok == zx_xa_PolicyCombinerParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicyCombinerParameters(c, (struct zx_xa_PolicyCombinerParameters_s*)se);
  for (se = &x->PolicySetCombinerParameters->gg;
       se && se->g.tok == zx_xa_PolicySetCombinerParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicySetCombinerParameters(c, (struct zx_xa_PolicySetCombinerParameters_s*)se);
  for (se = &x->Obligations->gg;
       se && se->g.tok == zx_xa_Obligations_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Obligations(c, (struct zx_xa_Obligations_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_PolicySet) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicySet_s* zx_DEEP_CLONE_xa_PolicySet(struct zx_ctx* c, struct zx_xa_PolicySet_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicySet_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicySet_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->PolicyCombiningAlgId = zx_clone_attr(c, x->PolicyCombiningAlgId);
  x->PolicySetId = zx_clone_attr(c, x->PolicySetId);
  x->Version = zx_clone_attr(c, x->Version);

  x->Description = zx_deep_clone_simple_elems(c,x->Description, dup_strs);
  for (enn = 0, e = &x->PolicySetDefaults->gg;
       e && e->g.tok == zx_xa_PolicySetDefaults_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicySetDefaults(c,(struct zx_xa_PolicySetDefaults_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicySetDefaults = (struct zx_xa_PolicySetDefaults_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Target(c,(struct zx_xa_Target_s*)e,dup_strs);
  	  if (!enn)
  	      x->Target = (struct zx_xa_Target_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PolicySet->gg;
       e && e->g.tok == zx_xa_PolicySet_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicySet(c,(struct zx_xa_PolicySet_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicySet = (struct zx_xa_PolicySet_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Policy->gg;
       e && e->g.tok == zx_xa_Policy_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Policy(c,(struct zx_xa_Policy_s*)e,dup_strs);
  	  if (!enn)
  	      x->Policy = (struct zx_xa_Policy_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PolicySetIdReference->gg;
       e && e->g.tok == zx_xa_PolicySetIdReference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicySetIdReference(c,(struct zx_xa_PolicySetIdReference_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicySetIdReference = (struct zx_xa_PolicySetIdReference_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PolicyIdReference->gg;
       e && e->g.tok == zx_xa_PolicyIdReference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicyIdReference(c,(struct zx_xa_PolicyIdReference_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicyIdReference = (struct zx_xa_PolicyIdReference_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CombinerParameters->gg;
       e && e->g.tok == zx_xa_CombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameters(c,(struct zx_xa_CombinerParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameters = (struct zx_xa_CombinerParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PolicyCombinerParameters->gg;
       e && e->g.tok == zx_xa_PolicyCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicyCombinerParameters(c,(struct zx_xa_PolicyCombinerParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicyCombinerParameters = (struct zx_xa_PolicyCombinerParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PolicySetCombinerParameters->gg;
       e && e->g.tok == zx_xa_PolicySetCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicySetCombinerParameters(c,(struct zx_xa_PolicySetCombinerParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicySetCombinerParameters = (struct zx_xa_PolicySetCombinerParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Obligations->gg;
       e && e->g.tok == zx_xa_Obligations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Obligations(c,(struct zx_xa_Obligations_s*)e,dup_strs);
  	  if (!enn)
  	      x->Obligations = (struct zx_xa_Obligations_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicySet) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicySet(struct zx_ctx* c, struct zx_xa_PolicySet_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Description, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PolicySetDefaults->gg;
       e && e->g.tok == zx_xa_PolicySetDefaults_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicySetDefaults(c, (struct zx_xa_PolicySetDefaults_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Target(c, (struct zx_xa_Target_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PolicySet->gg;
       e && e->g.tok == zx_xa_PolicySet_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicySet(c, (struct zx_xa_PolicySet_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Policy->gg;
       e && e->g.tok == zx_xa_Policy_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Policy(c, (struct zx_xa_Policy_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PolicySetIdReference->gg;
       e && e->g.tok == zx_xa_PolicySetIdReference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicySetIdReference(c, (struct zx_xa_PolicySetIdReference_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PolicyIdReference->gg;
       e && e->g.tok == zx_xa_PolicyIdReference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicyIdReference(c, (struct zx_xa_PolicyIdReference_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CombinerParameters->gg;
       e && e->g.tok == zx_xa_CombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PolicyCombinerParameters->gg;
       e && e->g.tok == zx_xa_PolicyCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicyCombinerParameters(c, (struct zx_xa_PolicyCombinerParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PolicySetCombinerParameters->gg;
       e && e->g.tok == zx_xa_PolicySetCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicySetCombinerParameters(c, (struct zx_xa_PolicySetCombinerParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Obligations->gg;
       e && e->g.tok == zx_xa_Obligations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Obligations(c, (struct zx_xa_Obligations_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicySet) */

int zx_WALK_WO_xa_PolicySet(struct zx_ctx* c, struct zx_xa_PolicySet_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicySetCombinerParameters
#define EL_STRUCT zx_xa_PolicySetCombinerParameters_s
#define EL_NS     xa
#define EL_TAG    PolicySetCombinerParameters

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicySetCombinerParameters) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicySetCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicySetCombinerParameters_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->PolicySetIdRef);

  for (se = &x->CombinerParameter->gg;
       se && se->g.tok == zx_xa_CombinerParameter_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_PolicySetCombinerParameters) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicySetCombinerParameters_s* zx_DEEP_CLONE_xa_PolicySetCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicySetCombinerParameters_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicySetCombinerParameters_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicySetCombinerParameters_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->PolicySetIdRef = zx_clone_attr(c, x->PolicySetIdRef);

  for (enn = 0, e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameter(c,(struct zx_xa_CombinerParameter_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicySetCombinerParameters) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicySetCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicySetCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicySetCombinerParameters) */

int zx_WALK_WO_xa_PolicySetCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicySetCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicySetDefaults
#define EL_STRUCT zx_xa_PolicySetDefaults_s
#define EL_NS     xa
#define EL_TAG    PolicySetDefaults

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicySetDefaults) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicySetDefaults(struct zx_ctx* c, struct zx_xa_PolicySetDefaults_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->XPathVersion);

}

/* FUNC(zx_DEEP_CLONE_xa_PolicySetDefaults) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicySetDefaults_s* zx_DEEP_CLONE_xa_PolicySetDefaults(struct zx_ctx* c, struct zx_xa_PolicySetDefaults_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicySetDefaults_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicySetDefaults_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->XPathVersion = zx_deep_clone_simple_elems(c,x->XPathVersion, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicySetDefaults) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicySetDefaults(struct zx_ctx* c, struct zx_xa_PolicySetDefaults_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->XPathVersion, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicySetDefaults) */

int zx_WALK_WO_xa_PolicySetDefaults(struct zx_ctx* c, struct zx_xa_PolicySetDefaults_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicySetIdReference
#define EL_STRUCT zx_xa_PolicySetIdReference_s
#define EL_NS     xa
#define EL_TAG    PolicySetIdReference

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicySetIdReference) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicySetIdReference(struct zx_ctx* c, struct zx_xa_PolicySetIdReference_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->EarliestVersion);
  zx_dup_attr(c, x->LatestVersion);
  zx_dup_attr(c, x->Version);


}

/* FUNC(zx_DEEP_CLONE_xa_PolicySetIdReference) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicySetIdReference_s* zx_DEEP_CLONE_xa_PolicySetIdReference(struct zx_ctx* c, struct zx_xa_PolicySetIdReference_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicySetIdReference_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicySetIdReference_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->EarliestVersion = zx_clone_attr(c, x->EarliestVersion);
  x->LatestVersion = zx_clone_attr(c, x->LatestVersion);
  x->Version = zx_clone_attr(c, x->Version);


  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicySetIdReference) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicySetIdReference(struct zx_ctx* c, struct zx_xa_PolicySetIdReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicySetIdReference) */

int zx_WALK_WO_xa_PolicySetIdReference(struct zx_ctx* c, struct zx_xa_PolicySetIdReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Resource
#define EL_STRUCT zx_xa_Resource_s
#define EL_NS     xa
#define EL_TAG    Resource

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Resource) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Resource(struct zx_ctx* c, struct zx_xa_Resource_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ResourceMatch->gg;
       se && se->g.tok == zx_xa_ResourceMatch_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_ResourceMatch(c, (struct zx_xa_ResourceMatch_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Resource) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Resource_s* zx_DEEP_CLONE_xa_Resource(struct zx_ctx* c, struct zx_xa_Resource_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Resource_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Resource_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ResourceMatch->gg;
       e && e->g.tok == zx_xa_ResourceMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_ResourceMatch(c,(struct zx_xa_ResourceMatch_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResourceMatch = (struct zx_xa_ResourceMatch_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Resource) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Resource(struct zx_ctx* c, struct zx_xa_Resource_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ResourceMatch->gg;
       e && e->g.tok == zx_xa_ResourceMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_ResourceMatch(c, (struct zx_xa_ResourceMatch_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Resource) */

int zx_WALK_WO_xa_Resource(struct zx_ctx* c, struct zx_xa_Resource_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_ResourceAttributeDesignator
#define EL_STRUCT zx_xa_ResourceAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    ResourceAttributeDesignator

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_ResourceAttributeDesignator) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_ResourceAttributeDesignator(struct zx_ctx* c, struct zx_xa_ResourceAttributeDesignator_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->AttributeId);
  zx_dup_attr(c, x->DataType);
  zx_dup_attr(c, x->Issuer);
  zx_dup_attr(c, x->MustBePresent);


}

/* FUNC(zx_DEEP_CLONE_xa_ResourceAttributeDesignator) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_ResourceAttributeDesignator_s* zx_DEEP_CLONE_xa_ResourceAttributeDesignator(struct zx_ctx* c, struct zx_xa_ResourceAttributeDesignator_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_ResourceAttributeDesignator_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_ResourceAttributeDesignator_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->AttributeId = zx_clone_attr(c, x->AttributeId);
  x->DataType = zx_clone_attr(c, x->DataType);
  x->Issuer = zx_clone_attr(c, x->Issuer);
  x->MustBePresent = zx_clone_attr(c, x->MustBePresent);


  return x;
}

/* FUNC(zx_WALK_SO_xa_ResourceAttributeDesignator) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_ResourceAttributeDesignator(struct zx_ctx* c, struct zx_xa_ResourceAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_ResourceAttributeDesignator) */

int zx_WALK_WO_xa_ResourceAttributeDesignator(struct zx_ctx* c, struct zx_xa_ResourceAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_ResourceMatch
#define EL_STRUCT zx_xa_ResourceMatch_s
#define EL_NS     xa
#define EL_TAG    ResourceMatch

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_ResourceMatch) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_ResourceMatch(struct zx_ctx* c, struct zx_xa_ResourceMatch_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->MatchId);

  for (se = &x->AttributeValue->gg;
       se && se->g.tok == zx_xa_AttributeValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)se);
  for (se = &x->ResourceAttributeDesignator->gg;
       se && se->g.tok == zx_xa_ResourceAttributeDesignator_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_ResourceAttributeDesignator(c, (struct zx_xa_ResourceAttributeDesignator_s*)se);
  for (se = &x->AttributeSelector->gg;
       se && se->g.tok == zx_xa_AttributeSelector_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_ResourceMatch) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_ResourceMatch_s* zx_DEEP_CLONE_xa_ResourceMatch(struct zx_ctx* c, struct zx_xa_ResourceMatch_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_ResourceMatch_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_ResourceMatch_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->MatchId = zx_clone_attr(c, x->MatchId);

  for (enn = 0, e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeValue(c,(struct zx_xa_AttributeValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeValue = (struct zx_xa_AttributeValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ResourceAttributeDesignator->gg;
       e && e->g.tok == zx_xa_ResourceAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_ResourceAttributeDesignator(c,(struct zx_xa_ResourceAttributeDesignator_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResourceAttributeDesignator = (struct zx_xa_ResourceAttributeDesignator_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeSelector(c,(struct zx_xa_AttributeSelector_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_ResourceMatch) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_ResourceMatch(struct zx_ctx* c, struct zx_xa_ResourceMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ResourceAttributeDesignator->gg;
       e && e->g.tok == zx_xa_ResourceAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_ResourceAttributeDesignator(c, (struct zx_xa_ResourceAttributeDesignator_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_ResourceMatch) */

int zx_WALK_WO_xa_ResourceMatch(struct zx_ctx* c, struct zx_xa_ResourceMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Resources
#define EL_STRUCT zx_xa_Resources_s
#define EL_NS     xa
#define EL_TAG    Resources

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Resources) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Resources(struct zx_ctx* c, struct zx_xa_Resources_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Resource->gg;
       se && se->g.tok == zx_xa_Resource_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Resource(c, (struct zx_xa_Resource_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Resources) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Resources_s* zx_DEEP_CLONE_xa_Resources(struct zx_ctx* c, struct zx_xa_Resources_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Resources_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Resources_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Resource->gg;
       e && e->g.tok == zx_xa_Resource_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Resource(c,(struct zx_xa_Resource_s*)e,dup_strs);
  	  if (!enn)
  	      x->Resource = (struct zx_xa_Resource_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Resources) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Resources(struct zx_ctx* c, struct zx_xa_Resources_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Resource->gg;
       e && e->g.tok == zx_xa_Resource_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Resource(c, (struct zx_xa_Resource_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Resources) */

int zx_WALK_WO_xa_Resources(struct zx_ctx* c, struct zx_xa_Resources_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Rule
#define EL_STRUCT zx_xa_Rule_s
#define EL_NS     xa
#define EL_TAG    Rule

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Rule) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Rule(struct zx_ctx* c, struct zx_xa_Rule_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->Effect);
  zx_dup_attr(c, x->RuleId);

  zx_dup_strs_simple_elems(c, x->Description);
  for (se = &x->Target->gg;
       se && se->g.tok == zx_xa_Target_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Target(c, (struct zx_xa_Target_s*)se);
  for (se = &x->Condition->gg;
       se && se->g.tok == zx_xa_Condition_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Condition(c, (struct zx_xa_Condition_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Rule) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Rule_s* zx_DEEP_CLONE_xa_Rule(struct zx_ctx* c, struct zx_xa_Rule_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Rule_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Rule_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->Effect = zx_clone_attr(c, x->Effect);
  x->RuleId = zx_clone_attr(c, x->RuleId);

  x->Description = zx_deep_clone_simple_elems(c,x->Description, dup_strs);
  for (enn = 0, e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Target(c,(struct zx_xa_Target_s*)e,dup_strs);
  	  if (!enn)
  	      x->Target = (struct zx_xa_Target_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Condition->gg;
       e && e->g.tok == zx_xa_Condition_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Condition(c,(struct zx_xa_Condition_s*)e,dup_strs);
  	  if (!enn)
  	      x->Condition = (struct zx_xa_Condition_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Rule) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Rule(struct zx_ctx* c, struct zx_xa_Rule_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Description, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Target(c, (struct zx_xa_Target_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Condition->gg;
       e && e->g.tok == zx_xa_Condition_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Condition(c, (struct zx_xa_Condition_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Rule) */

int zx_WALK_WO_xa_Rule(struct zx_ctx* c, struct zx_xa_Rule_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_RuleCombinerParameters
#define EL_STRUCT zx_xa_RuleCombinerParameters_s
#define EL_NS     xa
#define EL_TAG    RuleCombinerParameters

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_RuleCombinerParameters) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_RuleCombinerParameters(struct zx_ctx* c, struct zx_xa_RuleCombinerParameters_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->RuleIdRef);

  for (se = &x->CombinerParameter->gg;
       se && se->g.tok == zx_xa_CombinerParameter_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_RuleCombinerParameters) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_RuleCombinerParameters_s* zx_DEEP_CLONE_xa_RuleCombinerParameters(struct zx_ctx* c, struct zx_xa_RuleCombinerParameters_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_RuleCombinerParameters_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_RuleCombinerParameters_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->RuleIdRef = zx_clone_attr(c, x->RuleIdRef);

  for (enn = 0, e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameter(c,(struct zx_xa_CombinerParameter_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_RuleCombinerParameters) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_RuleCombinerParameters(struct zx_ctx* c, struct zx_xa_RuleCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_RuleCombinerParameters) */

int zx_WALK_WO_xa_RuleCombinerParameters(struct zx_ctx* c, struct zx_xa_RuleCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Subject
#define EL_STRUCT zx_xa_Subject_s
#define EL_NS     xa
#define EL_TAG    Subject

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Subject) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Subject(struct zx_ctx* c, struct zx_xa_Subject_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->SubjectMatch->gg;
       se && se->g.tok == zx_xa_SubjectMatch_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_SubjectMatch(c, (struct zx_xa_SubjectMatch_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Subject) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Subject_s* zx_DEEP_CLONE_xa_Subject(struct zx_ctx* c, struct zx_xa_Subject_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Subject_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Subject_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->SubjectMatch->gg;
       e && e->g.tok == zx_xa_SubjectMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_SubjectMatch(c,(struct zx_xa_SubjectMatch_s*)e,dup_strs);
  	  if (!enn)
  	      x->SubjectMatch = (struct zx_xa_SubjectMatch_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Subject) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Subject(struct zx_ctx* c, struct zx_xa_Subject_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->SubjectMatch->gg;
       e && e->g.tok == zx_xa_SubjectMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_SubjectMatch(c, (struct zx_xa_SubjectMatch_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Subject) */

int zx_WALK_WO_xa_Subject(struct zx_ctx* c, struct zx_xa_Subject_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_SubjectAttributeDesignator
#define EL_STRUCT zx_xa_SubjectAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    SubjectAttributeDesignator

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_SubjectAttributeDesignator) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_SubjectAttributeDesignator(struct zx_ctx* c, struct zx_xa_SubjectAttributeDesignator_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->AttributeId);
  zx_dup_attr(c, x->DataType);
  zx_dup_attr(c, x->Issuer);
  zx_dup_attr(c, x->MustBePresent);
  zx_dup_attr(c, x->SubjectCategory);


}

/* FUNC(zx_DEEP_CLONE_xa_SubjectAttributeDesignator) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_SubjectAttributeDesignator_s* zx_DEEP_CLONE_xa_SubjectAttributeDesignator(struct zx_ctx* c, struct zx_xa_SubjectAttributeDesignator_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_SubjectAttributeDesignator_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_SubjectAttributeDesignator_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->AttributeId = zx_clone_attr(c, x->AttributeId);
  x->DataType = zx_clone_attr(c, x->DataType);
  x->Issuer = zx_clone_attr(c, x->Issuer);
  x->MustBePresent = zx_clone_attr(c, x->MustBePresent);
  x->SubjectCategory = zx_clone_attr(c, x->SubjectCategory);


  return x;
}

/* FUNC(zx_WALK_SO_xa_SubjectAttributeDesignator) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_SubjectAttributeDesignator(struct zx_ctx* c, struct zx_xa_SubjectAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_SubjectAttributeDesignator) */

int zx_WALK_WO_xa_SubjectAttributeDesignator(struct zx_ctx* c, struct zx_xa_SubjectAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_SubjectMatch
#define EL_STRUCT zx_xa_SubjectMatch_s
#define EL_NS     xa
#define EL_TAG    SubjectMatch

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_SubjectMatch) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_SubjectMatch(struct zx_ctx* c, struct zx_xa_SubjectMatch_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->MatchId);

  for (se = &x->AttributeValue->gg;
       se && se->g.tok == zx_xa_AttributeValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)se);
  for (se = &x->SubjectAttributeDesignator->gg;
       se && se->g.tok == zx_xa_SubjectAttributeDesignator_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_SubjectAttributeDesignator(c, (struct zx_xa_SubjectAttributeDesignator_s*)se);
  for (se = &x->AttributeSelector->gg;
       se && se->g.tok == zx_xa_AttributeSelector_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_SubjectMatch) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_SubjectMatch_s* zx_DEEP_CLONE_xa_SubjectMatch(struct zx_ctx* c, struct zx_xa_SubjectMatch_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_SubjectMatch_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_SubjectMatch_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->MatchId = zx_clone_attr(c, x->MatchId);

  for (enn = 0, e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeValue(c,(struct zx_xa_AttributeValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeValue = (struct zx_xa_AttributeValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SubjectAttributeDesignator->gg;
       e && e->g.tok == zx_xa_SubjectAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_SubjectAttributeDesignator(c,(struct zx_xa_SubjectAttributeDesignator_s*)e,dup_strs);
  	  if (!enn)
  	      x->SubjectAttributeDesignator = (struct zx_xa_SubjectAttributeDesignator_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeSelector(c,(struct zx_xa_AttributeSelector_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_SubjectMatch) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_SubjectMatch(struct zx_ctx* c, struct zx_xa_SubjectMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SubjectAttributeDesignator->gg;
       e && e->g.tok == zx_xa_SubjectAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_SubjectAttributeDesignator(c, (struct zx_xa_SubjectAttributeDesignator_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_SubjectMatch) */

int zx_WALK_WO_xa_SubjectMatch(struct zx_ctx* c, struct zx_xa_SubjectMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Subjects
#define EL_STRUCT zx_xa_Subjects_s
#define EL_NS     xa
#define EL_TAG    Subjects

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Subjects) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Subjects(struct zx_ctx* c, struct zx_xa_Subjects_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Subject->gg;
       se && se->g.tok == zx_xa_Subject_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Subject(c, (struct zx_xa_Subject_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Subjects) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Subjects_s* zx_DEEP_CLONE_xa_Subjects(struct zx_ctx* c, struct zx_xa_Subjects_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Subjects_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Subjects_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Subject->gg;
       e && e->g.tok == zx_xa_Subject_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Subject(c,(struct zx_xa_Subject_s*)e,dup_strs);
  	  if (!enn)
  	      x->Subject = (struct zx_xa_Subject_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Subjects) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Subjects(struct zx_ctx* c, struct zx_xa_Subjects_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Subject->gg;
       e && e->g.tok == zx_xa_Subject_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Subject(c, (struct zx_xa_Subject_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Subjects) */

int zx_WALK_WO_xa_Subjects(struct zx_ctx* c, struct zx_xa_Subjects_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Target
#define EL_STRUCT zx_xa_Target_s
#define EL_NS     xa
#define EL_TAG    Target

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Target) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Target(struct zx_ctx* c, struct zx_xa_Target_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Subjects->gg;
       se && se->g.tok == zx_xa_Subjects_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Subjects(c, (struct zx_xa_Subjects_s*)se);
  for (se = &x->Resources->gg;
       se && se->g.tok == zx_xa_Resources_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Resources(c, (struct zx_xa_Resources_s*)se);
  for (se = &x->Actions->gg;
       se && se->g.tok == zx_xa_Actions_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Actions(c, (struct zx_xa_Actions_s*)se);
  for (se = &x->Environments->gg;
       se && se->g.tok == zx_xa_Environments_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Environments(c, (struct zx_xa_Environments_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Target) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Target_s* zx_DEEP_CLONE_xa_Target(struct zx_ctx* c, struct zx_xa_Target_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Target_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Target_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Subjects->gg;
       e && e->g.tok == zx_xa_Subjects_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Subjects(c,(struct zx_xa_Subjects_s*)e,dup_strs);
  	  if (!enn)
  	      x->Subjects = (struct zx_xa_Subjects_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Resources->gg;
       e && e->g.tok == zx_xa_Resources_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Resources(c,(struct zx_xa_Resources_s*)e,dup_strs);
  	  if (!enn)
  	      x->Resources = (struct zx_xa_Resources_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Actions->gg;
       e && e->g.tok == zx_xa_Actions_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Actions(c,(struct zx_xa_Actions_s*)e,dup_strs);
  	  if (!enn)
  	      x->Actions = (struct zx_xa_Actions_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Environments->gg;
       e && e->g.tok == zx_xa_Environments_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Environments(c,(struct zx_xa_Environments_s*)e,dup_strs);
  	  if (!enn)
  	      x->Environments = (struct zx_xa_Environments_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Target) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Target(struct zx_ctx* c, struct zx_xa_Target_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Subjects->gg;
       e && e->g.tok == zx_xa_Subjects_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Subjects(c, (struct zx_xa_Subjects_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Resources->gg;
       e && e->g.tok == zx_xa_Resources_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Resources(c, (struct zx_xa_Resources_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Actions->gg;
       e && e->g.tok == zx_xa_Actions_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Actions(c, (struct zx_xa_Actions_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Environments->gg;
       e && e->g.tok == zx_xa_Environments_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Environments(c, (struct zx_xa_Environments_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Target) */

int zx_WALK_WO_xa_Target(struct zx_ctx* c, struct zx_xa_Target_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_VariableDefinition
#define EL_STRUCT zx_xa_VariableDefinition_s
#define EL_NS     xa
#define EL_TAG    VariableDefinition

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_VariableDefinition) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_VariableDefinition(struct zx_ctx* c, struct zx_xa_VariableDefinition_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->VariableId);

  zx_dup_strs_simple_elems(c, x->Expression);

}

/* FUNC(zx_DEEP_CLONE_xa_VariableDefinition) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_VariableDefinition_s* zx_DEEP_CLONE_xa_VariableDefinition(struct zx_ctx* c, struct zx_xa_VariableDefinition_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_VariableDefinition_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_VariableDefinition_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->VariableId = zx_clone_attr(c, x->VariableId);

  x->Expression = zx_deep_clone_simple_elems(c,x->Expression, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_xa_VariableDefinition) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_VariableDefinition(struct zx_ctx* c, struct zx_xa_VariableDefinition_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Expression, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_VariableDefinition) */

int zx_WALK_WO_xa_VariableDefinition(struct zx_ctx* c, struct zx_xa_VariableDefinition_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_VariableReference
#define EL_STRUCT zx_xa_VariableReference_s
#define EL_NS     xa
#define EL_TAG    VariableReference

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_VariableReference) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_VariableReference(struct zx_ctx* c, struct zx_xa_VariableReference_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->VariableId);


}

/* FUNC(zx_DEEP_CLONE_xa_VariableReference) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_VariableReference_s* zx_DEEP_CLONE_xa_VariableReference(struct zx_ctx* c, struct zx_xa_VariableReference_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_VariableReference_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_VariableReference_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->VariableId = zx_clone_attr(c, x->VariableId);


  return x;
}

/* FUNC(zx_WALK_SO_xa_VariableReference) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_VariableReference(struct zx_ctx* c, struct zx_xa_VariableReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_VariableReference) */

int zx_WALK_WO_xa_VariableReference(struct zx_ctx* c, struct zx_xa_VariableReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif


/* EOF -- c/zx-xa-aux.c */
