/* c/zx-xa-aux.c - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** aux-templ.c  -  Auxiliary functions template: cloning, freeing, walking data
 ** Copyright (c) 2006 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: aux-templ.c,v 1.12 2008-10-04 23:42:14 sampo Exp $
 **
 ** 30.5.2006, created, Sampo Kellomaki (sampo@iki.fi)
 ** 6.8.2006, factored from enc-templ.c to separate file --Sampo
 **
 ** N.B: wo=wire order (needed for exc-c14n), so=schema order
 **/

#include <memory.h>
#include "errmac.h"
#include "zx.h"
#include "c/zx-const.h"
#include "c/zx-data.h"
#include "c/zx-xa-data.h"



#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Action
#define EL_STRUCT zx_xa_Action_s
#define EL_NS     xa
#define EL_TAG    Action

/* FUNC(zx_FREE_xa_Action) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Action(struct zx_ctx* c, struct zx_xa_Action_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->ActionMatch->gg;
       e && e->g.tok == zx_xa_ActionMatch_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_ActionMatch(c, (struct zx_xa_ActionMatch_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Action) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Action_s* zx_NEW_xa_Action(struct zx_ctx* c)
{
  struct zx_xa_Action_s* x = ZX_ZALLOC(c, struct zx_xa_Action_s);
  x->gg.g.tok = zx_xa_Action_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Action) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Action(struct zx_ctx* c, struct zx_xa_Action_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ActionMatch->gg;
       se && se->g.tok == zx_xa_ActionMatch_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_ActionMatch(c, (struct zx_xa_ActionMatch_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Action) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Action_s* zx_DEEP_CLONE_xa_Action(struct zx_ctx* c, struct zx_xa_Action_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Action_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Action_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ActionMatch->gg;
       e && e->g.tok == zx_xa_ActionMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_ActionMatch(c,(struct zx_xa_ActionMatch_s*)e,dup_strs);
  	  if (!enn)
  	      x->ActionMatch = (struct zx_xa_ActionMatch_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Action) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Action(struct zx_ctx* c, struct zx_xa_Action_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ActionMatch->gg;
       e && e->g.tok == zx_xa_ActionMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_ActionMatch(c, (struct zx_xa_ActionMatch_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Action) */

int zx_WALK_WO_xa_Action(struct zx_ctx* c, struct zx_xa_Action_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_ActionAttributeDesignator
#define EL_STRUCT zx_xa_ActionAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    ActionAttributeDesignator

/* FUNC(zx_FREE_xa_ActionAttributeDesignator) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_ActionAttributeDesignator(struct zx_ctx* c, struct zx_xa_ActionAttributeDesignator_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->AttributeId, free_strs);
  zx_free_attr(c, x->DataType, free_strs);
  zx_free_attr(c, x->Issuer, free_strs);
  zx_free_attr(c, x->MustBePresent, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_ActionAttributeDesignator) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_ActionAttributeDesignator_s* zx_NEW_xa_ActionAttributeDesignator(struct zx_ctx* c)
{
  struct zx_xa_ActionAttributeDesignator_s* x = ZX_ZALLOC(c, struct zx_xa_ActionAttributeDesignator_s);
  x->gg.g.tok = zx_xa_ActionAttributeDesignator_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_ActionAttributeDesignator) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_ActionAttributeDesignator(struct zx_ctx* c, struct zx_xa_ActionAttributeDesignator_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->AttributeId);
  zx_dup_attr(c, x->DataType);
  zx_dup_attr(c, x->Issuer);
  zx_dup_attr(c, x->MustBePresent);


}

/* FUNC(zx_DEEP_CLONE_xa_ActionAttributeDesignator) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_ActionAttributeDesignator_s* zx_DEEP_CLONE_xa_ActionAttributeDesignator(struct zx_ctx* c, struct zx_xa_ActionAttributeDesignator_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_ActionAttributeDesignator_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_ActionAttributeDesignator_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->AttributeId = zx_clone_attr(c, x->AttributeId);
  x->DataType = zx_clone_attr(c, x->DataType);
  x->Issuer = zx_clone_attr(c, x->Issuer);
  x->MustBePresent = zx_clone_attr(c, x->MustBePresent);


  return x;
}

/* FUNC(zx_WALK_SO_xa_ActionAttributeDesignator) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_ActionAttributeDesignator(struct zx_ctx* c, struct zx_xa_ActionAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_ActionAttributeDesignator) */

int zx_WALK_WO_xa_ActionAttributeDesignator(struct zx_ctx* c, struct zx_xa_ActionAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_ActionMatch
#define EL_STRUCT zx_xa_ActionMatch_s
#define EL_NS     xa
#define EL_TAG    ActionMatch

/* FUNC(zx_FREE_xa_ActionMatch) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_ActionMatch(struct zx_ctx* c, struct zx_xa_ActionMatch_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->MatchId, free_strs);

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, free_strs);
  }
  for (e = &x->ActionAttributeDesignator->gg;
       e && e->g.tok == zx_xa_ActionAttributeDesignator_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_ActionAttributeDesignator(c, (struct zx_xa_ActionAttributeDesignator_s*)e, free_strs);
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_ActionMatch) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_ActionMatch_s* zx_NEW_xa_ActionMatch(struct zx_ctx* c)
{
  struct zx_xa_ActionMatch_s* x = ZX_ZALLOC(c, struct zx_xa_ActionMatch_s);
  x->gg.g.tok = zx_xa_ActionMatch_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_ActionMatch) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_ActionMatch(struct zx_ctx* c, struct zx_xa_ActionMatch_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->MatchId);

  for (se = &x->AttributeValue->gg;
       se && se->g.tok == zx_xa_AttributeValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)se);
  for (se = &x->ActionAttributeDesignator->gg;
       se && se->g.tok == zx_xa_ActionAttributeDesignator_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_ActionAttributeDesignator(c, (struct zx_xa_ActionAttributeDesignator_s*)se);
  for (se = &x->AttributeSelector->gg;
       se && se->g.tok == zx_xa_AttributeSelector_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_ActionMatch) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_ActionMatch_s* zx_DEEP_CLONE_xa_ActionMatch(struct zx_ctx* c, struct zx_xa_ActionMatch_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_ActionMatch_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_ActionMatch_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->MatchId = zx_clone_attr(c, x->MatchId);

  for (enn = 0, e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeValue(c,(struct zx_xa_AttributeValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeValue = (struct zx_xa_AttributeValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ActionAttributeDesignator->gg;
       e && e->g.tok == zx_xa_ActionAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_ActionAttributeDesignator(c,(struct zx_xa_ActionAttributeDesignator_s*)e,dup_strs);
  	  if (!enn)
  	      x->ActionAttributeDesignator = (struct zx_xa_ActionAttributeDesignator_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeSelector(c,(struct zx_xa_AttributeSelector_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_ActionMatch) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_ActionMatch(struct zx_ctx* c, struct zx_xa_ActionMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ActionAttributeDesignator->gg;
       e && e->g.tok == zx_xa_ActionAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_ActionAttributeDesignator(c, (struct zx_xa_ActionAttributeDesignator_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_ActionMatch) */

int zx_WALK_WO_xa_ActionMatch(struct zx_ctx* c, struct zx_xa_ActionMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Actions
#define EL_STRUCT zx_xa_Actions_s
#define EL_NS     xa
#define EL_TAG    Actions

/* FUNC(zx_FREE_xa_Actions) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Actions(struct zx_ctx* c, struct zx_xa_Actions_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Action->gg;
       e && e->g.tok == zx_xa_Action_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Action(c, (struct zx_xa_Action_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Actions) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Actions_s* zx_NEW_xa_Actions(struct zx_ctx* c)
{
  struct zx_xa_Actions_s* x = ZX_ZALLOC(c, struct zx_xa_Actions_s);
  x->gg.g.tok = zx_xa_Actions_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Actions) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Actions(struct zx_ctx* c, struct zx_xa_Actions_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Action->gg;
       se && se->g.tok == zx_xa_Action_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Action(c, (struct zx_xa_Action_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Actions) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Actions_s* zx_DEEP_CLONE_xa_Actions(struct zx_ctx* c, struct zx_xa_Actions_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Actions_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Actions_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Action->gg;
       e && e->g.tok == zx_xa_Action_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Action(c,(struct zx_xa_Action_s*)e,dup_strs);
  	  if (!enn)
  	      x->Action = (struct zx_xa_Action_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Actions) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Actions(struct zx_ctx* c, struct zx_xa_Actions_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Action->gg;
       e && e->g.tok == zx_xa_Action_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Action(c, (struct zx_xa_Action_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Actions) */

int zx_WALK_WO_xa_Actions(struct zx_ctx* c, struct zx_xa_Actions_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Apply
#define EL_STRUCT zx_xa_Apply_s
#define EL_NS     xa
#define EL_TAG    Apply

/* FUNC(zx_FREE_xa_Apply) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Apply(struct zx_ctx* c, struct zx_xa_Apply_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->FunctionId, free_strs);

  zx_free_simple_elems(c, x->Expression, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Apply) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Apply_s* zx_NEW_xa_Apply(struct zx_ctx* c)
{
  struct zx_xa_Apply_s* x = ZX_ZALLOC(c, struct zx_xa_Apply_s);
  x->gg.g.tok = zx_xa_Apply_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Apply) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Apply(struct zx_ctx* c, struct zx_xa_Apply_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->FunctionId);

  zx_dup_strs_simple_elems(c, x->Expression);

}

/* FUNC(zx_DEEP_CLONE_xa_Apply) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Apply_s* zx_DEEP_CLONE_xa_Apply(struct zx_ctx* c, struct zx_xa_Apply_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Apply_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Apply_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->FunctionId = zx_clone_attr(c, x->FunctionId);

  x->Expression = zx_deep_clone_simple_elems(c,x->Expression, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_xa_Apply) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Apply(struct zx_ctx* c, struct zx_xa_Apply_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Expression, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Apply) */

int zx_WALK_WO_xa_Apply(struct zx_ctx* c, struct zx_xa_Apply_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_AttributeAssignment
#define EL_STRUCT zx_xa_AttributeAssignment_s
#define EL_NS     xa
#define EL_TAG    AttributeAssignment

/* FUNC(zx_FREE_xa_AttributeAssignment) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_AttributeAssignment(struct zx_ctx* c, struct zx_xa_AttributeAssignment_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->AttributeId, free_strs);
  zx_free_attr(c, x->DataType, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_AttributeAssignment) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_AttributeAssignment_s* zx_NEW_xa_AttributeAssignment(struct zx_ctx* c)
{
  struct zx_xa_AttributeAssignment_s* x = ZX_ZALLOC(c, struct zx_xa_AttributeAssignment_s);
  x->gg.g.tok = zx_xa_AttributeAssignment_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_AttributeAssignment) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_AttributeAssignment(struct zx_ctx* c, struct zx_xa_AttributeAssignment_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->AttributeId);
  zx_dup_attr(c, x->DataType);


}

/* FUNC(zx_DEEP_CLONE_xa_AttributeAssignment) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_AttributeAssignment_s* zx_DEEP_CLONE_xa_AttributeAssignment(struct zx_ctx* c, struct zx_xa_AttributeAssignment_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_AttributeAssignment_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_AttributeAssignment_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->AttributeId = zx_clone_attr(c, x->AttributeId);
  x->DataType = zx_clone_attr(c, x->DataType);


  return x;
}

/* FUNC(zx_WALK_SO_xa_AttributeAssignment) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_AttributeAssignment(struct zx_ctx* c, struct zx_xa_AttributeAssignment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_AttributeAssignment) */

int zx_WALK_WO_xa_AttributeAssignment(struct zx_ctx* c, struct zx_xa_AttributeAssignment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_AttributeSelector
#define EL_STRUCT zx_xa_AttributeSelector_s
#define EL_NS     xa
#define EL_TAG    AttributeSelector

/* FUNC(zx_FREE_xa_AttributeSelector) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_AttributeSelector(struct zx_ctx* c, struct zx_xa_AttributeSelector_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->DataType, free_strs);
  zx_free_attr(c, x->MustBePresent, free_strs);
  zx_free_attr(c, x->RequestContextPath, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_AttributeSelector) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_AttributeSelector_s* zx_NEW_xa_AttributeSelector(struct zx_ctx* c)
{
  struct zx_xa_AttributeSelector_s* x = ZX_ZALLOC(c, struct zx_xa_AttributeSelector_s);
  x->gg.g.tok = zx_xa_AttributeSelector_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_AttributeSelector) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_AttributeSelector(struct zx_ctx* c, struct zx_xa_AttributeSelector_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->DataType);
  zx_dup_attr(c, x->MustBePresent);
  zx_dup_attr(c, x->RequestContextPath);


}

/* FUNC(zx_DEEP_CLONE_xa_AttributeSelector) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_AttributeSelector_s* zx_DEEP_CLONE_xa_AttributeSelector(struct zx_ctx* c, struct zx_xa_AttributeSelector_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_AttributeSelector_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_AttributeSelector_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->DataType = zx_clone_attr(c, x->DataType);
  x->MustBePresent = zx_clone_attr(c, x->MustBePresent);
  x->RequestContextPath = zx_clone_attr(c, x->RequestContextPath);


  return x;
}

/* FUNC(zx_WALK_SO_xa_AttributeSelector) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_AttributeSelector(struct zx_ctx* c, struct zx_xa_AttributeSelector_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_AttributeSelector) */

int zx_WALK_WO_xa_AttributeSelector(struct zx_ctx* c, struct zx_xa_AttributeSelector_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_AttributeValue
#define EL_STRUCT zx_xa_AttributeValue_s
#define EL_NS     xa
#define EL_TAG    AttributeValue

/* FUNC(zx_FREE_xa_AttributeValue) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_AttributeValue(struct zx_ctx* c, struct zx_xa_AttributeValue_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->DataType, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_AttributeValue) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_AttributeValue_s* zx_NEW_xa_AttributeValue(struct zx_ctx* c)
{
  struct zx_xa_AttributeValue_s* x = ZX_ZALLOC(c, struct zx_xa_AttributeValue_s);
  x->gg.g.tok = zx_xa_AttributeValue_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_AttributeValue) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_AttributeValue(struct zx_ctx* c, struct zx_xa_AttributeValue_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->DataType);


}

/* FUNC(zx_DEEP_CLONE_xa_AttributeValue) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_AttributeValue_s* zx_DEEP_CLONE_xa_AttributeValue(struct zx_ctx* c, struct zx_xa_AttributeValue_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_AttributeValue_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_AttributeValue_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->DataType = zx_clone_attr(c, x->DataType);


  return x;
}

/* FUNC(zx_WALK_SO_xa_AttributeValue) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_AttributeValue(struct zx_ctx* c, struct zx_xa_AttributeValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_AttributeValue) */

int zx_WALK_WO_xa_AttributeValue(struct zx_ctx* c, struct zx_xa_AttributeValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_CombinerParameter
#define EL_STRUCT zx_xa_CombinerParameter_s
#define EL_NS     xa
#define EL_TAG    CombinerParameter

/* FUNC(zx_FREE_xa_CombinerParameter) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_CombinerParameter(struct zx_ctx* c, struct zx_xa_CombinerParameter_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->ParameterName, free_strs);

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_CombinerParameter) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_CombinerParameter_s* zx_NEW_xa_CombinerParameter(struct zx_ctx* c)
{
  struct zx_xa_CombinerParameter_s* x = ZX_ZALLOC(c, struct zx_xa_CombinerParameter_s);
  x->gg.g.tok = zx_xa_CombinerParameter_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_CombinerParameter) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_CombinerParameter(struct zx_ctx* c, struct zx_xa_CombinerParameter_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->ParameterName);

  for (se = &x->AttributeValue->gg;
       se && se->g.tok == zx_xa_AttributeValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_CombinerParameter) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_CombinerParameter_s* zx_DEEP_CLONE_xa_CombinerParameter(struct zx_ctx* c, struct zx_xa_CombinerParameter_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_CombinerParameter_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_CombinerParameter_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->ParameterName = zx_clone_attr(c, x->ParameterName);

  for (enn = 0, e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeValue(c,(struct zx_xa_AttributeValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeValue = (struct zx_xa_AttributeValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_CombinerParameter) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_CombinerParameter(struct zx_ctx* c, struct zx_xa_CombinerParameter_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_CombinerParameter) */

int zx_WALK_WO_xa_CombinerParameter(struct zx_ctx* c, struct zx_xa_CombinerParameter_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_CombinerParameters
#define EL_STRUCT zx_xa_CombinerParameters_s
#define EL_NS     xa
#define EL_TAG    CombinerParameters

/* FUNC(zx_FREE_xa_CombinerParameters) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_CombinerParameters(struct zx_ctx* c, struct zx_xa_CombinerParameters_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_CombinerParameters) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_CombinerParameters_s* zx_NEW_xa_CombinerParameters(struct zx_ctx* c)
{
  struct zx_xa_CombinerParameters_s* x = ZX_ZALLOC(c, struct zx_xa_CombinerParameters_s);
  x->gg.g.tok = zx_xa_CombinerParameters_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_CombinerParameters) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_CombinerParameters(struct zx_ctx* c, struct zx_xa_CombinerParameters_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->CombinerParameter->gg;
       se && se->g.tok == zx_xa_CombinerParameter_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_CombinerParameters) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_CombinerParameters_s* zx_DEEP_CLONE_xa_CombinerParameters(struct zx_ctx* c, struct zx_xa_CombinerParameters_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_CombinerParameters_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_CombinerParameters_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameter(c,(struct zx_xa_CombinerParameter_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_CombinerParameters) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_CombinerParameters(struct zx_ctx* c, struct zx_xa_CombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_CombinerParameters) */

int zx_WALK_WO_xa_CombinerParameters(struct zx_ctx* c, struct zx_xa_CombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Condition
#define EL_STRUCT zx_xa_Condition_s
#define EL_NS     xa
#define EL_TAG    Condition

/* FUNC(zx_FREE_xa_Condition) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Condition(struct zx_ctx* c, struct zx_xa_Condition_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Expression, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Condition) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Condition_s* zx_NEW_xa_Condition(struct zx_ctx* c)
{
  struct zx_xa_Condition_s* x = ZX_ZALLOC(c, struct zx_xa_Condition_s);
  x->gg.g.tok = zx_xa_Condition_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Condition) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Condition(struct zx_ctx* c, struct zx_xa_Condition_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Expression);

}

/* FUNC(zx_DEEP_CLONE_xa_Condition) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Condition_s* zx_DEEP_CLONE_xa_Condition(struct zx_ctx* c, struct zx_xa_Condition_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Condition_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Condition_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Expression = zx_deep_clone_simple_elems(c,x->Expression, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_xa_Condition) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Condition(struct zx_ctx* c, struct zx_xa_Condition_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Expression, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Condition) */

int zx_WALK_WO_xa_Condition(struct zx_ctx* c, struct zx_xa_Condition_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Environment
#define EL_STRUCT zx_xa_Environment_s
#define EL_NS     xa
#define EL_TAG    Environment

/* FUNC(zx_FREE_xa_Environment) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Environment(struct zx_ctx* c, struct zx_xa_Environment_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->EnvironmentMatch->gg;
       e && e->g.tok == zx_xa_EnvironmentMatch_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_EnvironmentMatch(c, (struct zx_xa_EnvironmentMatch_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Environment) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Environment_s* zx_NEW_xa_Environment(struct zx_ctx* c)
{
  struct zx_xa_Environment_s* x = ZX_ZALLOC(c, struct zx_xa_Environment_s);
  x->gg.g.tok = zx_xa_Environment_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Environment) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Environment(struct zx_ctx* c, struct zx_xa_Environment_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->EnvironmentMatch->gg;
       se && se->g.tok == zx_xa_EnvironmentMatch_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_EnvironmentMatch(c, (struct zx_xa_EnvironmentMatch_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Environment) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Environment_s* zx_DEEP_CLONE_xa_Environment(struct zx_ctx* c, struct zx_xa_Environment_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Environment_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Environment_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->EnvironmentMatch->gg;
       e && e->g.tok == zx_xa_EnvironmentMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_EnvironmentMatch(c,(struct zx_xa_EnvironmentMatch_s*)e,dup_strs);
  	  if (!enn)
  	      x->EnvironmentMatch = (struct zx_xa_EnvironmentMatch_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Environment) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Environment(struct zx_ctx* c, struct zx_xa_Environment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->EnvironmentMatch->gg;
       e && e->g.tok == zx_xa_EnvironmentMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_EnvironmentMatch(c, (struct zx_xa_EnvironmentMatch_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Environment) */

int zx_WALK_WO_xa_Environment(struct zx_ctx* c, struct zx_xa_Environment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_EnvironmentAttributeDesignator
#define EL_STRUCT zx_xa_EnvironmentAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    EnvironmentAttributeDesignator

/* FUNC(zx_FREE_xa_EnvironmentAttributeDesignator) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_EnvironmentAttributeDesignator(struct zx_ctx* c, struct zx_xa_EnvironmentAttributeDesignator_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->AttributeId, free_strs);
  zx_free_attr(c, x->DataType, free_strs);
  zx_free_attr(c, x->Issuer, free_strs);
  zx_free_attr(c, x->MustBePresent, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_EnvironmentAttributeDesignator) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_EnvironmentAttributeDesignator_s* zx_NEW_xa_EnvironmentAttributeDesignator(struct zx_ctx* c)
{
  struct zx_xa_EnvironmentAttributeDesignator_s* x = ZX_ZALLOC(c, struct zx_xa_EnvironmentAttributeDesignator_s);
  x->gg.g.tok = zx_xa_EnvironmentAttributeDesignator_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_EnvironmentAttributeDesignator) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_EnvironmentAttributeDesignator(struct zx_ctx* c, struct zx_xa_EnvironmentAttributeDesignator_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->AttributeId);
  zx_dup_attr(c, x->DataType);
  zx_dup_attr(c, x->Issuer);
  zx_dup_attr(c, x->MustBePresent);


}

/* FUNC(zx_DEEP_CLONE_xa_EnvironmentAttributeDesignator) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_EnvironmentAttributeDesignator_s* zx_DEEP_CLONE_xa_EnvironmentAttributeDesignator(struct zx_ctx* c, struct zx_xa_EnvironmentAttributeDesignator_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_EnvironmentAttributeDesignator_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_EnvironmentAttributeDesignator_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->AttributeId = zx_clone_attr(c, x->AttributeId);
  x->DataType = zx_clone_attr(c, x->DataType);
  x->Issuer = zx_clone_attr(c, x->Issuer);
  x->MustBePresent = zx_clone_attr(c, x->MustBePresent);


  return x;
}

/* FUNC(zx_WALK_SO_xa_EnvironmentAttributeDesignator) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_EnvironmentAttributeDesignator(struct zx_ctx* c, struct zx_xa_EnvironmentAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_EnvironmentAttributeDesignator) */

int zx_WALK_WO_xa_EnvironmentAttributeDesignator(struct zx_ctx* c, struct zx_xa_EnvironmentAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_EnvironmentMatch
#define EL_STRUCT zx_xa_EnvironmentMatch_s
#define EL_NS     xa
#define EL_TAG    EnvironmentMatch

/* FUNC(zx_FREE_xa_EnvironmentMatch) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_EnvironmentMatch(struct zx_ctx* c, struct zx_xa_EnvironmentMatch_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->MatchId, free_strs);

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, free_strs);
  }
  for (e = &x->EnvironmentAttributeDesignator->gg;
       e && e->g.tok == zx_xa_EnvironmentAttributeDesignator_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_EnvironmentAttributeDesignator(c, (struct zx_xa_EnvironmentAttributeDesignator_s*)e, free_strs);
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_EnvironmentMatch) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_EnvironmentMatch_s* zx_NEW_xa_EnvironmentMatch(struct zx_ctx* c)
{
  struct zx_xa_EnvironmentMatch_s* x = ZX_ZALLOC(c, struct zx_xa_EnvironmentMatch_s);
  x->gg.g.tok = zx_xa_EnvironmentMatch_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_EnvironmentMatch) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_EnvironmentMatch(struct zx_ctx* c, struct zx_xa_EnvironmentMatch_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->MatchId);

  for (se = &x->AttributeValue->gg;
       se && se->g.tok == zx_xa_AttributeValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)se);
  for (se = &x->EnvironmentAttributeDesignator->gg;
       se && se->g.tok == zx_xa_EnvironmentAttributeDesignator_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_EnvironmentAttributeDesignator(c, (struct zx_xa_EnvironmentAttributeDesignator_s*)se);
  for (se = &x->AttributeSelector->gg;
       se && se->g.tok == zx_xa_AttributeSelector_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_EnvironmentMatch) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_EnvironmentMatch_s* zx_DEEP_CLONE_xa_EnvironmentMatch(struct zx_ctx* c, struct zx_xa_EnvironmentMatch_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_EnvironmentMatch_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_EnvironmentMatch_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->MatchId = zx_clone_attr(c, x->MatchId);

  for (enn = 0, e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeValue(c,(struct zx_xa_AttributeValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeValue = (struct zx_xa_AttributeValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EnvironmentAttributeDesignator->gg;
       e && e->g.tok == zx_xa_EnvironmentAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_EnvironmentAttributeDesignator(c,(struct zx_xa_EnvironmentAttributeDesignator_s*)e,dup_strs);
  	  if (!enn)
  	      x->EnvironmentAttributeDesignator = (struct zx_xa_EnvironmentAttributeDesignator_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeSelector(c,(struct zx_xa_AttributeSelector_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_EnvironmentMatch) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_EnvironmentMatch(struct zx_ctx* c, struct zx_xa_EnvironmentMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EnvironmentAttributeDesignator->gg;
       e && e->g.tok == zx_xa_EnvironmentAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_EnvironmentAttributeDesignator(c, (struct zx_xa_EnvironmentAttributeDesignator_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_EnvironmentMatch) */

int zx_WALK_WO_xa_EnvironmentMatch(struct zx_ctx* c, struct zx_xa_EnvironmentMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Environments
#define EL_STRUCT zx_xa_Environments_s
#define EL_NS     xa
#define EL_TAG    Environments

/* FUNC(zx_FREE_xa_Environments) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Environments(struct zx_ctx* c, struct zx_xa_Environments_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Environment->gg;
       e && e->g.tok == zx_xa_Environment_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Environment(c, (struct zx_xa_Environment_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Environments) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Environments_s* zx_NEW_xa_Environments(struct zx_ctx* c)
{
  struct zx_xa_Environments_s* x = ZX_ZALLOC(c, struct zx_xa_Environments_s);
  x->gg.g.tok = zx_xa_Environments_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Environments) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Environments(struct zx_ctx* c, struct zx_xa_Environments_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Environment->gg;
       se && se->g.tok == zx_xa_Environment_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Environment(c, (struct zx_xa_Environment_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Environments) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Environments_s* zx_DEEP_CLONE_xa_Environments(struct zx_ctx* c, struct zx_xa_Environments_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Environments_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Environments_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Environment->gg;
       e && e->g.tok == zx_xa_Environment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Environment(c,(struct zx_xa_Environment_s*)e,dup_strs);
  	  if (!enn)
  	      x->Environment = (struct zx_xa_Environment_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Environments) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Environments(struct zx_ctx* c, struct zx_xa_Environments_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Environment->gg;
       e && e->g.tok == zx_xa_Environment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Environment(c, (struct zx_xa_Environment_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Environments) */

int zx_WALK_WO_xa_Environments(struct zx_ctx* c, struct zx_xa_Environments_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Function
#define EL_STRUCT zx_xa_Function_s
#define EL_NS     xa
#define EL_TAG    Function

/* FUNC(zx_FREE_xa_Function) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Function(struct zx_ctx* c, struct zx_xa_Function_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->FunctionId, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Function) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Function_s* zx_NEW_xa_Function(struct zx_ctx* c)
{
  struct zx_xa_Function_s* x = ZX_ZALLOC(c, struct zx_xa_Function_s);
  x->gg.g.tok = zx_xa_Function_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Function) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Function(struct zx_ctx* c, struct zx_xa_Function_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->FunctionId);


}

/* FUNC(zx_DEEP_CLONE_xa_Function) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Function_s* zx_DEEP_CLONE_xa_Function(struct zx_ctx* c, struct zx_xa_Function_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Function_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Function_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->FunctionId = zx_clone_attr(c, x->FunctionId);


  return x;
}

/* FUNC(zx_WALK_SO_xa_Function) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Function(struct zx_ctx* c, struct zx_xa_Function_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Function) */

int zx_WALK_WO_xa_Function(struct zx_ctx* c, struct zx_xa_Function_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Obligation
#define EL_STRUCT zx_xa_Obligation_s
#define EL_NS     xa
#define EL_TAG    Obligation

/* FUNC(zx_FREE_xa_Obligation) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Obligation(struct zx_ctx* c, struct zx_xa_Obligation_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->FulfillOn, free_strs);
  zx_free_attr(c, x->ObligationId, free_strs);

  for (e = &x->AttributeAssignment->gg;
       e && e->g.tok == zx_xa_AttributeAssignment_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_AttributeAssignment(c, (struct zx_xa_AttributeAssignment_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Obligation) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Obligation_s* zx_NEW_xa_Obligation(struct zx_ctx* c)
{
  struct zx_xa_Obligation_s* x = ZX_ZALLOC(c, struct zx_xa_Obligation_s);
  x->gg.g.tok = zx_xa_Obligation_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Obligation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Obligation(struct zx_ctx* c, struct zx_xa_Obligation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->FulfillOn);
  zx_dup_attr(c, x->ObligationId);

  for (se = &x->AttributeAssignment->gg;
       se && se->g.tok == zx_xa_AttributeAssignment_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeAssignment(c, (struct zx_xa_AttributeAssignment_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Obligation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Obligation_s* zx_DEEP_CLONE_xa_Obligation(struct zx_ctx* c, struct zx_xa_Obligation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Obligation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Obligation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->FulfillOn = zx_clone_attr(c, x->FulfillOn);
  x->ObligationId = zx_clone_attr(c, x->ObligationId);

  for (enn = 0, e = &x->AttributeAssignment->gg;
       e && e->g.tok == zx_xa_AttributeAssignment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeAssignment(c,(struct zx_xa_AttributeAssignment_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeAssignment = (struct zx_xa_AttributeAssignment_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Obligation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Obligation(struct zx_ctx* c, struct zx_xa_Obligation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeAssignment->gg;
       e && e->g.tok == zx_xa_AttributeAssignment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeAssignment(c, (struct zx_xa_AttributeAssignment_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Obligation) */

int zx_WALK_WO_xa_Obligation(struct zx_ctx* c, struct zx_xa_Obligation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Obligations
#define EL_STRUCT zx_xa_Obligations_s
#define EL_NS     xa
#define EL_TAG    Obligations

/* FUNC(zx_FREE_xa_Obligations) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Obligations(struct zx_ctx* c, struct zx_xa_Obligations_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Obligation->gg;
       e && e->g.tok == zx_xa_Obligation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Obligation(c, (struct zx_xa_Obligation_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Obligations) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Obligations_s* zx_NEW_xa_Obligations(struct zx_ctx* c)
{
  struct zx_xa_Obligations_s* x = ZX_ZALLOC(c, struct zx_xa_Obligations_s);
  x->gg.g.tok = zx_xa_Obligations_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Obligations) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Obligations(struct zx_ctx* c, struct zx_xa_Obligations_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Obligation->gg;
       se && se->g.tok == zx_xa_Obligation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Obligation(c, (struct zx_xa_Obligation_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Obligations) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Obligations_s* zx_DEEP_CLONE_xa_Obligations(struct zx_ctx* c, struct zx_xa_Obligations_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Obligations_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Obligations_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Obligation->gg;
       e && e->g.tok == zx_xa_Obligation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Obligation(c,(struct zx_xa_Obligation_s*)e,dup_strs);
  	  if (!enn)
  	      x->Obligation = (struct zx_xa_Obligation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Obligations) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Obligations(struct zx_ctx* c, struct zx_xa_Obligations_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Obligation->gg;
       e && e->g.tok == zx_xa_Obligation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Obligation(c, (struct zx_xa_Obligation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Obligations) */

int zx_WALK_WO_xa_Obligations(struct zx_ctx* c, struct zx_xa_Obligations_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Policy
#define EL_STRUCT zx_xa_Policy_s
#define EL_NS     xa
#define EL_TAG    Policy

/* FUNC(zx_FREE_xa_Policy) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Policy(struct zx_ctx* c, struct zx_xa_Policy_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->PolicyId, free_strs);
  zx_free_attr(c, x->RuleCombiningAlgId, free_strs);
  zx_free_attr(c, x->Version, free_strs);

  zx_free_simple_elems(c, x->Description, free_strs);
  for (e = &x->PolicyDefaults->gg;
       e && e->g.tok == zx_xa_PolicyDefaults_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_PolicyDefaults(c, (struct zx_xa_PolicyDefaults_s*)e, free_strs);
  }
  for (e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Target(c, (struct zx_xa_Target_s*)e, free_strs);
  }
  for (e = &x->CombinerParameters->gg;
       e && e->g.tok == zx_xa_CombinerParameters_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)e, free_strs);
  }
  for (e = &x->RuleCombinerParameters->gg;
       e && e->g.tok == zx_xa_RuleCombinerParameters_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_RuleCombinerParameters(c, (struct zx_xa_RuleCombinerParameters_s*)e, free_strs);
  }
  for (e = &x->VariableDefinition->gg;
       e && e->g.tok == zx_xa_VariableDefinition_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_VariableDefinition(c, (struct zx_xa_VariableDefinition_s*)e, free_strs);
  }
  for (e = &x->Rule->gg;
       e && e->g.tok == zx_xa_Rule_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Rule(c, (struct zx_xa_Rule_s*)e, free_strs);
  }
  for (e = &x->Obligations->gg;
       e && e->g.tok == zx_xa_Obligations_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Obligations(c, (struct zx_xa_Obligations_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Policy) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Policy_s* zx_NEW_xa_Policy(struct zx_ctx* c)
{
  struct zx_xa_Policy_s* x = ZX_ZALLOC(c, struct zx_xa_Policy_s);
  x->gg.g.tok = zx_xa_Policy_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Policy) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Policy(struct zx_ctx* c, struct zx_xa_Policy_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->PolicyId);
  zx_dup_attr(c, x->RuleCombiningAlgId);
  zx_dup_attr(c, x->Version);

  zx_dup_strs_simple_elems(c, x->Description);
  for (se = &x->PolicyDefaults->gg;
       se && se->g.tok == zx_xa_PolicyDefaults_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicyDefaults(c, (struct zx_xa_PolicyDefaults_s*)se);
  for (se = &x->Target->gg;
       se && se->g.tok == zx_xa_Target_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Target(c, (struct zx_xa_Target_s*)se);
  for (se = &x->CombinerParameters->gg;
       se && se->g.tok == zx_xa_CombinerParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)se);
  for (se = &x->RuleCombinerParameters->gg;
       se && se->g.tok == zx_xa_RuleCombinerParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_RuleCombinerParameters(c, (struct zx_xa_RuleCombinerParameters_s*)se);
  for (se = &x->VariableDefinition->gg;
       se && se->g.tok == zx_xa_VariableDefinition_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_VariableDefinition(c, (struct zx_xa_VariableDefinition_s*)se);
  for (se = &x->Rule->gg;
       se && se->g.tok == zx_xa_Rule_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Rule(c, (struct zx_xa_Rule_s*)se);
  for (se = &x->Obligations->gg;
       se && se->g.tok == zx_xa_Obligations_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Obligations(c, (struct zx_xa_Obligations_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Policy) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Policy_s* zx_DEEP_CLONE_xa_Policy(struct zx_ctx* c, struct zx_xa_Policy_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Policy_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Policy_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->PolicyId = zx_clone_attr(c, x->PolicyId);
  x->RuleCombiningAlgId = zx_clone_attr(c, x->RuleCombiningAlgId);
  x->Version = zx_clone_attr(c, x->Version);

  x->Description = zx_deep_clone_simple_elems(c,x->Description, dup_strs);
  for (enn = 0, e = &x->PolicyDefaults->gg;
       e && e->g.tok == zx_xa_PolicyDefaults_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicyDefaults(c,(struct zx_xa_PolicyDefaults_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicyDefaults = (struct zx_xa_PolicyDefaults_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Target(c,(struct zx_xa_Target_s*)e,dup_strs);
  	  if (!enn)
  	      x->Target = (struct zx_xa_Target_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CombinerParameters->gg;
       e && e->g.tok == zx_xa_CombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameters(c,(struct zx_xa_CombinerParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameters = (struct zx_xa_CombinerParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RuleCombinerParameters->gg;
       e && e->g.tok == zx_xa_RuleCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_RuleCombinerParameters(c,(struct zx_xa_RuleCombinerParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->RuleCombinerParameters = (struct zx_xa_RuleCombinerParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->VariableDefinition->gg;
       e && e->g.tok == zx_xa_VariableDefinition_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_VariableDefinition(c,(struct zx_xa_VariableDefinition_s*)e,dup_strs);
  	  if (!enn)
  	      x->VariableDefinition = (struct zx_xa_VariableDefinition_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Rule->gg;
       e && e->g.tok == zx_xa_Rule_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Rule(c,(struct zx_xa_Rule_s*)e,dup_strs);
  	  if (!enn)
  	      x->Rule = (struct zx_xa_Rule_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Obligations->gg;
       e && e->g.tok == zx_xa_Obligations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Obligations(c,(struct zx_xa_Obligations_s*)e,dup_strs);
  	  if (!enn)
  	      x->Obligations = (struct zx_xa_Obligations_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Policy) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Policy(struct zx_ctx* c, struct zx_xa_Policy_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Description, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PolicyDefaults->gg;
       e && e->g.tok == zx_xa_PolicyDefaults_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicyDefaults(c, (struct zx_xa_PolicyDefaults_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Target(c, (struct zx_xa_Target_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CombinerParameters->gg;
       e && e->g.tok == zx_xa_CombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RuleCombinerParameters->gg;
       e && e->g.tok == zx_xa_RuleCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_RuleCombinerParameters(c, (struct zx_xa_RuleCombinerParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->VariableDefinition->gg;
       e && e->g.tok == zx_xa_VariableDefinition_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_VariableDefinition(c, (struct zx_xa_VariableDefinition_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Rule->gg;
       e && e->g.tok == zx_xa_Rule_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Rule(c, (struct zx_xa_Rule_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Obligations->gg;
       e && e->g.tok == zx_xa_Obligations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Obligations(c, (struct zx_xa_Obligations_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Policy) */

int zx_WALK_WO_xa_Policy(struct zx_ctx* c, struct zx_xa_Policy_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicyCombinerParameters
#define EL_STRUCT zx_xa_PolicyCombinerParameters_s
#define EL_NS     xa
#define EL_TAG    PolicyCombinerParameters

/* FUNC(zx_FREE_xa_PolicyCombinerParameters) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_PolicyCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicyCombinerParameters_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->PolicyIdRef, free_strs);

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_PolicyCombinerParameters) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_PolicyCombinerParameters_s* zx_NEW_xa_PolicyCombinerParameters(struct zx_ctx* c)
{
  struct zx_xa_PolicyCombinerParameters_s* x = ZX_ZALLOC(c, struct zx_xa_PolicyCombinerParameters_s);
  x->gg.g.tok = zx_xa_PolicyCombinerParameters_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicyCombinerParameters) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicyCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicyCombinerParameters_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->PolicyIdRef);

  for (se = &x->CombinerParameter->gg;
       se && se->g.tok == zx_xa_CombinerParameter_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_PolicyCombinerParameters) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicyCombinerParameters_s* zx_DEEP_CLONE_xa_PolicyCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicyCombinerParameters_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicyCombinerParameters_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicyCombinerParameters_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->PolicyIdRef = zx_clone_attr(c, x->PolicyIdRef);

  for (enn = 0, e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameter(c,(struct zx_xa_CombinerParameter_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicyCombinerParameters) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicyCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicyCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicyCombinerParameters) */

int zx_WALK_WO_xa_PolicyCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicyCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicyDefaults
#define EL_STRUCT zx_xa_PolicyDefaults_s
#define EL_NS     xa
#define EL_TAG    PolicyDefaults

/* FUNC(zx_FREE_xa_PolicyDefaults) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_PolicyDefaults(struct zx_ctx* c, struct zx_xa_PolicyDefaults_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->XPathVersion, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_PolicyDefaults) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_PolicyDefaults_s* zx_NEW_xa_PolicyDefaults(struct zx_ctx* c)
{
  struct zx_xa_PolicyDefaults_s* x = ZX_ZALLOC(c, struct zx_xa_PolicyDefaults_s);
  x->gg.g.tok = zx_xa_PolicyDefaults_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicyDefaults) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicyDefaults(struct zx_ctx* c, struct zx_xa_PolicyDefaults_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->XPathVersion);

}

/* FUNC(zx_DEEP_CLONE_xa_PolicyDefaults) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicyDefaults_s* zx_DEEP_CLONE_xa_PolicyDefaults(struct zx_ctx* c, struct zx_xa_PolicyDefaults_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicyDefaults_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicyDefaults_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->XPathVersion = zx_deep_clone_simple_elems(c,x->XPathVersion, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicyDefaults) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicyDefaults(struct zx_ctx* c, struct zx_xa_PolicyDefaults_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->XPathVersion, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicyDefaults) */

int zx_WALK_WO_xa_PolicyDefaults(struct zx_ctx* c, struct zx_xa_PolicyDefaults_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicyIdReference
#define EL_STRUCT zx_xa_PolicyIdReference_s
#define EL_NS     xa
#define EL_TAG    PolicyIdReference

/* FUNC(zx_FREE_xa_PolicyIdReference) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_PolicyIdReference(struct zx_ctx* c, struct zx_xa_PolicyIdReference_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->EarliestVersion, free_strs);
  zx_free_attr(c, x->LatestVersion, free_strs);
  zx_free_attr(c, x->Version, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_PolicyIdReference) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_PolicyIdReference_s* zx_NEW_xa_PolicyIdReference(struct zx_ctx* c)
{
  struct zx_xa_PolicyIdReference_s* x = ZX_ZALLOC(c, struct zx_xa_PolicyIdReference_s);
  x->gg.g.tok = zx_xa_PolicyIdReference_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicyIdReference) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicyIdReference(struct zx_ctx* c, struct zx_xa_PolicyIdReference_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->EarliestVersion);
  zx_dup_attr(c, x->LatestVersion);
  zx_dup_attr(c, x->Version);


}

/* FUNC(zx_DEEP_CLONE_xa_PolicyIdReference) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicyIdReference_s* zx_DEEP_CLONE_xa_PolicyIdReference(struct zx_ctx* c, struct zx_xa_PolicyIdReference_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicyIdReference_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicyIdReference_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->EarliestVersion = zx_clone_attr(c, x->EarliestVersion);
  x->LatestVersion = zx_clone_attr(c, x->LatestVersion);
  x->Version = zx_clone_attr(c, x->Version);


  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicyIdReference) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicyIdReference(struct zx_ctx* c, struct zx_xa_PolicyIdReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicyIdReference) */

int zx_WALK_WO_xa_PolicyIdReference(struct zx_ctx* c, struct zx_xa_PolicyIdReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicySet
#define EL_STRUCT zx_xa_PolicySet_s
#define EL_NS     xa
#define EL_TAG    PolicySet

/* FUNC(zx_FREE_xa_PolicySet) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_PolicySet(struct zx_ctx* c, struct zx_xa_PolicySet_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->PolicyCombiningAlgId, free_strs);
  zx_free_attr(c, x->PolicySetId, free_strs);
  zx_free_attr(c, x->Version, free_strs);

  zx_free_simple_elems(c, x->Description, free_strs);
  for (e = &x->PolicySetDefaults->gg;
       e && e->g.tok == zx_xa_PolicySetDefaults_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_PolicySetDefaults(c, (struct zx_xa_PolicySetDefaults_s*)e, free_strs);
  }
  for (e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Target(c, (struct zx_xa_Target_s*)e, free_strs);
  }
  for (e = &x->PolicySet->gg;
       e && e->g.tok == zx_xa_PolicySet_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_PolicySet(c, (struct zx_xa_PolicySet_s*)e, free_strs);
  }
  for (e = &x->Policy->gg;
       e && e->g.tok == zx_xa_Policy_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Policy(c, (struct zx_xa_Policy_s*)e, free_strs);
  }
  for (e = &x->PolicySetIdReference->gg;
       e && e->g.tok == zx_xa_PolicySetIdReference_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_PolicySetIdReference(c, (struct zx_xa_PolicySetIdReference_s*)e, free_strs);
  }
  for (e = &x->PolicyIdReference->gg;
       e && e->g.tok == zx_xa_PolicyIdReference_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_PolicyIdReference(c, (struct zx_xa_PolicyIdReference_s*)e, free_strs);
  }
  for (e = &x->CombinerParameters->gg;
       e && e->g.tok == zx_xa_CombinerParameters_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)e, free_strs);
  }
  for (e = &x->PolicyCombinerParameters->gg;
       e && e->g.tok == zx_xa_PolicyCombinerParameters_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_PolicyCombinerParameters(c, (struct zx_xa_PolicyCombinerParameters_s*)e, free_strs);
  }
  for (e = &x->PolicySetCombinerParameters->gg;
       e && e->g.tok == zx_xa_PolicySetCombinerParameters_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_PolicySetCombinerParameters(c, (struct zx_xa_PolicySetCombinerParameters_s*)e, free_strs);
  }
  for (e = &x->Obligations->gg;
       e && e->g.tok == zx_xa_Obligations_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Obligations(c, (struct zx_xa_Obligations_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_PolicySet) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_PolicySet_s* zx_NEW_xa_PolicySet(struct zx_ctx* c)
{
  struct zx_xa_PolicySet_s* x = ZX_ZALLOC(c, struct zx_xa_PolicySet_s);
  x->gg.g.tok = zx_xa_PolicySet_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicySet) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicySet(struct zx_ctx* c, struct zx_xa_PolicySet_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->PolicyCombiningAlgId);
  zx_dup_attr(c, x->PolicySetId);
  zx_dup_attr(c, x->Version);

  zx_dup_strs_simple_elems(c, x->Description);
  for (se = &x->PolicySetDefaults->gg;
       se && se->g.tok == zx_xa_PolicySetDefaults_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicySetDefaults(c, (struct zx_xa_PolicySetDefaults_s*)se);
  for (se = &x->Target->gg;
       se && se->g.tok == zx_xa_Target_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Target(c, (struct zx_xa_Target_s*)se);
  for (se = &x->PolicySet->gg;
       se && se->g.tok == zx_xa_PolicySet_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicySet(c, (struct zx_xa_PolicySet_s*)se);
  for (se = &x->Policy->gg;
       se && se->g.tok == zx_xa_Policy_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Policy(c, (struct zx_xa_Policy_s*)se);
  for (se = &x->PolicySetIdReference->gg;
       se && se->g.tok == zx_xa_PolicySetIdReference_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicySetIdReference(c, (struct zx_xa_PolicySetIdReference_s*)se);
  for (se = &x->PolicyIdReference->gg;
       se && se->g.tok == zx_xa_PolicyIdReference_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicyIdReference(c, (struct zx_xa_PolicyIdReference_s*)se);
  for (se = &x->CombinerParameters->gg;
       se && se->g.tok == zx_xa_CombinerParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)se);
  for (se = &x->PolicyCombinerParameters->gg;
       se && se->g.tok == zx_xa_PolicyCombinerParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicyCombinerParameters(c, (struct zx_xa_PolicyCombinerParameters_s*)se);
  for (se = &x->PolicySetCombinerParameters->gg;
       se && se->g.tok == zx_xa_PolicySetCombinerParameters_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_PolicySetCombinerParameters(c, (struct zx_xa_PolicySetCombinerParameters_s*)se);
  for (se = &x->Obligations->gg;
       se && se->g.tok == zx_xa_Obligations_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Obligations(c, (struct zx_xa_Obligations_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_PolicySet) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicySet_s* zx_DEEP_CLONE_xa_PolicySet(struct zx_ctx* c, struct zx_xa_PolicySet_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicySet_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicySet_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->PolicyCombiningAlgId = zx_clone_attr(c, x->PolicyCombiningAlgId);
  x->PolicySetId = zx_clone_attr(c, x->PolicySetId);
  x->Version = zx_clone_attr(c, x->Version);

  x->Description = zx_deep_clone_simple_elems(c,x->Description, dup_strs);
  for (enn = 0, e = &x->PolicySetDefaults->gg;
       e && e->g.tok == zx_xa_PolicySetDefaults_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicySetDefaults(c,(struct zx_xa_PolicySetDefaults_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicySetDefaults = (struct zx_xa_PolicySetDefaults_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Target(c,(struct zx_xa_Target_s*)e,dup_strs);
  	  if (!enn)
  	      x->Target = (struct zx_xa_Target_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PolicySet->gg;
       e && e->g.tok == zx_xa_PolicySet_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicySet(c,(struct zx_xa_PolicySet_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicySet = (struct zx_xa_PolicySet_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Policy->gg;
       e && e->g.tok == zx_xa_Policy_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Policy(c,(struct zx_xa_Policy_s*)e,dup_strs);
  	  if (!enn)
  	      x->Policy = (struct zx_xa_Policy_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PolicySetIdReference->gg;
       e && e->g.tok == zx_xa_PolicySetIdReference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicySetIdReference(c,(struct zx_xa_PolicySetIdReference_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicySetIdReference = (struct zx_xa_PolicySetIdReference_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PolicyIdReference->gg;
       e && e->g.tok == zx_xa_PolicyIdReference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicyIdReference(c,(struct zx_xa_PolicyIdReference_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicyIdReference = (struct zx_xa_PolicyIdReference_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CombinerParameters->gg;
       e && e->g.tok == zx_xa_CombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameters(c,(struct zx_xa_CombinerParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameters = (struct zx_xa_CombinerParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PolicyCombinerParameters->gg;
       e && e->g.tok == zx_xa_PolicyCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicyCombinerParameters(c,(struct zx_xa_PolicyCombinerParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicyCombinerParameters = (struct zx_xa_PolicyCombinerParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PolicySetCombinerParameters->gg;
       e && e->g.tok == zx_xa_PolicySetCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_PolicySetCombinerParameters(c,(struct zx_xa_PolicySetCombinerParameters_s*)e,dup_strs);
  	  if (!enn)
  	      x->PolicySetCombinerParameters = (struct zx_xa_PolicySetCombinerParameters_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Obligations->gg;
       e && e->g.tok == zx_xa_Obligations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Obligations(c,(struct zx_xa_Obligations_s*)e,dup_strs);
  	  if (!enn)
  	      x->Obligations = (struct zx_xa_Obligations_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicySet) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicySet(struct zx_ctx* c, struct zx_xa_PolicySet_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Description, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PolicySetDefaults->gg;
       e && e->g.tok == zx_xa_PolicySetDefaults_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicySetDefaults(c, (struct zx_xa_PolicySetDefaults_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Target(c, (struct zx_xa_Target_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PolicySet->gg;
       e && e->g.tok == zx_xa_PolicySet_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicySet(c, (struct zx_xa_PolicySet_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Policy->gg;
       e && e->g.tok == zx_xa_Policy_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Policy(c, (struct zx_xa_Policy_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PolicySetIdReference->gg;
       e && e->g.tok == zx_xa_PolicySetIdReference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicySetIdReference(c, (struct zx_xa_PolicySetIdReference_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PolicyIdReference->gg;
       e && e->g.tok == zx_xa_PolicyIdReference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicyIdReference(c, (struct zx_xa_PolicyIdReference_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CombinerParameters->gg;
       e && e->g.tok == zx_xa_CombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PolicyCombinerParameters->gg;
       e && e->g.tok == zx_xa_PolicyCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicyCombinerParameters(c, (struct zx_xa_PolicyCombinerParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PolicySetCombinerParameters->gg;
       e && e->g.tok == zx_xa_PolicySetCombinerParameters_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_PolicySetCombinerParameters(c, (struct zx_xa_PolicySetCombinerParameters_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Obligations->gg;
       e && e->g.tok == zx_xa_Obligations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Obligations(c, (struct zx_xa_Obligations_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicySet) */

int zx_WALK_WO_xa_PolicySet(struct zx_ctx* c, struct zx_xa_PolicySet_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicySetCombinerParameters
#define EL_STRUCT zx_xa_PolicySetCombinerParameters_s
#define EL_NS     xa
#define EL_TAG    PolicySetCombinerParameters

/* FUNC(zx_FREE_xa_PolicySetCombinerParameters) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_PolicySetCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicySetCombinerParameters_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->PolicySetIdRef, free_strs);

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_PolicySetCombinerParameters) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_PolicySetCombinerParameters_s* zx_NEW_xa_PolicySetCombinerParameters(struct zx_ctx* c)
{
  struct zx_xa_PolicySetCombinerParameters_s* x = ZX_ZALLOC(c, struct zx_xa_PolicySetCombinerParameters_s);
  x->gg.g.tok = zx_xa_PolicySetCombinerParameters_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicySetCombinerParameters) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicySetCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicySetCombinerParameters_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->PolicySetIdRef);

  for (se = &x->CombinerParameter->gg;
       se && se->g.tok == zx_xa_CombinerParameter_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_PolicySetCombinerParameters) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicySetCombinerParameters_s* zx_DEEP_CLONE_xa_PolicySetCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicySetCombinerParameters_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicySetCombinerParameters_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicySetCombinerParameters_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->PolicySetIdRef = zx_clone_attr(c, x->PolicySetIdRef);

  for (enn = 0, e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameter(c,(struct zx_xa_CombinerParameter_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicySetCombinerParameters) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicySetCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicySetCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicySetCombinerParameters) */

int zx_WALK_WO_xa_PolicySetCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicySetCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicySetDefaults
#define EL_STRUCT zx_xa_PolicySetDefaults_s
#define EL_NS     xa
#define EL_TAG    PolicySetDefaults

/* FUNC(zx_FREE_xa_PolicySetDefaults) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_PolicySetDefaults(struct zx_ctx* c, struct zx_xa_PolicySetDefaults_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->XPathVersion, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_PolicySetDefaults) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_PolicySetDefaults_s* zx_NEW_xa_PolicySetDefaults(struct zx_ctx* c)
{
  struct zx_xa_PolicySetDefaults_s* x = ZX_ZALLOC(c, struct zx_xa_PolicySetDefaults_s);
  x->gg.g.tok = zx_xa_PolicySetDefaults_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicySetDefaults) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicySetDefaults(struct zx_ctx* c, struct zx_xa_PolicySetDefaults_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->XPathVersion);

}

/* FUNC(zx_DEEP_CLONE_xa_PolicySetDefaults) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicySetDefaults_s* zx_DEEP_CLONE_xa_PolicySetDefaults(struct zx_ctx* c, struct zx_xa_PolicySetDefaults_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicySetDefaults_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicySetDefaults_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->XPathVersion = zx_deep_clone_simple_elems(c,x->XPathVersion, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicySetDefaults) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicySetDefaults(struct zx_ctx* c, struct zx_xa_PolicySetDefaults_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->XPathVersion, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicySetDefaults) */

int zx_WALK_WO_xa_PolicySetDefaults(struct zx_ctx* c, struct zx_xa_PolicySetDefaults_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_PolicySetIdReference
#define EL_STRUCT zx_xa_PolicySetIdReference_s
#define EL_NS     xa
#define EL_TAG    PolicySetIdReference

/* FUNC(zx_FREE_xa_PolicySetIdReference) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_PolicySetIdReference(struct zx_ctx* c, struct zx_xa_PolicySetIdReference_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->EarliestVersion, free_strs);
  zx_free_attr(c, x->LatestVersion, free_strs);
  zx_free_attr(c, x->Version, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_PolicySetIdReference) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_PolicySetIdReference_s* zx_NEW_xa_PolicySetIdReference(struct zx_ctx* c)
{
  struct zx_xa_PolicySetIdReference_s* x = ZX_ZALLOC(c, struct zx_xa_PolicySetIdReference_s);
  x->gg.g.tok = zx_xa_PolicySetIdReference_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_PolicySetIdReference) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_PolicySetIdReference(struct zx_ctx* c, struct zx_xa_PolicySetIdReference_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->EarliestVersion);
  zx_dup_attr(c, x->LatestVersion);
  zx_dup_attr(c, x->Version);


}

/* FUNC(zx_DEEP_CLONE_xa_PolicySetIdReference) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_PolicySetIdReference_s* zx_DEEP_CLONE_xa_PolicySetIdReference(struct zx_ctx* c, struct zx_xa_PolicySetIdReference_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_PolicySetIdReference_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_PolicySetIdReference_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->EarliestVersion = zx_clone_attr(c, x->EarliestVersion);
  x->LatestVersion = zx_clone_attr(c, x->LatestVersion);
  x->Version = zx_clone_attr(c, x->Version);


  return x;
}

/* FUNC(zx_WALK_SO_xa_PolicySetIdReference) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_PolicySetIdReference(struct zx_ctx* c, struct zx_xa_PolicySetIdReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_PolicySetIdReference) */

int zx_WALK_WO_xa_PolicySetIdReference(struct zx_ctx* c, struct zx_xa_PolicySetIdReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Resource
#define EL_STRUCT zx_xa_Resource_s
#define EL_NS     xa
#define EL_TAG    Resource

/* FUNC(zx_FREE_xa_Resource) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Resource(struct zx_ctx* c, struct zx_xa_Resource_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->ResourceMatch->gg;
       e && e->g.tok == zx_xa_ResourceMatch_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_ResourceMatch(c, (struct zx_xa_ResourceMatch_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Resource) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Resource_s* zx_NEW_xa_Resource(struct zx_ctx* c)
{
  struct zx_xa_Resource_s* x = ZX_ZALLOC(c, struct zx_xa_Resource_s);
  x->gg.g.tok = zx_xa_Resource_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Resource) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Resource(struct zx_ctx* c, struct zx_xa_Resource_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ResourceMatch->gg;
       se && se->g.tok == zx_xa_ResourceMatch_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_ResourceMatch(c, (struct zx_xa_ResourceMatch_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Resource) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Resource_s* zx_DEEP_CLONE_xa_Resource(struct zx_ctx* c, struct zx_xa_Resource_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Resource_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Resource_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ResourceMatch->gg;
       e && e->g.tok == zx_xa_ResourceMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_ResourceMatch(c,(struct zx_xa_ResourceMatch_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResourceMatch = (struct zx_xa_ResourceMatch_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Resource) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Resource(struct zx_ctx* c, struct zx_xa_Resource_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ResourceMatch->gg;
       e && e->g.tok == zx_xa_ResourceMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_ResourceMatch(c, (struct zx_xa_ResourceMatch_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Resource) */

int zx_WALK_WO_xa_Resource(struct zx_ctx* c, struct zx_xa_Resource_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_ResourceAttributeDesignator
#define EL_STRUCT zx_xa_ResourceAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    ResourceAttributeDesignator

/* FUNC(zx_FREE_xa_ResourceAttributeDesignator) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_ResourceAttributeDesignator(struct zx_ctx* c, struct zx_xa_ResourceAttributeDesignator_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->AttributeId, free_strs);
  zx_free_attr(c, x->DataType, free_strs);
  zx_free_attr(c, x->Issuer, free_strs);
  zx_free_attr(c, x->MustBePresent, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_ResourceAttributeDesignator) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_ResourceAttributeDesignator_s* zx_NEW_xa_ResourceAttributeDesignator(struct zx_ctx* c)
{
  struct zx_xa_ResourceAttributeDesignator_s* x = ZX_ZALLOC(c, struct zx_xa_ResourceAttributeDesignator_s);
  x->gg.g.tok = zx_xa_ResourceAttributeDesignator_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_ResourceAttributeDesignator) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_ResourceAttributeDesignator(struct zx_ctx* c, struct zx_xa_ResourceAttributeDesignator_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->AttributeId);
  zx_dup_attr(c, x->DataType);
  zx_dup_attr(c, x->Issuer);
  zx_dup_attr(c, x->MustBePresent);


}

/* FUNC(zx_DEEP_CLONE_xa_ResourceAttributeDesignator) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_ResourceAttributeDesignator_s* zx_DEEP_CLONE_xa_ResourceAttributeDesignator(struct zx_ctx* c, struct zx_xa_ResourceAttributeDesignator_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_ResourceAttributeDesignator_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_ResourceAttributeDesignator_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->AttributeId = zx_clone_attr(c, x->AttributeId);
  x->DataType = zx_clone_attr(c, x->DataType);
  x->Issuer = zx_clone_attr(c, x->Issuer);
  x->MustBePresent = zx_clone_attr(c, x->MustBePresent);


  return x;
}

/* FUNC(zx_WALK_SO_xa_ResourceAttributeDesignator) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_ResourceAttributeDesignator(struct zx_ctx* c, struct zx_xa_ResourceAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_ResourceAttributeDesignator) */

int zx_WALK_WO_xa_ResourceAttributeDesignator(struct zx_ctx* c, struct zx_xa_ResourceAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_ResourceMatch
#define EL_STRUCT zx_xa_ResourceMatch_s
#define EL_NS     xa
#define EL_TAG    ResourceMatch

/* FUNC(zx_FREE_xa_ResourceMatch) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_ResourceMatch(struct zx_ctx* c, struct zx_xa_ResourceMatch_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->MatchId, free_strs);

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, free_strs);
  }
  for (e = &x->ResourceAttributeDesignator->gg;
       e && e->g.tok == zx_xa_ResourceAttributeDesignator_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_ResourceAttributeDesignator(c, (struct zx_xa_ResourceAttributeDesignator_s*)e, free_strs);
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_ResourceMatch) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_ResourceMatch_s* zx_NEW_xa_ResourceMatch(struct zx_ctx* c)
{
  struct zx_xa_ResourceMatch_s* x = ZX_ZALLOC(c, struct zx_xa_ResourceMatch_s);
  x->gg.g.tok = zx_xa_ResourceMatch_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_ResourceMatch) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_ResourceMatch(struct zx_ctx* c, struct zx_xa_ResourceMatch_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->MatchId);

  for (se = &x->AttributeValue->gg;
       se && se->g.tok == zx_xa_AttributeValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)se);
  for (se = &x->ResourceAttributeDesignator->gg;
       se && se->g.tok == zx_xa_ResourceAttributeDesignator_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_ResourceAttributeDesignator(c, (struct zx_xa_ResourceAttributeDesignator_s*)se);
  for (se = &x->AttributeSelector->gg;
       se && se->g.tok == zx_xa_AttributeSelector_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_ResourceMatch) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_ResourceMatch_s* zx_DEEP_CLONE_xa_ResourceMatch(struct zx_ctx* c, struct zx_xa_ResourceMatch_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_ResourceMatch_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_ResourceMatch_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->MatchId = zx_clone_attr(c, x->MatchId);

  for (enn = 0, e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeValue(c,(struct zx_xa_AttributeValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeValue = (struct zx_xa_AttributeValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ResourceAttributeDesignator->gg;
       e && e->g.tok == zx_xa_ResourceAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_ResourceAttributeDesignator(c,(struct zx_xa_ResourceAttributeDesignator_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResourceAttributeDesignator = (struct zx_xa_ResourceAttributeDesignator_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeSelector(c,(struct zx_xa_AttributeSelector_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_ResourceMatch) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_ResourceMatch(struct zx_ctx* c, struct zx_xa_ResourceMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ResourceAttributeDesignator->gg;
       e && e->g.tok == zx_xa_ResourceAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_ResourceAttributeDesignator(c, (struct zx_xa_ResourceAttributeDesignator_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_ResourceMatch) */

int zx_WALK_WO_xa_ResourceMatch(struct zx_ctx* c, struct zx_xa_ResourceMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Resources
#define EL_STRUCT zx_xa_Resources_s
#define EL_NS     xa
#define EL_TAG    Resources

/* FUNC(zx_FREE_xa_Resources) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Resources(struct zx_ctx* c, struct zx_xa_Resources_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Resource->gg;
       e && e->g.tok == zx_xa_Resource_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Resource(c, (struct zx_xa_Resource_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Resources) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Resources_s* zx_NEW_xa_Resources(struct zx_ctx* c)
{
  struct zx_xa_Resources_s* x = ZX_ZALLOC(c, struct zx_xa_Resources_s);
  x->gg.g.tok = zx_xa_Resources_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Resources) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Resources(struct zx_ctx* c, struct zx_xa_Resources_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Resource->gg;
       se && se->g.tok == zx_xa_Resource_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Resource(c, (struct zx_xa_Resource_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Resources) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Resources_s* zx_DEEP_CLONE_xa_Resources(struct zx_ctx* c, struct zx_xa_Resources_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Resources_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Resources_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Resource->gg;
       e && e->g.tok == zx_xa_Resource_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Resource(c,(struct zx_xa_Resource_s*)e,dup_strs);
  	  if (!enn)
  	      x->Resource = (struct zx_xa_Resource_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Resources) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Resources(struct zx_ctx* c, struct zx_xa_Resources_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Resource->gg;
       e && e->g.tok == zx_xa_Resource_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Resource(c, (struct zx_xa_Resource_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Resources) */

int zx_WALK_WO_xa_Resources(struct zx_ctx* c, struct zx_xa_Resources_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Rule
#define EL_STRUCT zx_xa_Rule_s
#define EL_NS     xa
#define EL_TAG    Rule

/* FUNC(zx_FREE_xa_Rule) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Rule(struct zx_ctx* c, struct zx_xa_Rule_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->Effect, free_strs);
  zx_free_attr(c, x->RuleId, free_strs);

  zx_free_simple_elems(c, x->Description, free_strs);
  for (e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Target(c, (struct zx_xa_Target_s*)e, free_strs);
  }
  for (e = &x->Condition->gg;
       e && e->g.tok == zx_xa_Condition_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Condition(c, (struct zx_xa_Condition_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Rule) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Rule_s* zx_NEW_xa_Rule(struct zx_ctx* c)
{
  struct zx_xa_Rule_s* x = ZX_ZALLOC(c, struct zx_xa_Rule_s);
  x->gg.g.tok = zx_xa_Rule_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Rule) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Rule(struct zx_ctx* c, struct zx_xa_Rule_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->Effect);
  zx_dup_attr(c, x->RuleId);

  zx_dup_strs_simple_elems(c, x->Description);
  for (se = &x->Target->gg;
       se && se->g.tok == zx_xa_Target_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Target(c, (struct zx_xa_Target_s*)se);
  for (se = &x->Condition->gg;
       se && se->g.tok == zx_xa_Condition_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Condition(c, (struct zx_xa_Condition_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Rule) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Rule_s* zx_DEEP_CLONE_xa_Rule(struct zx_ctx* c, struct zx_xa_Rule_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Rule_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Rule_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->Effect = zx_clone_attr(c, x->Effect);
  x->RuleId = zx_clone_attr(c, x->RuleId);

  x->Description = zx_deep_clone_simple_elems(c,x->Description, dup_strs);
  for (enn = 0, e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Target(c,(struct zx_xa_Target_s*)e,dup_strs);
  	  if (!enn)
  	      x->Target = (struct zx_xa_Target_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Condition->gg;
       e && e->g.tok == zx_xa_Condition_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Condition(c,(struct zx_xa_Condition_s*)e,dup_strs);
  	  if (!enn)
  	      x->Condition = (struct zx_xa_Condition_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Rule) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Rule(struct zx_ctx* c, struct zx_xa_Rule_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Description, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Target->gg;
       e && e->g.tok == zx_xa_Target_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Target(c, (struct zx_xa_Target_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Condition->gg;
       e && e->g.tok == zx_xa_Condition_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Condition(c, (struct zx_xa_Condition_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Rule) */

int zx_WALK_WO_xa_Rule(struct zx_ctx* c, struct zx_xa_Rule_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_RuleCombinerParameters
#define EL_STRUCT zx_xa_RuleCombinerParameters_s
#define EL_NS     xa
#define EL_TAG    RuleCombinerParameters

/* FUNC(zx_FREE_xa_RuleCombinerParameters) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_RuleCombinerParameters(struct zx_ctx* c, struct zx_xa_RuleCombinerParameters_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->RuleIdRef, free_strs);

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_RuleCombinerParameters) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_RuleCombinerParameters_s* zx_NEW_xa_RuleCombinerParameters(struct zx_ctx* c)
{
  struct zx_xa_RuleCombinerParameters_s* x = ZX_ZALLOC(c, struct zx_xa_RuleCombinerParameters_s);
  x->gg.g.tok = zx_xa_RuleCombinerParameters_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_RuleCombinerParameters) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_RuleCombinerParameters(struct zx_ctx* c, struct zx_xa_RuleCombinerParameters_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->RuleIdRef);

  for (se = &x->CombinerParameter->gg;
       se && se->g.tok == zx_xa_CombinerParameter_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_RuleCombinerParameters) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_RuleCombinerParameters_s* zx_DEEP_CLONE_xa_RuleCombinerParameters(struct zx_ctx* c, struct zx_xa_RuleCombinerParameters_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_RuleCombinerParameters_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_RuleCombinerParameters_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->RuleIdRef = zx_clone_attr(c, x->RuleIdRef);

  for (enn = 0, e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_CombinerParameter(c,(struct zx_xa_CombinerParameter_s*)e,dup_strs);
  	  if (!enn)
  	      x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_RuleCombinerParameters) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_RuleCombinerParameters(struct zx_ctx* c, struct zx_xa_RuleCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CombinerParameter->gg;
       e && e->g.tok == zx_xa_CombinerParameter_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_RuleCombinerParameters) */

int zx_WALK_WO_xa_RuleCombinerParameters(struct zx_ctx* c, struct zx_xa_RuleCombinerParameters_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Subject
#define EL_STRUCT zx_xa_Subject_s
#define EL_NS     xa
#define EL_TAG    Subject

/* FUNC(zx_FREE_xa_Subject) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Subject(struct zx_ctx* c, struct zx_xa_Subject_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->SubjectMatch->gg;
       e && e->g.tok == zx_xa_SubjectMatch_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_SubjectMatch(c, (struct zx_xa_SubjectMatch_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Subject) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Subject_s* zx_NEW_xa_Subject(struct zx_ctx* c)
{
  struct zx_xa_Subject_s* x = ZX_ZALLOC(c, struct zx_xa_Subject_s);
  x->gg.g.tok = zx_xa_Subject_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Subject) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Subject(struct zx_ctx* c, struct zx_xa_Subject_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->SubjectMatch->gg;
       se && se->g.tok == zx_xa_SubjectMatch_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_SubjectMatch(c, (struct zx_xa_SubjectMatch_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Subject) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Subject_s* zx_DEEP_CLONE_xa_Subject(struct zx_ctx* c, struct zx_xa_Subject_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Subject_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Subject_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->SubjectMatch->gg;
       e && e->g.tok == zx_xa_SubjectMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_SubjectMatch(c,(struct zx_xa_SubjectMatch_s*)e,dup_strs);
  	  if (!enn)
  	      x->SubjectMatch = (struct zx_xa_SubjectMatch_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Subject) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Subject(struct zx_ctx* c, struct zx_xa_Subject_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->SubjectMatch->gg;
       e && e->g.tok == zx_xa_SubjectMatch_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_SubjectMatch(c, (struct zx_xa_SubjectMatch_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Subject) */

int zx_WALK_WO_xa_Subject(struct zx_ctx* c, struct zx_xa_Subject_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_SubjectAttributeDesignator
#define EL_STRUCT zx_xa_SubjectAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    SubjectAttributeDesignator

/* FUNC(zx_FREE_xa_SubjectAttributeDesignator) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_SubjectAttributeDesignator(struct zx_ctx* c, struct zx_xa_SubjectAttributeDesignator_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->AttributeId, free_strs);
  zx_free_attr(c, x->DataType, free_strs);
  zx_free_attr(c, x->Issuer, free_strs);
  zx_free_attr(c, x->MustBePresent, free_strs);
  zx_free_attr(c, x->SubjectCategory, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_SubjectAttributeDesignator) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_SubjectAttributeDesignator_s* zx_NEW_xa_SubjectAttributeDesignator(struct zx_ctx* c)
{
  struct zx_xa_SubjectAttributeDesignator_s* x = ZX_ZALLOC(c, struct zx_xa_SubjectAttributeDesignator_s);
  x->gg.g.tok = zx_xa_SubjectAttributeDesignator_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_SubjectAttributeDesignator) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_SubjectAttributeDesignator(struct zx_ctx* c, struct zx_xa_SubjectAttributeDesignator_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->AttributeId);
  zx_dup_attr(c, x->DataType);
  zx_dup_attr(c, x->Issuer);
  zx_dup_attr(c, x->MustBePresent);
  zx_dup_attr(c, x->SubjectCategory);


}

/* FUNC(zx_DEEP_CLONE_xa_SubjectAttributeDesignator) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_SubjectAttributeDesignator_s* zx_DEEP_CLONE_xa_SubjectAttributeDesignator(struct zx_ctx* c, struct zx_xa_SubjectAttributeDesignator_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_SubjectAttributeDesignator_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_SubjectAttributeDesignator_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->AttributeId = zx_clone_attr(c, x->AttributeId);
  x->DataType = zx_clone_attr(c, x->DataType);
  x->Issuer = zx_clone_attr(c, x->Issuer);
  x->MustBePresent = zx_clone_attr(c, x->MustBePresent);
  x->SubjectCategory = zx_clone_attr(c, x->SubjectCategory);


  return x;
}

/* FUNC(zx_WALK_SO_xa_SubjectAttributeDesignator) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_SubjectAttributeDesignator(struct zx_ctx* c, struct zx_xa_SubjectAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_SubjectAttributeDesignator) */

int zx_WALK_WO_xa_SubjectAttributeDesignator(struct zx_ctx* c, struct zx_xa_SubjectAttributeDesignator_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_SubjectMatch
#define EL_STRUCT zx_xa_SubjectMatch_s
#define EL_NS     xa
#define EL_TAG    SubjectMatch

/* FUNC(zx_FREE_xa_SubjectMatch) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_SubjectMatch(struct zx_ctx* c, struct zx_xa_SubjectMatch_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->MatchId, free_strs);

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, free_strs);
  }
  for (e = &x->SubjectAttributeDesignator->gg;
       e && e->g.tok == zx_xa_SubjectAttributeDesignator_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_SubjectAttributeDesignator(c, (struct zx_xa_SubjectAttributeDesignator_s*)e, free_strs);
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_SubjectMatch) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_SubjectMatch_s* zx_NEW_xa_SubjectMatch(struct zx_ctx* c)
{
  struct zx_xa_SubjectMatch_s* x = ZX_ZALLOC(c, struct zx_xa_SubjectMatch_s);
  x->gg.g.tok = zx_xa_SubjectMatch_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_SubjectMatch) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_SubjectMatch(struct zx_ctx* c, struct zx_xa_SubjectMatch_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->MatchId);

  for (se = &x->AttributeValue->gg;
       se && se->g.tok == zx_xa_AttributeValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)se);
  for (se = &x->SubjectAttributeDesignator->gg;
       se && se->g.tok == zx_xa_SubjectAttributeDesignator_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_SubjectAttributeDesignator(c, (struct zx_xa_SubjectAttributeDesignator_s*)se);
  for (se = &x->AttributeSelector->gg;
       se && se->g.tok == zx_xa_AttributeSelector_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_SubjectMatch) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_SubjectMatch_s* zx_DEEP_CLONE_xa_SubjectMatch(struct zx_ctx* c, struct zx_xa_SubjectMatch_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_SubjectMatch_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_SubjectMatch_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->MatchId = zx_clone_attr(c, x->MatchId);

  for (enn = 0, e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeValue(c,(struct zx_xa_AttributeValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeValue = (struct zx_xa_AttributeValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SubjectAttributeDesignator->gg;
       e && e->g.tok == zx_xa_SubjectAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_SubjectAttributeDesignator(c,(struct zx_xa_SubjectAttributeDesignator_s*)e,dup_strs);
  	  if (!enn)
  	      x->SubjectAttributeDesignator = (struct zx_xa_SubjectAttributeDesignator_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_AttributeSelector(c,(struct zx_xa_AttributeSelector_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_SubjectMatch) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_SubjectMatch(struct zx_ctx* c, struct zx_xa_SubjectMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AttributeValue->gg;
       e && e->g.tok == zx_xa_AttributeValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SubjectAttributeDesignator->gg;
       e && e->g.tok == zx_xa_SubjectAttributeDesignator_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_SubjectAttributeDesignator(c, (struct zx_xa_SubjectAttributeDesignator_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AttributeSelector->gg;
       e && e->g.tok == zx_xa_AttributeSelector_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_SubjectMatch) */

int zx_WALK_WO_xa_SubjectMatch(struct zx_ctx* c, struct zx_xa_SubjectMatch_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Subjects
#define EL_STRUCT zx_xa_Subjects_s
#define EL_NS     xa
#define EL_TAG    Subjects

/* FUNC(zx_FREE_xa_Subjects) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Subjects(struct zx_ctx* c, struct zx_xa_Subjects_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Subject->gg;
       e && e->g.tok == zx_xa_Subject_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Subject(c, (struct zx_xa_Subject_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Subjects) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Subjects_s* zx_NEW_xa_Subjects(struct zx_ctx* c)
{
  struct zx_xa_Subjects_s* x = ZX_ZALLOC(c, struct zx_xa_Subjects_s);
  x->gg.g.tok = zx_xa_Subjects_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Subjects) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Subjects(struct zx_ctx* c, struct zx_xa_Subjects_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Subject->gg;
       se && se->g.tok == zx_xa_Subject_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Subject(c, (struct zx_xa_Subject_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Subjects) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Subjects_s* zx_DEEP_CLONE_xa_Subjects(struct zx_ctx* c, struct zx_xa_Subjects_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Subjects_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Subjects_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Subject->gg;
       e && e->g.tok == zx_xa_Subject_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Subject(c,(struct zx_xa_Subject_s*)e,dup_strs);
  	  if (!enn)
  	      x->Subject = (struct zx_xa_Subject_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Subjects) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Subjects(struct zx_ctx* c, struct zx_xa_Subjects_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Subject->gg;
       e && e->g.tok == zx_xa_Subject_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Subject(c, (struct zx_xa_Subject_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Subjects) */

int zx_WALK_WO_xa_Subjects(struct zx_ctx* c, struct zx_xa_Subjects_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_Target
#define EL_STRUCT zx_xa_Target_s
#define EL_NS     xa
#define EL_TAG    Target

/* FUNC(zx_FREE_xa_Target) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_Target(struct zx_ctx* c, struct zx_xa_Target_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Subjects->gg;
       e && e->g.tok == zx_xa_Subjects_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Subjects(c, (struct zx_xa_Subjects_s*)e, free_strs);
  }
  for (e = &x->Resources->gg;
       e && e->g.tok == zx_xa_Resources_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Resources(c, (struct zx_xa_Resources_s*)e, free_strs);
  }
  for (e = &x->Actions->gg;
       e && e->g.tok == zx_xa_Actions_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Actions(c, (struct zx_xa_Actions_s*)e, free_strs);
  }
  for (e = &x->Environments->gg;
       e && e->g.tok == zx_xa_Environments_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_xa_Environments(c, (struct zx_xa_Environments_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_Target) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_Target_s* zx_NEW_xa_Target(struct zx_ctx* c)
{
  struct zx_xa_Target_s* x = ZX_ZALLOC(c, struct zx_xa_Target_s);
  x->gg.g.tok = zx_xa_Target_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_Target) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_Target(struct zx_ctx* c, struct zx_xa_Target_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Subjects->gg;
       se && se->g.tok == zx_xa_Subjects_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Subjects(c, (struct zx_xa_Subjects_s*)se);
  for (se = &x->Resources->gg;
       se && se->g.tok == zx_xa_Resources_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Resources(c, (struct zx_xa_Resources_s*)se);
  for (se = &x->Actions->gg;
       se && se->g.tok == zx_xa_Actions_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Actions(c, (struct zx_xa_Actions_s*)se);
  for (se = &x->Environments->gg;
       se && se->g.tok == zx_xa_Environments_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_xa_Environments(c, (struct zx_xa_Environments_s*)se);

}

/* FUNC(zx_DEEP_CLONE_xa_Target) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_Target_s* zx_DEEP_CLONE_xa_Target(struct zx_ctx* c, struct zx_xa_Target_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_Target_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_Target_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Subjects->gg;
       e && e->g.tok == zx_xa_Subjects_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Subjects(c,(struct zx_xa_Subjects_s*)e,dup_strs);
  	  if (!enn)
  	      x->Subjects = (struct zx_xa_Subjects_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Resources->gg;
       e && e->g.tok == zx_xa_Resources_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Resources(c,(struct zx_xa_Resources_s*)e,dup_strs);
  	  if (!enn)
  	      x->Resources = (struct zx_xa_Resources_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Actions->gg;
       e && e->g.tok == zx_xa_Actions_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Actions(c,(struct zx_xa_Actions_s*)e,dup_strs);
  	  if (!enn)
  	      x->Actions = (struct zx_xa_Actions_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Environments->gg;
       e && e->g.tok == zx_xa_Environments_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_xa_Environments(c,(struct zx_xa_Environments_s*)e,dup_strs);
  	  if (!enn)
  	      x->Environments = (struct zx_xa_Environments_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_xa_Target) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_Target(struct zx_ctx* c, struct zx_xa_Target_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Subjects->gg;
       e && e->g.tok == zx_xa_Subjects_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Subjects(c, (struct zx_xa_Subjects_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Resources->gg;
       e && e->g.tok == zx_xa_Resources_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Resources(c, (struct zx_xa_Resources_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Actions->gg;
       e && e->g.tok == zx_xa_Actions_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Actions(c, (struct zx_xa_Actions_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Environments->gg;
       e && e->g.tok == zx_xa_Environments_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_xa_Environments(c, (struct zx_xa_Environments_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_Target) */

int zx_WALK_WO_xa_Target(struct zx_ctx* c, struct zx_xa_Target_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_VariableDefinition
#define EL_STRUCT zx_xa_VariableDefinition_s
#define EL_NS     xa
#define EL_TAG    VariableDefinition

/* FUNC(zx_FREE_xa_VariableDefinition) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_VariableDefinition(struct zx_ctx* c, struct zx_xa_VariableDefinition_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->VariableId, free_strs);

  zx_free_simple_elems(c, x->Expression, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_VariableDefinition) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_VariableDefinition_s* zx_NEW_xa_VariableDefinition(struct zx_ctx* c)
{
  struct zx_xa_VariableDefinition_s* x = ZX_ZALLOC(c, struct zx_xa_VariableDefinition_s);
  x->gg.g.tok = zx_xa_VariableDefinition_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_VariableDefinition) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_VariableDefinition(struct zx_ctx* c, struct zx_xa_VariableDefinition_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->VariableId);

  zx_dup_strs_simple_elems(c, x->Expression);

}

/* FUNC(zx_DEEP_CLONE_xa_VariableDefinition) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_VariableDefinition_s* zx_DEEP_CLONE_xa_VariableDefinition(struct zx_ctx* c, struct zx_xa_VariableDefinition_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_VariableDefinition_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_VariableDefinition_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->VariableId = zx_clone_attr(c, x->VariableId);

  x->Expression = zx_deep_clone_simple_elems(c,x->Expression, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_xa_VariableDefinition) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_VariableDefinition(struct zx_ctx* c, struct zx_xa_VariableDefinition_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Expression, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_VariableDefinition) */

int zx_WALK_WO_xa_VariableDefinition(struct zx_ctx* c, struct zx_xa_VariableDefinition_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   xa_VariableReference
#define EL_STRUCT zx_xa_VariableReference_s
#define EL_NS     xa
#define EL_TAG    VariableReference

/* FUNC(zx_FREE_xa_VariableReference) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_xa_VariableReference(struct zx_ctx* c, struct zx_xa_VariableReference_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->VariableId, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_xa_VariableReference) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_xa_VariableReference_s* zx_NEW_xa_VariableReference(struct zx_ctx* c)
{
  struct zx_xa_VariableReference_s* x = ZX_ZALLOC(c, struct zx_xa_VariableReference_s);
  x->gg.g.tok = zx_xa_VariableReference_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_xa_VariableReference) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_xa_VariableReference(struct zx_ctx* c, struct zx_xa_VariableReference_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->VariableId);


}

/* FUNC(zx_DEEP_CLONE_xa_VariableReference) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_xa_VariableReference_s* zx_DEEP_CLONE_xa_VariableReference(struct zx_ctx* c, struct zx_xa_VariableReference_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_xa_VariableReference_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_xa_VariableReference_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->VariableId = zx_clone_attr(c, x->VariableId);


  return x;
}

/* FUNC(zx_WALK_SO_xa_VariableReference) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_xa_VariableReference(struct zx_ctx* c, struct zx_xa_VariableReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_xa_VariableReference) */

int zx_WALK_WO_xa_VariableReference(struct zx_ctx* c, struct zx_xa_VariableReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif


/* EOF -- c/zx-xa-aux.c */
