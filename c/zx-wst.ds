/* c/zx-wst.ds - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** ds-templ.c  -  DirectoryScript template, used in code generation
 ** Copyright (c) 2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: ds-templ.c,v 1.1 2007-08-10 17:44:49 sampo Exp $
 **
 ** 6.6.2007, created, Sampo Kellomaki (sampo@iki.fi)
 **
 ** N.B: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/



function parse_wst_Authenticator(data, x) {

  POPTAG_RAW(x[2],  'CombinedHash', data.CombinedHash);

}

function build_wst_Authenticator(data) {
  attr = [];
  body = [];

  PUSHTAG_RAW(body, 'CombinedHash', data.CombinedHash);

  return TAG('wst:Authenticator', attr, body);
}




function parse_wst_BinaryExchange(data, x) {
  POPATTR(x[1], 'EncodingType', data.EncodingType);
  POPATTR(x[1], 'ValueType', data.ValueType);


}

function build_wst_BinaryExchange(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'EncodingType', data.EncodingType);
  PUSHATTR(attr, 'ValueType', data.ValueType);


  return TAG('wst:BinaryExchange', attr, body);
}




function parse_wst_BinarySecret(data, x) {
  POPATTR(x[1], 'Type', data.Type);


}

function build_wst_BinarySecret(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Type', data.Type);


  return TAG('wst:BinarySecret', attr, body);
}




function parse_wst_CancelTarget(data, x) {


}

function build_wst_CancelTarget(data) {
  attr = [];
  body = [];


  return TAG('wst:CancelTarget', attr, body);
}




function parse_wst_Claims(data, x) {
  POPATTR(x[1], 'Dialect', data.Dialect);


}

function build_wst_Claims(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Dialect', data.Dialect);


  return TAG('wst:Claims', attr, body);
}




function parse_wst_DelegateTo(data, x) {


}

function build_wst_DelegateTo(data) {
  attr = [];
  body = [];


  return TAG('wst:DelegateTo', attr, body);
}




function parse_wst_Encryption(data, x) {


}

function build_wst_Encryption(data) {
  attr = [];
  body = [];


  return TAG('wst:Encryption', attr, body);
}




function parse_wst_Entropy(data, x) {


}

function build_wst_Entropy(data) {
  attr = [];
  body = [];


  return TAG('wst:Entropy', attr, body);
}




function parse_wst_IssuedTokens(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'RequestSecurityTokenResponse', i); ++i) {
    h =  hash [];
    parse_wst_RequestSecurityTokenResponse(h, tag);
    push data{'RequestSecurityTokenResponse'}, h;
  }

}

function build_wst_IssuedTokens(data) {
  attr = [];
  body = [];

  for d(data{'RequestSecurityTokenResponse'}) push body,build_wst_RequestSecurityTokenResponse(d);

  return TAG('wst:IssuedTokens', attr, body);
}




function parse_wst_Issuer(data, x) {
  POPATTR(x[1], 'ID', data.ID);
  POPATTR(x[1], 'id', data.id);
  POPATTR(x[1], 'notOnOrAfter', data.notOnOrAfter);
  POPATTR(x[1], 'wsu_Id', data.wsu_Id);
  POPATTR(x[1], 'e_actor', data.e_actor);
  POPATTR(x[1], 'e_mustUnderstand', data.e_mustUnderstand);

  tag = find_xml_local(x[2], 'Address', 1);
  h =  hash [];
  parse_a_Address(h, aux1);
  data{'Address'} = h;
  tag = find_xml_local(x[2], 'ReferenceParameters', 1);
  h =  hash [];
  parse_a_ReferenceParameters(h, aux1);
  data{'ReferenceParameters'} = h;
  tag = find_xml_local(x[2], 'Metadata', 1);
  h =  hash [];
  parse_a_Metadata(h, aux1);
  data{'Metadata'} = h;

}

function build_wst_Issuer(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'ID', data.ID);
  PUSHATTR(attr, 'id', data.id);
  PUSHATTR(attr, 'notOnOrAfter', data.notOnOrAfter);
  PUSHATTR(attr, 'wsu_Id', data.wsu_Id);
  PUSHATTR(attr, 'e_actor', data.e_actor);
  PUSHATTR(attr, 'e_mustUnderstand', data.e_mustUnderstand);

  push body, build_a_Address(data{'Address'});
  push body, build_a_ReferenceParameters(data{'ReferenceParameters'});
  push body, build_a_Metadata(data{'Metadata'});

  return TAG('wst:Issuer', attr, body);
}




function parse_wst_KeyExchangeToken(data, x) {


}

function build_wst_KeyExchangeToken(data) {
  attr = [];
  body = [];


  return TAG('wst:KeyExchangeToken', attr, body);
}




function parse_wst_Lifetime(data, x) {

  tag = find_xml_local(x[2], 'Created', 1);
  h =  hash [];
  parse_wsu_Created(h, aux1);
  data{'Created'} = h;
  tag = find_xml_local(x[2], 'Expires', 1);
  h =  hash [];
  parse_wsu_Expires(h, aux1);
  data{'Expires'} = h;

}

function build_wst_Lifetime(data) {
  attr = [];
  body = [];

  push body, build_wsu_Created(data{'Created'});
  push body, build_wsu_Expires(data{'Expires'});

  return TAG('wst:Lifetime', attr, body);
}




function parse_wst_OnBehalfOf(data, x) {


}

function build_wst_OnBehalfOf(data) {
  attr = [];
  body = [];


  return TAG('wst:OnBehalfOf', attr, body);
}




function parse_wst_Participant(data, x) {


}

function build_wst_Participant(data) {
  attr = [];
  body = [];


  return TAG('wst:Participant', attr, body);
}




function parse_wst_Participants(data, x) {

  tag = find_xml_local(x[2], 'Primary', 1);
  h =  hash [];
  parse_wst_Primary(h, aux1);
  data{'Primary'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Participant', i); ++i) {
    h =  hash [];
    parse_wst_Participant(h, tag);
    push data{'Participant'}, h;
  }

}

function build_wst_Participants(data) {
  attr = [];
  body = [];

  push body, build_wst_Primary(data{'Primary'});
  for d(data{'Participant'}) push body,build_wst_Participant(d);

  return TAG('wst:Participants', attr, body);
}




function parse_wst_Primary(data, x) {


}

function build_wst_Primary(data) {
  attr = [];
  body = [];


  return TAG('wst:Primary', attr, body);
}




function parse_wst_ProofEncryption(data, x) {


}

function build_wst_ProofEncryption(data) {
  attr = [];
  body = [];


  return TAG('wst:ProofEncryption', attr, body);
}




function parse_wst_RenewTarget(data, x) {


}

function build_wst_RenewTarget(data) {
  attr = [];
  body = [];


  return TAG('wst:RenewTarget', attr, body);
}




function parse_wst_Renewing(data, x) {
  POPATTR(x[1], 'Allow', data.Allow);
  POPATTR(x[1], 'OK', data.OK);


}

function build_wst_Renewing(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Allow', data.Allow);
  PUSHATTR(attr, 'OK', data.OK);


  return TAG('wst:Renewing', attr, body);
}




function parse_wst_RequestSecurityToken(data, x) {
  POPATTR(x[1], 'Context', data.Context);

  POPTAG_RAW(x[2],  'TokenType', data.TokenType);
  POPTAG_RAW(x[2],  'RequestType', data.RequestType);
  tag = find_xml_local(x[2], 'AppliesTo', 1);
  h =  hash [];
  parse_wsp_AppliesTo(h, aux1);
  data{'AppliesTo'} = h;
  tag = find_xml_local(x[2], 'Claims', 1);
  h =  hash [];
  parse_wst_Claims(h, aux1);
  data{'Claims'} = h;
  tag = find_xml_local(x[2], 'Entropy', 1);
  h =  hash [];
  parse_wst_Entropy(h, aux1);
  data{'Entropy'} = h;
  tag = find_xml_local(x[2], 'Lifetime', 1);
  h =  hash [];
  parse_wst_Lifetime(h, aux1);
  data{'Lifetime'} = h;
  POPTAG_RAW(x[2],  'AllowPostdating', data.AllowPostdating);
  tag = find_xml_local(x[2], 'Renewing', 1);
  h =  hash [];
  parse_wst_Renewing(h, aux1);
  data{'Renewing'} = h;
  tag = find_xml_local(x[2], 'OnBehalfOf', 1);
  h =  hash [];
  parse_wst_OnBehalfOf(h, aux1);
  data{'OnBehalfOf'} = h;
  tag = find_xml_local(x[2], 'Issuer', 1);
  h =  hash [];
  parse_wst_Issuer(h, aux1);
  data{'Issuer'} = h;
  POPTAG_RAW(x[2],  'AuthenticationType', data.AuthenticationType);
  POPTAG_RAW(x[2],  'KeyType', data.KeyType);
  POPTAG_RAW(x[2],  'KeySize', data.KeySize);
  POPTAG_RAW(x[2],  'SignatureAlgorithm', data.SignatureAlgorithm);
  tag = find_xml_local(x[2], 'Encryption', 1);
  h =  hash [];
  parse_wst_Encryption(h, aux1);
  data{'Encryption'} = h;
  POPTAG_RAW(x[2],  'EncryptionAlgorithm', data.EncryptionAlgorithm);
  POPTAG_RAW(x[2],  'CanonicalizationAlgorithm', data.CanonicalizationAlgorithm);
  tag = find_xml_local(x[2], 'ProofEncryption', 1);
  h =  hash [];
  parse_wst_ProofEncryption(h, aux1);
  data{'ProofEncryption'} = h;
  tag = find_xml_local(x[2], 'UseKey', 1);
  h =  hash [];
  parse_wst_UseKey(h, aux1);
  data{'UseKey'} = h;
  POPTAG_RAW(x[2],  'SignWith', data.SignWith);
  POPTAG_RAW(x[2],  'EncryptWith', data.EncryptWith);
  tag = find_xml_local(x[2], 'DelegateTo', 1);
  h =  hash [];
  parse_wst_DelegateTo(h, aux1);
  data{'DelegateTo'} = h;
  POPTAG_RAW(x[2],  'Forwardable', data.Forwardable);
  POPTAG_RAW(x[2],  'Delegatable', data.Delegatable);
  tag = find_xml_local(x[2], 'Policy', 1);
  h =  hash [];
  parse_wsp_Policy(h, aux1);
  data{'Policy'} = h;
  tag = find_xml_local(x[2], 'PolicyReference', 1);
  h =  hash [];
  parse_wsp_PolicyReference(h, aux1);
  data{'PolicyReference'} = h;

}

function build_wst_RequestSecurityToken(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Context', data.Context);

  PUSHTAG_RAW(body, 'TokenType', data.TokenType);
  PUSHTAG_RAW(body, 'RequestType', data.RequestType);
  push body, build_wsp_AppliesTo(data{'AppliesTo'});
  push body, build_wst_Claims(data{'Claims'});
  push body, build_wst_Entropy(data{'Entropy'});
  push body, build_wst_Lifetime(data{'Lifetime'});
  PUSHTAG_RAW(body, 'AllowPostdating', data.AllowPostdating);
  push body, build_wst_Renewing(data{'Renewing'});
  push body, build_wst_OnBehalfOf(data{'OnBehalfOf'});
  push body, build_wst_Issuer(data{'Issuer'});
  PUSHTAG_RAW(body, 'AuthenticationType', data.AuthenticationType);
  PUSHTAG_RAW(body, 'KeyType', data.KeyType);
  PUSHTAG_RAW(body, 'KeySize', data.KeySize);
  PUSHTAG_RAW(body, 'SignatureAlgorithm', data.SignatureAlgorithm);
  push body, build_wst_Encryption(data{'Encryption'});
  PUSHTAG_RAW(body, 'EncryptionAlgorithm', data.EncryptionAlgorithm);
  PUSHTAG_RAW(body, 'CanonicalizationAlgorithm', data.CanonicalizationAlgorithm);
  push body, build_wst_ProofEncryption(data{'ProofEncryption'});
  push body, build_wst_UseKey(data{'UseKey'});
  PUSHTAG_RAW(body, 'SignWith', data.SignWith);
  PUSHTAG_RAW(body, 'EncryptWith', data.EncryptWith);
  push body, build_wst_DelegateTo(data{'DelegateTo'});
  PUSHTAG_RAW(body, 'Forwardable', data.Forwardable);
  PUSHTAG_RAW(body, 'Delegatable', data.Delegatable);
  push body, build_wsp_Policy(data{'Policy'});
  push body, build_wsp_PolicyReference(data{'PolicyReference'});

  return TAG('wst:RequestSecurityToken', attr, body);
}




function parse_wst_RequestSecurityTokenCollection(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'RequestSecurityToken', i); ++i) {
    h =  hash [];
    parse_wst_RequestSecurityToken(h, tag);
    push data{'RequestSecurityToken'}, h;
  }

}

function build_wst_RequestSecurityTokenCollection(data) {
  attr = [];
  body = [];

  for d(data{'RequestSecurityToken'}) push body,build_wst_RequestSecurityToken(d);

  return TAG('wst:RequestSecurityTokenCollection', attr, body);
}




function parse_wst_RequestSecurityTokenResponse(data, x) {
  POPATTR(x[1], 'Context', data.Context);

  POPTAG_RAW(x[2],  'TokenType', data.TokenType);
  POPTAG_RAW(x[2],  'RequestType', data.RequestType);
  tag = find_xml_local(x[2], 'RequestedSecurityToken', 1);
  h =  hash [];
  parse_wst_RequestedSecurityToken(h, aux1);
  data{'RequestedSecurityToken'} = h;
  tag = find_xml_local(x[2], 'AppliesTo', 1);
  h =  hash [];
  parse_wsp_AppliesTo(h, aux1);
  data{'AppliesTo'} = h;
  tag = find_xml_local(x[2], 'RequestedAttachedReference', 1);
  h =  hash [];
  parse_wst_RequestedAttachedReference(h, aux1);
  data{'RequestedAttachedReference'} = h;
  tag = find_xml_local(x[2], 'RequestedUnattachedReference', 1);
  h =  hash [];
  parse_wst_RequestedUnattachedReference(h, aux1);
  data{'RequestedUnattachedReference'} = h;
  tag = find_xml_local(x[2], 'RequestedProofToken', 1);
  h =  hash [];
  parse_wst_RequestedProofToken(h, aux1);
  data{'RequestedProofToken'} = h;
  tag = find_xml_local(x[2], 'Entropy', 1);
  h =  hash [];
  parse_wst_Entropy(h, aux1);
  data{'Entropy'} = h;
  tag = find_xml_local(x[2], 'Lifetime', 1);
  h =  hash [];
  parse_wst_Lifetime(h, aux1);
  data{'Lifetime'} = h;
  tag = find_xml_local(x[2], 'Status', 1);
  h =  hash [];
  parse_wst_Status(h, aux1);
  data{'Status'} = h;
  POPTAG_RAW(x[2],  'AllowPostdating', data.AllowPostdating);
  tag = find_xml_local(x[2], 'Renewing', 1);
  h =  hash [];
  parse_wst_Renewing(h, aux1);
  data{'Renewing'} = h;
  tag = find_xml_local(x[2], 'OnBehalfOf', 1);
  h =  hash [];
  parse_wst_OnBehalfOf(h, aux1);
  data{'OnBehalfOf'} = h;
  tag = find_xml_local(x[2], 'Issuer', 1);
  h =  hash [];
  parse_wst_Issuer(h, aux1);
  data{'Issuer'} = h;
  POPTAG_RAW(x[2],  'AuthenticationType', data.AuthenticationType);
  tag = find_xml_local(x[2], 'Authenticator', 1);
  h =  hash [];
  parse_wst_Authenticator(h, aux1);
  data{'Authenticator'} = h;
  POPTAG_RAW(x[2],  'KeyType', data.KeyType);
  POPTAG_RAW(x[2],  'KeySize', data.KeySize);
  POPTAG_RAW(x[2],  'SignatureAlgorithm', data.SignatureAlgorithm);
  tag = find_xml_local(x[2], 'Encryption', 1);
  h =  hash [];
  parse_wst_Encryption(h, aux1);
  data{'Encryption'} = h;
  POPTAG_RAW(x[2],  'EncryptionAlgorithm', data.EncryptionAlgorithm);
  POPTAG_RAW(x[2],  'CanonicalizationAlgorithm', data.CanonicalizationAlgorithm);
  tag = find_xml_local(x[2], 'ProofEncryption', 1);
  h =  hash [];
  parse_wst_ProofEncryption(h, aux1);
  data{'ProofEncryption'} = h;
  tag = find_xml_local(x[2], 'UseKey', 1);
  h =  hash [];
  parse_wst_UseKey(h, aux1);
  data{'UseKey'} = h;
  POPTAG_RAW(x[2],  'SignWith', data.SignWith);
  POPTAG_RAW(x[2],  'EncryptWith', data.EncryptWith);
  tag = find_xml_local(x[2], 'DelegateTo', 1);
  h =  hash [];
  parse_wst_DelegateTo(h, aux1);
  data{'DelegateTo'} = h;
  POPTAG_RAW(x[2],  'Forwardable', data.Forwardable);
  POPTAG_RAW(x[2],  'Delegatable', data.Delegatable);
  tag = find_xml_local(x[2], 'Policy', 1);
  h =  hash [];
  parse_wsp_Policy(h, aux1);
  data{'Policy'} = h;
  tag = find_xml_local(x[2], 'PolicyReference', 1);
  h =  hash [];
  parse_wsp_PolicyReference(h, aux1);
  data{'PolicyReference'} = h;

}

function build_wst_RequestSecurityTokenResponse(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Context', data.Context);

  PUSHTAG_RAW(body, 'TokenType', data.TokenType);
  PUSHTAG_RAW(body, 'RequestType', data.RequestType);
  push body, build_wst_RequestedSecurityToken(data{'RequestedSecurityToken'});
  push body, build_wsp_AppliesTo(data{'AppliesTo'});
  push body, build_wst_RequestedAttachedReference(data{'RequestedAttachedReference'});
  push body, build_wst_RequestedUnattachedReference(data{'RequestedUnattachedReference'});
  push body, build_wst_RequestedProofToken(data{'RequestedProofToken'});
  push body, build_wst_Entropy(data{'Entropy'});
  push body, build_wst_Lifetime(data{'Lifetime'});
  push body, build_wst_Status(data{'Status'});
  PUSHTAG_RAW(body, 'AllowPostdating', data.AllowPostdating);
  push body, build_wst_Renewing(data{'Renewing'});
  push body, build_wst_OnBehalfOf(data{'OnBehalfOf'});
  push body, build_wst_Issuer(data{'Issuer'});
  PUSHTAG_RAW(body, 'AuthenticationType', data.AuthenticationType);
  push body, build_wst_Authenticator(data{'Authenticator'});
  PUSHTAG_RAW(body, 'KeyType', data.KeyType);
  PUSHTAG_RAW(body, 'KeySize', data.KeySize);
  PUSHTAG_RAW(body, 'SignatureAlgorithm', data.SignatureAlgorithm);
  push body, build_wst_Encryption(data{'Encryption'});
  PUSHTAG_RAW(body, 'EncryptionAlgorithm', data.EncryptionAlgorithm);
  PUSHTAG_RAW(body, 'CanonicalizationAlgorithm', data.CanonicalizationAlgorithm);
  push body, build_wst_ProofEncryption(data{'ProofEncryption'});
  push body, build_wst_UseKey(data{'UseKey'});
  PUSHTAG_RAW(body, 'SignWith', data.SignWith);
  PUSHTAG_RAW(body, 'EncryptWith', data.EncryptWith);
  push body, build_wst_DelegateTo(data{'DelegateTo'});
  PUSHTAG_RAW(body, 'Forwardable', data.Forwardable);
  PUSHTAG_RAW(body, 'Delegatable', data.Delegatable);
  push body, build_wsp_Policy(data{'Policy'});
  push body, build_wsp_PolicyReference(data{'PolicyReference'});

  return TAG('wst:RequestSecurityTokenResponse', attr, body);
}




function parse_wst_RequestSecurityTokenResponseCollection(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'RequestSecurityTokenResponse', i); ++i) {
    h =  hash [];
    parse_wst_RequestSecurityTokenResponse(h, tag);
    push data{'RequestSecurityTokenResponse'}, h;
  }

}

function build_wst_RequestSecurityTokenResponseCollection(data) {
  attr = [];
  body = [];

  for d(data{'RequestSecurityTokenResponse'}) push body,build_wst_RequestSecurityTokenResponse(d);

  return TAG('wst:RequestSecurityTokenResponseCollection', attr, body);
}




function parse_wst_RequestedAttachedReference(data, x) {

  tag = find_xml_local(x[2], 'SecurityTokenReference', 1);
  h =  hash [];
  parse_wsse_SecurityTokenReference(h, aux1);
  data{'SecurityTokenReference'} = h;

}

function build_wst_RequestedAttachedReference(data) {
  attr = [];
  body = [];

  push body, build_wsse_SecurityTokenReference(data{'SecurityTokenReference'});

  return TAG('wst:RequestedAttachedReference', attr, body);
}




function parse_wst_RequestedProofToken(data, x) {


}

function build_wst_RequestedProofToken(data) {
  attr = [];
  body = [];


  return TAG('wst:RequestedProofToken', attr, body);
}




function parse_wst_RequestedSecurityToken(data, x) {


}

function build_wst_RequestedSecurityToken(data) {
  attr = [];
  body = [];


  return TAG('wst:RequestedSecurityToken', attr, body);
}




function parse_wst_RequestedUnattachedReference(data, x) {

  tag = find_xml_local(x[2], 'SecurityTokenReference', 1);
  h =  hash [];
  parse_wsse_SecurityTokenReference(h, aux1);
  data{'SecurityTokenReference'} = h;

}

function build_wst_RequestedUnattachedReference(data) {
  attr = [];
  body = [];

  push body, build_wsse_SecurityTokenReference(data{'SecurityTokenReference'});

  return TAG('wst:RequestedUnattachedReference', attr, body);
}




function parse_wst_SignChallenge(data, x) {

  POPTAG_RAW(x[2],  'Challenge', data.Challenge);

}

function build_wst_SignChallenge(data) {
  attr = [];
  body = [];

  PUSHTAG_RAW(body, 'Challenge', data.Challenge);

  return TAG('wst:SignChallenge', attr, body);
}




function parse_wst_SignChallengeResponse(data, x) {

  POPTAG_RAW(x[2],  'Challenge', data.Challenge);

}

function build_wst_SignChallengeResponse(data) {
  attr = [];
  body = [];

  PUSHTAG_RAW(body, 'Challenge', data.Challenge);

  return TAG('wst:SignChallengeResponse', attr, body);
}




function parse_wst_Status(data, x) {

  POPTAG_RAW(x[2],  'Code', data.Code);
  POPTAG_RAW(x[2],  'Reason', data.Reason);

}

function build_wst_Status(data) {
  attr = [];
  body = [];

  PUSHTAG_RAW(body, 'Code', data.Code);
  PUSHTAG_RAW(body, 'Reason', data.Reason);

  return TAG('wst:Status', attr, body);
}




function parse_wst_UseKey(data, x) {
  POPATTR(x[1], 'Sig', data.Sig);


}

function build_wst_UseKey(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Sig', data.Sig);


  return TAG('wst:UseKey', attr, body);
}




function parse_wst_ValidateTarget(data, x) {


}

function build_wst_ValidateTarget(data) {
  attr = [];
  body = [];


  return TAG('wst:ValidateTarget', attr, body);
}


/* EOF -- c/zx-wst.ds */
