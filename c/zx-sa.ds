/* c/zx-sa.ds - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** ds-templ.c  -  DirectoryScript template, used in code generation
 ** Copyright (c) 2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: ds-templ.c,v 1.1 2007-08-10 17:44:49 sampo Exp $
 **
 ** 6.6.2007, created, Sampo Kellomaki (sampo@iki.fi)
 **
 ** N.B: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/



function parse_sa_Action(data, x) {
  POPATTR(x[1], 'Namespace', data.Namespace);


}

function build_sa_Action(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Namespace', data.Namespace);


  return TAG('sa:Action', attr, body);
}




function parse_sa_Advice(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'AssertionIDRef', i); ++i)
    push data{'AssertionIDRef'}, tag[2];
  for (i=1; tag = find_xml_local(x[2], 'AssertionURIRef', i); ++i)
    push data{'AssertionURIRef'}, tag[2];
  for (i=1; tag = find_xml_local(x[2], 'Assertion', i); ++i) {
    h =  hash [];
    parse_sa_Assertion(h, tag);
    push data{'Assertion'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'EncryptedAssertion', i); ++i) {
    h =  hash [];
    parse_sa_EncryptedAssertion(h, tag);
    push data{'EncryptedAssertion'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'sa11_Assertion', i); ++i) {
    h =  hash [];
    parse_sa11_Assertion(h, tag);
    push data{'sa11_Assertion'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'ff12_Assertion', i); ++i) {
    h =  hash [];
    parse_ff12_Assertion(h, tag);
    push data{'ff12_Assertion'}, h;
  }

}

function build_sa_Advice(data) {
  attr = [];
  body = [];

  for d(data{'AssertionIDRef'})PUSHTAG_RAW(body,'AssertionIDRef',d);
  for d(data{'AssertionURIRef'})PUSHTAG_RAW(body,'AssertionURIRef',d);
  for d(data{'Assertion'}) push body,build_sa_Assertion(d);
  for d(data{'EncryptedAssertion'}) push body,build_sa_EncryptedAssertion(d);
  for d(data{'sa11_Assertion'}) push body,build_sa11_Assertion(d);
  for d(data{'ff12_Assertion'}) push body,build_ff12_Assertion(d);

  return TAG('sa:Advice', attr, body);
}




function parse_sa_Assertion(data, x) {
  POPATTR(x[1], 'ID', data.ID);
  POPATTR(x[1], 'IssueInstant', data.IssueInstant);
  POPATTR(x[1], 'Version', data.Version);

  tag = find_xml_local(x[2], 'Issuer', 1);
  h =  hash [];
  parse_sa_Issuer(h, aux1);
  data{'Issuer'} = h;
  tag = find_xml_local(x[2], 'Signature', 1);
  h =  hash [];
  parse_ds_Signature(h, aux1);
  data{'Signature'} = h;
  tag = find_xml_local(x[2], 'Subject', 1);
  h =  hash [];
  parse_sa_Subject(h, aux1);
  data{'Subject'} = h;
  tag = find_xml_local(x[2], 'Conditions', 1);
  h =  hash [];
  parse_sa_Conditions(h, aux1);
  data{'Conditions'} = h;
  tag = find_xml_local(x[2], 'Advice', 1);
  h =  hash [];
  parse_sa_Advice(h, aux1);
  data{'Advice'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Statement', i); ++i) {
    h =  hash [];
    parse_sa_Statement(h, tag);
    push data{'Statement'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'AuthnStatement', i); ++i) {
    h =  hash [];
    parse_sa_AuthnStatement(h, tag);
    push data{'AuthnStatement'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'AuthzDecisionStatement', i); ++i) {
    h =  hash [];
    parse_sa_AuthzDecisionStatement(h, tag);
    push data{'AuthzDecisionStatement'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'AttributeStatement', i); ++i) {
    h =  hash [];
    parse_sa_AttributeStatement(h, tag);
    push data{'AttributeStatement'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'XACMLAuthzDecisionStatement', i); ++i) {
    h =  hash [];
    parse_xasa_XACMLAuthzDecisionStatement(h, tag);
    push data{'XACMLAuthzDecisionStatement'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'XACMLPolicyStatement', i); ++i) {
    h =  hash [];
    parse_xasa_XACMLPolicyStatement(h, tag);
    push data{'XACMLPolicyStatement'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'xasacd1_XACMLAuthzDecisionStatement', i); ++i) {
    h =  hash [];
    parse_xasacd1_XACMLAuthzDecisionStatement(h, tag);
    push data{'xasacd1_XACMLAuthzDecisionStatement'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'xasacd1_XACMLPolicyStatement', i); ++i) {
    h =  hash [];
    parse_xasacd1_XACMLPolicyStatement(h, tag);
    push data{'xasacd1_XACMLPolicyStatement'}, h;
  }

}

function build_sa_Assertion(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'ID', data.ID);
  PUSHATTR(attr, 'IssueInstant', data.IssueInstant);
  PUSHATTR(attr, 'Version', data.Version);

  push body, build_sa_Issuer(data{'Issuer'});
  push body, build_ds_Signature(data{'Signature'});
  push body, build_sa_Subject(data{'Subject'});
  push body, build_sa_Conditions(data{'Conditions'});
  push body, build_sa_Advice(data{'Advice'});
  for d(data{'Statement'}) push body,build_sa_Statement(d);
  for d(data{'AuthnStatement'}) push body,build_sa_AuthnStatement(d);
  for d(data{'AuthzDecisionStatement'}) push body,build_sa_AuthzDecisionStatement(d);
  for d(data{'AttributeStatement'}) push body,build_sa_AttributeStatement(d);
  for d(data{'XACMLAuthzDecisionStatement'}) push body,build_xasa_XACMLAuthzDecisionStatement(d);
  for d(data{'XACMLPolicyStatement'}) push body,build_xasa_XACMLPolicyStatement(d);
  for d(data{'xasacd1_XACMLAuthzDecisionStatement'}) push body,build_xasacd1_XACMLAuthzDecisionStatement(d);
  for d(data{'xasacd1_XACMLPolicyStatement'}) push body,build_xasacd1_XACMLPolicyStatement(d);

  return TAG('sa:Assertion', attr, body);
}




function parse_sa_Attribute(data, x) {
  POPATTR(x[1], 'FriendlyName', data.FriendlyName);
  POPATTR(x[1], 'Name', data.Name);
  POPATTR(x[1], 'NameFormat', data.NameFormat);

  for (i=1; tag = find_xml_local(x[2], 'AttributeValue', i); ++i) {
    h =  hash [];
    parse_sa_AttributeValue(h, tag);
    push data{'AttributeValue'}, h;
  }

}

function build_sa_Attribute(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'FriendlyName', data.FriendlyName);
  PUSHATTR(attr, 'Name', data.Name);
  PUSHATTR(attr, 'NameFormat', data.NameFormat);

  for d(data{'AttributeValue'}) push body,build_sa_AttributeValue(d);

  return TAG('sa:Attribute', attr, body);
}




function parse_sa_AttributeStatement(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'Attribute', i); ++i) {
    h =  hash [];
    parse_sa_Attribute(h, tag);
    push data{'Attribute'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'EncryptedAttribute', i); ++i) {
    h =  hash [];
    parse_sa_EncryptedAttribute(h, tag);
    push data{'EncryptedAttribute'}, h;
  }

}

function build_sa_AttributeStatement(data) {
  attr = [];
  body = [];

  for d(data{'Attribute'}) push body,build_sa_Attribute(d);
  for d(data{'EncryptedAttribute'}) push body,build_sa_EncryptedAttribute(d);

  return TAG('sa:AttributeStatement', attr, body);
}




function parse_sa_AttributeValue(data, x) {
  POPATTR(x[1], 'xsi_type', data.xsi_type);

  for (i=1; tag = find_xml_local(x[2], 'ResourceOffering', i); ++i) {
    h =  hash [];
    parse_di12_ResourceOffering(h, tag);
    push data{'ResourceOffering'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'EndpointReference', i); ++i) {
    h =  hash [];
    parse_a_EndpointReference(h, tag);
    push data{'EndpointReference'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'Assertion', i); ++i) {
    h =  hash [];
    parse_sa_Assertion(h, tag);
    push data{'Assertion'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'EncryptedAssertion', i); ++i) {
    h =  hash [];
    parse_sa_EncryptedAssertion(h, tag);
    push data{'EncryptedAssertion'}, h;
  }

}

function build_sa_AttributeValue(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'xsi_type', data.xsi_type);

  for d(data{'ResourceOffering'}) push body,build_di12_ResourceOffering(d);
  for d(data{'EndpointReference'}) push body,build_a_EndpointReference(d);
  for d(data{'Assertion'}) push body,build_sa_Assertion(d);
  for d(data{'EncryptedAssertion'}) push body,build_sa_EncryptedAssertion(d);

  return TAG('sa:AttributeValue', attr, body);
}




function parse_sa_AudienceRestriction(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'Audience', i); ++i)
    push data{'Audience'}, tag[2];

}

function build_sa_AudienceRestriction(data) {
  attr = [];
  body = [];

  for d(data{'Audience'})PUSHTAG_RAW(body,'Audience',d);

  return TAG('sa:AudienceRestriction', attr, body);
}




function parse_sa_AuthnContext(data, x) {

  POPTAG_RAW(x[2],  'AuthnContextClassRef', data.AuthnContextClassRef);
  POPTAG_RAW(x[2],  'AuthnContextDecl', data.AuthnContextDecl);
  POPTAG_RAW(x[2],  'AuthnContextDeclRef', data.AuthnContextDeclRef);
  for (i=1; tag = find_xml_local(x[2], 'AuthenticatingAuthority', i); ++i)
    push data{'AuthenticatingAuthority'}, tag[2];

}

function build_sa_AuthnContext(data) {
  attr = [];
  body = [];

  PUSHTAG_RAW(body, 'AuthnContextClassRef', data.AuthnContextClassRef);
  PUSHTAG_RAW(body, 'AuthnContextDecl', data.AuthnContextDecl);
  PUSHTAG_RAW(body, 'AuthnContextDeclRef', data.AuthnContextDeclRef);
  for d(data{'AuthenticatingAuthority'})PUSHTAG_RAW(body,'AuthenticatingAuthority',d);

  return TAG('sa:AuthnContext', attr, body);
}




function parse_sa_AuthnStatement(data, x) {
  POPATTR(x[1], 'AuthnInstant', data.AuthnInstant);
  POPATTR(x[1], 'SessionIndex', data.SessionIndex);
  POPATTR(x[1], 'SessionNotOnOrAfter', data.SessionNotOnOrAfter);

  tag = find_xml_local(x[2], 'SubjectLocality', 1);
  h =  hash [];
  parse_sa_SubjectLocality(h, aux1);
  data{'SubjectLocality'} = h;
  tag = find_xml_local(x[2], 'AuthnContext', 1);
  h =  hash [];
  parse_sa_AuthnContext(h, aux1);
  data{'AuthnContext'} = h;

}

function build_sa_AuthnStatement(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'AuthnInstant', data.AuthnInstant);
  PUSHATTR(attr, 'SessionIndex', data.SessionIndex);
  PUSHATTR(attr, 'SessionNotOnOrAfter', data.SessionNotOnOrAfter);

  push body, build_sa_SubjectLocality(data{'SubjectLocality'});
  push body, build_sa_AuthnContext(data{'AuthnContext'});

  return TAG('sa:AuthnStatement', attr, body);
}




function parse_sa_AuthzDecisionStatement(data, x) {
  POPATTR(x[1], 'Decision', data.Decision);
  POPATTR(x[1], 'Resource', data.Resource);

  for (i=1; tag = find_xml_local(x[2], 'Action', i); ++i) {
    h =  hash [];
    parse_sa_Action(h, tag);
    push data{'Action'}, h;
  }
  tag = find_xml_local(x[2], 'Evidence', 1);
  h =  hash [];
  parse_sa_Evidence(h, aux1);
  data{'Evidence'} = h;

}

function build_sa_AuthzDecisionStatement(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Decision', data.Decision);
  PUSHATTR(attr, 'Resource', data.Resource);

  for d(data{'Action'}) push body,build_sa_Action(d);
  push body, build_sa_Evidence(data{'Evidence'});

  return TAG('sa:AuthzDecisionStatement', attr, body);
}




function parse_sa_BaseID(data, x) {
  POPATTR(x[1], 'NameQualifier', data.NameQualifier);
  POPATTR(x[1], 'SPNameQualifier', data.SPNameQualifier);


}

function build_sa_BaseID(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'NameQualifier', data.NameQualifier);
  PUSHATTR(attr, 'SPNameQualifier', data.SPNameQualifier);


  return TAG('sa:BaseID', attr, body);
}




function parse_sa_Conditions(data, x) {
  POPATTR(x[1], 'NotBefore', data.NotBefore);
  POPATTR(x[1], 'NotOnOrAfter', data.NotOnOrAfter);

  for (i=1; tag = find_xml_local(x[2], 'Condition', i); ++i)
    push data{'Condition'}, tag[2];
  for (i=1; tag = find_xml_local(x[2], 'AudienceRestriction', i); ++i) {
    h =  hash [];
    parse_sa_AudienceRestriction(h, tag);
    push data{'AudienceRestriction'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'OneTimeUse', i); ++i) {
    h =  hash [];
    parse_sa_OneTimeUse(h, tag);
    push data{'OneTimeUse'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'ProxyRestriction', i); ++i) {
    h =  hash [];
    parse_sa_ProxyRestriction(h, tag);
    push data{'ProxyRestriction'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'SubjectRestriction', i); ++i) {
    h =  hash [];
    parse_idp_SubjectRestriction(h, tag);
    push data{'SubjectRestriction'}, h;
  }

}

function build_sa_Conditions(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'NotBefore', data.NotBefore);
  PUSHATTR(attr, 'NotOnOrAfter', data.NotOnOrAfter);

  for d(data{'Condition'})PUSHTAG_RAW(body,'Condition',d);
  for d(data{'AudienceRestriction'}) push body,build_sa_AudienceRestriction(d);
  for d(data{'OneTimeUse'}) push body,build_sa_OneTimeUse(d);
  for d(data{'ProxyRestriction'}) push body,build_sa_ProxyRestriction(d);
  for d(data{'SubjectRestriction'}) push body,build_idp_SubjectRestriction(d);

  return TAG('sa:Conditions', attr, body);
}




function parse_sa_EncryptedAssertion(data, x) {

  tag = find_xml_local(x[2], 'EncryptedData', 1);
  h =  hash [];
  parse_xenc_EncryptedData(h, aux1);
  data{'EncryptedData'} = h;
  for (i=1; tag = find_xml_local(x[2], 'EncryptedKey', i); ++i) {
    h =  hash [];
    parse_xenc_EncryptedKey(h, tag);
    push data{'EncryptedKey'}, h;
  }

}

function build_sa_EncryptedAssertion(data) {
  attr = [];
  body = [];

  push body, build_xenc_EncryptedData(data{'EncryptedData'});
  for d(data{'EncryptedKey'}) push body,build_xenc_EncryptedKey(d);

  return TAG('sa:EncryptedAssertion', attr, body);
}




function parse_sa_EncryptedAttribute(data, x) {

  tag = find_xml_local(x[2], 'EncryptedData', 1);
  h =  hash [];
  parse_xenc_EncryptedData(h, aux1);
  data{'EncryptedData'} = h;
  for (i=1; tag = find_xml_local(x[2], 'EncryptedKey', i); ++i) {
    h =  hash [];
    parse_xenc_EncryptedKey(h, tag);
    push data{'EncryptedKey'}, h;
  }

}

function build_sa_EncryptedAttribute(data) {
  attr = [];
  body = [];

  push body, build_xenc_EncryptedData(data{'EncryptedData'});
  for d(data{'EncryptedKey'}) push body,build_xenc_EncryptedKey(d);

  return TAG('sa:EncryptedAttribute', attr, body);
}




function parse_sa_EncryptedID(data, x) {

  tag = find_xml_local(x[2], 'EncryptedData', 1);
  h =  hash [];
  parse_xenc_EncryptedData(h, aux1);
  data{'EncryptedData'} = h;
  for (i=1; tag = find_xml_local(x[2], 'EncryptedKey', i); ++i) {
    h =  hash [];
    parse_xenc_EncryptedKey(h, tag);
    push data{'EncryptedKey'}, h;
  }

}

function build_sa_EncryptedID(data) {
  attr = [];
  body = [];

  push body, build_xenc_EncryptedData(data{'EncryptedData'});
  for d(data{'EncryptedKey'}) push body,build_xenc_EncryptedKey(d);

  return TAG('sa:EncryptedID', attr, body);
}




function parse_sa_Evidence(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'AssertionIDRef', i); ++i)
    push data{'AssertionIDRef'}, tag[2];
  for (i=1; tag = find_xml_local(x[2], 'AssertionURIRef', i); ++i)
    push data{'AssertionURIRef'}, tag[2];
  for (i=1; tag = find_xml_local(x[2], 'Assertion', i); ++i) {
    h =  hash [];
    parse_sa_Assertion(h, tag);
    push data{'Assertion'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'EncryptedAssertion', i); ++i) {
    h =  hash [];
    parse_sa_EncryptedAssertion(h, tag);
    push data{'EncryptedAssertion'}, h;
  }

}

function build_sa_Evidence(data) {
  attr = [];
  body = [];

  for d(data{'AssertionIDRef'})PUSHTAG_RAW(body,'AssertionIDRef',d);
  for d(data{'AssertionURIRef'})PUSHTAG_RAW(body,'AssertionURIRef',d);
  for d(data{'Assertion'}) push body,build_sa_Assertion(d);
  for d(data{'EncryptedAssertion'}) push body,build_sa_EncryptedAssertion(d);

  return TAG('sa:Evidence', attr, body);
}




function parse_sa_Issuer(data, x) {
  POPATTR(x[1], 'Format', data.Format);
  POPATTR(x[1], 'NameQualifier', data.NameQualifier);
  POPATTR(x[1], 'SPNameQualifier', data.SPNameQualifier);
  POPATTR(x[1], 'SPProvidedID', data.SPProvidedID);


}

function build_sa_Issuer(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Format', data.Format);
  PUSHATTR(attr, 'NameQualifier', data.NameQualifier);
  PUSHATTR(attr, 'SPNameQualifier', data.SPNameQualifier);
  PUSHATTR(attr, 'SPProvidedID', data.SPProvidedID);


  return TAG('sa:Issuer', attr, body);
}




function parse_sa_NameID(data, x) {
  POPATTR(x[1], 'Format', data.Format);
  POPATTR(x[1], 'NameQualifier', data.NameQualifier);
  POPATTR(x[1], 'SPNameQualifier', data.SPNameQualifier);
  POPATTR(x[1], 'SPProvidedID', data.SPProvidedID);


}

function build_sa_NameID(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Format', data.Format);
  PUSHATTR(attr, 'NameQualifier', data.NameQualifier);
  PUSHATTR(attr, 'SPNameQualifier', data.SPNameQualifier);
  PUSHATTR(attr, 'SPProvidedID', data.SPProvidedID);


  return TAG('sa:NameID', attr, body);
}




function parse_sa_OneTimeUse(data, x) {


}

function build_sa_OneTimeUse(data) {
  attr = [];
  body = [];


  return TAG('sa:OneTimeUse', attr, body);
}




function parse_sa_ProxyRestriction(data, x) {
  POPATTR(x[1], 'Count', data.Count);

  for (i=1; tag = find_xml_local(x[2], 'Audience', i); ++i)
    push data{'Audience'}, tag[2];

}

function build_sa_ProxyRestriction(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Count', data.Count);

  for d(data{'Audience'})PUSHTAG_RAW(body,'Audience',d);

  return TAG('sa:ProxyRestriction', attr, body);
}




function parse_sa_Statement(data, x) {
  POPATTR(x[1], 'xsi_type', data.xsi_type);

  for (i=1; tag = find_xml_local(x[2], 'Response', i); ++i) {
    h =  hash [];
    parse_xac_Response(h, tag);
    push data{'Response'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'Request', i); ++i) {
    h =  hash [];
    parse_xac_Request(h, tag);
    push data{'Request'}, h;
  }

}

function build_sa_Statement(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'xsi_type', data.xsi_type);

  for d(data{'Response'}) push body,build_xac_Response(d);
  for d(data{'Request'}) push body,build_xac_Request(d);

  return TAG('sa:Statement', attr, body);
}




function parse_sa_Subject(data, x) {

  tag = find_xml_local(x[2], 'BaseID', 1);
  h =  hash [];
  parse_sa_BaseID(h, aux1);
  data{'BaseID'} = h;
  tag = find_xml_local(x[2], 'NameID', 1);
  h =  hash [];
  parse_sa_NameID(h, aux1);
  data{'NameID'} = h;
  tag = find_xml_local(x[2], 'EncryptedID', 1);
  h =  hash [];
  parse_sa_EncryptedID(h, aux1);
  data{'EncryptedID'} = h;
  for (i=1; tag = find_xml_local(x[2], 'SubjectConfirmation', i); ++i) {
    h =  hash [];
    parse_sa_SubjectConfirmation(h, tag);
    push data{'SubjectConfirmation'}, h;
  }

}

function build_sa_Subject(data) {
  attr = [];
  body = [];

  push body, build_sa_BaseID(data{'BaseID'});
  push body, build_sa_NameID(data{'NameID'});
  push body, build_sa_EncryptedID(data{'EncryptedID'});
  for d(data{'SubjectConfirmation'}) push body,build_sa_SubjectConfirmation(d);

  return TAG('sa:Subject', attr, body);
}




function parse_sa_SubjectConfirmation(data, x) {
  POPATTR(x[1], 'Method', data.Method);

  tag = find_xml_local(x[2], 'BaseID', 1);
  h =  hash [];
  parse_sa_BaseID(h, aux1);
  data{'BaseID'} = h;
  tag = find_xml_local(x[2], 'NameID', 1);
  h =  hash [];
  parse_sa_NameID(h, aux1);
  data{'NameID'} = h;
  tag = find_xml_local(x[2], 'EncryptedID', 1);
  h =  hash [];
  parse_sa_EncryptedID(h, aux1);
  data{'EncryptedID'} = h;
  tag = find_xml_local(x[2], 'SubjectConfirmationData', 1);
  h =  hash [];
  parse_sa_SubjectConfirmationData(h, aux1);
  data{'SubjectConfirmationData'} = h;

}

function build_sa_SubjectConfirmation(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Method', data.Method);

  push body, build_sa_BaseID(data{'BaseID'});
  push body, build_sa_NameID(data{'NameID'});
  push body, build_sa_EncryptedID(data{'EncryptedID'});
  push body, build_sa_SubjectConfirmationData(data{'SubjectConfirmationData'});

  return TAG('sa:SubjectConfirmation', attr, body);
}




function parse_sa_SubjectConfirmationData(data, x) {
  POPATTR(x[1], 'Address', data.Address);
  POPATTR(x[1], 'InResponseTo', data.InResponseTo);
  POPATTR(x[1], 'NotBefore', data.NotBefore);
  POPATTR(x[1], 'NotOnOrAfter', data.NotOnOrAfter);
  POPATTR(x[1], 'Recipient', data.Recipient);
  POPATTR(x[1], 'xsi_type', data.xsi_type);

  for (i=1; tag = find_xml_local(x[2], 'KeyInfo', i); ++i) {
    h =  hash [];
    parse_ds_KeyInfo(h, tag);
    push data{'KeyInfo'}, h;
  }

}

function build_sa_SubjectConfirmationData(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Address', data.Address);
  PUSHATTR(attr, 'InResponseTo', data.InResponseTo);
  PUSHATTR(attr, 'NotBefore', data.NotBefore);
  PUSHATTR(attr, 'NotOnOrAfter', data.NotOnOrAfter);
  PUSHATTR(attr, 'Recipient', data.Recipient);
  PUSHATTR(attr, 'xsi_type', data.xsi_type);

  for d(data{'KeyInfo'}) push body,build_ds_KeyInfo(d);

  return TAG('sa:SubjectConfirmationData', attr, body);
}




function parse_sa_SubjectLocality(data, x) {
  POPATTR(x[1], 'Address', data.Address);
  POPATTR(x[1], 'DNSName', data.DNSName);


}

function build_sa_SubjectLocality(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Address', data.Address);
  PUSHATTR(attr, 'DNSName', data.DNSName);


  return TAG('sa:SubjectLocality', attr, body);
}




function parse_sa_TestElem(data, x) {

  for (i=1; tag = find_xml_local(x[2], 'AttributeValue', i); ++i) {
    h =  hash [];
    parse_sa_AttributeValue(h, tag);
    push data{'AttributeValue'}, h;
  }

}

function build_sa_TestElem(data) {
  attr = [];
  body = [];

  for d(data{'AttributeValue'}) push body,build_sa_AttributeValue(d);

  return TAG('sa:TestElem', attr, body);
}


/* EOF -- c/zx-sa.ds */
