/* c/zx-xaspcd1.ds - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** ds-templ.c  -  DirectoryScript template, used in code generation
 ** Copyright (c) 2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: ds-templ.c,v 1.1 2007-08-10 17:44:49 sampo Exp $
 **
 ** 6.6.2007, created, Sampo Kellomaki (sampo@iki.fi)
 **
 ** N.B: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/



function parse_xaspcd1_XACMLAuthzDecisionQuery(data, x) {
  POPATTR(x[1], 'CombinePolicies', data.CombinePolicies);
  POPATTR(x[1], 'Consent', data.Consent);
  POPATTR(x[1], 'Destination', data.Destination);
  POPATTR(x[1], 'ID', data.ID);
  POPATTR(x[1], 'InputContextOnly', data.InputContextOnly);
  POPATTR(x[1], 'IssueInstant', data.IssueInstant);
  POPATTR(x[1], 'ReturnContext', data.ReturnContext);
  POPATTR(x[1], 'Version', data.Version);

  tag = find_xml_local(x[2], 'Issuer', 1);
  h =  hash [];
  parse_sa_Issuer(h, aux1);
  data{'Issuer'} = h;
  tag = find_xml_local(x[2], 'Signature', 1);
  h =  hash [];
  parse_ds_Signature(h, aux1);
  data{'Signature'} = h;
  tag = find_xml_local(x[2], 'Extensions', 1);
  h =  hash [];
  parse_sp_Extensions(h, aux1);
  data{'Extensions'} = h;
  tag = find_xml_local(x[2], 'Request', 1);
  h =  hash [];
  parse_xac_Request(h, aux1);
  data{'Request'} = h;
  for (i=1; tag = find_xml_local(x[2], 'Policy', i); ++i) {
    h =  hash [];
    parse_xa_Policy(h, tag);
    push data{'Policy'}, h;
  }
  for (i=1; tag = find_xml_local(x[2], 'PolicySet', i); ++i) {
    h =  hash [];
    parse_xa_PolicySet(h, tag);
    push data{'PolicySet'}, h;
  }
  tag = find_xml_local(x[2], 'ReferencedPolicies', 1);
  h =  hash [];
  parse_xasacd1_ReferencedPolicies(h, aux1);
  data{'ReferencedPolicies'} = h;

}

function build_xaspcd1_XACMLAuthzDecisionQuery(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'CombinePolicies', data.CombinePolicies);
  PUSHATTR(attr, 'Consent', data.Consent);
  PUSHATTR(attr, 'Destination', data.Destination);
  PUSHATTR(attr, 'ID', data.ID);
  PUSHATTR(attr, 'InputContextOnly', data.InputContextOnly);
  PUSHATTR(attr, 'IssueInstant', data.IssueInstant);
  PUSHATTR(attr, 'ReturnContext', data.ReturnContext);
  PUSHATTR(attr, 'Version', data.Version);

  push body, build_sa_Issuer(data{'Issuer'});
  push body, build_ds_Signature(data{'Signature'});
  push body, build_sp_Extensions(data{'Extensions'});
  push body, build_xac_Request(data{'Request'});
  for d(data{'Policy'}) push body,build_xa_Policy(d);
  for d(data{'PolicySet'}) push body,build_xa_PolicySet(d);
  push body, build_xasacd1_ReferencedPolicies(data{'ReferencedPolicies'});

  return TAG('xaspcd1:XACMLAuthzDecisionQuery', attr, body);
}




function parse_xaspcd1_XACMLPolicyQuery(data, x) {
  POPATTR(x[1], 'Consent', data.Consent);
  POPATTR(x[1], 'Destination', data.Destination);
  POPATTR(x[1], 'ID', data.ID);
  POPATTR(x[1], 'IssueInstant', data.IssueInstant);
  POPATTR(x[1], 'Version', data.Version);

  tag = find_xml_local(x[2], 'Issuer', 1);
  h =  hash [];
  parse_sa_Issuer(h, aux1);
  data{'Issuer'} = h;
  tag = find_xml_local(x[2], 'Signature', 1);
  h =  hash [];
  parse_ds_Signature(h, aux1);
  data{'Signature'} = h;
  tag = find_xml_local(x[2], 'Extensions', 1);
  h =  hash [];
  parse_sp_Extensions(h, aux1);
  data{'Extensions'} = h;
  tag = find_xml_local(x[2], 'Request', 1);
  h =  hash [];
  parse_xac_Request(h, aux1);
  data{'Request'} = h;
  tag = find_xml_local(x[2], 'Target', 1);
  h =  hash [];
  parse_xa_Target(h, aux1);
  data{'Target'} = h;
  tag = find_xml_local(x[2], 'PolicySetIdReference', 1);
  h =  hash [];
  parse_xa_PolicySetIdReference(h, aux1);
  data{'PolicySetIdReference'} = h;
  tag = find_xml_local(x[2], 'PolicyIdReference', 1);
  h =  hash [];
  parse_xa_PolicyIdReference(h, aux1);
  data{'PolicyIdReference'} = h;

}

function build_xaspcd1_XACMLPolicyQuery(data) {
  attr = [];
  body = [];
  PUSHATTR(attr, 'Consent', data.Consent);
  PUSHATTR(attr, 'Destination', data.Destination);
  PUSHATTR(attr, 'ID', data.ID);
  PUSHATTR(attr, 'IssueInstant', data.IssueInstant);
  PUSHATTR(attr, 'Version', data.Version);

  push body, build_sa_Issuer(data{'Issuer'});
  push body, build_ds_Signature(data{'Signature'});
  push body, build_sp_Extensions(data{'Extensions'});
  push body, build_xac_Request(data{'Request'});
  push body, build_xa_Target(data{'Target'});
  push body, build_xa_PolicySetIdReference(data{'PolicySetIdReference'});
  push body, build_xa_PolicyIdReference(data{'PolicyIdReference'});

  return TAG('xaspcd1:XACMLPolicyQuery', attr, body);
}


/* EOF -- c/zx-xaspcd1.ds */
