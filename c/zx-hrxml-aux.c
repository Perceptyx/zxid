/* c/zx-hrxml-aux.c - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** aux-templ.c  -  Auxiliary functions template: cloning, freeing, walking data
 ** Copyright (c) 2006 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: aux-templ.c,v 1.12 2008-10-04 23:42:14 sampo Exp $
 **
 ** 30.5.2006, created, Sampo Kellomaki (sampo@iki.fi)
 ** 6.8.2006, factored from enc-templ.c to separate file --Sampo
 **
 ** N.B: wo=wire order (needed for exc-c14n), so=schema order
 **/

#include <memory.h>
#include "errmac.h"
#include "zx.h"
#include "c/zx-const.h"
#include "c/zx-data.h"
#include "c/zx-hrxml-data.h"



#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AccountingCode
#define EL_STRUCT zx_hrxml_AccountingCode_s
#define EL_NS     hrxml
#define EL_TAG    AccountingCode

/* FUNC(zx_FREE_hrxml_AccountingCode) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->description, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_AccountingCode) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_AccountingCode_s* zx_NEW_hrxml_AccountingCode(struct zx_ctx* c)
{
  struct zx_hrxml_AccountingCode_s* x = ZX_ZALLOC(c, struct zx_hrxml_AccountingCode_s);
  x->gg.g.tok = zx_hrxml_AccountingCode_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_AccountingCode) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->description);


}

/* FUNC(zx_DEEP_CLONE_hrxml_AccountingCode) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_AccountingCode_s* zx_DEEP_CLONE_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_AccountingCode_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_AccountingCode_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->description = zx_clone_attr(c, x->description);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_AccountingCode) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_AccountingCode) */

int zx_WALK_WO_hrxml_AccountingCode(struct zx_ctx* c, struct zx_hrxml_AccountingCode_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Achievement
#define EL_STRUCT zx_hrxml_Achievement_s
#define EL_NS     hrxml
#define EL_TAG    Achievement

/* FUNC(zx_FREE_hrxml_Achievement) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Date, free_strs);
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }
  for (e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Achievement) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Achievement_s* zx_NEW_hrxml_Achievement(struct zx_ctx* c)
{
  struct zx_hrxml_Achievement_s* x = ZX_ZALLOC(c, struct zx_hrxml_Achievement_s);
  x->gg.g.tok = zx_hrxml_Achievement_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Achievement) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Date);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->IssuingAuthority->gg;
       se && se->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Achievement) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Achievement_s* zx_DEEP_CLONE_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Achievement_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Achievement_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Date = zx_deep_clone_simple_elems(c,x->Date, dup_strs);
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IssuingAuthority(c,(struct zx_hrxml_IssuingAuthority_s*)e,dup_strs);
  	  if (!enn)
  	      x->IssuingAuthority = (struct zx_hrxml_IssuingAuthority_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Achievement) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Date, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Achievement) */

int zx_WALK_WO_hrxml_Achievement(struct zx_ctx* c, struct zx_hrxml_Achievement_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Achievements
#define EL_STRUCT zx_hrxml_Achievements_s
#define EL_NS     hrxml
#define EL_TAG    Achievements

/* FUNC(zx_FREE_hrxml_Achievements) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Achievement->gg;
       e && e->g.tok == zx_hrxml_Achievement_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Achievement(c, (struct zx_hrxml_Achievement_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Achievements) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Achievements_s* zx_NEW_hrxml_Achievements(struct zx_ctx* c)
{
  struct zx_hrxml_Achievements_s* x = ZX_ZALLOC(c, struct zx_hrxml_Achievements_s);
  x->gg.g.tok = zx_hrxml_Achievements_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Achievements) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Achievement->gg;
       se && se->g.tok == zx_hrxml_Achievement_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Achievement(c, (struct zx_hrxml_Achievement_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Achievements) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Achievements_s* zx_DEEP_CLONE_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Achievements_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Achievements_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Achievement->gg;
       e && e->g.tok == zx_hrxml_Achievement_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Achievement(c,(struct zx_hrxml_Achievement_s*)e,dup_strs);
  	  if (!enn)
  	      x->Achievement = (struct zx_hrxml_Achievement_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Achievements) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Achievement->gg;
       e && e->g.tok == zx_hrxml_Achievement_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Achievement(c, (struct zx_hrxml_Achievement_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Achievements) */

int zx_WALK_WO_hrxml_Achievements(struct zx_ctx* c, struct zx_hrxml_Achievements_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AffirmativeActionPlanJobGroupId
#define EL_STRUCT zx_hrxml_AffirmativeActionPlanJobGroupId_s
#define EL_NS     hrxml
#define EL_TAG    AffirmativeActionPlanJobGroupId

/* FUNC(zx_FREE_hrxml_AffirmativeActionPlanJobGroupId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_AffirmativeActionPlanJobGroupId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* zx_NEW_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c)
{
  struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x = ZX_ZALLOC(c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s);
  x->gg.g.tok = zx_hrxml_AffirmativeActionPlanJobGroupId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_AffirmativeActionPlanJobGroupId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_AffirmativeActionPlanJobGroupId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* zx_DEEP_CLONE_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_AffirmativeActionPlanJobGroupId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_AffirmativeActionPlanJobGroupId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_AffirmativeActionPlanJobGroupId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_AffirmativeActionPlanJobGroupId) */

int zx_WALK_WO_hrxml_AffirmativeActionPlanJobGroupId(struct zx_ctx* c, struct zx_hrxml_AffirmativeActionPlanJobGroupId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Affix
#define EL_STRUCT zx_hrxml_Affix_s
#define EL_NS     hrxml
#define EL_TAG    Affix

/* FUNC(zx_FREE_hrxml_Affix) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Affix) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Affix_s* zx_NEW_hrxml_Affix(struct zx_ctx* c)
{
  struct zx_hrxml_Affix_s* x = ZX_ZALLOC(c, struct zx_hrxml_Affix_s);
  x->gg.g.tok = zx_hrxml_Affix_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Affix) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_hrxml_Affix) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Affix_s* zx_DEEP_CLONE_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Affix_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Affix_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Affix) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Affix) */

int zx_WALK_WO_hrxml_Affix(struct zx_ctx* c, struct zx_hrxml_Affix_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AlternateScript
#define EL_STRUCT zx_hrxml_AlternateScript_s
#define EL_NS     hrxml
#define EL_TAG    AlternateScript

/* FUNC(zx_FREE_hrxml_AlternateScript) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->script, free_strs);

  zx_free_simple_elems(c, x->FormattedName, free_strs);
  zx_free_simple_elems(c, x->LegalName, free_strs);
  zx_free_simple_elems(c, x->GivenName, free_strs);
  zx_free_simple_elems(c, x->PreferredGivenName, free_strs);
  zx_free_simple_elems(c, x->MiddleName, free_strs);
  for (e = &x->FamilyName->gg;
       e && e->g.tok == zx_hrxml_FamilyName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)e, free_strs);
  }
  for (e = &x->Affix->gg;
       e && e->g.tok == zx_hrxml_Affix_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_AlternateScript) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_AlternateScript_s* zx_NEW_hrxml_AlternateScript(struct zx_ctx* c)
{
  struct zx_hrxml_AlternateScript_s* x = ZX_ZALLOC(c, struct zx_hrxml_AlternateScript_s);
  x->gg.g.tok = zx_hrxml_AlternateScript_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_AlternateScript) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->script);

  zx_dup_strs_simple_elems(c, x->FormattedName);
  zx_dup_strs_simple_elems(c, x->LegalName);
  zx_dup_strs_simple_elems(c, x->GivenName);
  zx_dup_strs_simple_elems(c, x->PreferredGivenName);
  zx_dup_strs_simple_elems(c, x->MiddleName);
  for (se = &x->FamilyName->gg;
       se && se->g.tok == zx_hrxml_FamilyName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)se);
  for (se = &x->Affix->gg;
       se && se->g.tok == zx_hrxml_Affix_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_AlternateScript) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_AlternateScript_s* zx_DEEP_CLONE_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_AlternateScript_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_AlternateScript_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->script = zx_clone_attr(c, x->script);

  x->FormattedName = zx_deep_clone_simple_elems(c,x->FormattedName, dup_strs);
  x->LegalName = zx_deep_clone_simple_elems(c,x->LegalName, dup_strs);
  x->GivenName = zx_deep_clone_simple_elems(c,x->GivenName, dup_strs);
  x->PreferredGivenName = zx_deep_clone_simple_elems(c,x->PreferredGivenName, dup_strs);
  x->MiddleName = zx_deep_clone_simple_elems(c,x->MiddleName, dup_strs);
  for (enn = 0, e = &x->FamilyName->gg;
       e && e->g.tok == zx_hrxml_FamilyName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_FamilyName(c,(struct zx_hrxml_FamilyName_s*)e,dup_strs);
  	  if (!enn)
  	      x->FamilyName = (struct zx_hrxml_FamilyName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Affix->gg;
       e && e->g.tok == zx_hrxml_Affix_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Affix(c,(struct zx_hrxml_Affix_s*)e,dup_strs);
  	  if (!enn)
  	      x->Affix = (struct zx_hrxml_Affix_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_AlternateScript) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->FormattedName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->LegalName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->GivenName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PreferredGivenName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MiddleName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->FamilyName->gg;
       e && e->g.tok == zx_hrxml_FamilyName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Affix->gg;
       e && e->g.tok == zx_hrxml_Affix_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_AlternateScript) */

int zx_WALK_WO_hrxml_AlternateScript(struct zx_ctx* c, struct zx_hrxml_AlternateScript_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Area
#define EL_STRUCT zx_hrxml_Area_s
#define EL_NS     hrxml
#define EL_TAG    Area

/* FUNC(zx_FREE_hrxml_Area) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);

  zx_free_simple_elems(c, x->Value, free_strs);
  for (e = &x->Area->gg;
       e && e->g.tok == zx_hrxml_Area_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Area(c, (struct zx_hrxml_Area_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Area) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Area_s* zx_NEW_hrxml_Area(struct zx_ctx* c)
{
  struct zx_hrxml_Area_s* x = ZX_ZALLOC(c, struct zx_hrxml_Area_s);
  x->gg.g.tok = zx_hrxml_Area_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Area) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);

  zx_dup_strs_simple_elems(c, x->Value);
  for (se = &x->Area->gg;
       se && se->g.tok == zx_hrxml_Area_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Area(c, (struct zx_hrxml_Area_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Area) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Area_s* zx_DEEP_CLONE_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Area_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Area_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);

  x->Value = zx_deep_clone_simple_elems(c,x->Value, dup_strs);
  for (enn = 0, e = &x->Area->gg;
       e && e->g.tok == zx_hrxml_Area_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Area(c,(struct zx_hrxml_Area_s*)e,dup_strs);
  	  if (!enn)
  	      x->Area = (struct zx_hrxml_Area_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Area) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Value, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Area->gg;
       e && e->g.tok == zx_hrxml_Area_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Area(c, (struct zx_hrxml_Area_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Area) */

int zx_WALK_WO_hrxml_Area(struct zx_ctx* c, struct zx_hrxml_Area_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Article
#define EL_STRUCT zx_hrxml_Article_s
#define EL_NS     hrxml
#define EL_TAG    Article

/* FUNC(zx_FREE_hrxml_Article) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Title, free_strs);
  zx_free_simple_elems(c, x->Name, free_strs);
  for (e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Link, free_strs);
  zx_free_simple_elems(c, x->Abstract, free_strs);
  for (e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);
  zx_free_simple_elems(c, x->JournalOrSerialName, free_strs);
  zx_free_simple_elems(c, x->ISSN, free_strs);
  zx_free_simple_elems(c, x->Volume, free_strs);
  zx_free_simple_elems(c, x->Issue, free_strs);
  zx_free_simple_elems(c, x->PageNumber, free_strs);
  for (e = &x->PublicationLanguage->gg;
       e && e->g.tok == zx_hrxml_PublicationLanguage_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PublicationLanguage(c, (struct zx_hrxml_PublicationLanguage_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Article) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Article_s* zx_NEW_hrxml_Article(struct zx_ctx* c)
{
  struct zx_hrxml_Article_s* x = ZX_ZALLOC(c, struct zx_hrxml_Article_s);
  x->gg.g.tok = zx_hrxml_Article_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Article) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Title);
  zx_dup_strs_simple_elems(c, x->Name);
  for (se = &x->PublicationDate->gg;
       se && se->g.tok == zx_hrxml_PublicationDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se);
  zx_dup_strs_simple_elems(c, x->Link);
  zx_dup_strs_simple_elems(c, x->Abstract);
  for (se = &x->Copyright->gg;
       se && se->g.tok == zx_hrxml_Copyright_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);
  zx_dup_strs_simple_elems(c, x->JournalOrSerialName);
  zx_dup_strs_simple_elems(c, x->ISSN);
  zx_dup_strs_simple_elems(c, x->Volume);
  zx_dup_strs_simple_elems(c, x->Issue);
  zx_dup_strs_simple_elems(c, x->PageNumber);
  for (se = &x->PublicationLanguage->gg;
       se && se->g.tok == zx_hrxml_PublicationLanguage_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PublicationLanguage(c, (struct zx_hrxml_PublicationLanguage_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Article) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Article_s* zx_DEEP_CLONE_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Article_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Article_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Title = zx_deep_clone_simple_elems(c,x->Title, dup_strs);
  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  for (enn = 0, e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PublicationDate(c,(struct zx_hrxml_PublicationDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->PublicationDate = (struct zx_hrxml_PublicationDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Link = zx_deep_clone_simple_elems(c,x->Link, dup_strs);
  x->Abstract = zx_deep_clone_simple_elems(c,x->Abstract, dup_strs);
  for (enn = 0, e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Copyright(c,(struct zx_hrxml_Copyright_s*)e,dup_strs);
  	  if (!enn)
  	      x->Copyright = (struct zx_hrxml_Copyright_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  x->JournalOrSerialName = zx_deep_clone_simple_elems(c,x->JournalOrSerialName, dup_strs);
  x->ISSN = zx_deep_clone_simple_elems(c,x->ISSN, dup_strs);
  x->Volume = zx_deep_clone_simple_elems(c,x->Volume, dup_strs);
  x->Issue = zx_deep_clone_simple_elems(c,x->Issue, dup_strs);
  x->PageNumber = zx_deep_clone_simple_elems(c,x->PageNumber, dup_strs);
  for (enn = 0, e = &x->PublicationLanguage->gg;
       e && e->g.tok == zx_hrxml_PublicationLanguage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PublicationLanguage(c,(struct zx_hrxml_PublicationLanguage_s*)e,dup_strs);
  	  if (!enn)
  	      x->PublicationLanguage = (struct zx_hrxml_PublicationLanguage_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Article) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Title, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Link, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Abstract, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->JournalOrSerialName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->ISSN, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Volume, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Issue, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PageNumber, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PublicationLanguage->gg;
       e && e->g.tok == zx_hrxml_PublicationLanguage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PublicationLanguage(c, (struct zx_hrxml_PublicationLanguage_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Article) */

int zx_WALK_WO_hrxml_Article(struct zx_ctx* c, struct zx_hrxml_Article_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Association
#define EL_STRUCT zx_hrxml_Association_s
#define EL_NS     hrxml
#define EL_TAG    Association

/* FUNC(zx_FREE_hrxml_Association) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);

  zx_free_simple_elems(c, x->Name, free_strs);
  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Link, free_strs);
  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, free_strs);
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Role, free_strs);
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Association) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Association_s* zx_NEW_hrxml_Association(struct zx_ctx* c)
{
  struct zx_hrxml_Association_s* x = ZX_ZALLOC(c, struct zx_hrxml_Association_s);
  x->gg.g.tok = zx_hrxml_Association_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Association) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);

  zx_dup_strs_simple_elems(c, x->Name);
  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  zx_dup_strs_simple_elems(c, x->Link);
  for (se = &x->StartDate->gg;
       se && se->g.tok == zx_hrxml_StartDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg;
       se && se->g.tok == zx_hrxml_EndDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);
  zx_dup_strs_simple_elems(c, x->Role);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Association) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Association_s* zx_DEEP_CLONE_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Association_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Association_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);

  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Link = zx_deep_clone_simple_elems(c,x->Link, dup_strs);
  for (enn = 0, e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StartDate(c,(struct zx_hrxml_StartDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->StartDate = (struct zx_hrxml_StartDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EndDate(c,(struct zx_hrxml_EndDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EndDate = (struct zx_hrxml_EndDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Role = zx_deep_clone_simple_elems(c,x->Role, dup_strs);
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Association) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Link, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Role, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Association) */

int zx_WALK_WO_hrxml_Association(struct zx_ctx* c, struct zx_hrxml_Association_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Associations
#define EL_STRUCT zx_hrxml_Associations_s
#define EL_NS     hrxml
#define EL_TAG    Associations

/* FUNC(zx_FREE_hrxml_Associations) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Association->gg;
       e && e->g.tok == zx_hrxml_Association_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Association(c, (struct zx_hrxml_Association_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Associations) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Associations_s* zx_NEW_hrxml_Associations(struct zx_ctx* c)
{
  struct zx_hrxml_Associations_s* x = ZX_ZALLOC(c, struct zx_hrxml_Associations_s);
  x->gg.g.tok = zx_hrxml_Associations_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Associations) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Association->gg;
       se && se->g.tok == zx_hrxml_Association_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Association(c, (struct zx_hrxml_Association_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Associations) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Associations_s* zx_DEEP_CLONE_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Associations_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Associations_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Association->gg;
       e && e->g.tok == zx_hrxml_Association_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Association(c,(struct zx_hrxml_Association_s*)e,dup_strs);
  	  if (!enn)
  	      x->Association = (struct zx_hrxml_Association_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Associations) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Association->gg;
       e && e->g.tok == zx_hrxml_Association_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Association(c, (struct zx_hrxml_Association_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Associations) */

int zx_WALK_WO_hrxml_Associations(struct zx_ctx* c, struct zx_hrxml_Associations_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AttachmentReference
#define EL_STRUCT zx_hrxml_AttachmentReference_s
#define EL_NS     hrxml
#define EL_TAG    AttachmentReference

/* FUNC(zx_FREE_hrxml_AttachmentReference) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->context, free_strs);
  zx_free_attr(c, x->mimeType, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_AttachmentReference) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_AttachmentReference_s* zx_NEW_hrxml_AttachmentReference(struct zx_ctx* c)
{
  struct zx_hrxml_AttachmentReference_s* x = ZX_ZALLOC(c, struct zx_hrxml_AttachmentReference_s);
  x->gg.g.tok = zx_hrxml_AttachmentReference_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_AttachmentReference) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->context);
  zx_dup_attr(c, x->mimeType);


}

/* FUNC(zx_DEEP_CLONE_hrxml_AttachmentReference) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_AttachmentReference_s* zx_DEEP_CLONE_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_AttachmentReference_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_AttachmentReference_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->context = zx_clone_attr(c, x->context);
  x->mimeType = zx_clone_attr(c, x->mimeType);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_AttachmentReference) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_AttachmentReference) */

int zx_WALK_WO_hrxml_AttachmentReference(struct zx_ctx* c, struct zx_hrxml_AttachmentReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AvailabilityDates
#define EL_STRUCT zx_hrxml_AvailabilityDates_s
#define EL_NS     hrxml
#define EL_TAG    AvailabilityDates

/* FUNC(zx_FREE_hrxml_AvailabilityDates) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, free_strs);
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_AvailabilityDates) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_AvailabilityDates_s* zx_NEW_hrxml_AvailabilityDates(struct zx_ctx* c)
{
  struct zx_hrxml_AvailabilityDates_s* x = ZX_ZALLOC(c, struct zx_hrxml_AvailabilityDates_s);
  x->gg.g.tok = zx_hrxml_AvailabilityDates_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_AvailabilityDates) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->StartDate->gg;
       se && se->g.tok == zx_hrxml_StartDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg;
       se && se->g.tok == zx_hrxml_EndDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_AvailabilityDates) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_AvailabilityDates_s* zx_DEEP_CLONE_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_AvailabilityDates_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_AvailabilityDates_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StartDate(c,(struct zx_hrxml_StartDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->StartDate = (struct zx_hrxml_StartDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EndDate(c,(struct zx_hrxml_EndDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EndDate = (struct zx_hrxml_EndDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_AvailabilityDates) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_AvailabilityDates) */

int zx_WALK_WO_hrxml_AvailabilityDates(struct zx_ctx* c, struct zx_hrxml_AvailabilityDates_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_AvailabilityInfo
#define EL_STRUCT zx_hrxml_AvailabilityInfo_s
#define EL_NS     hrxml
#define EL_TAG    AvailabilityInfo

/* FUNC(zx_FREE_hrxml_AvailabilityInfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->AvailabilityDates->gg;
       e && e->g.tok == zx_hrxml_AvailabilityDates_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_AvailabilityDates(c, (struct zx_hrxml_AvailabilityDates_s*)e, free_strs);
  }
  for (e = &x->TermOfNotice->gg;
       e && e->g.tok == zx_hrxml_TermOfNotice_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_TermOfNotice(c, (struct zx_hrxml_TermOfNotice_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_AvailabilityInfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_AvailabilityInfo_s* zx_NEW_hrxml_AvailabilityInfo(struct zx_ctx* c)
{
  struct zx_hrxml_AvailabilityInfo_s* x = ZX_ZALLOC(c, struct zx_hrxml_AvailabilityInfo_s);
  x->gg.g.tok = zx_hrxml_AvailabilityInfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_AvailabilityInfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->AvailabilityDates->gg;
       se && se->g.tok == zx_hrxml_AvailabilityDates_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_AvailabilityDates(c, (struct zx_hrxml_AvailabilityDates_s*)se);
  for (se = &x->TermOfNotice->gg;
       se && se->g.tok == zx_hrxml_TermOfNotice_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_TermOfNotice(c, (struct zx_hrxml_TermOfNotice_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_AvailabilityInfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_AvailabilityInfo_s* zx_DEEP_CLONE_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_AvailabilityInfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_AvailabilityInfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->AvailabilityDates->gg;
       e && e->g.tok == zx_hrxml_AvailabilityDates_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_AvailabilityDates(c,(struct zx_hrxml_AvailabilityDates_s*)e,dup_strs);
  	  if (!enn)
  	      x->AvailabilityDates = (struct zx_hrxml_AvailabilityDates_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->TermOfNotice->gg;
       e && e->g.tok == zx_hrxml_TermOfNotice_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_TermOfNotice(c,(struct zx_hrxml_TermOfNotice_s*)e,dup_strs);
  	  if (!enn)
  	      x->TermOfNotice = (struct zx_hrxml_TermOfNotice_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_AvailabilityInfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->AvailabilityDates->gg;
       e && e->g.tok == zx_hrxml_AvailabilityDates_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_AvailabilityDates(c, (struct zx_hrxml_AvailabilityDates_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->TermOfNotice->gg;
       e && e->g.tok == zx_hrxml_TermOfNotice_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_TermOfNotice(c, (struct zx_hrxml_TermOfNotice_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_AvailabilityInfo) */

int zx_WALK_WO_hrxml_AvailabilityInfo(struct zx_ctx* c, struct zx_hrxml_AvailabilityInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BKZClassification
#define EL_STRUCT zx_hrxml_BKZClassification_s
#define EL_NS     hrxml
#define EL_TAG    BKZClassification

/* FUNC(zx_FREE_hrxml_BKZClassification) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->BKZId->gg;
       e && e->g.tok == zx_hrxml_BKZId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_BKZId(c, (struct zx_hrxml_BKZId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->BKZName, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_BKZClassification) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_BKZClassification_s* zx_NEW_hrxml_BKZClassification(struct zx_ctx* c)
{
  struct zx_hrxml_BKZClassification_s* x = ZX_ZALLOC(c, struct zx_hrxml_BKZClassification_s);
  x->gg.g.tok = zx_hrxml_BKZClassification_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_BKZClassification) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->BKZId->gg;
       se && se->g.tok == zx_hrxml_BKZId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_BKZId(c, (struct zx_hrxml_BKZId_s*)se);
  zx_dup_strs_simple_elems(c, x->BKZName);

}

/* FUNC(zx_DEEP_CLONE_hrxml_BKZClassification) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_BKZClassification_s* zx_DEEP_CLONE_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_BKZClassification_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_BKZClassification_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->BKZId->gg;
       e && e->g.tok == zx_hrxml_BKZId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_BKZId(c,(struct zx_hrxml_BKZId_s*)e,dup_strs);
  	  if (!enn)
  	      x->BKZId = (struct zx_hrxml_BKZId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->BKZName = zx_deep_clone_simple_elems(c,x->BKZName, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_BKZClassification) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->BKZId->gg;
       e && e->g.tok == zx_hrxml_BKZId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_BKZId(c, (struct zx_hrxml_BKZId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->BKZName, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_BKZClassification) */

int zx_WALK_WO_hrxml_BKZClassification(struct zx_ctx* c, struct zx_hrxml_BKZClassification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BKZId
#define EL_STRUCT zx_hrxml_BKZId_s
#define EL_NS     hrxml
#define EL_TAG    BKZId

/* FUNC(zx_FREE_hrxml_BKZId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_BKZId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_BKZId_s* zx_NEW_hrxml_BKZId(struct zx_ctx* c)
{
  struct zx_hrxml_BKZId_s* x = ZX_ZALLOC(c, struct zx_hrxml_BKZId_s);
  x->gg.g.tok = zx_hrxml_BKZId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_BKZId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_BKZId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_BKZId_s* zx_DEEP_CLONE_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_BKZId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_BKZId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_BKZId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_BKZId) */

int zx_WALK_WO_hrxml_BKZId(struct zx_ctx* c, struct zx_hrxml_BKZId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BasePay
#define EL_STRUCT zx_hrxml_BasePay_s
#define EL_NS     hrxml
#define EL_TAG    BasePay

/* FUNC(zx_FREE_hrxml_BasePay) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->baseInterval, free_strs);
  zx_free_attr(c, x->currencyCode, free_strs);

  zx_free_simple_elems(c, x->BasePayAmountMin, free_strs);
  zx_free_simple_elems(c, x->BasePayAmountMax, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_BasePay) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_BasePay_s* zx_NEW_hrxml_BasePay(struct zx_ctx* c)
{
  struct zx_hrxml_BasePay_s* x = ZX_ZALLOC(c, struct zx_hrxml_BasePay_s);
  x->gg.g.tok = zx_hrxml_BasePay_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_BasePay) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->baseInterval);
  zx_dup_attr(c, x->currencyCode);

  zx_dup_strs_simple_elems(c, x->BasePayAmountMin);
  zx_dup_strs_simple_elems(c, x->BasePayAmountMax);

}

/* FUNC(zx_DEEP_CLONE_hrxml_BasePay) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_BasePay_s* zx_DEEP_CLONE_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_BasePay_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_BasePay_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->baseInterval = zx_clone_attr(c, x->baseInterval);
  x->currencyCode = zx_clone_attr(c, x->currencyCode);

  x->BasePayAmountMin = zx_deep_clone_simple_elems(c,x->BasePayAmountMin, dup_strs);
  x->BasePayAmountMax = zx_deep_clone_simple_elems(c,x->BasePayAmountMax, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_BasePay) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->BasePayAmountMin, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->BasePayAmountMax, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_BasePay) */

int zx_WALK_WO_hrxml_BasePay(struct zx_ctx* c, struct zx_hrxml_BasePay_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Benefits
#define EL_STRUCT zx_hrxml_Benefits_s
#define EL_NS     hrxml
#define EL_TAG    Benefits

/* FUNC(zx_FREE_hrxml_Benefits) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Insurance->gg;
       e && e->g.tok == zx_hrxml_Insurance_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Insurance(c, (struct zx_hrxml_Insurance_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->RetirementOrSavingsPlan, free_strs);
  for (e = &x->CompanyVehicle->gg;
       e && e->g.tok == zx_hrxml_CompanyVehicle_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_CompanyVehicle(c, (struct zx_hrxml_CompanyVehicle_s*)e, free_strs);
  }
  for (e = &x->RelocationAssistance->gg;
       e && e->g.tok == zx_hrxml_RelocationAssistance_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RelocationAssistance(c, (struct zx_hrxml_RelocationAssistance_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->VisaSponsorship, free_strs);
  for (e = &x->TimeOffAllowance->gg;
       e && e->g.tok == zx_hrxml_TimeOffAllowance_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_TimeOffAllowance(c, (struct zx_hrxml_TimeOffAllowance_s*)e, free_strs);
  }
  for (e = &x->ExpatriateBenefits->gg;
       e && e->g.tok == zx_hrxml_ExpatriateBenefits_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ExpatriateBenefits(c, (struct zx_hrxml_ExpatriateBenefits_s*)e, free_strs);
  }
  for (e = &x->OtherBenefits->gg;
       e && e->g.tok == zx_hrxml_OtherBenefits_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OtherBenefits(c, (struct zx_hrxml_OtherBenefits_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Benefits) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Benefits_s* zx_NEW_hrxml_Benefits(struct zx_ctx* c)
{
  struct zx_hrxml_Benefits_s* x = ZX_ZALLOC(c, struct zx_hrxml_Benefits_s);
  x->gg.g.tok = zx_hrxml_Benefits_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Benefits) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Insurance->gg;
       se && se->g.tok == zx_hrxml_Insurance_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Insurance(c, (struct zx_hrxml_Insurance_s*)se);
  zx_dup_strs_simple_elems(c, x->RetirementOrSavingsPlan);
  for (se = &x->CompanyVehicle->gg;
       se && se->g.tok == zx_hrxml_CompanyVehicle_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_CompanyVehicle(c, (struct zx_hrxml_CompanyVehicle_s*)se);
  for (se = &x->RelocationAssistance->gg;
       se && se->g.tok == zx_hrxml_RelocationAssistance_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RelocationAssistance(c, (struct zx_hrxml_RelocationAssistance_s*)se);
  zx_dup_strs_simple_elems(c, x->VisaSponsorship);
  for (se = &x->TimeOffAllowance->gg;
       se && se->g.tok == zx_hrxml_TimeOffAllowance_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_TimeOffAllowance(c, (struct zx_hrxml_TimeOffAllowance_s*)se);
  for (se = &x->ExpatriateBenefits->gg;
       se && se->g.tok == zx_hrxml_ExpatriateBenefits_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ExpatriateBenefits(c, (struct zx_hrxml_ExpatriateBenefits_s*)se);
  for (se = &x->OtherBenefits->gg;
       se && se->g.tok == zx_hrxml_OtherBenefits_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OtherBenefits(c, (struct zx_hrxml_OtherBenefits_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Benefits) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Benefits_s* zx_DEEP_CLONE_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Benefits_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Benefits_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Insurance->gg;
       e && e->g.tok == zx_hrxml_Insurance_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Insurance(c,(struct zx_hrxml_Insurance_s*)e,dup_strs);
  	  if (!enn)
  	      x->Insurance = (struct zx_hrxml_Insurance_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->RetirementOrSavingsPlan = zx_deep_clone_simple_elems(c,x->RetirementOrSavingsPlan, dup_strs);
  for (enn = 0, e = &x->CompanyVehicle->gg;
       e && e->g.tok == zx_hrxml_CompanyVehicle_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_CompanyVehicle(c,(struct zx_hrxml_CompanyVehicle_s*)e,dup_strs);
  	  if (!enn)
  	      x->CompanyVehicle = (struct zx_hrxml_CompanyVehicle_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RelocationAssistance->gg;
       e && e->g.tok == zx_hrxml_RelocationAssistance_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RelocationAssistance(c,(struct zx_hrxml_RelocationAssistance_s*)e,dup_strs);
  	  if (!enn)
  	      x->RelocationAssistance = (struct zx_hrxml_RelocationAssistance_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->VisaSponsorship = zx_deep_clone_simple_elems(c,x->VisaSponsorship, dup_strs);
  for (enn = 0, e = &x->TimeOffAllowance->gg;
       e && e->g.tok == zx_hrxml_TimeOffAllowance_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_TimeOffAllowance(c,(struct zx_hrxml_TimeOffAllowance_s*)e,dup_strs);
  	  if (!enn)
  	      x->TimeOffAllowance = (struct zx_hrxml_TimeOffAllowance_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ExpatriateBenefits->gg;
       e && e->g.tok == zx_hrxml_ExpatriateBenefits_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ExpatriateBenefits(c,(struct zx_hrxml_ExpatriateBenefits_s*)e,dup_strs);
  	  if (!enn)
  	      x->ExpatriateBenefits = (struct zx_hrxml_ExpatriateBenefits_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OtherBenefits->gg;
       e && e->g.tok == zx_hrxml_OtherBenefits_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OtherBenefits(c,(struct zx_hrxml_OtherBenefits_s*)e,dup_strs);
  	  if (!enn)
  	      x->OtherBenefits = (struct zx_hrxml_OtherBenefits_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Benefits) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Insurance->gg;
       e && e->g.tok == zx_hrxml_Insurance_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Insurance(c, (struct zx_hrxml_Insurance_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->RetirementOrSavingsPlan, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->CompanyVehicle->gg;
       e && e->g.tok == zx_hrxml_CompanyVehicle_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_CompanyVehicle(c, (struct zx_hrxml_CompanyVehicle_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RelocationAssistance->gg;
       e && e->g.tok == zx_hrxml_RelocationAssistance_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RelocationAssistance(c, (struct zx_hrxml_RelocationAssistance_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->VisaSponsorship, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->TimeOffAllowance->gg;
       e && e->g.tok == zx_hrxml_TimeOffAllowance_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_TimeOffAllowance(c, (struct zx_hrxml_TimeOffAllowance_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ExpatriateBenefits->gg;
       e && e->g.tok == zx_hrxml_ExpatriateBenefits_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ExpatriateBenefits(c, (struct zx_hrxml_ExpatriateBenefits_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OtherBenefits->gg;
       e && e->g.tok == zx_hrxml_OtherBenefits_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OtherBenefits(c, (struct zx_hrxml_OtherBenefits_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Benefits) */

int zx_WALK_WO_hrxml_Benefits(struct zx_ctx* c, struct zx_hrxml_Benefits_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_BiologicalDescriptors
#define EL_STRUCT zx_hrxml_BiologicalDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    BiologicalDescriptors

/* FUNC(zx_FREE_hrxml_BiologicalDescriptors) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->DateOfBirth, free_strs);
  zx_free_simple_elems(c, x->MonthDayOfBirth, free_strs);
  zx_free_simple_elems(c, x->Age, free_strs);
  zx_free_simple_elems(c, x->GenderCode, free_strs);
  zx_free_simple_elems(c, x->EyeColor, free_strs);
  zx_free_simple_elems(c, x->HairColor, free_strs);
  for (e = &x->Height->gg;
       e && e->g.tok == zx_hrxml_Height_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Height(c, (struct zx_hrxml_Height_s*)e, free_strs);
  }
  for (e = &x->Weight->gg;
       e && e->g.tok == zx_hrxml_Weight_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->IdentifyingMarks, free_strs);
  for (e = &x->DisabilityInfo->gg;
       e && e->g.tok == zx_hrxml_DisabilityInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DisabilityInfo(c, (struct zx_hrxml_DisabilityInfo_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_BiologicalDescriptors) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_BiologicalDescriptors_s* zx_NEW_hrxml_BiologicalDescriptors(struct zx_ctx* c)
{
  struct zx_hrxml_BiologicalDescriptors_s* x = ZX_ZALLOC(c, struct zx_hrxml_BiologicalDescriptors_s);
  x->gg.g.tok = zx_hrxml_BiologicalDescriptors_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_BiologicalDescriptors) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->DateOfBirth);
  zx_dup_strs_simple_elems(c, x->MonthDayOfBirth);
  zx_dup_strs_simple_elems(c, x->Age);
  zx_dup_strs_simple_elems(c, x->GenderCode);
  zx_dup_strs_simple_elems(c, x->EyeColor);
  zx_dup_strs_simple_elems(c, x->HairColor);
  for (se = &x->Height->gg;
       se && se->g.tok == zx_hrxml_Height_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Height(c, (struct zx_hrxml_Height_s*)se);
  for (se = &x->Weight->gg;
       se && se->g.tok == zx_hrxml_Weight_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)se);
  zx_dup_strs_simple_elems(c, x->IdentifyingMarks);
  for (se = &x->DisabilityInfo->gg;
       se && se->g.tok == zx_hrxml_DisabilityInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DisabilityInfo(c, (struct zx_hrxml_DisabilityInfo_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_BiologicalDescriptors) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_BiologicalDescriptors_s* zx_DEEP_CLONE_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_BiologicalDescriptors_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_BiologicalDescriptors_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->DateOfBirth = zx_deep_clone_simple_elems(c,x->DateOfBirth, dup_strs);
  x->MonthDayOfBirth = zx_deep_clone_simple_elems(c,x->MonthDayOfBirth, dup_strs);
  x->Age = zx_deep_clone_simple_elems(c,x->Age, dup_strs);
  x->GenderCode = zx_deep_clone_simple_elems(c,x->GenderCode, dup_strs);
  x->EyeColor = zx_deep_clone_simple_elems(c,x->EyeColor, dup_strs);
  x->HairColor = zx_deep_clone_simple_elems(c,x->HairColor, dup_strs);
  for (enn = 0, e = &x->Height->gg;
       e && e->g.tok == zx_hrxml_Height_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Height(c,(struct zx_hrxml_Height_s*)e,dup_strs);
  	  if (!enn)
  	      x->Height = (struct zx_hrxml_Height_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Weight->gg;
       e && e->g.tok == zx_hrxml_Weight_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Weight(c,(struct zx_hrxml_Weight_s*)e,dup_strs);
  	  if (!enn)
  	      x->Weight = (struct zx_hrxml_Weight_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->IdentifyingMarks = zx_deep_clone_simple_elems(c,x->IdentifyingMarks, dup_strs);
  for (enn = 0, e = &x->DisabilityInfo->gg;
       e && e->g.tok == zx_hrxml_DisabilityInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DisabilityInfo(c,(struct zx_hrxml_DisabilityInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->DisabilityInfo = (struct zx_hrxml_DisabilityInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_BiologicalDescriptors) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->DateOfBirth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDayOfBirth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Age, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->GenderCode, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->EyeColor, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->HairColor, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Height->gg;
       e && e->g.tok == zx_hrxml_Height_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Height(c, (struct zx_hrxml_Height_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Weight->gg;
       e && e->g.tok == zx_hrxml_Weight_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->IdentifyingMarks, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->DisabilityInfo->gg;
       e && e->g.tok == zx_hrxml_DisabilityInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DisabilityInfo(c, (struct zx_hrxml_DisabilityInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_BiologicalDescriptors) */

int zx_WALK_WO_hrxml_BiologicalDescriptors(struct zx_ctx* c, struct zx_hrxml_BiologicalDescriptors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Book
#define EL_STRUCT zx_hrxml_Book_s
#define EL_NS     hrxml
#define EL_TAG    Book

/* FUNC(zx_FREE_hrxml_Book) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Title, free_strs);
  zx_free_simple_elems(c, x->Name, free_strs);
  for (e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Link, free_strs);
  zx_free_simple_elems(c, x->Abstract, free_strs);
  for (e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);
  zx_free_simple_elems(c, x->Edition, free_strs);
  zx_free_simple_elems(c, x->Chapter, free_strs);
  zx_free_simple_elems(c, x->ISSN, free_strs);
  zx_free_simple_elems(c, x->ISBN, free_strs);
  zx_free_simple_elems(c, x->NumberOfPages, free_strs);
  zx_free_simple_elems(c, x->PublisherName, free_strs);
  zx_free_simple_elems(c, x->PublisherLocation, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Book) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Book_s* zx_NEW_hrxml_Book(struct zx_ctx* c)
{
  struct zx_hrxml_Book_s* x = ZX_ZALLOC(c, struct zx_hrxml_Book_s);
  x->gg.g.tok = zx_hrxml_Book_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Book) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Title);
  zx_dup_strs_simple_elems(c, x->Name);
  for (se = &x->PublicationDate->gg;
       se && se->g.tok == zx_hrxml_PublicationDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se);
  zx_dup_strs_simple_elems(c, x->Link);
  zx_dup_strs_simple_elems(c, x->Abstract);
  for (se = &x->Copyright->gg;
       se && se->g.tok == zx_hrxml_Copyright_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);
  zx_dup_strs_simple_elems(c, x->Edition);
  zx_dup_strs_simple_elems(c, x->Chapter);
  zx_dup_strs_simple_elems(c, x->ISSN);
  zx_dup_strs_simple_elems(c, x->ISBN);
  zx_dup_strs_simple_elems(c, x->NumberOfPages);
  zx_dup_strs_simple_elems(c, x->PublisherName);
  zx_dup_strs_simple_elems(c, x->PublisherLocation);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Book) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Book_s* zx_DEEP_CLONE_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Book_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Book_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Title = zx_deep_clone_simple_elems(c,x->Title, dup_strs);
  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  for (enn = 0, e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PublicationDate(c,(struct zx_hrxml_PublicationDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->PublicationDate = (struct zx_hrxml_PublicationDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Link = zx_deep_clone_simple_elems(c,x->Link, dup_strs);
  x->Abstract = zx_deep_clone_simple_elems(c,x->Abstract, dup_strs);
  for (enn = 0, e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Copyright(c,(struct zx_hrxml_Copyright_s*)e,dup_strs);
  	  if (!enn)
  	      x->Copyright = (struct zx_hrxml_Copyright_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  x->Edition = zx_deep_clone_simple_elems(c,x->Edition, dup_strs);
  x->Chapter = zx_deep_clone_simple_elems(c,x->Chapter, dup_strs);
  x->ISSN = zx_deep_clone_simple_elems(c,x->ISSN, dup_strs);
  x->ISBN = zx_deep_clone_simple_elems(c,x->ISBN, dup_strs);
  x->NumberOfPages = zx_deep_clone_simple_elems(c,x->NumberOfPages, dup_strs);
  x->PublisherName = zx_deep_clone_simple_elems(c,x->PublisherName, dup_strs);
  x->PublisherLocation = zx_deep_clone_simple_elems(c,x->PublisherLocation, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Book) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Title, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Link, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Abstract, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Edition, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Chapter, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->ISSN, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->ISBN, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->NumberOfPages, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PublisherName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PublisherLocation, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Book) */

int zx_WALK_WO_hrxml_Book(struct zx_ctx* c, struct zx_hrxml_Book_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Candidate
#define EL_STRUCT zx_hrxml_Candidate_s
#define EL_NS     hrxml
#define EL_TAG    Candidate

/* FUNC(zx_FREE_hrxml_Candidate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);

  for (e = &x->CandidateRecordInfo->gg;
       e && e->g.tok == zx_hrxml_CandidateRecordInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_CandidateRecordInfo(c, (struct zx_hrxml_CandidateRecordInfo_s*)e, free_strs);
  }
  for (e = &x->RelatedPositionPostings->gg;
       e && e->g.tok == zx_hrxml_RelatedPositionPostings_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RelatedPositionPostings(c, (struct zx_hrxml_RelatedPositionPostings_s*)e, free_strs);
  }
  for (e = &x->CandidateSupplier->gg;
       e && e->g.tok == zx_hrxml_CandidateSupplier_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_CandidateSupplier(c, (struct zx_hrxml_CandidateSupplier_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->DistributionGuidelines, free_strs);
  for (e = &x->CandidateProfile->gg;
       e && e->g.tok == zx_hrxml_CandidateProfile_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_CandidateProfile(c, (struct zx_hrxml_CandidateProfile_s*)e, free_strs);
  }
  for (e = &x->Resume->gg;
       e && e->g.tok == zx_hrxml_Resume_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Resume(c, (struct zx_hrxml_Resume_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Candidate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Candidate_s* zx_NEW_hrxml_Candidate(struct zx_ctx* c)
{
  struct zx_hrxml_Candidate_s* x = ZX_ZALLOC(c, struct zx_hrxml_Candidate_s);
  x->gg.g.tok = zx_hrxml_Candidate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Candidate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);

  for (se = &x->CandidateRecordInfo->gg;
       se && se->g.tok == zx_hrxml_CandidateRecordInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_CandidateRecordInfo(c, (struct zx_hrxml_CandidateRecordInfo_s*)se);
  for (se = &x->RelatedPositionPostings->gg;
       se && se->g.tok == zx_hrxml_RelatedPositionPostings_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RelatedPositionPostings(c, (struct zx_hrxml_RelatedPositionPostings_s*)se);
  for (se = &x->CandidateSupplier->gg;
       se && se->g.tok == zx_hrxml_CandidateSupplier_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_CandidateSupplier(c, (struct zx_hrxml_CandidateSupplier_s*)se);
  zx_dup_strs_simple_elems(c, x->DistributionGuidelines);
  for (se = &x->CandidateProfile->gg;
       se && se->g.tok == zx_hrxml_CandidateProfile_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_CandidateProfile(c, (struct zx_hrxml_CandidateProfile_s*)se);
  for (se = &x->Resume->gg;
       se && se->g.tok == zx_hrxml_Resume_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Resume(c, (struct zx_hrxml_Resume_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Candidate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Candidate_s* zx_DEEP_CLONE_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Candidate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Candidate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);

  for (enn = 0, e = &x->CandidateRecordInfo->gg;
       e && e->g.tok == zx_hrxml_CandidateRecordInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_CandidateRecordInfo(c,(struct zx_hrxml_CandidateRecordInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->CandidateRecordInfo = (struct zx_hrxml_CandidateRecordInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RelatedPositionPostings->gg;
       e && e->g.tok == zx_hrxml_RelatedPositionPostings_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RelatedPositionPostings(c,(struct zx_hrxml_RelatedPositionPostings_s*)e,dup_strs);
  	  if (!enn)
  	      x->RelatedPositionPostings = (struct zx_hrxml_RelatedPositionPostings_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CandidateSupplier->gg;
       e && e->g.tok == zx_hrxml_CandidateSupplier_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_CandidateSupplier(c,(struct zx_hrxml_CandidateSupplier_s*)e,dup_strs);
  	  if (!enn)
  	      x->CandidateSupplier = (struct zx_hrxml_CandidateSupplier_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->DistributionGuidelines = zx_deep_clone_simple_elems(c,x->DistributionGuidelines, dup_strs);
  for (enn = 0, e = &x->CandidateProfile->gg;
       e && e->g.tok == zx_hrxml_CandidateProfile_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_CandidateProfile(c,(struct zx_hrxml_CandidateProfile_s*)e,dup_strs);
  	  if (!enn)
  	      x->CandidateProfile = (struct zx_hrxml_CandidateProfile_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Resume->gg;
       e && e->g.tok == zx_hrxml_Resume_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Resume(c,(struct zx_hrxml_Resume_s*)e,dup_strs);
  	  if (!enn)
  	      x->Resume = (struct zx_hrxml_Resume_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Candidate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CandidateRecordInfo->gg;
       e && e->g.tok == zx_hrxml_CandidateRecordInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_CandidateRecordInfo(c, (struct zx_hrxml_CandidateRecordInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RelatedPositionPostings->gg;
       e && e->g.tok == zx_hrxml_RelatedPositionPostings_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RelatedPositionPostings(c, (struct zx_hrxml_RelatedPositionPostings_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CandidateSupplier->gg;
       e && e->g.tok == zx_hrxml_CandidateSupplier_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_CandidateSupplier(c, (struct zx_hrxml_CandidateSupplier_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->DistributionGuidelines, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->CandidateProfile->gg;
       e && e->g.tok == zx_hrxml_CandidateProfile_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_CandidateProfile(c, (struct zx_hrxml_CandidateProfile_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Resume->gg;
       e && e->g.tok == zx_hrxml_Resume_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Resume(c, (struct zx_hrxml_Resume_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Candidate) */

int zx_WALK_WO_hrxml_Candidate(struct zx_ctx* c, struct zx_hrxml_Candidate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CandidateProfile
#define EL_STRUCT zx_hrxml_CandidateProfile_s
#define EL_NS     hrxml
#define EL_TAG    CandidateProfile

/* FUNC(zx_FREE_hrxml_CandidateProfile) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);

  for (e = &x->ProfileId->gg;
       e && e->g.tok == zx_hrxml_ProfileId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ProfileId(c, (struct zx_hrxml_ProfileId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->ProfileName, free_strs);
  for (e = &x->AvailabilityInfo->gg;
       e && e->g.tok == zx_hrxml_AvailabilityInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_AvailabilityInfo(c, (struct zx_hrxml_AvailabilityInfo_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->DistributionGuidelines, free_strs);
  for (e = &x->PersonalData->gg;
       e && e->g.tok == zx_hrxml_PersonalData_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonalData(c, (struct zx_hrxml_PersonalData_s*)e, free_strs);
  }
  for (e = &x->PreferredPosition->gg;
       e && e->g.tok == zx_hrxml_PreferredPosition_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PreferredPosition(c, (struct zx_hrxml_PreferredPosition_s*)e, free_strs);
  }
  for (e = &x->EmploymentHistory->gg;
       e && e->g.tok == zx_hrxml_EmploymentHistory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EmploymentHistory(c, (struct zx_hrxml_EmploymentHistory_s*)e, free_strs);
  }
  for (e = &x->EducationHistory->gg;
       e && e->g.tok == zx_hrxml_EducationHistory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EducationHistory(c, (struct zx_hrxml_EducationHistory_s*)e, free_strs);
  }
  for (e = &x->MilitaryHistory->gg;
       e && e->g.tok == zx_hrxml_MilitaryHistory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_MilitaryHistory(c, (struct zx_hrxml_MilitaryHistory_s*)e, free_strs);
  }
  for (e = &x->Associations->gg;
       e && e->g.tok == zx_hrxml_Associations_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Associations(c, (struct zx_hrxml_Associations_s*)e, free_strs);
  }
  for (e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_CandidateProfile) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_CandidateProfile_s* zx_NEW_hrxml_CandidateProfile(struct zx_ctx* c)
{
  struct zx_hrxml_CandidateProfile_s* x = ZX_ZALLOC(c, struct zx_hrxml_CandidateProfile_s);
  x->gg.g.tok = zx_hrxml_CandidateProfile_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_CandidateProfile) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);

  for (se = &x->ProfileId->gg;
       se && se->g.tok == zx_hrxml_ProfileId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ProfileId(c, (struct zx_hrxml_ProfileId_s*)se);
  zx_dup_strs_simple_elems(c, x->ProfileName);
  for (se = &x->AvailabilityInfo->gg;
       se && se->g.tok == zx_hrxml_AvailabilityInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_AvailabilityInfo(c, (struct zx_hrxml_AvailabilityInfo_s*)se);
  zx_dup_strs_simple_elems(c, x->DistributionGuidelines);
  for (se = &x->PersonalData->gg;
       se && se->g.tok == zx_hrxml_PersonalData_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonalData(c, (struct zx_hrxml_PersonalData_s*)se);
  for (se = &x->PreferredPosition->gg;
       se && se->g.tok == zx_hrxml_PreferredPosition_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PreferredPosition(c, (struct zx_hrxml_PreferredPosition_s*)se);
  for (se = &x->EmploymentHistory->gg;
       se && se->g.tok == zx_hrxml_EmploymentHistory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EmploymentHistory(c, (struct zx_hrxml_EmploymentHistory_s*)se);
  for (se = &x->EducationHistory->gg;
       se && se->g.tok == zx_hrxml_EducationHistory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EducationHistory(c, (struct zx_hrxml_EducationHistory_s*)se);
  for (se = &x->MilitaryHistory->gg;
       se && se->g.tok == zx_hrxml_MilitaryHistory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_MilitaryHistory(c, (struct zx_hrxml_MilitaryHistory_s*)se);
  for (se = &x->Associations->gg;
       se && se->g.tok == zx_hrxml_Associations_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Associations(c, (struct zx_hrxml_Associations_s*)se);
  for (se = &x->SupportingMaterials->gg;
       se && se->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_CandidateProfile) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_CandidateProfile_s* zx_DEEP_CLONE_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_CandidateProfile_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_CandidateProfile_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);

  for (enn = 0, e = &x->ProfileId->gg;
       e && e->g.tok == zx_hrxml_ProfileId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ProfileId(c,(struct zx_hrxml_ProfileId_s*)e,dup_strs);
  	  if (!enn)
  	      x->ProfileId = (struct zx_hrxml_ProfileId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->ProfileName = zx_deep_clone_simple_elems(c,x->ProfileName, dup_strs);
  for (enn = 0, e = &x->AvailabilityInfo->gg;
       e && e->g.tok == zx_hrxml_AvailabilityInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_AvailabilityInfo(c,(struct zx_hrxml_AvailabilityInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->AvailabilityInfo = (struct zx_hrxml_AvailabilityInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->DistributionGuidelines = zx_deep_clone_simple_elems(c,x->DistributionGuidelines, dup_strs);
  for (enn = 0, e = &x->PersonalData->gg;
       e && e->g.tok == zx_hrxml_PersonalData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonalData(c,(struct zx_hrxml_PersonalData_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonalData = (struct zx_hrxml_PersonalData_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PreferredPosition->gg;
       e && e->g.tok == zx_hrxml_PreferredPosition_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PreferredPosition(c,(struct zx_hrxml_PreferredPosition_s*)e,dup_strs);
  	  if (!enn)
  	      x->PreferredPosition = (struct zx_hrxml_PreferredPosition_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EmploymentHistory->gg;
       e && e->g.tok == zx_hrxml_EmploymentHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EmploymentHistory(c,(struct zx_hrxml_EmploymentHistory_s*)e,dup_strs);
  	  if (!enn)
  	      x->EmploymentHistory = (struct zx_hrxml_EmploymentHistory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EducationHistory->gg;
       e && e->g.tok == zx_hrxml_EducationHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EducationHistory(c,(struct zx_hrxml_EducationHistory_s*)e,dup_strs);
  	  if (!enn)
  	      x->EducationHistory = (struct zx_hrxml_EducationHistory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->MilitaryHistory->gg;
       e && e->g.tok == zx_hrxml_MilitaryHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_MilitaryHistory(c,(struct zx_hrxml_MilitaryHistory_s*)e,dup_strs);
  	  if (!enn)
  	      x->MilitaryHistory = (struct zx_hrxml_MilitaryHistory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Associations->gg;
       e && e->g.tok == zx_hrxml_Associations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Associations(c,(struct zx_hrxml_Associations_s*)e,dup_strs);
  	  if (!enn)
  	      x->Associations = (struct zx_hrxml_Associations_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SupportingMaterials(c,(struct zx_hrxml_SupportingMaterials_s*)e,dup_strs);
  	  if (!enn)
  	      x->SupportingMaterials = (struct zx_hrxml_SupportingMaterials_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_CandidateProfile) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ProfileId->gg;
       e && e->g.tok == zx_hrxml_ProfileId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ProfileId(c, (struct zx_hrxml_ProfileId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->ProfileName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->AvailabilityInfo->gg;
       e && e->g.tok == zx_hrxml_AvailabilityInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_AvailabilityInfo(c, (struct zx_hrxml_AvailabilityInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->DistributionGuidelines, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PersonalData->gg;
       e && e->g.tok == zx_hrxml_PersonalData_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonalData(c, (struct zx_hrxml_PersonalData_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PreferredPosition->gg;
       e && e->g.tok == zx_hrxml_PreferredPosition_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PreferredPosition(c, (struct zx_hrxml_PreferredPosition_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EmploymentHistory->gg;
       e && e->g.tok == zx_hrxml_EmploymentHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EmploymentHistory(c, (struct zx_hrxml_EmploymentHistory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EducationHistory->gg;
       e && e->g.tok == zx_hrxml_EducationHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EducationHistory(c, (struct zx_hrxml_EducationHistory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->MilitaryHistory->gg;
       e && e->g.tok == zx_hrxml_MilitaryHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_MilitaryHistory(c, (struct zx_hrxml_MilitaryHistory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Associations->gg;
       e && e->g.tok == zx_hrxml_Associations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Associations(c, (struct zx_hrxml_Associations_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_CandidateProfile) */

int zx_WALK_WO_hrxml_CandidateProfile(struct zx_ctx* c, struct zx_hrxml_CandidateProfile_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CandidateRecordInfo
#define EL_STRUCT zx_hrxml_CandidateRecordInfo_s
#define EL_NS     hrxml
#define EL_TAG    CandidateRecordInfo

/* FUNC(zx_FREE_hrxml_CandidateRecordInfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  for (e = &x->Status->gg;
       e && e->g.tok == zx_hrxml_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Status(c, (struct zx_hrxml_Status_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_CandidateRecordInfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_CandidateRecordInfo_s* zx_NEW_hrxml_CandidateRecordInfo(struct zx_ctx* c)
{
  struct zx_hrxml_CandidateRecordInfo_s* x = ZX_ZALLOC(c, struct zx_hrxml_CandidateRecordInfo_s);
  x->gg.g.tok = zx_hrxml_CandidateRecordInfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_CandidateRecordInfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->Status->gg;
       se && se->g.tok == zx_hrxml_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Status(c, (struct zx_hrxml_Status_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_CandidateRecordInfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_CandidateRecordInfo_s* zx_DEEP_CLONE_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_CandidateRecordInfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_CandidateRecordInfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_hrxml_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Status(c,(struct zx_hrxml_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_hrxml_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_CandidateRecordInfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Status->gg;
       e && e->g.tok == zx_hrxml_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Status(c, (struct zx_hrxml_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_CandidateRecordInfo) */

int zx_WALK_WO_hrxml_CandidateRecordInfo(struct zx_ctx* c, struct zx_hrxml_CandidateRecordInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CandidateSupplier
#define EL_STRUCT zx_hrxml_CandidateSupplier_s
#define EL_NS     hrxml
#define EL_TAG    CandidateSupplier

/* FUNC(zx_FREE_hrxml_CandidateSupplier) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->relationship, free_strs);

  for (e = &x->SupplierId->gg;
       e && e->g.tok == zx_hrxml_SupplierId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SupplierId(c, (struct zx_hrxml_SupplierId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->EntityName, free_strs);
  for (e = &x->ContactName->gg;
       e && e->g.tok == zx_hrxml_ContactName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactName(c, (struct zx_hrxml_ContactName_s*)e, free_strs);
  }
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, free_strs);
  }
  for (e = &x->SourceType->gg;
       e && e->g.tok == zx_hrxml_SourceType_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SourceType(c, (struct zx_hrxml_SourceType_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_CandidateSupplier) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_CandidateSupplier_s* zx_NEW_hrxml_CandidateSupplier(struct zx_ctx* c)
{
  struct zx_hrxml_CandidateSupplier_s* x = ZX_ZALLOC(c, struct zx_hrxml_CandidateSupplier_s);
  x->gg.g.tok = zx_hrxml_CandidateSupplier_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_CandidateSupplier) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->relationship);

  for (se = &x->SupplierId->gg;
       se && se->g.tok == zx_hrxml_SupplierId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SupplierId(c, (struct zx_hrxml_SupplierId_s*)se);
  zx_dup_strs_simple_elems(c, x->EntityName);
  for (se = &x->ContactName->gg;
       se && se->g.tok == zx_hrxml_ContactName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactName(c, (struct zx_hrxml_ContactName_s*)se);
  for (se = &x->ContactMethod->gg;
       se && se->g.tok == zx_hrxml_ContactMethod_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);
  for (se = &x->SourceType->gg;
       se && se->g.tok == zx_hrxml_SourceType_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SourceType(c, (struct zx_hrxml_SourceType_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_CandidateSupplier) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_CandidateSupplier_s* zx_DEEP_CLONE_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_CandidateSupplier_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_CandidateSupplier_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->relationship = zx_clone_attr(c, x->relationship);

  for (enn = 0, e = &x->SupplierId->gg;
       e && e->g.tok == zx_hrxml_SupplierId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SupplierId(c,(struct zx_hrxml_SupplierId_s*)e,dup_strs);
  	  if (!enn)
  	      x->SupplierId = (struct zx_hrxml_SupplierId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->EntityName = zx_deep_clone_simple_elems(c,x->EntityName, dup_strs);
  for (enn = 0, e = &x->ContactName->gg;
       e && e->g.tok == zx_hrxml_ContactName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactName(c,(struct zx_hrxml_ContactName_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactName = (struct zx_hrxml_ContactName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactMethod(c,(struct zx_hrxml_ContactMethod_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactMethod = (struct zx_hrxml_ContactMethod_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SourceType->gg;
       e && e->g.tok == zx_hrxml_SourceType_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SourceType(c,(struct zx_hrxml_SourceType_s*)e,dup_strs);
  	  if (!enn)
  	      x->SourceType = (struct zx_hrxml_SourceType_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_CandidateSupplier) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->SupplierId->gg;
       e && e->g.tok == zx_hrxml_SupplierId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SupplierId(c, (struct zx_hrxml_SupplierId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->EntityName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->ContactName->gg;
       e && e->g.tok == zx_hrxml_ContactName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactName(c, (struct zx_hrxml_ContactName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SourceType->gg;
       e && e->g.tok == zx_hrxml_SourceType_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SourceType(c, (struct zx_hrxml_SourceType_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_CandidateSupplier) */

int zx_WALK_WO_hrxml_CandidateSupplier(struct zx_ctx* c, struct zx_hrxml_CandidateSupplier_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ChildrenInfo
#define EL_STRUCT zx_hrxml_ChildrenInfo_s
#define EL_NS     hrxml
#define EL_TAG    ChildrenInfo

/* FUNC(zx_FREE_hrxml_ChildrenInfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->NumberOfChildren, free_strs);
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ChildrenInfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ChildrenInfo_s* zx_NEW_hrxml_ChildrenInfo(struct zx_ctx* c)
{
  struct zx_hrxml_ChildrenInfo_s* x = ZX_ZALLOC(c, struct zx_hrxml_ChildrenInfo_s);
  x->gg.g.tok = zx_hrxml_ChildrenInfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ChildrenInfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->NumberOfChildren);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ChildrenInfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ChildrenInfo_s* zx_DEEP_CLONE_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ChildrenInfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ChildrenInfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->NumberOfChildren = zx_deep_clone_simple_elems(c,x->NumberOfChildren, dup_strs);
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ChildrenInfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->NumberOfChildren, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ChildrenInfo) */

int zx_WALK_WO_hrxml_ChildrenInfo(struct zx_ctx* c, struct zx_hrxml_ChildrenInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ClassRank
#define EL_STRUCT zx_hrxml_ClassRank_s
#define EL_NS     hrxml
#define EL_TAG    ClassRank

/* FUNC(zx_FREE_hrxml_ClassRank) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->numberOfStudents, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ClassRank) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ClassRank_s* zx_NEW_hrxml_ClassRank(struct zx_ctx* c)
{
  struct zx_hrxml_ClassRank_s* x = ZX_ZALLOC(c, struct zx_hrxml_ClassRank_s);
  x->gg.g.tok = zx_hrxml_ClassRank_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ClassRank) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->numberOfStudents);


}

/* FUNC(zx_DEEP_CLONE_hrxml_ClassRank) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ClassRank_s* zx_DEEP_CLONE_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ClassRank_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ClassRank_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->numberOfStudents = zx_clone_attr(c, x->numberOfStudents);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ClassRank) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ClassRank) */

int zx_WALK_WO_hrxml_ClassRank(struct zx_ctx* c, struct zx_hrxml_ClassRank_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Commute
#define EL_STRUCT zx_hrxml_Commute_s
#define EL_NS     hrxml
#define EL_TAG    Commute

/* FUNC(zx_FREE_hrxml_Commute) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->TimeMax->gg;
       e && e->g.tok == zx_hrxml_TimeMax_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_TimeMax(c, (struct zx_hrxml_TimeMax_s*)e, free_strs);
  }
  for (e = &x->DistanceMax->gg;
       e && e->g.tok == zx_hrxml_DistanceMax_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DistanceMax(c, (struct zx_hrxml_DistanceMax_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Commute) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Commute_s* zx_NEW_hrxml_Commute(struct zx_ctx* c)
{
  struct zx_hrxml_Commute_s* x = ZX_ZALLOC(c, struct zx_hrxml_Commute_s);
  x->gg.g.tok = zx_hrxml_Commute_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Commute) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->TimeMax->gg;
       se && se->g.tok == zx_hrxml_TimeMax_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_TimeMax(c, (struct zx_hrxml_TimeMax_s*)se);
  for (se = &x->DistanceMax->gg;
       se && se->g.tok == zx_hrxml_DistanceMax_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DistanceMax(c, (struct zx_hrxml_DistanceMax_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Commute) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Commute_s* zx_DEEP_CLONE_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Commute_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Commute_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->TimeMax->gg;
       e && e->g.tok == zx_hrxml_TimeMax_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_TimeMax(c,(struct zx_hrxml_TimeMax_s*)e,dup_strs);
  	  if (!enn)
  	      x->TimeMax = (struct zx_hrxml_TimeMax_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DistanceMax->gg;
       e && e->g.tok == zx_hrxml_DistanceMax_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DistanceMax(c,(struct zx_hrxml_DistanceMax_s*)e,dup_strs);
  	  if (!enn)
  	      x->DistanceMax = (struct zx_hrxml_DistanceMax_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Commute) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->TimeMax->gg;
       e && e->g.tok == zx_hrxml_TimeMax_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_TimeMax(c, (struct zx_hrxml_TimeMax_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DistanceMax->gg;
       e && e->g.tok == zx_hrxml_DistanceMax_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DistanceMax(c, (struct zx_hrxml_DistanceMax_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Commute) */

int zx_WALK_WO_hrxml_Commute(struct zx_ctx* c, struct zx_hrxml_Commute_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Company
#define EL_STRUCT zx_hrxml_Company_s
#define EL_NS     hrxml
#define EL_TAG    Company

/* FUNC(zx_FREE_hrxml_Company) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Name, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Company) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Company_s* zx_NEW_hrxml_Company(struct zx_ctx* c)
{
  struct zx_hrxml_Company_s* x = ZX_ZALLOC(c, struct zx_hrxml_Company_s);
  x->gg.g.tok = zx_hrxml_Company_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Company) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  zx_dup_strs_simple_elems(c, x->Name);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Company) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Company_s* zx_DEEP_CLONE_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Company_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Company_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Company) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Company) */

int zx_WALK_WO_hrxml_Company(struct zx_ctx* c, struct zx_hrxml_Company_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompanyVehicle
#define EL_STRUCT zx_hrxml_CompanyVehicle_s
#define EL_NS     hrxml
#define EL_TAG    CompanyVehicle

/* FUNC(zx_FREE_hrxml_CompanyVehicle) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->companyOffered, free_strs);

  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_CompanyVehicle) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_CompanyVehicle_s* zx_NEW_hrxml_CompanyVehicle(struct zx_ctx* c)
{
  struct zx_hrxml_CompanyVehicle_s* x = ZX_ZALLOC(c, struct zx_hrxml_CompanyVehicle_s);
  x->gg.g.tok = zx_hrxml_CompanyVehicle_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_CompanyVehicle) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->companyOffered);

  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_CompanyVehicle) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_CompanyVehicle_s* zx_DEEP_CLONE_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_CompanyVehicle_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_CompanyVehicle_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->companyOffered = zx_clone_attr(c, x->companyOffered);

  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_CompanyVehicle) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_CompanyVehicle) */

int zx_WALK_WO_hrxml_CompanyVehicle(struct zx_ctx* c, struct zx_hrxml_CompanyVehicle_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Compensation
#define EL_STRUCT zx_hrxml_Compensation_s
#define EL_NS     hrxml
#define EL_TAG    Compensation

/* FUNC(zx_FREE_hrxml_Compensation) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->StartingCompensation->gg;
       e && e->g.tok == zx_hrxml_StartingCompensation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StartingCompensation(c, (struct zx_hrxml_StartingCompensation_s*)e, free_strs);
  }
  for (e = &x->EndingCompensation->gg;
       e && e->g.tok == zx_hrxml_EndingCompensation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EndingCompensation(c, (struct zx_hrxml_EndingCompensation_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);
  for (e = &x->OtherCompensation->gg;
       e && e->g.tok == zx_hrxml_OtherCompensation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OtherCompensation(c, (struct zx_hrxml_OtherCompensation_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Compensation) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Compensation_s* zx_NEW_hrxml_Compensation(struct zx_ctx* c)
{
  struct zx_hrxml_Compensation_s* x = ZX_ZALLOC(c, struct zx_hrxml_Compensation_s);
  x->gg.g.tok = zx_hrxml_Compensation_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Compensation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->StartingCompensation->gg;
       se && se->g.tok == zx_hrxml_StartingCompensation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StartingCompensation(c, (struct zx_hrxml_StartingCompensation_s*)se);
  for (se = &x->EndingCompensation->gg;
       se && se->g.tok == zx_hrxml_EndingCompensation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EndingCompensation(c, (struct zx_hrxml_EndingCompensation_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);
  for (se = &x->OtherCompensation->gg;
       se && se->g.tok == zx_hrxml_OtherCompensation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OtherCompensation(c, (struct zx_hrxml_OtherCompensation_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Compensation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Compensation_s* zx_DEEP_CLONE_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Compensation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Compensation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->StartingCompensation->gg;
       e && e->g.tok == zx_hrxml_StartingCompensation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StartingCompensation(c,(struct zx_hrxml_StartingCompensation_s*)e,dup_strs);
  	  if (!enn)
  	      x->StartingCompensation = (struct zx_hrxml_StartingCompensation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EndingCompensation->gg;
       e && e->g.tok == zx_hrxml_EndingCompensation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EndingCompensation(c,(struct zx_hrxml_EndingCompensation_s*)e,dup_strs);
  	  if (!enn)
  	      x->EndingCompensation = (struct zx_hrxml_EndingCompensation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  for (enn = 0, e = &x->OtherCompensation->gg;
       e && e->g.tok == zx_hrxml_OtherCompensation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OtherCompensation(c,(struct zx_hrxml_OtherCompensation_s*)e,dup_strs);
  	  if (!enn)
  	      x->OtherCompensation = (struct zx_hrxml_OtherCompensation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Compensation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->StartingCompensation->gg;
       e && e->g.tok == zx_hrxml_StartingCompensation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StartingCompensation(c, (struct zx_hrxml_StartingCompensation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EndingCompensation->gg;
       e && e->g.tok == zx_hrxml_EndingCompensation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EndingCompensation(c, (struct zx_hrxml_EndingCompensation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->OtherCompensation->gg;
       e && e->g.tok == zx_hrxml_OtherCompensation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OtherCompensation(c, (struct zx_hrxml_OtherCompensation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Compensation) */

int zx_WALK_WO_hrxml_Compensation(struct zx_ctx* c, struct zx_hrxml_Compensation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Competency
#define EL_STRUCT zx_hrxml_Competency_s
#define EL_NS     hrxml
#define EL_TAG    Competency

/* FUNC(zx_FREE_hrxml_Competency) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->description, free_strs);
  zx_free_attr(c, x->name, free_strs);
  zx_free_attr(c, x->required, free_strs);

  for (e = &x->CompetencyId->gg;
       e && e->g.tok == zx_hrxml_CompetencyId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_CompetencyId(c, (struct zx_hrxml_CompetencyId_s*)e, free_strs);
  }
  for (e = &x->TaxonomyId->gg;
       e && e->g.tok == zx_hrxml_TaxonomyId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_TaxonomyId(c, (struct zx_hrxml_TaxonomyId_s*)e, free_strs);
  }
  for (e = &x->CompetencyEvidence->gg;
       e && e->g.tok == zx_hrxml_CompetencyEvidence_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_CompetencyEvidence(c, (struct zx_hrxml_CompetencyEvidence_s*)e, free_strs);
  }
  for (e = &x->CompetencyWeight->gg;
       e && e->g.tok == zx_hrxml_CompetencyWeight_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_CompetencyWeight(c, (struct zx_hrxml_CompetencyWeight_s*)e, free_strs);
  }
  for (e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Competency) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Competency_s* zx_NEW_hrxml_Competency(struct zx_ctx* c)
{
  struct zx_hrxml_Competency_s* x = ZX_ZALLOC(c, struct zx_hrxml_Competency_s);
  x->gg.g.tok = zx_hrxml_Competency_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Competency) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->description);
  zx_dup_attr(c, x->name);
  zx_dup_attr(c, x->required);

  for (se = &x->CompetencyId->gg;
       se && se->g.tok == zx_hrxml_CompetencyId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_CompetencyId(c, (struct zx_hrxml_CompetencyId_s*)se);
  for (se = &x->TaxonomyId->gg;
       se && se->g.tok == zx_hrxml_TaxonomyId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_TaxonomyId(c, (struct zx_hrxml_TaxonomyId_s*)se);
  for (se = &x->CompetencyEvidence->gg;
       se && se->g.tok == zx_hrxml_CompetencyEvidence_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_CompetencyEvidence(c, (struct zx_hrxml_CompetencyEvidence_s*)se);
  for (se = &x->CompetencyWeight->gg;
       se && se->g.tok == zx_hrxml_CompetencyWeight_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_CompetencyWeight(c, (struct zx_hrxml_CompetencyWeight_s*)se);
  for (se = &x->Competency->gg;
       se && se->g.tok == zx_hrxml_Competency_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Competency) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Competency_s* zx_DEEP_CLONE_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Competency_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Competency_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->description = zx_clone_attr(c, x->description);
  x->name = zx_clone_attr(c, x->name);
  x->required = zx_clone_attr(c, x->required);

  for (enn = 0, e = &x->CompetencyId->gg;
       e && e->g.tok == zx_hrxml_CompetencyId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_CompetencyId(c,(struct zx_hrxml_CompetencyId_s*)e,dup_strs);
  	  if (!enn)
  	      x->CompetencyId = (struct zx_hrxml_CompetencyId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->TaxonomyId->gg;
       e && e->g.tok == zx_hrxml_TaxonomyId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_TaxonomyId(c,(struct zx_hrxml_TaxonomyId_s*)e,dup_strs);
  	  if (!enn)
  	      x->TaxonomyId = (struct zx_hrxml_TaxonomyId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CompetencyEvidence->gg;
       e && e->g.tok == zx_hrxml_CompetencyEvidence_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_CompetencyEvidence(c,(struct zx_hrxml_CompetencyEvidence_s*)e,dup_strs);
  	  if (!enn)
  	      x->CompetencyEvidence = (struct zx_hrxml_CompetencyEvidence_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->CompetencyWeight->gg;
       e && e->g.tok == zx_hrxml_CompetencyWeight_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_CompetencyWeight(c,(struct zx_hrxml_CompetencyWeight_s*)e,dup_strs);
  	  if (!enn)
  	      x->CompetencyWeight = (struct zx_hrxml_CompetencyWeight_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Competency(c,(struct zx_hrxml_Competency_s*)e,dup_strs);
  	  if (!enn)
  	      x->Competency = (struct zx_hrxml_Competency_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Competency) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CompetencyId->gg;
       e && e->g.tok == zx_hrxml_CompetencyId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_CompetencyId(c, (struct zx_hrxml_CompetencyId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->TaxonomyId->gg;
       e && e->g.tok == zx_hrxml_TaxonomyId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_TaxonomyId(c, (struct zx_hrxml_TaxonomyId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CompetencyEvidence->gg;
       e && e->g.tok == zx_hrxml_CompetencyEvidence_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_CompetencyEvidence(c, (struct zx_hrxml_CompetencyEvidence_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->CompetencyWeight->gg;
       e && e->g.tok == zx_hrxml_CompetencyWeight_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_CompetencyWeight(c, (struct zx_hrxml_CompetencyWeight_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Competency) */

int zx_WALK_WO_hrxml_Competency(struct zx_ctx* c, struct zx_hrxml_Competency_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompetencyEvidence
#define EL_STRUCT zx_hrxml_CompetencyEvidence_s
#define EL_NS     hrxml
#define EL_TAG    CompetencyEvidence

/* FUNC(zx_FREE_hrxml_CompetencyEvidence) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateOfIncident, free_strs);
  zx_free_attr(c, x->expirationDate, free_strs);
  zx_free_attr(c, x->lastUsed, free_strs);
  zx_free_attr(c, x->name, free_strs);
  zx_free_attr(c, x->required, free_strs);
  zx_free_attr(c, x->typeDescription, free_strs);
  zx_free_attr(c, x->typeId, free_strs);

  for (e = &x->EvidenceId->gg;
       e && e->g.tok == zx_hrxml_EvidenceId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EvidenceId(c, (struct zx_hrxml_EvidenceId_s*)e, free_strs);
  }
  for (e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)e, free_strs);
  }
  for (e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->SupportingInformation, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_CompetencyEvidence) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_CompetencyEvidence_s* zx_NEW_hrxml_CompetencyEvidence(struct zx_ctx* c)
{
  struct zx_hrxml_CompetencyEvidence_s* x = ZX_ZALLOC(c, struct zx_hrxml_CompetencyEvidence_s);
  x->gg.g.tok = zx_hrxml_CompetencyEvidence_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_CompetencyEvidence) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateOfIncident);
  zx_dup_attr(c, x->expirationDate);
  zx_dup_attr(c, x->lastUsed);
  zx_dup_attr(c, x->name);
  zx_dup_attr(c, x->required);
  zx_dup_attr(c, x->typeDescription);
  zx_dup_attr(c, x->typeId);

  for (se = &x->EvidenceId->gg;
       se && se->g.tok == zx_hrxml_EvidenceId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EvidenceId(c, (struct zx_hrxml_EvidenceId_s*)se);
  for (se = &x->NumericValue->gg;
       se && se->g.tok == zx_hrxml_NumericValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se);
  for (se = &x->StringValue->gg;
       se && se->g.tok == zx_hrxml_StringValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se);
  zx_dup_strs_simple_elems(c, x->SupportingInformation);

}

/* FUNC(zx_DEEP_CLONE_hrxml_CompetencyEvidence) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_CompetencyEvidence_s* zx_DEEP_CLONE_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_CompetencyEvidence_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_CompetencyEvidence_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateOfIncident = zx_clone_attr(c, x->dateOfIncident);
  x->expirationDate = zx_clone_attr(c, x->expirationDate);
  x->lastUsed = zx_clone_attr(c, x->lastUsed);
  x->name = zx_clone_attr(c, x->name);
  x->required = zx_clone_attr(c, x->required);
  x->typeDescription = zx_clone_attr(c, x->typeDescription);
  x->typeId = zx_clone_attr(c, x->typeId);

  for (enn = 0, e = &x->EvidenceId->gg;
       e && e->g.tok == zx_hrxml_EvidenceId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EvidenceId(c,(struct zx_hrxml_EvidenceId_s*)e,dup_strs);
  	  if (!enn)
  	      x->EvidenceId = (struct zx_hrxml_EvidenceId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_NumericValue(c,(struct zx_hrxml_NumericValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->NumericValue = (struct zx_hrxml_NumericValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StringValue(c,(struct zx_hrxml_StringValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->StringValue = (struct zx_hrxml_StringValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->SupportingInformation = zx_deep_clone_simple_elems(c,x->SupportingInformation, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_CompetencyEvidence) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->EvidenceId->gg;
       e && e->g.tok == zx_hrxml_EvidenceId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EvidenceId(c, (struct zx_hrxml_EvidenceId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->SupportingInformation, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_CompetencyEvidence) */

int zx_WALK_WO_hrxml_CompetencyEvidence(struct zx_ctx* c, struct zx_hrxml_CompetencyEvidence_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompetencyId
#define EL_STRUCT zx_hrxml_CompetencyId_s
#define EL_NS     hrxml
#define EL_TAG    CompetencyId

/* FUNC(zx_FREE_hrxml_CompetencyId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_CompetencyId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_CompetencyId_s* zx_NEW_hrxml_CompetencyId(struct zx_ctx* c)
{
  struct zx_hrxml_CompetencyId_s* x = ZX_ZALLOC(c, struct zx_hrxml_CompetencyId_s);
  x->gg.g.tok = zx_hrxml_CompetencyId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_CompetencyId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_CompetencyId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_CompetencyId_s* zx_DEEP_CLONE_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_CompetencyId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_CompetencyId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_CompetencyId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_CompetencyId) */

int zx_WALK_WO_hrxml_CompetencyId(struct zx_ctx* c, struct zx_hrxml_CompetencyId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CompetencyWeight
#define EL_STRUCT zx_hrxml_CompetencyWeight_s
#define EL_NS     hrxml
#define EL_TAG    CompetencyWeight

/* FUNC(zx_FREE_hrxml_CompetencyWeight) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);

  for (e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)e, free_strs);
  }
  for (e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->SupportingInformation, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_CompetencyWeight) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_CompetencyWeight_s* zx_NEW_hrxml_CompetencyWeight(struct zx_ctx* c)
{
  struct zx_hrxml_CompetencyWeight_s* x = ZX_ZALLOC(c, struct zx_hrxml_CompetencyWeight_s);
  x->gg.g.tok = zx_hrxml_CompetencyWeight_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_CompetencyWeight) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);

  for (se = &x->NumericValue->gg;
       se && se->g.tok == zx_hrxml_NumericValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se);
  for (se = &x->StringValue->gg;
       se && se->g.tok == zx_hrxml_StringValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se);
  zx_dup_strs_simple_elems(c, x->SupportingInformation);

}

/* FUNC(zx_DEEP_CLONE_hrxml_CompetencyWeight) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_CompetencyWeight_s* zx_DEEP_CLONE_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_CompetencyWeight_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_CompetencyWeight_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);

  for (enn = 0, e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_NumericValue(c,(struct zx_hrxml_NumericValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->NumericValue = (struct zx_hrxml_NumericValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StringValue(c,(struct zx_hrxml_StringValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->StringValue = (struct zx_hrxml_StringValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->SupportingInformation = zx_deep_clone_simple_elems(c,x->SupportingInformation, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_CompetencyWeight) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->SupportingInformation, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_CompetencyWeight) */

int zx_WALK_WO_hrxml_CompetencyWeight(struct zx_ctx* c, struct zx_hrxml_CompetencyWeight_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ConferenceDate
#define EL_STRUCT zx_hrxml_ConferenceDate_s
#define EL_NS     hrxml
#define EL_TAG    ConferenceDate

/* FUNC(zx_FREE_hrxml_ConferenceDate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateDescription, free_strs);

  zx_free_simple_elems(c, x->AnyDate, free_strs);
  zx_free_simple_elems(c, x->YearMonth, free_strs);
  zx_free_simple_elems(c, x->Year, free_strs);
  zx_free_simple_elems(c, x->MonthDay, free_strs);
  zx_free_simple_elems(c, x->StringDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ConferenceDate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ConferenceDate_s* zx_NEW_hrxml_ConferenceDate(struct zx_ctx* c)
{
  struct zx_hrxml_ConferenceDate_s* x = ZX_ZALLOC(c, struct zx_hrxml_ConferenceDate_s);
  x->gg.g.tok = zx_hrxml_ConferenceDate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ConferenceDate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateDescription);

  zx_dup_strs_simple_elems(c, x->AnyDate);
  zx_dup_strs_simple_elems(c, x->YearMonth);
  zx_dup_strs_simple_elems(c, x->Year);
  zx_dup_strs_simple_elems(c, x->MonthDay);
  zx_dup_strs_simple_elems(c, x->StringDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ConferenceDate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ConferenceDate_s* zx_DEEP_CLONE_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ConferenceDate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ConferenceDate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateDescription = zx_clone_attr(c, x->dateDescription);

  x->AnyDate = zx_deep_clone_simple_elems(c,x->AnyDate, dup_strs);
  x->YearMonth = zx_deep_clone_simple_elems(c,x->YearMonth, dup_strs);
  x->Year = zx_deep_clone_simple_elems(c,x->Year, dup_strs);
  x->MonthDay = zx_deep_clone_simple_elems(c,x->MonthDay, dup_strs);
  x->StringDate = zx_deep_clone_simple_elems(c,x->StringDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ConferenceDate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AnyDate, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->YearMonth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Year, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDay, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StringDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ConferenceDate) */

int zx_WALK_WO_hrxml_ConferenceDate(struct zx_ctx* c, struct zx_hrxml_ConferenceDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ConferencePaper
#define EL_STRUCT zx_hrxml_ConferencePaper_s
#define EL_NS     hrxml
#define EL_TAG    ConferencePaper

/* FUNC(zx_FREE_hrxml_ConferencePaper) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Title, free_strs);
  zx_free_simple_elems(c, x->Name, free_strs);
  for (e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Link, free_strs);
  zx_free_simple_elems(c, x->Abstract, free_strs);
  for (e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);
  zx_free_simple_elems(c, x->EventName, free_strs);
  for (e = &x->ConferenceDate->gg;
       e && e->g.tok == zx_hrxml_ConferenceDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ConferenceDate(c, (struct zx_hrxml_ConferenceDate_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->ConferenceLocation, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ConferencePaper) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ConferencePaper_s* zx_NEW_hrxml_ConferencePaper(struct zx_ctx* c)
{
  struct zx_hrxml_ConferencePaper_s* x = ZX_ZALLOC(c, struct zx_hrxml_ConferencePaper_s);
  x->gg.g.tok = zx_hrxml_ConferencePaper_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ConferencePaper) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Title);
  zx_dup_strs_simple_elems(c, x->Name);
  for (se = &x->PublicationDate->gg;
       se && se->g.tok == zx_hrxml_PublicationDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se);
  zx_dup_strs_simple_elems(c, x->Link);
  zx_dup_strs_simple_elems(c, x->Abstract);
  for (se = &x->Copyright->gg;
       se && se->g.tok == zx_hrxml_Copyright_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);
  zx_dup_strs_simple_elems(c, x->EventName);
  for (se = &x->ConferenceDate->gg;
       se && se->g.tok == zx_hrxml_ConferenceDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ConferenceDate(c, (struct zx_hrxml_ConferenceDate_s*)se);
  zx_dup_strs_simple_elems(c, x->ConferenceLocation);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ConferencePaper) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ConferencePaper_s* zx_DEEP_CLONE_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ConferencePaper_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ConferencePaper_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Title = zx_deep_clone_simple_elems(c,x->Title, dup_strs);
  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  for (enn = 0, e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PublicationDate(c,(struct zx_hrxml_PublicationDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->PublicationDate = (struct zx_hrxml_PublicationDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Link = zx_deep_clone_simple_elems(c,x->Link, dup_strs);
  x->Abstract = zx_deep_clone_simple_elems(c,x->Abstract, dup_strs);
  for (enn = 0, e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Copyright(c,(struct zx_hrxml_Copyright_s*)e,dup_strs);
  	  if (!enn)
  	      x->Copyright = (struct zx_hrxml_Copyright_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  x->EventName = zx_deep_clone_simple_elems(c,x->EventName, dup_strs);
  for (enn = 0, e = &x->ConferenceDate->gg;
       e && e->g.tok == zx_hrxml_ConferenceDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ConferenceDate(c,(struct zx_hrxml_ConferenceDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->ConferenceDate = (struct zx_hrxml_ConferenceDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->ConferenceLocation = zx_deep_clone_simple_elems(c,x->ConferenceLocation, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ConferencePaper) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Title, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Link, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Abstract, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->EventName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->ConferenceDate->gg;
       e && e->g.tok == zx_hrxml_ConferenceDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ConferenceDate(c, (struct zx_hrxml_ConferenceDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->ConferenceLocation, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ConferencePaper) */

int zx_WALK_WO_hrxml_ConferencePaper(struct zx_ctx* c, struct zx_hrxml_ConferencePaper_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Considerations
#define EL_STRUCT zx_hrxml_Considerations_s
#define EL_NS     hrxml
#define EL_TAG    Considerations

/* FUNC(zx_FREE_hrxml_Considerations) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);

  zx_free_simple_elems(c, x->General, free_strs);
  zx_free_simple_elems(c, x->Physical, free_strs);
  for (e = &x->SafetyEquipment->gg;
       e && e->g.tok == zx_hrxml_SafetyEquipment_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SafetyEquipment(c, (struct zx_hrxml_SafetyEquipment_s*)e, free_strs);
  }
  for (e = &x->DressCode->gg;
       e && e->g.tok == zx_hrxml_DressCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Considerations) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Considerations_s* zx_NEW_hrxml_Considerations(struct zx_ctx* c)
{
  struct zx_hrxml_Considerations_s* x = ZX_ZALLOC(c, struct zx_hrxml_Considerations_s);
  x->gg.g.tok = zx_hrxml_Considerations_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Considerations) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);

  zx_dup_strs_simple_elems(c, x->General);
  zx_dup_strs_simple_elems(c, x->Physical);
  for (se = &x->SafetyEquipment->gg;
       se && se->g.tok == zx_hrxml_SafetyEquipment_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SafetyEquipment(c, (struct zx_hrxml_SafetyEquipment_s*)se);
  for (se = &x->DressCode->gg;
       se && se->g.tok == zx_hrxml_DressCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Considerations) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Considerations_s* zx_DEEP_CLONE_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Considerations_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Considerations_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);

  x->General = zx_deep_clone_simple_elems(c,x->General, dup_strs);
  x->Physical = zx_deep_clone_simple_elems(c,x->Physical, dup_strs);
  for (enn = 0, e = &x->SafetyEquipment->gg;
       e && e->g.tok == zx_hrxml_SafetyEquipment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SafetyEquipment(c,(struct zx_hrxml_SafetyEquipment_s*)e,dup_strs);
  	  if (!enn)
  	      x->SafetyEquipment = (struct zx_hrxml_SafetyEquipment_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DressCode->gg;
       e && e->g.tok == zx_hrxml_DressCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DressCode(c,(struct zx_hrxml_DressCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->DressCode = (struct zx_hrxml_DressCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Considerations) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->General, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Physical, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->SafetyEquipment->gg;
       e && e->g.tok == zx_hrxml_SafetyEquipment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SafetyEquipment(c, (struct zx_hrxml_SafetyEquipment_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DressCode->gg;
       e && e->g.tok == zx_hrxml_DressCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Considerations) */

int zx_WALK_WO_hrxml_Considerations(struct zx_ctx* c, struct zx_hrxml_Considerations_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactId
#define EL_STRUCT zx_hrxml_ContactId_s
#define EL_NS     hrxml
#define EL_TAG    ContactId

/* FUNC(zx_FREE_hrxml_ContactId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ContactId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ContactId_s* zx_NEW_hrxml_ContactId(struct zx_ctx* c)
{
  struct zx_hrxml_ContactId_s* x = ZX_ZALLOC(c, struct zx_hrxml_ContactId_s);
  x->gg.g.tok = zx_hrxml_ContactId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ContactId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ContactId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ContactId_s* zx_DEEP_CLONE_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ContactId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ContactId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ContactId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ContactId) */

int zx_WALK_WO_hrxml_ContactId(struct zx_ctx* c, struct zx_hrxml_ContactId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactInfo
#define EL_STRUCT zx_hrxml_ContactInfo_s
#define EL_NS     hrxml
#define EL_TAG    ContactInfo

/* FUNC(zx_FREE_hrxml_ContactInfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, free_strs);
  }
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ContactInfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ContactInfo_s* zx_NEW_hrxml_ContactInfo(struct zx_ctx* c)
{
  struct zx_hrxml_ContactInfo_s* x = ZX_ZALLOC(c, struct zx_hrxml_ContactInfo_s);
  x->gg.g.tok = zx_hrxml_ContactInfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ContactInfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PersonName->gg;
       se && se->g.tok == zx_hrxml_PersonName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  for (se = &x->ContactMethod->gg;
       se && se->g.tok == zx_hrxml_ContactMethod_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ContactInfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ContactInfo_s* zx_DEEP_CLONE_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ContactInfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ContactInfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonName(c,(struct zx_hrxml_PersonName_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonName = (struct zx_hrxml_PersonName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactMethod(c,(struct zx_hrxml_ContactMethod_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactMethod = (struct zx_hrxml_ContactMethod_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ContactInfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ContactInfo) */

int zx_WALK_WO_hrxml_ContactInfo(struct zx_ctx* c, struct zx_hrxml_ContactInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactMethod
#define EL_STRUCT zx_hrxml_ContactMethod_s
#define EL_NS     hrxml
#define EL_TAG    ContactMethod

/* FUNC(zx_FREE_hrxml_ContactMethod) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Use, free_strs);
  zx_free_simple_elems(c, x->Location, free_strs);
  zx_free_simple_elems(c, x->WhenAvailable, free_strs);
  for (e = &x->Telephone->gg;
       e && e->g.tok == zx_hrxml_Telephone_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Telephone(c, (struct zx_hrxml_Telephone_s*)e, free_strs);
  }
  for (e = &x->Mobile->gg;
       e && e->g.tok == zx_hrxml_Mobile_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Mobile(c, (struct zx_hrxml_Mobile_s*)e, free_strs);
  }
  for (e = &x->Fax->gg;
       e && e->g.tok == zx_hrxml_Fax_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Fax(c, (struct zx_hrxml_Fax_s*)e, free_strs);
  }
  for (e = &x->Pager->gg;
       e && e->g.tok == zx_hrxml_Pager_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Pager(c, (struct zx_hrxml_Pager_s*)e, free_strs);
  }
  for (e = &x->TTYTDD->gg;
       e && e->g.tok == zx_hrxml_TTYTDD_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_TTYTDD(c, (struct zx_hrxml_TTYTDD_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->InternetEmailAddress, free_strs);
  zx_free_simple_elems(c, x->InternetWebAddress, free_strs);
  for (e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ContactMethod) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ContactMethod_s* zx_NEW_hrxml_ContactMethod(struct zx_ctx* c)
{
  struct zx_hrxml_ContactMethod_s* x = ZX_ZALLOC(c, struct zx_hrxml_ContactMethod_s);
  x->gg.g.tok = zx_hrxml_ContactMethod_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ContactMethod) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Use);
  zx_dup_strs_simple_elems(c, x->Location);
  zx_dup_strs_simple_elems(c, x->WhenAvailable);
  for (se = &x->Telephone->gg;
       se && se->g.tok == zx_hrxml_Telephone_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Telephone(c, (struct zx_hrxml_Telephone_s*)se);
  for (se = &x->Mobile->gg;
       se && se->g.tok == zx_hrxml_Mobile_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Mobile(c, (struct zx_hrxml_Mobile_s*)se);
  for (se = &x->Fax->gg;
       se && se->g.tok == zx_hrxml_Fax_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Fax(c, (struct zx_hrxml_Fax_s*)se);
  for (se = &x->Pager->gg;
       se && se->g.tok == zx_hrxml_Pager_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Pager(c, (struct zx_hrxml_Pager_s*)se);
  for (se = &x->TTYTDD->gg;
       se && se->g.tok == zx_hrxml_TTYTDD_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_TTYTDD(c, (struct zx_hrxml_TTYTDD_s*)se);
  zx_dup_strs_simple_elems(c, x->InternetEmailAddress);
  zx_dup_strs_simple_elems(c, x->InternetWebAddress);
  for (se = &x->PostalAddress->gg;
       se && se->g.tok == zx_hrxml_PostalAddress_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ContactMethod) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ContactMethod_s* zx_DEEP_CLONE_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ContactMethod_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ContactMethod_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Use = zx_deep_clone_simple_elems(c,x->Use, dup_strs);
  x->Location = zx_deep_clone_simple_elems(c,x->Location, dup_strs);
  x->WhenAvailable = zx_deep_clone_simple_elems(c,x->WhenAvailable, dup_strs);
  for (enn = 0, e = &x->Telephone->gg;
       e && e->g.tok == zx_hrxml_Telephone_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Telephone(c,(struct zx_hrxml_Telephone_s*)e,dup_strs);
  	  if (!enn)
  	      x->Telephone = (struct zx_hrxml_Telephone_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Mobile->gg;
       e && e->g.tok == zx_hrxml_Mobile_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Mobile(c,(struct zx_hrxml_Mobile_s*)e,dup_strs);
  	  if (!enn)
  	      x->Mobile = (struct zx_hrxml_Mobile_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Fax->gg;
       e && e->g.tok == zx_hrxml_Fax_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Fax(c,(struct zx_hrxml_Fax_s*)e,dup_strs);
  	  if (!enn)
  	      x->Fax = (struct zx_hrxml_Fax_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Pager->gg;
       e && e->g.tok == zx_hrxml_Pager_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Pager(c,(struct zx_hrxml_Pager_s*)e,dup_strs);
  	  if (!enn)
  	      x->Pager = (struct zx_hrxml_Pager_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->TTYTDD->gg;
       e && e->g.tok == zx_hrxml_TTYTDD_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_TTYTDD(c,(struct zx_hrxml_TTYTDD_s*)e,dup_strs);
  	  if (!enn)
  	      x->TTYTDD = (struct zx_hrxml_TTYTDD_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->InternetEmailAddress = zx_deep_clone_simple_elems(c,x->InternetEmailAddress, dup_strs);
  x->InternetWebAddress = zx_deep_clone_simple_elems(c,x->InternetWebAddress, dup_strs);
  for (enn = 0, e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PostalAddress(c,(struct zx_hrxml_PostalAddress_s*)e,dup_strs);
  	  if (!enn)
  	      x->PostalAddress = (struct zx_hrxml_PostalAddress_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ContactMethod) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Use, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Location, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->WhenAvailable, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Telephone->gg;
       e && e->g.tok == zx_hrxml_Telephone_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Telephone(c, (struct zx_hrxml_Telephone_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Mobile->gg;
       e && e->g.tok == zx_hrxml_Mobile_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Mobile(c, (struct zx_hrxml_Mobile_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Fax->gg;
       e && e->g.tok == zx_hrxml_Fax_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Fax(c, (struct zx_hrxml_Fax_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Pager->gg;
       e && e->g.tok == zx_hrxml_Pager_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Pager(c, (struct zx_hrxml_Pager_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->TTYTDD->gg;
       e && e->g.tok == zx_hrxml_TTYTDD_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_TTYTDD(c, (struct zx_hrxml_TTYTDD_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->InternetEmailAddress, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->InternetWebAddress, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ContactMethod) */

int zx_WALK_WO_hrxml_ContactMethod(struct zx_ctx* c, struct zx_hrxml_ContactMethod_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ContactName
#define EL_STRUCT zx_hrxml_ContactName_s
#define EL_NS     hrxml
#define EL_TAG    ContactName

/* FUNC(zx_FREE_hrxml_ContactName) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->script, free_strs);

  zx_free_simple_elems(c, x->FormattedName, free_strs);
  zx_free_simple_elems(c, x->LegalName, free_strs);
  zx_free_simple_elems(c, x->GivenName, free_strs);
  zx_free_simple_elems(c, x->PreferredGivenName, free_strs);
  zx_free_simple_elems(c, x->MiddleName, free_strs);
  for (e = &x->FamilyName->gg;
       e && e->g.tok == zx_hrxml_FamilyName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)e, free_strs);
  }
  for (e = &x->Affix->gg;
       e && e->g.tok == zx_hrxml_Affix_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)e, free_strs);
  }
  for (e = &x->AlternateScript->gg;
       e && e->g.tok == zx_hrxml_AlternateScript_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_AlternateScript(c, (struct zx_hrxml_AlternateScript_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ContactName) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ContactName_s* zx_NEW_hrxml_ContactName(struct zx_ctx* c)
{
  struct zx_hrxml_ContactName_s* x = ZX_ZALLOC(c, struct zx_hrxml_ContactName_s);
  x->gg.g.tok = zx_hrxml_ContactName_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ContactName) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->script);

  zx_dup_strs_simple_elems(c, x->FormattedName);
  zx_dup_strs_simple_elems(c, x->LegalName);
  zx_dup_strs_simple_elems(c, x->GivenName);
  zx_dup_strs_simple_elems(c, x->PreferredGivenName);
  zx_dup_strs_simple_elems(c, x->MiddleName);
  for (se = &x->FamilyName->gg;
       se && se->g.tok == zx_hrxml_FamilyName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)se);
  for (se = &x->Affix->gg;
       se && se->g.tok == zx_hrxml_Affix_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)se);
  for (se = &x->AlternateScript->gg;
       se && se->g.tok == zx_hrxml_AlternateScript_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_AlternateScript(c, (struct zx_hrxml_AlternateScript_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ContactName) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ContactName_s* zx_DEEP_CLONE_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ContactName_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ContactName_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->script = zx_clone_attr(c, x->script);

  x->FormattedName = zx_deep_clone_simple_elems(c,x->FormattedName, dup_strs);
  x->LegalName = zx_deep_clone_simple_elems(c,x->LegalName, dup_strs);
  x->GivenName = zx_deep_clone_simple_elems(c,x->GivenName, dup_strs);
  x->PreferredGivenName = zx_deep_clone_simple_elems(c,x->PreferredGivenName, dup_strs);
  x->MiddleName = zx_deep_clone_simple_elems(c,x->MiddleName, dup_strs);
  for (enn = 0, e = &x->FamilyName->gg;
       e && e->g.tok == zx_hrxml_FamilyName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_FamilyName(c,(struct zx_hrxml_FamilyName_s*)e,dup_strs);
  	  if (!enn)
  	      x->FamilyName = (struct zx_hrxml_FamilyName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Affix->gg;
       e && e->g.tok == zx_hrxml_Affix_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Affix(c,(struct zx_hrxml_Affix_s*)e,dup_strs);
  	  if (!enn)
  	      x->Affix = (struct zx_hrxml_Affix_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AlternateScript->gg;
       e && e->g.tok == zx_hrxml_AlternateScript_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_AlternateScript(c,(struct zx_hrxml_AlternateScript_s*)e,dup_strs);
  	  if (!enn)
  	      x->AlternateScript = (struct zx_hrxml_AlternateScript_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ContactName) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->FormattedName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->LegalName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->GivenName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PreferredGivenName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MiddleName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->FamilyName->gg;
       e && e->g.tok == zx_hrxml_FamilyName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Affix->gg;
       e && e->g.tok == zx_hrxml_Affix_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AlternateScript->gg;
       e && e->g.tok == zx_hrxml_AlternateScript_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_AlternateScript(c, (struct zx_hrxml_AlternateScript_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ContactName) */

int zx_WALK_WO_hrxml_ContactName(struct zx_ctx* c, struct zx_hrxml_ContactName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Copyright
#define EL_STRUCT zx_hrxml_Copyright_s
#define EL_NS     hrxml
#define EL_TAG    Copyright

/* FUNC(zx_FREE_hrxml_Copyright) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->CopyrightDates->gg;
       e && e->g.tok == zx_hrxml_CopyrightDates_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_CopyrightDates(c, (struct zx_hrxml_CopyrightDates_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->CopyrightText, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Copyright) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Copyright_s* zx_NEW_hrxml_Copyright(struct zx_ctx* c)
{
  struct zx_hrxml_Copyright_s* x = ZX_ZALLOC(c, struct zx_hrxml_Copyright_s);
  x->gg.g.tok = zx_hrxml_Copyright_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Copyright) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->CopyrightDates->gg;
       se && se->g.tok == zx_hrxml_CopyrightDates_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_CopyrightDates(c, (struct zx_hrxml_CopyrightDates_s*)se);
  zx_dup_strs_simple_elems(c, x->CopyrightText);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Copyright) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Copyright_s* zx_DEEP_CLONE_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Copyright_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Copyright_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->CopyrightDates->gg;
       e && e->g.tok == zx_hrxml_CopyrightDates_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_CopyrightDates(c,(struct zx_hrxml_CopyrightDates_s*)e,dup_strs);
  	  if (!enn)
  	      x->CopyrightDates = (struct zx_hrxml_CopyrightDates_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->CopyrightText = zx_deep_clone_simple_elems(c,x->CopyrightText, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Copyright) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CopyrightDates->gg;
       e && e->g.tok == zx_hrxml_CopyrightDates_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_CopyrightDates(c, (struct zx_hrxml_CopyrightDates_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->CopyrightText, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Copyright) */

int zx_WALK_WO_hrxml_Copyright(struct zx_ctx* c, struct zx_hrxml_Copyright_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_CopyrightDates
#define EL_STRUCT zx_hrxml_CopyrightDates_s
#define EL_NS     hrxml
#define EL_TAG    CopyrightDates

/* FUNC(zx_FREE_hrxml_CopyrightDates) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->OriginalDate->gg;
       e && e->g.tok == zx_hrxml_OriginalDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OriginalDate(c, (struct zx_hrxml_OriginalDate_s*)e, free_strs);
  }
  for (e = &x->MostRecentDate->gg;
       e && e->g.tok == zx_hrxml_MostRecentDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_MostRecentDate(c, (struct zx_hrxml_MostRecentDate_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_CopyrightDates) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_CopyrightDates_s* zx_NEW_hrxml_CopyrightDates(struct zx_ctx* c)
{
  struct zx_hrxml_CopyrightDates_s* x = ZX_ZALLOC(c, struct zx_hrxml_CopyrightDates_s);
  x->gg.g.tok = zx_hrxml_CopyrightDates_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_CopyrightDates) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->OriginalDate->gg;
       se && se->g.tok == zx_hrxml_OriginalDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OriginalDate(c, (struct zx_hrxml_OriginalDate_s*)se);
  for (se = &x->MostRecentDate->gg;
       se && se->g.tok == zx_hrxml_MostRecentDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_MostRecentDate(c, (struct zx_hrxml_MostRecentDate_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_CopyrightDates) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_CopyrightDates_s* zx_DEEP_CLONE_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_CopyrightDates_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_CopyrightDates_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->OriginalDate->gg;
       e && e->g.tok == zx_hrxml_OriginalDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OriginalDate(c,(struct zx_hrxml_OriginalDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->OriginalDate = (struct zx_hrxml_OriginalDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->MostRecentDate->gg;
       e && e->g.tok == zx_hrxml_MostRecentDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_MostRecentDate(c,(struct zx_hrxml_MostRecentDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->MostRecentDate = (struct zx_hrxml_MostRecentDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_CopyrightDates) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->OriginalDate->gg;
       e && e->g.tok == zx_hrxml_OriginalDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OriginalDate(c, (struct zx_hrxml_OriginalDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->MostRecentDate->gg;
       e && e->g.tok == zx_hrxml_MostRecentDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_MostRecentDate(c, (struct zx_hrxml_MostRecentDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_CopyrightDates) */

int zx_WALK_WO_hrxml_CopyrightDates(struct zx_ctx* c, struct zx_hrxml_CopyrightDates_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DatesOfAttendance
#define EL_STRUCT zx_hrxml_DatesOfAttendance_s
#define EL_NS     hrxml
#define EL_TAG    DatesOfAttendance

/* FUNC(zx_FREE_hrxml_DatesOfAttendance) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->currentlyEnrolled, free_strs);
  zx_free_attr(c, x->enrollmentStatus, free_strs);
  zx_free_attr(c, x->studentInGoodStanding, free_strs);

  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, free_strs);
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DatesOfAttendance) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DatesOfAttendance_s* zx_NEW_hrxml_DatesOfAttendance(struct zx_ctx* c)
{
  struct zx_hrxml_DatesOfAttendance_s* x = ZX_ZALLOC(c, struct zx_hrxml_DatesOfAttendance_s);
  x->gg.g.tok = zx_hrxml_DatesOfAttendance_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DatesOfAttendance) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->currentlyEnrolled);
  zx_dup_attr(c, x->enrollmentStatus);
  zx_dup_attr(c, x->studentInGoodStanding);

  for (se = &x->StartDate->gg;
       se && se->g.tok == zx_hrxml_StartDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg;
       se && se->g.tok == zx_hrxml_EndDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DatesOfAttendance) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DatesOfAttendance_s* zx_DEEP_CLONE_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DatesOfAttendance_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DatesOfAttendance_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->currentlyEnrolled = zx_clone_attr(c, x->currentlyEnrolled);
  x->enrollmentStatus = zx_clone_attr(c, x->enrollmentStatus);
  x->studentInGoodStanding = zx_clone_attr(c, x->studentInGoodStanding);

  for (enn = 0, e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StartDate(c,(struct zx_hrxml_StartDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->StartDate = (struct zx_hrxml_StartDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EndDate(c,(struct zx_hrxml_EndDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EndDate = (struct zx_hrxml_EndDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DatesOfAttendance) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DatesOfAttendance) */

int zx_WALK_WO_hrxml_DatesOfAttendance(struct zx_ctx* c, struct zx_hrxml_DatesOfAttendance_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DatesOfService
#define EL_STRUCT zx_hrxml_DatesOfService_s
#define EL_NS     hrxml
#define EL_TAG    DatesOfService

/* FUNC(zx_FREE_hrxml_DatesOfService) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, free_strs);
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DatesOfService) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DatesOfService_s* zx_NEW_hrxml_DatesOfService(struct zx_ctx* c)
{
  struct zx_hrxml_DatesOfService_s* x = ZX_ZALLOC(c, struct zx_hrxml_DatesOfService_s);
  x->gg.g.tok = zx_hrxml_DatesOfService_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DatesOfService) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->StartDate->gg;
       se && se->g.tok == zx_hrxml_StartDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg;
       se && se->g.tok == zx_hrxml_EndDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DatesOfService) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DatesOfService_s* zx_DEEP_CLONE_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DatesOfService_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DatesOfService_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StartDate(c,(struct zx_hrxml_StartDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->StartDate = (struct zx_hrxml_StartDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EndDate(c,(struct zx_hrxml_EndDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EndDate = (struct zx_hrxml_EndDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DatesOfService) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DatesOfService) */

int zx_WALK_WO_hrxml_DatesOfService(struct zx_ctx* c, struct zx_hrxml_DatesOfService_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Degree
#define EL_STRUCT zx_hrxml_Degree_s
#define EL_NS     hrxml
#define EL_TAG    Degree

/* FUNC(zx_FREE_hrxml_Degree) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->degreeType, free_strs);
  zx_free_attr(c, x->examPassed, free_strs);
  zx_free_attr(c, x->graduatingDegree, free_strs);

  for (e = &x->DegreeName->gg;
       e && e->g.tok == zx_hrxml_DegreeName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DegreeName(c, (struct zx_hrxml_DegreeName_s*)e, free_strs);
  }
  for (e = &x->DegreeDate->gg;
       e && e->g.tok == zx_hrxml_DegreeDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DegreeDate(c, (struct zx_hrxml_DegreeDate_s*)e, free_strs);
  }
  for (e = &x->OtherHonors->gg;
       e && e->g.tok == zx_hrxml_OtherHonors_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OtherHonors(c, (struct zx_hrxml_OtherHonors_s*)e, free_strs);
  }
  for (e = &x->DegreeMajor->gg;
       e && e->g.tok == zx_hrxml_DegreeMajor_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DegreeMajor(c, (struct zx_hrxml_DegreeMajor_s*)e, free_strs);
  }
  for (e = &x->DegreeMinor->gg;
       e && e->g.tok == zx_hrxml_DegreeMinor_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DegreeMinor(c, (struct zx_hrxml_DegreeMinor_s*)e, free_strs);
  }
  for (e = &x->DegreeMeasure->gg;
       e && e->g.tok == zx_hrxml_DegreeMeasure_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DegreeMeasure(c, (struct zx_hrxml_DegreeMeasure_s*)e, free_strs);
  }
  for (e = &x->DatesOfAttendance->gg;
       e && e->g.tok == zx_hrxml_DatesOfAttendance_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DatesOfAttendance(c, (struct zx_hrxml_DatesOfAttendance_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);
  for (e = &x->DegreeClassification->gg;
       e && e->g.tok == zx_hrxml_DegreeClassification_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DegreeClassification(c, (struct zx_hrxml_DegreeClassification_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Degree) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Degree_s* zx_NEW_hrxml_Degree(struct zx_ctx* c)
{
  struct zx_hrxml_Degree_s* x = ZX_ZALLOC(c, struct zx_hrxml_Degree_s);
  x->gg.g.tok = zx_hrxml_Degree_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Degree) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->degreeType);
  zx_dup_attr(c, x->examPassed);
  zx_dup_attr(c, x->graduatingDegree);

  for (se = &x->DegreeName->gg;
       se && se->g.tok == zx_hrxml_DegreeName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DegreeName(c, (struct zx_hrxml_DegreeName_s*)se);
  for (se = &x->DegreeDate->gg;
       se && se->g.tok == zx_hrxml_DegreeDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DegreeDate(c, (struct zx_hrxml_DegreeDate_s*)se);
  for (se = &x->OtherHonors->gg;
       se && se->g.tok == zx_hrxml_OtherHonors_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OtherHonors(c, (struct zx_hrxml_OtherHonors_s*)se);
  for (se = &x->DegreeMajor->gg;
       se && se->g.tok == zx_hrxml_DegreeMajor_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DegreeMajor(c, (struct zx_hrxml_DegreeMajor_s*)se);
  for (se = &x->DegreeMinor->gg;
       se && se->g.tok == zx_hrxml_DegreeMinor_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DegreeMinor(c, (struct zx_hrxml_DegreeMinor_s*)se);
  for (se = &x->DegreeMeasure->gg;
       se && se->g.tok == zx_hrxml_DegreeMeasure_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DegreeMeasure(c, (struct zx_hrxml_DegreeMeasure_s*)se);
  for (se = &x->DatesOfAttendance->gg;
       se && se->g.tok == zx_hrxml_DatesOfAttendance_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DatesOfAttendance(c, (struct zx_hrxml_DatesOfAttendance_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);
  for (se = &x->DegreeClassification->gg;
       se && se->g.tok == zx_hrxml_DegreeClassification_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DegreeClassification(c, (struct zx_hrxml_DegreeClassification_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Degree) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Degree_s* zx_DEEP_CLONE_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Degree_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Degree_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->degreeType = zx_clone_attr(c, x->degreeType);
  x->examPassed = zx_clone_attr(c, x->examPassed);
  x->graduatingDegree = zx_clone_attr(c, x->graduatingDegree);

  for (enn = 0, e = &x->DegreeName->gg;
       e && e->g.tok == zx_hrxml_DegreeName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DegreeName(c,(struct zx_hrxml_DegreeName_s*)e,dup_strs);
  	  if (!enn)
  	      x->DegreeName = (struct zx_hrxml_DegreeName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DegreeDate->gg;
       e && e->g.tok == zx_hrxml_DegreeDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DegreeDate(c,(struct zx_hrxml_DegreeDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->DegreeDate = (struct zx_hrxml_DegreeDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OtherHonors->gg;
       e && e->g.tok == zx_hrxml_OtherHonors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OtherHonors(c,(struct zx_hrxml_OtherHonors_s*)e,dup_strs);
  	  if (!enn)
  	      x->OtherHonors = (struct zx_hrxml_OtherHonors_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DegreeMajor->gg;
       e && e->g.tok == zx_hrxml_DegreeMajor_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DegreeMajor(c,(struct zx_hrxml_DegreeMajor_s*)e,dup_strs);
  	  if (!enn)
  	      x->DegreeMajor = (struct zx_hrxml_DegreeMajor_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DegreeMinor->gg;
       e && e->g.tok == zx_hrxml_DegreeMinor_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DegreeMinor(c,(struct zx_hrxml_DegreeMinor_s*)e,dup_strs);
  	  if (!enn)
  	      x->DegreeMinor = (struct zx_hrxml_DegreeMinor_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DegreeMeasure->gg;
       e && e->g.tok == zx_hrxml_DegreeMeasure_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DegreeMeasure(c,(struct zx_hrxml_DegreeMeasure_s*)e,dup_strs);
  	  if (!enn)
  	      x->DegreeMeasure = (struct zx_hrxml_DegreeMeasure_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DatesOfAttendance->gg;
       e && e->g.tok == zx_hrxml_DatesOfAttendance_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DatesOfAttendance(c,(struct zx_hrxml_DatesOfAttendance_s*)e,dup_strs);
  	  if (!enn)
  	      x->DatesOfAttendance = (struct zx_hrxml_DatesOfAttendance_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  for (enn = 0, e = &x->DegreeClassification->gg;
       e && e->g.tok == zx_hrxml_DegreeClassification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DegreeClassification(c,(struct zx_hrxml_DegreeClassification_s*)e,dup_strs);
  	  if (!enn)
  	      x->DegreeClassification = (struct zx_hrxml_DegreeClassification_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Degree) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->DegreeName->gg;
       e && e->g.tok == zx_hrxml_DegreeName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DegreeName(c, (struct zx_hrxml_DegreeName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DegreeDate->gg;
       e && e->g.tok == zx_hrxml_DegreeDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DegreeDate(c, (struct zx_hrxml_DegreeDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OtherHonors->gg;
       e && e->g.tok == zx_hrxml_OtherHonors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OtherHonors(c, (struct zx_hrxml_OtherHonors_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DegreeMajor->gg;
       e && e->g.tok == zx_hrxml_DegreeMajor_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DegreeMajor(c, (struct zx_hrxml_DegreeMajor_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DegreeMinor->gg;
       e && e->g.tok == zx_hrxml_DegreeMinor_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DegreeMinor(c, (struct zx_hrxml_DegreeMinor_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DegreeMeasure->gg;
       e && e->g.tok == zx_hrxml_DegreeMeasure_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DegreeMeasure(c, (struct zx_hrxml_DegreeMeasure_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DatesOfAttendance->gg;
       e && e->g.tok == zx_hrxml_DatesOfAttendance_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DatesOfAttendance(c, (struct zx_hrxml_DatesOfAttendance_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->DegreeClassification->gg;
       e && e->g.tok == zx_hrxml_DegreeClassification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DegreeClassification(c, (struct zx_hrxml_DegreeClassification_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Degree) */

int zx_WALK_WO_hrxml_Degree(struct zx_ctx* c, struct zx_hrxml_Degree_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeClassification
#define EL_STRUCT zx_hrxml_DegreeClassification_s
#define EL_NS     hrxml
#define EL_TAG    DegreeClassification

/* FUNC(zx_FREE_hrxml_DegreeClassification) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DegreeClassification) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DegreeClassification_s* zx_NEW_hrxml_DegreeClassification(struct zx_ctx* c)
{
  struct zx_hrxml_DegreeClassification_s* x = ZX_ZALLOC(c, struct zx_hrxml_DegreeClassification_s);
  x->gg.g.tok = zx_hrxml_DegreeClassification_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DegreeClassification) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DegreeClassification) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DegreeClassification_s* zx_DEEP_CLONE_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DegreeClassification_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DegreeClassification_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DegreeClassification) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DegreeClassification) */

int zx_WALK_WO_hrxml_DegreeClassification(struct zx_ctx* c, struct zx_hrxml_DegreeClassification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeDate
#define EL_STRUCT zx_hrxml_DegreeDate_s
#define EL_NS     hrxml
#define EL_TAG    DegreeDate

/* FUNC(zx_FREE_hrxml_DegreeDate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateDescription, free_strs);

  zx_free_simple_elems(c, x->AnyDate, free_strs);
  zx_free_simple_elems(c, x->YearMonth, free_strs);
  zx_free_simple_elems(c, x->Year, free_strs);
  zx_free_simple_elems(c, x->MonthDay, free_strs);
  zx_free_simple_elems(c, x->StringDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DegreeDate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DegreeDate_s* zx_NEW_hrxml_DegreeDate(struct zx_ctx* c)
{
  struct zx_hrxml_DegreeDate_s* x = ZX_ZALLOC(c, struct zx_hrxml_DegreeDate_s);
  x->gg.g.tok = zx_hrxml_DegreeDate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DegreeDate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateDescription);

  zx_dup_strs_simple_elems(c, x->AnyDate);
  zx_dup_strs_simple_elems(c, x->YearMonth);
  zx_dup_strs_simple_elems(c, x->Year);
  zx_dup_strs_simple_elems(c, x->MonthDay);
  zx_dup_strs_simple_elems(c, x->StringDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DegreeDate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DegreeDate_s* zx_DEEP_CLONE_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DegreeDate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DegreeDate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateDescription = zx_clone_attr(c, x->dateDescription);

  x->AnyDate = zx_deep_clone_simple_elems(c,x->AnyDate, dup_strs);
  x->YearMonth = zx_deep_clone_simple_elems(c,x->YearMonth, dup_strs);
  x->Year = zx_deep_clone_simple_elems(c,x->Year, dup_strs);
  x->MonthDay = zx_deep_clone_simple_elems(c,x->MonthDay, dup_strs);
  x->StringDate = zx_deep_clone_simple_elems(c,x->StringDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DegreeDate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AnyDate, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->YearMonth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Year, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDay, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StringDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DegreeDate) */

int zx_WALK_WO_hrxml_DegreeDate(struct zx_ctx* c, struct zx_hrxml_DegreeDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeMajor
#define EL_STRUCT zx_hrxml_DegreeMajor_s
#define EL_NS     hrxml
#define EL_TAG    DegreeMajor

/* FUNC(zx_FREE_hrxml_DegreeMajor) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->ProgramId->gg;
       e && e->g.tok == zx_hrxml_ProgramId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ProgramId(c, (struct zx_hrxml_ProgramId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->DegreeConcentration, free_strs);
  zx_free_simple_elems(c, x->Name, free_strs);
  zx_free_simple_elems(c, x->Option, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DegreeMajor) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DegreeMajor_s* zx_NEW_hrxml_DegreeMajor(struct zx_ctx* c)
{
  struct zx_hrxml_DegreeMajor_s* x = ZX_ZALLOC(c, struct zx_hrxml_DegreeMajor_s);
  x->gg.g.tok = zx_hrxml_DegreeMajor_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DegreeMajor) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ProgramId->gg;
       se && se->g.tok == zx_hrxml_ProgramId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ProgramId(c, (struct zx_hrxml_ProgramId_s*)se);
  zx_dup_strs_simple_elems(c, x->DegreeConcentration);
  zx_dup_strs_simple_elems(c, x->Name);
  zx_dup_strs_simple_elems(c, x->Option);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DegreeMajor) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DegreeMajor_s* zx_DEEP_CLONE_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DegreeMajor_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DegreeMajor_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ProgramId->gg;
       e && e->g.tok == zx_hrxml_ProgramId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ProgramId(c,(struct zx_hrxml_ProgramId_s*)e,dup_strs);
  	  if (!enn)
  	      x->ProgramId = (struct zx_hrxml_ProgramId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->DegreeConcentration = zx_deep_clone_simple_elems(c,x->DegreeConcentration, dup_strs);
  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  x->Option = zx_deep_clone_simple_elems(c,x->Option, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DegreeMajor) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ProgramId->gg;
       e && e->g.tok == zx_hrxml_ProgramId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ProgramId(c, (struct zx_hrxml_ProgramId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->DegreeConcentration, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Option, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DegreeMajor) */

int zx_WALK_WO_hrxml_DegreeMajor(struct zx_ctx* c, struct zx_hrxml_DegreeMajor_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeMeasure
#define EL_STRUCT zx_hrxml_DegreeMeasure_s
#define EL_NS     hrxml
#define EL_TAG    DegreeMeasure

/* FUNC(zx_FREE_hrxml_DegreeMeasure) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->measureType, free_strs);

  for (e = &x->EducationalMeasure->gg;
       e && e->g.tok == zx_hrxml_EducationalMeasure_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EducationalMeasure(c, (struct zx_hrxml_EducationalMeasure_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->AcademicCreditCode, free_strs);
  zx_free_simple_elems(c, x->CourseLevelCode, free_strs);
  zx_free_simple_elems(c, x->CumulativeSummaryIndicator, free_strs);
  zx_free_simple_elems(c, x->AcademicCreditHoursIncluded, free_strs);
  zx_free_simple_elems(c, x->AcademicCreditHoursAttempted, free_strs);
  zx_free_simple_elems(c, x->AcademicCreditHoursEarned, free_strs);
  for (e = &x->ClassRank->gg;
       e && e->g.tok == zx_hrxml_ClassRank_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ClassRank(c, (struct zx_hrxml_ClassRank_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DegreeMeasure) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DegreeMeasure_s* zx_NEW_hrxml_DegreeMeasure(struct zx_ctx* c)
{
  struct zx_hrxml_DegreeMeasure_s* x = ZX_ZALLOC(c, struct zx_hrxml_DegreeMeasure_s);
  x->gg.g.tok = zx_hrxml_DegreeMeasure_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DegreeMeasure) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->measureType);

  for (se = &x->EducationalMeasure->gg;
       se && se->g.tok == zx_hrxml_EducationalMeasure_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EducationalMeasure(c, (struct zx_hrxml_EducationalMeasure_s*)se);
  zx_dup_strs_simple_elems(c, x->AcademicCreditCode);
  zx_dup_strs_simple_elems(c, x->CourseLevelCode);
  zx_dup_strs_simple_elems(c, x->CumulativeSummaryIndicator);
  zx_dup_strs_simple_elems(c, x->AcademicCreditHoursIncluded);
  zx_dup_strs_simple_elems(c, x->AcademicCreditHoursAttempted);
  zx_dup_strs_simple_elems(c, x->AcademicCreditHoursEarned);
  for (se = &x->ClassRank->gg;
       se && se->g.tok == zx_hrxml_ClassRank_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ClassRank(c, (struct zx_hrxml_ClassRank_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DegreeMeasure) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DegreeMeasure_s* zx_DEEP_CLONE_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DegreeMeasure_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DegreeMeasure_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->measureType = zx_clone_attr(c, x->measureType);

  for (enn = 0, e = &x->EducationalMeasure->gg;
       e && e->g.tok == zx_hrxml_EducationalMeasure_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EducationalMeasure(c,(struct zx_hrxml_EducationalMeasure_s*)e,dup_strs);
  	  if (!enn)
  	      x->EducationalMeasure = (struct zx_hrxml_EducationalMeasure_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->AcademicCreditCode = zx_deep_clone_simple_elems(c,x->AcademicCreditCode, dup_strs);
  x->CourseLevelCode = zx_deep_clone_simple_elems(c,x->CourseLevelCode, dup_strs);
  x->CumulativeSummaryIndicator = zx_deep_clone_simple_elems(c,x->CumulativeSummaryIndicator, dup_strs);
  x->AcademicCreditHoursIncluded = zx_deep_clone_simple_elems(c,x->AcademicCreditHoursIncluded, dup_strs);
  x->AcademicCreditHoursAttempted = zx_deep_clone_simple_elems(c,x->AcademicCreditHoursAttempted, dup_strs);
  x->AcademicCreditHoursEarned = zx_deep_clone_simple_elems(c,x->AcademicCreditHoursEarned, dup_strs);
  for (enn = 0, e = &x->ClassRank->gg;
       e && e->g.tok == zx_hrxml_ClassRank_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ClassRank(c,(struct zx_hrxml_ClassRank_s*)e,dup_strs);
  	  if (!enn)
  	      x->ClassRank = (struct zx_hrxml_ClassRank_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DegreeMeasure) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->EducationalMeasure->gg;
       e && e->g.tok == zx_hrxml_EducationalMeasure_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EducationalMeasure(c, (struct zx_hrxml_EducationalMeasure_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->AcademicCreditCode, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->CourseLevelCode, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->CumulativeSummaryIndicator, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->AcademicCreditHoursIncluded, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->AcademicCreditHoursAttempted, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->AcademicCreditHoursEarned, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->ClassRank->gg;
       e && e->g.tok == zx_hrxml_ClassRank_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ClassRank(c, (struct zx_hrxml_ClassRank_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DegreeMeasure) */

int zx_WALK_WO_hrxml_DegreeMeasure(struct zx_ctx* c, struct zx_hrxml_DegreeMeasure_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeMinor
#define EL_STRUCT zx_hrxml_DegreeMinor_s
#define EL_NS     hrxml
#define EL_TAG    DegreeMinor

/* FUNC(zx_FREE_hrxml_DegreeMinor) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->ProgramId->gg;
       e && e->g.tok == zx_hrxml_ProgramId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ProgramId(c, (struct zx_hrxml_ProgramId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Name, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DegreeMinor) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DegreeMinor_s* zx_NEW_hrxml_DegreeMinor(struct zx_ctx* c)
{
  struct zx_hrxml_DegreeMinor_s* x = ZX_ZALLOC(c, struct zx_hrxml_DegreeMinor_s);
  x->gg.g.tok = zx_hrxml_DegreeMinor_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DegreeMinor) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ProgramId->gg;
       se && se->g.tok == zx_hrxml_ProgramId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ProgramId(c, (struct zx_hrxml_ProgramId_s*)se);
  zx_dup_strs_simple_elems(c, x->Name);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DegreeMinor) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DegreeMinor_s* zx_DEEP_CLONE_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DegreeMinor_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DegreeMinor_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ProgramId->gg;
       e && e->g.tok == zx_hrxml_ProgramId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ProgramId(c,(struct zx_hrxml_ProgramId_s*)e,dup_strs);
  	  if (!enn)
  	      x->ProgramId = (struct zx_hrxml_ProgramId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DegreeMinor) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ProgramId->gg;
       e && e->g.tok == zx_hrxml_ProgramId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ProgramId(c, (struct zx_hrxml_ProgramId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DegreeMinor) */

int zx_WALK_WO_hrxml_DegreeMinor(struct zx_ctx* c, struct zx_hrxml_DegreeMinor_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DegreeName
#define EL_STRUCT zx_hrxml_DegreeName_s
#define EL_NS     hrxml
#define EL_TAG    DegreeName

/* FUNC(zx_FREE_hrxml_DegreeName) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->academicHonors, free_strs);
  zx_free_attr(c, x->honorsProgram, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DegreeName) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DegreeName_s* zx_NEW_hrxml_DegreeName(struct zx_ctx* c)
{
  struct zx_hrxml_DegreeName_s* x = ZX_ZALLOC(c, struct zx_hrxml_DegreeName_s);
  x->gg.g.tok = zx_hrxml_DegreeName_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DegreeName) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->academicHonors);
  zx_dup_attr(c, x->honorsProgram);


}

/* FUNC(zx_DEEP_CLONE_hrxml_DegreeName) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DegreeName_s* zx_DEEP_CLONE_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DegreeName_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DegreeName_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->academicHonors = zx_clone_attr(c, x->academicHonors);
  x->honorsProgram = zx_clone_attr(c, x->honorsProgram);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DegreeName) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DegreeName) */

int zx_WALK_WO_hrxml_DegreeName(struct zx_ctx* c, struct zx_hrxml_DegreeName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DeliveryAddress
#define EL_STRUCT zx_hrxml_DeliveryAddress_s
#define EL_NS     hrxml
#define EL_TAG    DeliveryAddress

/* FUNC(zx_FREE_hrxml_DeliveryAddress) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->AddressLine, free_strs);
  zx_free_simple_elems(c, x->StreetName, free_strs);
  zx_free_simple_elems(c, x->BuildingNumber, free_strs);
  zx_free_simple_elems(c, x->Unit, free_strs);
  zx_free_simple_elems(c, x->PostOfficeBox, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DeliveryAddress) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DeliveryAddress_s* zx_NEW_hrxml_DeliveryAddress(struct zx_ctx* c)
{
  struct zx_hrxml_DeliveryAddress_s* x = ZX_ZALLOC(c, struct zx_hrxml_DeliveryAddress_s);
  x->gg.g.tok = zx_hrxml_DeliveryAddress_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DeliveryAddress) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->AddressLine);
  zx_dup_strs_simple_elems(c, x->StreetName);
  zx_dup_strs_simple_elems(c, x->BuildingNumber);
  zx_dup_strs_simple_elems(c, x->Unit);
  zx_dup_strs_simple_elems(c, x->PostOfficeBox);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DeliveryAddress) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DeliveryAddress_s* zx_DEEP_CLONE_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DeliveryAddress_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DeliveryAddress_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->AddressLine = zx_deep_clone_simple_elems(c,x->AddressLine, dup_strs);
  x->StreetName = zx_deep_clone_simple_elems(c,x->StreetName, dup_strs);
  x->BuildingNumber = zx_deep_clone_simple_elems(c,x->BuildingNumber, dup_strs);
  x->Unit = zx_deep_clone_simple_elems(c,x->Unit, dup_strs);
  x->PostOfficeBox = zx_deep_clone_simple_elems(c,x->PostOfficeBox, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DeliveryAddress) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AddressLine, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StreetName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->BuildingNumber, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Unit, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PostOfficeBox, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DeliveryAddress) */

int zx_WALK_WO_hrxml_DeliveryAddress(struct zx_ctx* c, struct zx_hrxml_DeliveryAddress_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DemographicDescriptors
#define EL_STRUCT zx_hrxml_DemographicDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    DemographicDescriptors

/* FUNC(zx_FREE_hrxml_DemographicDescriptors) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Race, free_strs);
  zx_free_simple_elems(c, x->Ethnicity, free_strs);
  zx_free_simple_elems(c, x->Nationality, free_strs);
  for (e = &x->PrimaryLanguage->gg;
       e && e->g.tok == zx_hrxml_PrimaryLanguage_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PrimaryLanguage(c, (struct zx_hrxml_PrimaryLanguage_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->BirthPlace, free_strs);
  zx_free_simple_elems(c, x->Religion, free_strs);
  zx_free_simple_elems(c, x->MaritalStatus, free_strs);
  for (e = &x->ChildrenInfo->gg;
       e && e->g.tok == zx_hrxml_ChildrenInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ChildrenInfo(c, (struct zx_hrxml_ChildrenInfo_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DemographicDescriptors) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DemographicDescriptors_s* zx_NEW_hrxml_DemographicDescriptors(struct zx_ctx* c)
{
  struct zx_hrxml_DemographicDescriptors_s* x = ZX_ZALLOC(c, struct zx_hrxml_DemographicDescriptors_s);
  x->gg.g.tok = zx_hrxml_DemographicDescriptors_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DemographicDescriptors) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Race);
  zx_dup_strs_simple_elems(c, x->Ethnicity);
  zx_dup_strs_simple_elems(c, x->Nationality);
  for (se = &x->PrimaryLanguage->gg;
       se && se->g.tok == zx_hrxml_PrimaryLanguage_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PrimaryLanguage(c, (struct zx_hrxml_PrimaryLanguage_s*)se);
  zx_dup_strs_simple_elems(c, x->BirthPlace);
  zx_dup_strs_simple_elems(c, x->Religion);
  zx_dup_strs_simple_elems(c, x->MaritalStatus);
  for (se = &x->ChildrenInfo->gg;
       se && se->g.tok == zx_hrxml_ChildrenInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ChildrenInfo(c, (struct zx_hrxml_ChildrenInfo_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DemographicDescriptors) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DemographicDescriptors_s* zx_DEEP_CLONE_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DemographicDescriptors_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DemographicDescriptors_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Race = zx_deep_clone_simple_elems(c,x->Race, dup_strs);
  x->Ethnicity = zx_deep_clone_simple_elems(c,x->Ethnicity, dup_strs);
  x->Nationality = zx_deep_clone_simple_elems(c,x->Nationality, dup_strs);
  for (enn = 0, e = &x->PrimaryLanguage->gg;
       e && e->g.tok == zx_hrxml_PrimaryLanguage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PrimaryLanguage(c,(struct zx_hrxml_PrimaryLanguage_s*)e,dup_strs);
  	  if (!enn)
  	      x->PrimaryLanguage = (struct zx_hrxml_PrimaryLanguage_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->BirthPlace = zx_deep_clone_simple_elems(c,x->BirthPlace, dup_strs);
  x->Religion = zx_deep_clone_simple_elems(c,x->Religion, dup_strs);
  x->MaritalStatus = zx_deep_clone_simple_elems(c,x->MaritalStatus, dup_strs);
  for (enn = 0, e = &x->ChildrenInfo->gg;
       e && e->g.tok == zx_hrxml_ChildrenInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ChildrenInfo(c,(struct zx_hrxml_ChildrenInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->ChildrenInfo = (struct zx_hrxml_ChildrenInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DemographicDescriptors) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Race, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Ethnicity, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Nationality, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PrimaryLanguage->gg;
       e && e->g.tok == zx_hrxml_PrimaryLanguage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PrimaryLanguage(c, (struct zx_hrxml_PrimaryLanguage_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->BirthPlace, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Religion, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MaritalStatus, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->ChildrenInfo->gg;
       e && e->g.tok == zx_hrxml_ChildrenInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ChildrenInfo(c, (struct zx_hrxml_ChildrenInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DemographicDescriptors) */

int zx_WALK_WO_hrxml_DemographicDescriptors(struct zx_ctx* c, struct zx_hrxml_DemographicDescriptors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Description
#define EL_STRUCT zx_hrxml_Description_s
#define EL_NS     hrxml
#define EL_TAG    Description

/* FUNC(zx_FREE_hrxml_Description) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Description) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Description_s* zx_NEW_hrxml_Description(struct zx_ctx* c)
{
  struct zx_hrxml_Description_s* x = ZX_ZALLOC(c, struct zx_hrxml_Description_s);
  x->gg.g.tok = zx_hrxml_Description_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Description) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);


}

/* FUNC(zx_DEEP_CLONE_hrxml_Description) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Description_s* zx_DEEP_CLONE_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Description_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Description_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Description) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Description) */

int zx_WALK_WO_hrxml_Description(struct zx_ctx* c, struct zx_hrxml_Description_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Details
#define EL_STRUCT zx_hrxml_Details_s
#define EL_NS     hrxml
#define EL_TAG    Details

/* FUNC(zx_FREE_hrxml_Details) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);
  zx_free_attr(c, x->lang, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Details) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Details_s* zx_NEW_hrxml_Details(struct zx_ctx* c)
{
  struct zx_hrxml_Details_s* x = ZX_ZALLOC(c, struct zx_hrxml_Details_s);
  x->gg.g.tok = zx_hrxml_Details_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Details) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);
  zx_dup_attr(c, x->lang);


}

/* FUNC(zx_DEEP_CLONE_hrxml_Details) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Details_s* zx_DEEP_CLONE_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Details_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Details_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);
  x->lang = zx_clone_attr(c, x->lang);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Details) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Details) */

int zx_WALK_WO_hrxml_Details(struct zx_ctx* c, struct zx_hrxml_Details_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DisabilityInfo
#define EL_STRUCT zx_hrxml_DisabilityInfo_s
#define EL_NS     hrxml
#define EL_TAG    DisabilityInfo

/* FUNC(zx_FREE_hrxml_DisabilityInfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->LevelOfDisability, free_strs);
  zx_free_simple_elems(c, x->Percentage, free_strs);
  zx_free_simple_elems(c, x->Type, free_strs);
  zx_free_simple_elems(c, x->AccommodationsNeeded, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DisabilityInfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DisabilityInfo_s* zx_NEW_hrxml_DisabilityInfo(struct zx_ctx* c)
{
  struct zx_hrxml_DisabilityInfo_s* x = ZX_ZALLOC(c, struct zx_hrxml_DisabilityInfo_s);
  x->gg.g.tok = zx_hrxml_DisabilityInfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DisabilityInfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->LevelOfDisability);
  zx_dup_strs_simple_elems(c, x->Percentage);
  zx_dup_strs_simple_elems(c, x->Type);
  zx_dup_strs_simple_elems(c, x->AccommodationsNeeded);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DisabilityInfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DisabilityInfo_s* zx_DEEP_CLONE_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DisabilityInfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DisabilityInfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->LevelOfDisability = zx_deep_clone_simple_elems(c,x->LevelOfDisability, dup_strs);
  x->Percentage = zx_deep_clone_simple_elems(c,x->Percentage, dup_strs);
  x->Type = zx_deep_clone_simple_elems(c,x->Type, dup_strs);
  x->AccommodationsNeeded = zx_deep_clone_simple_elems(c,x->AccommodationsNeeded, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DisabilityInfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->LevelOfDisability, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Percentage, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Type, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->AccommodationsNeeded, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DisabilityInfo) */

int zx_WALK_WO_hrxml_DisabilityInfo(struct zx_ctx* c, struct zx_hrxml_DisabilityInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DistanceMax
#define EL_STRUCT zx_hrxml_DistanceMax_s
#define EL_NS     hrxml
#define EL_TAG    DistanceMax

/* FUNC(zx_FREE_hrxml_DistanceMax) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->unitOfMeasure, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DistanceMax) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DistanceMax_s* zx_NEW_hrxml_DistanceMax(struct zx_ctx* c)
{
  struct zx_hrxml_DistanceMax_s* x = ZX_ZALLOC(c, struct zx_hrxml_DistanceMax_s);
  x->gg.g.tok = zx_hrxml_DistanceMax_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DistanceMax) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->unitOfMeasure);


}

/* FUNC(zx_DEEP_CLONE_hrxml_DistanceMax) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DistanceMax_s* zx_DEEP_CLONE_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DistanceMax_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DistanceMax_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->unitOfMeasure = zx_clone_attr(c, x->unitOfMeasure);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DistanceMax) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DistanceMax) */

int zx_WALK_WO_hrxml_DistanceMax(struct zx_ctx* c, struct zx_hrxml_DistanceMax_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DistributeTo
#define EL_STRUCT zx_hrxml_DistributeTo_s
#define EL_NS     hrxml
#define EL_TAG    DistributeTo

/* FUNC(zx_FREE_hrxml_DistributeTo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DistributeTo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DistributeTo_s* zx_NEW_hrxml_DistributeTo(struct zx_ctx* c)
{
  struct zx_hrxml_DistributeTo_s* x = ZX_ZALLOC(c, struct zx_hrxml_DistributeTo_s);
  x->gg.g.tok = zx_hrxml_DistributeTo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DistributeTo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ContactMethod->gg;
       se && se->g.tok == zx_hrxml_ContactMethod_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_DistributeTo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DistributeTo_s* zx_DEEP_CLONE_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DistributeTo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DistributeTo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactMethod(c,(struct zx_hrxml_ContactMethod_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactMethod = (struct zx_hrxml_ContactMethod_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DistributeTo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DistributeTo) */

int zx_WALK_WO_hrxml_DistributeTo(struct zx_ctx* c, struct zx_hrxml_DistributeTo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DoingBusinessAs
#define EL_STRUCT zx_hrxml_DoingBusinessAs_s
#define EL_NS     hrxml
#define EL_TAG    DoingBusinessAs

/* FUNC(zx_FREE_hrxml_DoingBusinessAs) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DoingBusinessAs) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DoingBusinessAs_s* zx_NEW_hrxml_DoingBusinessAs(struct zx_ctx* c)
{
  struct zx_hrxml_DoingBusinessAs_s* x = ZX_ZALLOC(c, struct zx_hrxml_DoingBusinessAs_s);
  x->gg.g.tok = zx_hrxml_DoingBusinessAs_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DoingBusinessAs) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);


}

/* FUNC(zx_DEEP_CLONE_hrxml_DoingBusinessAs) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DoingBusinessAs_s* zx_DEEP_CLONE_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DoingBusinessAs_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DoingBusinessAs_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DoingBusinessAs) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DoingBusinessAs) */

int zx_WALK_WO_hrxml_DoingBusinessAs(struct zx_ctx* c, struct zx_hrxml_DoingBusinessAs_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DressCode
#define EL_STRUCT zx_hrxml_DressCode_s
#define EL_NS     hrxml
#define EL_TAG    DressCode

/* FUNC(zx_FREE_hrxml_DressCode) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->suppliedByOrganization, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DressCode) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DressCode_s* zx_NEW_hrxml_DressCode(struct zx_ctx* c)
{
  struct zx_hrxml_DressCode_s* x = ZX_ZALLOC(c, struct zx_hrxml_DressCode_s);
  x->gg.g.tok = zx_hrxml_DressCode_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DressCode) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->suppliedByOrganization);


}

/* FUNC(zx_DEEP_CLONE_hrxml_DressCode) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DressCode_s* zx_DEEP_CLONE_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DressCode_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DressCode_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->suppliedByOrganization = zx_clone_attr(c, x->suppliedByOrganization);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DressCode) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DressCode) */

int zx_WALK_WO_hrxml_DressCode(struct zx_ctx* c, struct zx_hrxml_DressCode_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_DunsNumber
#define EL_STRUCT zx_hrxml_DunsNumber_s
#define EL_NS     hrxml
#define EL_TAG    DunsNumber

/* FUNC(zx_FREE_hrxml_DunsNumber) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dunsNumberType, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_DunsNumber) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_DunsNumber_s* zx_NEW_hrxml_DunsNumber(struct zx_ctx* c)
{
  struct zx_hrxml_DunsNumber_s* x = ZX_ZALLOC(c, struct zx_hrxml_DunsNumber_s);
  x->gg.g.tok = zx_hrxml_DunsNumber_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_DunsNumber) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dunsNumberType);


}

/* FUNC(zx_DEEP_CLONE_hrxml_DunsNumber) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_DunsNumber_s* zx_DEEP_CLONE_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_DunsNumber_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_DunsNumber_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dunsNumberType = zx_clone_attr(c, x->dunsNumberType);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_DunsNumber) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_DunsNumber) */

int zx_WALK_WO_hrxml_DunsNumber(struct zx_ctx* c, struct zx_hrxml_DunsNumber_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EEOCJobCategory
#define EL_STRUCT zx_hrxml_EEOCJobCategory_s
#define EL_NS     hrxml
#define EL_TAG    EEOCJobCategory

/* FUNC(zx_FREE_hrxml_EEOCJobCategory) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->StandardValue, free_strs);
  zx_free_simple_elems(c, x->NonStandardValue, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EEOCJobCategory) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EEOCJobCategory_s* zx_NEW_hrxml_EEOCJobCategory(struct zx_ctx* c)
{
  struct zx_hrxml_EEOCJobCategory_s* x = ZX_ZALLOC(c, struct zx_hrxml_EEOCJobCategory_s);
  x->gg.g.tok = zx_hrxml_EEOCJobCategory_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EEOCJobCategory) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->StandardValue);
  zx_dup_strs_simple_elems(c, x->NonStandardValue);

}

/* FUNC(zx_DEEP_CLONE_hrxml_EEOCJobCategory) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EEOCJobCategory_s* zx_DEEP_CLONE_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EEOCJobCategory_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EEOCJobCategory_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->StandardValue = zx_deep_clone_simple_elems(c,x->StandardValue, dup_strs);
  x->NonStandardValue = zx_deep_clone_simple_elems(c,x->NonStandardValue, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EEOCJobCategory) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->StandardValue, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->NonStandardValue, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EEOCJobCategory) */

int zx_WALK_WO_hrxml_EEOCJobCategory(struct zx_ctx* c, struct zx_hrxml_EEOCJobCategory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EducationHistory
#define EL_STRUCT zx_hrxml_EducationHistory_s
#define EL_NS     hrxml
#define EL_TAG    EducationHistory

/* FUNC(zx_FREE_hrxml_EducationHistory) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->SchoolOrInstitution->gg;
       e && e->g.tok == zx_hrxml_SchoolOrInstitution_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SchoolOrInstitution(c, (struct zx_hrxml_SchoolOrInstitution_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EducationHistory) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EducationHistory_s* zx_NEW_hrxml_EducationHistory(struct zx_ctx* c)
{
  struct zx_hrxml_EducationHistory_s* x = ZX_ZALLOC(c, struct zx_hrxml_EducationHistory_s);
  x->gg.g.tok = zx_hrxml_EducationHistory_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EducationHistory) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->SchoolOrInstitution->gg;
       se && se->g.tok == zx_hrxml_SchoolOrInstitution_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SchoolOrInstitution(c, (struct zx_hrxml_SchoolOrInstitution_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_EducationHistory) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EducationHistory_s* zx_DEEP_CLONE_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EducationHistory_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EducationHistory_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->SchoolOrInstitution->gg;
       e && e->g.tok == zx_hrxml_SchoolOrInstitution_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SchoolOrInstitution(c,(struct zx_hrxml_SchoolOrInstitution_s*)e,dup_strs);
  	  if (!enn)
  	      x->SchoolOrInstitution = (struct zx_hrxml_SchoolOrInstitution_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EducationHistory) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->SchoolOrInstitution->gg;
       e && e->g.tok == zx_hrxml_SchoolOrInstitution_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SchoolOrInstitution(c, (struct zx_hrxml_SchoolOrInstitution_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EducationHistory) */

int zx_WALK_WO_hrxml_EducationHistory(struct zx_ctx* c, struct zx_hrxml_EducationHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EducationalMeasure
#define EL_STRUCT zx_hrxml_EducationalMeasure_s
#define EL_NS     hrxml
#define EL_TAG    EducationalMeasure

/* FUNC(zx_FREE_hrxml_EducationalMeasure) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->MeasureSystem, free_strs);
  zx_free_simple_elems(c, x->MeasureValue, free_strs);
  for (e = &x->LowestPossibleValue->gg;
       e && e->g.tok == zx_hrxml_LowestPossibleValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LowestPossibleValue(c, (struct zx_hrxml_LowestPossibleValue_s*)e, free_strs);
  }
  for (e = &x->HighestPossibleValue->gg;
       e && e->g.tok == zx_hrxml_HighestPossibleValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_HighestPossibleValue(c, (struct zx_hrxml_HighestPossibleValue_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->ExcessiveValueIndicator, free_strs);
  zx_free_simple_elems(c, x->GoodStudentIndicator, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EducationalMeasure) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EducationalMeasure_s* zx_NEW_hrxml_EducationalMeasure(struct zx_ctx* c)
{
  struct zx_hrxml_EducationalMeasure_s* x = ZX_ZALLOC(c, struct zx_hrxml_EducationalMeasure_s);
  x->gg.g.tok = zx_hrxml_EducationalMeasure_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EducationalMeasure) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->MeasureSystem);
  zx_dup_strs_simple_elems(c, x->MeasureValue);
  for (se = &x->LowestPossibleValue->gg;
       se && se->g.tok == zx_hrxml_LowestPossibleValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LowestPossibleValue(c, (struct zx_hrxml_LowestPossibleValue_s*)se);
  for (se = &x->HighestPossibleValue->gg;
       se && se->g.tok == zx_hrxml_HighestPossibleValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_HighestPossibleValue(c, (struct zx_hrxml_HighestPossibleValue_s*)se);
  zx_dup_strs_simple_elems(c, x->ExcessiveValueIndicator);
  zx_dup_strs_simple_elems(c, x->GoodStudentIndicator);

}

/* FUNC(zx_DEEP_CLONE_hrxml_EducationalMeasure) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EducationalMeasure_s* zx_DEEP_CLONE_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EducationalMeasure_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EducationalMeasure_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->MeasureSystem = zx_deep_clone_simple_elems(c,x->MeasureSystem, dup_strs);
  x->MeasureValue = zx_deep_clone_simple_elems(c,x->MeasureValue, dup_strs);
  for (enn = 0, e = &x->LowestPossibleValue->gg;
       e && e->g.tok == zx_hrxml_LowestPossibleValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LowestPossibleValue(c,(struct zx_hrxml_LowestPossibleValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->LowestPossibleValue = (struct zx_hrxml_LowestPossibleValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->HighestPossibleValue->gg;
       e && e->g.tok == zx_hrxml_HighestPossibleValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_HighestPossibleValue(c,(struct zx_hrxml_HighestPossibleValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->HighestPossibleValue = (struct zx_hrxml_HighestPossibleValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->ExcessiveValueIndicator = zx_deep_clone_simple_elems(c,x->ExcessiveValueIndicator, dup_strs);
  x->GoodStudentIndicator = zx_deep_clone_simple_elems(c,x->GoodStudentIndicator, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EducationalMeasure) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->MeasureSystem, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MeasureValue, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->LowestPossibleValue->gg;
       e && e->g.tok == zx_hrxml_LowestPossibleValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LowestPossibleValue(c, (struct zx_hrxml_LowestPossibleValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->HighestPossibleValue->gg;
       e && e->g.tok == zx_hrxml_HighestPossibleValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_HighestPossibleValue(c, (struct zx_hrxml_HighestPossibleValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->ExcessiveValueIndicator, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->GoodStudentIndicator, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EducationalMeasure) */

int zx_WALK_WO_hrxml_EducationalMeasure(struct zx_ctx* c, struct zx_hrxml_EducationalMeasure_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EffectiveDate
#define EL_STRUCT zx_hrxml_EffectiveDate_s
#define EL_NS     hrxml
#define EL_TAG    EffectiveDate

/* FUNC(zx_FREE_hrxml_EffectiveDate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, free_strs);
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EffectiveDate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EffectiveDate_s* zx_NEW_hrxml_EffectiveDate(struct zx_ctx* c)
{
  struct zx_hrxml_EffectiveDate_s* x = ZX_ZALLOC(c, struct zx_hrxml_EffectiveDate_s);
  x->gg.g.tok = zx_hrxml_EffectiveDate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EffectiveDate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->StartDate->gg;
       se && se->g.tok == zx_hrxml_StartDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg;
       se && se->g.tok == zx_hrxml_EndDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_EffectiveDate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EffectiveDate_s* zx_DEEP_CLONE_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EffectiveDate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EffectiveDate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StartDate(c,(struct zx_hrxml_StartDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->StartDate = (struct zx_hrxml_StartDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EndDate(c,(struct zx_hrxml_EndDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EndDate = (struct zx_hrxml_EndDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EffectiveDate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EffectiveDate) */

int zx_WALK_WO_hrxml_EffectiveDate(struct zx_ctx* c, struct zx_hrxml_EffectiveDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EmployerContactInfo
#define EL_STRUCT zx_hrxml_EmployerContactInfo_s
#define EL_NS     hrxml
#define EL_TAG    EmployerContactInfo

/* FUNC(zx_FREE_hrxml_EmployerContactInfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->contactType, free_strs);

  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, free_strs);
  }
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, free_strs);
  }
  for (e = &x->LocationSummary->gg;
       e && e->g.tok == zx_hrxml_LocationSummary_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)e, free_strs);
  }
  for (e = &x->InternetDomainName->gg;
       e && e->g.tok == zx_hrxml_InternetDomainName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EmployerContactInfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EmployerContactInfo_s* zx_NEW_hrxml_EmployerContactInfo(struct zx_ctx* c)
{
  struct zx_hrxml_EmployerContactInfo_s* x = ZX_ZALLOC(c, struct zx_hrxml_EmployerContactInfo_s);
  x->gg.g.tok = zx_hrxml_EmployerContactInfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EmployerContactInfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->contactType);

  for (se = &x->PersonName->gg;
       se && se->g.tok == zx_hrxml_PersonName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  for (se = &x->ContactMethod->gg;
       se && se->g.tok == zx_hrxml_ContactMethod_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);
  for (se = &x->LocationSummary->gg;
       se && se->g.tok == zx_hrxml_LocationSummary_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)se);
  for (se = &x->InternetDomainName->gg;
       se && se->g.tok == zx_hrxml_InternetDomainName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_EmployerContactInfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EmployerContactInfo_s* zx_DEEP_CLONE_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EmployerContactInfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EmployerContactInfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->contactType = zx_clone_attr(c, x->contactType);

  for (enn = 0, e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonName(c,(struct zx_hrxml_PersonName_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonName = (struct zx_hrxml_PersonName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactMethod(c,(struct zx_hrxml_ContactMethod_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactMethod = (struct zx_hrxml_ContactMethod_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->LocationSummary->gg;
       e && e->g.tok == zx_hrxml_LocationSummary_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LocationSummary(c,(struct zx_hrxml_LocationSummary_s*)e,dup_strs);
  	  if (!enn)
  	      x->LocationSummary = (struct zx_hrxml_LocationSummary_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->InternetDomainName->gg;
       e && e->g.tok == zx_hrxml_InternetDomainName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_InternetDomainName(c,(struct zx_hrxml_InternetDomainName_s*)e,dup_strs);
  	  if (!enn)
  	      x->InternetDomainName = (struct zx_hrxml_InternetDomainName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EmployerContactInfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->LocationSummary->gg;
       e && e->g.tok == zx_hrxml_LocationSummary_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->InternetDomainName->gg;
       e && e->g.tok == zx_hrxml_InternetDomainName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EmployerContactInfo) */

int zx_WALK_WO_hrxml_EmployerContactInfo(struct zx_ctx* c, struct zx_hrxml_EmployerContactInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EmployerOrg
#define EL_STRUCT zx_hrxml_EmployerOrg_s
#define EL_NS     hrxml
#define EL_TAG    EmployerOrg

/* FUNC(zx_FREE_hrxml_EmployerOrg) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->employerOrgType, free_strs);

  zx_free_simple_elems(c, x->EmployerOrgName, free_strs);
  for (e = &x->EmployerContactInfo->gg;
       e && e->g.tok == zx_hrxml_EmployerContactInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EmployerContactInfo(c, (struct zx_hrxml_EmployerContactInfo_s*)e, free_strs);
  }
  for (e = &x->PositionHistory->gg;
       e && e->g.tok == zx_hrxml_PositionHistory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PositionHistory(c, (struct zx_hrxml_PositionHistory_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EmployerOrg) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EmployerOrg_s* zx_NEW_hrxml_EmployerOrg(struct zx_ctx* c)
{
  struct zx_hrxml_EmployerOrg_s* x = ZX_ZALLOC(c, struct zx_hrxml_EmployerOrg_s);
  x->gg.g.tok = zx_hrxml_EmployerOrg_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EmployerOrg) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->employerOrgType);

  zx_dup_strs_simple_elems(c, x->EmployerOrgName);
  for (se = &x->EmployerContactInfo->gg;
       se && se->g.tok == zx_hrxml_EmployerContactInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EmployerContactInfo(c, (struct zx_hrxml_EmployerContactInfo_s*)se);
  for (se = &x->PositionHistory->gg;
       se && se->g.tok == zx_hrxml_PositionHistory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PositionHistory(c, (struct zx_hrxml_PositionHistory_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_EmployerOrg) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EmployerOrg_s* zx_DEEP_CLONE_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EmployerOrg_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EmployerOrg_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->employerOrgType = zx_clone_attr(c, x->employerOrgType);

  x->EmployerOrgName = zx_deep_clone_simple_elems(c,x->EmployerOrgName, dup_strs);
  for (enn = 0, e = &x->EmployerContactInfo->gg;
       e && e->g.tok == zx_hrxml_EmployerContactInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EmployerContactInfo(c,(struct zx_hrxml_EmployerContactInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->EmployerContactInfo = (struct zx_hrxml_EmployerContactInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PositionHistory->gg;
       e && e->g.tok == zx_hrxml_PositionHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PositionHistory(c,(struct zx_hrxml_PositionHistory_s*)e,dup_strs);
  	  if (!enn)
  	      x->PositionHistory = (struct zx_hrxml_PositionHistory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EmployerOrg) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->EmployerOrgName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->EmployerContactInfo->gg;
       e && e->g.tok == zx_hrxml_EmployerContactInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EmployerContactInfo(c, (struct zx_hrxml_EmployerContactInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PositionHistory->gg;
       e && e->g.tok == zx_hrxml_PositionHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PositionHistory(c, (struct zx_hrxml_PositionHistory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EmployerOrg) */

int zx_WALK_WO_hrxml_EmployerOrg(struct zx_ctx* c, struct zx_hrxml_EmployerOrg_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EmploymentHistory
#define EL_STRUCT zx_hrxml_EmploymentHistory_s
#define EL_NS     hrxml
#define EL_TAG    EmploymentHistory

/* FUNC(zx_FREE_hrxml_EmploymentHistory) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->EmployerOrg->gg;
       e && e->g.tok == zx_hrxml_EmployerOrg_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EmployerOrg(c, (struct zx_hrxml_EmployerOrg_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EmploymentHistory) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EmploymentHistory_s* zx_NEW_hrxml_EmploymentHistory(struct zx_ctx* c)
{
  struct zx_hrxml_EmploymentHistory_s* x = ZX_ZALLOC(c, struct zx_hrxml_EmploymentHistory_s);
  x->gg.g.tok = zx_hrxml_EmploymentHistory_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EmploymentHistory) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->EmployerOrg->gg;
       se && se->g.tok == zx_hrxml_EmployerOrg_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EmployerOrg(c, (struct zx_hrxml_EmployerOrg_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_EmploymentHistory) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EmploymentHistory_s* zx_DEEP_CLONE_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EmploymentHistory_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EmploymentHistory_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->EmployerOrg->gg;
       e && e->g.tok == zx_hrxml_EmployerOrg_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EmployerOrg(c,(struct zx_hrxml_EmployerOrg_s*)e,dup_strs);
  	  if (!enn)
  	      x->EmployerOrg = (struct zx_hrxml_EmployerOrg_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EmploymentHistory) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->EmployerOrg->gg;
       e && e->g.tok == zx_hrxml_EmployerOrg_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EmployerOrg(c, (struct zx_hrxml_EmployerOrg_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EmploymentHistory) */

int zx_WALK_WO_hrxml_EmploymentHistory(struct zx_ctx* c, struct zx_hrxml_EmploymentHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EndDate
#define EL_STRUCT zx_hrxml_EndDate_s
#define EL_NS     hrxml
#define EL_TAG    EndDate

/* FUNC(zx_FREE_hrxml_EndDate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateDescription, free_strs);

  zx_free_simple_elems(c, x->AnyDate, free_strs);
  zx_free_simple_elems(c, x->YearMonth, free_strs);
  zx_free_simple_elems(c, x->Year, free_strs);
  zx_free_simple_elems(c, x->MonthDay, free_strs);
  zx_free_simple_elems(c, x->StringDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EndDate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EndDate_s* zx_NEW_hrxml_EndDate(struct zx_ctx* c)
{
  struct zx_hrxml_EndDate_s* x = ZX_ZALLOC(c, struct zx_hrxml_EndDate_s);
  x->gg.g.tok = zx_hrxml_EndDate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EndDate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateDescription);

  zx_dup_strs_simple_elems(c, x->AnyDate);
  zx_dup_strs_simple_elems(c, x->YearMonth);
  zx_dup_strs_simple_elems(c, x->Year);
  zx_dup_strs_simple_elems(c, x->MonthDay);
  zx_dup_strs_simple_elems(c, x->StringDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_EndDate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EndDate_s* zx_DEEP_CLONE_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EndDate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EndDate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateDescription = zx_clone_attr(c, x->dateDescription);

  x->AnyDate = zx_deep_clone_simple_elems(c,x->AnyDate, dup_strs);
  x->YearMonth = zx_deep_clone_simple_elems(c,x->YearMonth, dup_strs);
  x->Year = zx_deep_clone_simple_elems(c,x->Year, dup_strs);
  x->MonthDay = zx_deep_clone_simple_elems(c,x->MonthDay, dup_strs);
  x->StringDate = zx_deep_clone_simple_elems(c,x->StringDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EndDate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AnyDate, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->YearMonth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Year, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDay, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StringDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EndDate) */

int zx_WALK_WO_hrxml_EndDate(struct zx_ctx* c, struct zx_hrxml_EndDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EndingCompensation
#define EL_STRUCT zx_hrxml_EndingCompensation_s
#define EL_NS     hrxml
#define EL_TAG    EndingCompensation

/* FUNC(zx_FREE_hrxml_EndingCompensation) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->currency, free_strs);
  zx_free_attr(c, x->intervalType, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EndingCompensation) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EndingCompensation_s* zx_NEW_hrxml_EndingCompensation(struct zx_ctx* c)
{
  struct zx_hrxml_EndingCompensation_s* x = ZX_ZALLOC(c, struct zx_hrxml_EndingCompensation_s);
  x->gg.g.tok = zx_hrxml_EndingCompensation_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EndingCompensation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->currency);
  zx_dup_attr(c, x->intervalType);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);


}

/* FUNC(zx_DEEP_CLONE_hrxml_EndingCompensation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EndingCompensation_s* zx_DEEP_CLONE_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EndingCompensation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EndingCompensation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->currency = zx_clone_attr(c, x->currency);
  x->intervalType = zx_clone_attr(c, x->intervalType);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EndingCompensation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EndingCompensation) */

int zx_WALK_WO_hrxml_EndingCompensation(struct zx_ctx* c, struct zx_hrxml_EndingCompensation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EnvironmentId
#define EL_STRUCT zx_hrxml_EnvironmentId_s
#define EL_NS     hrxml
#define EL_TAG    EnvironmentId

/* FUNC(zx_FREE_hrxml_EnvironmentId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EnvironmentId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EnvironmentId_s* zx_NEW_hrxml_EnvironmentId(struct zx_ctx* c)
{
  struct zx_hrxml_EnvironmentId_s* x = ZX_ZALLOC(c, struct zx_hrxml_EnvironmentId_s);
  x->gg.g.tok = zx_hrxml_EnvironmentId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EnvironmentId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_EnvironmentId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EnvironmentId_s* zx_DEEP_CLONE_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EnvironmentId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EnvironmentId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EnvironmentId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EnvironmentId) */

int zx_WALK_WO_hrxml_EnvironmentId(struct zx_ctx* c, struct zx_hrxml_EnvironmentId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_EvidenceId
#define EL_STRUCT zx_hrxml_EvidenceId_s
#define EL_NS     hrxml
#define EL_TAG    EvidenceId

/* FUNC(zx_FREE_hrxml_EvidenceId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->description, free_strs);
  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->idOwner, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_EvidenceId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_EvidenceId_s* zx_NEW_hrxml_EvidenceId(struct zx_ctx* c)
{
  struct zx_hrxml_EvidenceId_s* x = ZX_ZALLOC(c, struct zx_hrxml_EvidenceId_s);
  x->gg.g.tok = zx_hrxml_EvidenceId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_EvidenceId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->description);
  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->idOwner);


}

/* FUNC(zx_DEEP_CLONE_hrxml_EvidenceId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_EvidenceId_s* zx_DEEP_CLONE_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_EvidenceId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_EvidenceId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->description = zx_clone_attr(c, x->description);
  x->id = zx_clone_attr(c, x->id);
  x->idOwner = zx_clone_attr(c, x->idOwner);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_EvidenceId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_EvidenceId) */

int zx_WALK_WO_hrxml_EvidenceId(struct zx_ctx* c, struct zx_hrxml_EvidenceId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ExpatriateBenefits
#define EL_STRUCT zx_hrxml_ExpatriateBenefits_s
#define EL_NS     hrxml
#define EL_TAG    ExpatriateBenefits

/* FUNC(zx_FREE_hrxml_ExpatriateBenefits) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->ExpatriateBenefitsOffered, free_strs);
  zx_free_simple_elems(c, x->ExpatriateBenefitList, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ExpatriateBenefits) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ExpatriateBenefits_s* zx_NEW_hrxml_ExpatriateBenefits(struct zx_ctx* c)
{
  struct zx_hrxml_ExpatriateBenefits_s* x = ZX_ZALLOC(c, struct zx_hrxml_ExpatriateBenefits_s);
  x->gg.g.tok = zx_hrxml_ExpatriateBenefits_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ExpatriateBenefits) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->ExpatriateBenefitsOffered);
  zx_dup_strs_simple_elems(c, x->ExpatriateBenefitList);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ExpatriateBenefits) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ExpatriateBenefits_s* zx_DEEP_CLONE_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ExpatriateBenefits_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ExpatriateBenefits_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->ExpatriateBenefitsOffered = zx_deep_clone_simple_elems(c,x->ExpatriateBenefitsOffered, dup_strs);
  x->ExpatriateBenefitList = zx_deep_clone_simple_elems(c,x->ExpatriateBenefitList, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ExpatriateBenefits) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->ExpatriateBenefitsOffered, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->ExpatriateBenefitList, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ExpatriateBenefits) */

int zx_WALK_WO_hrxml_ExpatriateBenefits(struct zx_ctx* c, struct zx_hrxml_ExpatriateBenefits_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_FamilyName
#define EL_STRUCT zx_hrxml_FamilyName_s
#define EL_NS     hrxml
#define EL_TAG    FamilyName

/* FUNC(zx_FREE_hrxml_FamilyName) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->prefix, free_strs);
  zx_free_attr(c, x->primary, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_FamilyName) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_FamilyName_s* zx_NEW_hrxml_FamilyName(struct zx_ctx* c)
{
  struct zx_hrxml_FamilyName_s* x = ZX_ZALLOC(c, struct zx_hrxml_FamilyName_s);
  x->gg.g.tok = zx_hrxml_FamilyName_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_FamilyName) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->prefix);
  zx_dup_attr(c, x->primary);


}

/* FUNC(zx_DEEP_CLONE_hrxml_FamilyName) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_FamilyName_s* zx_DEEP_CLONE_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_FamilyName_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_FamilyName_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->prefix = zx_clone_attr(c, x->prefix);
  x->primary = zx_clone_attr(c, x->primary);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_FamilyName) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_FamilyName) */

int zx_WALK_WO_hrxml_FamilyName(struct zx_ctx* c, struct zx_hrxml_FamilyName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Fax
#define EL_STRUCT zx_hrxml_Fax_s
#define EL_NS     hrxml
#define EL_TAG    Fax

/* FUNC(zx_FREE_hrxml_Fax) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->FormattedNumber, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Fax) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Fax_s* zx_NEW_hrxml_Fax(struct zx_ctx* c)
{
  struct zx_hrxml_Fax_s* x = ZX_ZALLOC(c, struct zx_hrxml_Fax_s);
  x->gg.g.tok = zx_hrxml_Fax_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Fax) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->FormattedNumber);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Fax) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Fax_s* zx_DEEP_CLONE_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Fax_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Fax_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->FormattedNumber = zx_deep_clone_simple_elems(c,x->FormattedNumber, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Fax) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->FormattedNumber, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Fax) */

int zx_WALK_WO_hrxml_Fax(struct zx_ctx* c, struct zx_hrxml_Fax_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_FirstIssuedDate
#define EL_STRUCT zx_hrxml_FirstIssuedDate_s
#define EL_NS     hrxml
#define EL_TAG    FirstIssuedDate

/* FUNC(zx_FREE_hrxml_FirstIssuedDate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateDescription, free_strs);

  zx_free_simple_elems(c, x->AnyDate, free_strs);
  zx_free_simple_elems(c, x->YearMonth, free_strs);
  zx_free_simple_elems(c, x->Year, free_strs);
  zx_free_simple_elems(c, x->MonthDay, free_strs);
  zx_free_simple_elems(c, x->StringDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_FirstIssuedDate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_FirstIssuedDate_s* zx_NEW_hrxml_FirstIssuedDate(struct zx_ctx* c)
{
  struct zx_hrxml_FirstIssuedDate_s* x = ZX_ZALLOC(c, struct zx_hrxml_FirstIssuedDate_s);
  x->gg.g.tok = zx_hrxml_FirstIssuedDate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_FirstIssuedDate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateDescription);

  zx_dup_strs_simple_elems(c, x->AnyDate);
  zx_dup_strs_simple_elems(c, x->YearMonth);
  zx_dup_strs_simple_elems(c, x->Year);
  zx_dup_strs_simple_elems(c, x->MonthDay);
  zx_dup_strs_simple_elems(c, x->StringDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_FirstIssuedDate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_FirstIssuedDate_s* zx_DEEP_CLONE_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_FirstIssuedDate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_FirstIssuedDate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateDescription = zx_clone_attr(c, x->dateDescription);

  x->AnyDate = zx_deep_clone_simple_elems(c,x->AnyDate, dup_strs);
  x->YearMonth = zx_deep_clone_simple_elems(c,x->YearMonth, dup_strs);
  x->Year = zx_deep_clone_simple_elems(c,x->Year, dup_strs);
  x->MonthDay = zx_deep_clone_simple_elems(c,x->MonthDay, dup_strs);
  x->StringDate = zx_deep_clone_simple_elems(c,x->StringDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_FirstIssuedDate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AnyDate, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->YearMonth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Year, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDay, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StringDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_FirstIssuedDate) */

int zx_WALK_WO_hrxml_FirstIssuedDate(struct zx_ctx* c, struct zx_hrxml_FirstIssuedDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_FormattedPublicationDescription
#define EL_STRUCT zx_hrxml_FormattedPublicationDescription_s
#define EL_NS     hrxml
#define EL_TAG    FormattedPublicationDescription

/* FUNC(zx_FREE_hrxml_FormattedPublicationDescription) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_FormattedPublicationDescription) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_FormattedPublicationDescription_s* zx_NEW_hrxml_FormattedPublicationDescription(struct zx_ctx* c)
{
  struct zx_hrxml_FormattedPublicationDescription_s* x = ZX_ZALLOC(c, struct zx_hrxml_FormattedPublicationDescription_s);
  x->gg.g.tok = zx_hrxml_FormattedPublicationDescription_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_FormattedPublicationDescription) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_hrxml_FormattedPublicationDescription) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_FormattedPublicationDescription_s* zx_DEEP_CLONE_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_FormattedPublicationDescription_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_FormattedPublicationDescription_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_FormattedPublicationDescription) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_FormattedPublicationDescription) */

int zx_WALK_WO_hrxml_FormattedPublicationDescription(struct zx_ctx* c, struct zx_hrxml_FormattedPublicationDescription_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Height
#define EL_STRUCT zx_hrxml_Height_s
#define EL_NS     hrxml
#define EL_TAG    Height

/* FUNC(zx_FREE_hrxml_Height) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->unitOfMeasure, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Height) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Height_s* zx_NEW_hrxml_Height(struct zx_ctx* c)
{
  struct zx_hrxml_Height_s* x = ZX_ZALLOC(c, struct zx_hrxml_Height_s);
  x->gg.g.tok = zx_hrxml_Height_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Height) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->unitOfMeasure);


}

/* FUNC(zx_DEEP_CLONE_hrxml_Height) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Height_s* zx_DEEP_CLONE_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Height_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Height_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->unitOfMeasure = zx_clone_attr(c, x->unitOfMeasure);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Height) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Height) */

int zx_WALK_WO_hrxml_Height(struct zx_ctx* c, struct zx_hrxml_Height_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_HighestPossibleValue
#define EL_STRUCT zx_hrxml_HighestPossibleValue_s
#define EL_NS     hrxml
#define EL_TAG    HighestPossibleValue

/* FUNC(zx_FREE_hrxml_HighestPossibleValue) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)e, free_strs);
  }
  for (e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_HighestPossibleValue) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_HighestPossibleValue_s* zx_NEW_hrxml_HighestPossibleValue(struct zx_ctx* c)
{
  struct zx_hrxml_HighestPossibleValue_s* x = ZX_ZALLOC(c, struct zx_hrxml_HighestPossibleValue_s);
  x->gg.g.tok = zx_hrxml_HighestPossibleValue_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_HighestPossibleValue) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->NumericValue->gg;
       se && se->g.tok == zx_hrxml_NumericValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se);
  for (se = &x->StringValue->gg;
       se && se->g.tok == zx_hrxml_StringValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_HighestPossibleValue) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_HighestPossibleValue_s* zx_DEEP_CLONE_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_HighestPossibleValue_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_HighestPossibleValue_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_NumericValue(c,(struct zx_hrxml_NumericValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->NumericValue = (struct zx_hrxml_NumericValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StringValue(c,(struct zx_hrxml_StringValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->StringValue = (struct zx_hrxml_StringValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_HighestPossibleValue) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_HighestPossibleValue) */

int zx_WALK_WO_hrxml_HighestPossibleValue(struct zx_ctx* c, struct zx_hrxml_HighestPossibleValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_HorizontalAccuracy
#define EL_STRUCT zx_hrxml_HorizontalAccuracy_s
#define EL_NS     hrxml
#define EL_TAG    HorizontalAccuracy

/* FUNC(zx_FREE_hrxml_HorizontalAccuracy) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_HorizontalAccuracy) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_HorizontalAccuracy_s* zx_NEW_hrxml_HorizontalAccuracy(struct zx_ctx* c)
{
  struct zx_hrxml_HorizontalAccuracy_s* x = ZX_ZALLOC(c, struct zx_hrxml_HorizontalAccuracy_s);
  x->gg.g.tok = zx_hrxml_HorizontalAccuracy_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_HorizontalAccuracy) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_hrxml_HorizontalAccuracy) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_HorizontalAccuracy_s* zx_DEEP_CLONE_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_HorizontalAccuracy_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_HorizontalAccuracy_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_hrxml_HorizontalAccuracy) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_HorizontalAccuracy) */

int zx_WALK_WO_hrxml_HorizontalAccuracy(struct zx_ctx* c, struct zx_hrxml_HorizontalAccuracy_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Id
#define EL_STRUCT zx_hrxml_Id_s
#define EL_NS     hrxml
#define EL_TAG    Id

/* FUNC(zx_FREE_hrxml_Id) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Id) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Id_s* zx_NEW_hrxml_Id(struct zx_ctx* c)
{
  struct zx_hrxml_Id_s* x = ZX_ZALLOC(c, struct zx_hrxml_Id_s);
  x->gg.g.tok = zx_hrxml_Id_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Id) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Id) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Id_s* zx_DEEP_CLONE_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Id_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Id_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Id) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Id) */

int zx_WALK_WO_hrxml_Id(struct zx_ctx* c, struct zx_hrxml_Id_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_IdValue
#define EL_STRUCT zx_hrxml_IdValue_s
#define EL_NS     hrxml
#define EL_TAG    IdValue

/* FUNC(zx_FREE_hrxml_IdValue) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->name, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_IdValue) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_IdValue_s* zx_NEW_hrxml_IdValue(struct zx_ctx* c)
{
  struct zx_hrxml_IdValue_s* x = ZX_ZALLOC(c, struct zx_hrxml_IdValue_s);
  x->gg.g.tok = zx_hrxml_IdValue_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_IdValue) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->name);


}

/* FUNC(zx_DEEP_CLONE_hrxml_IdValue) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_IdValue_s* zx_DEEP_CLONE_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_IdValue_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_IdValue_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->name = zx_clone_attr(c, x->name);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_IdValue) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_IdValue) */

int zx_WALK_WO_hrxml_IdValue(struct zx_ctx* c, struct zx_hrxml_IdValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_IndustryCode
#define EL_STRUCT zx_hrxml_IndustryCode_s
#define EL_NS     hrxml
#define EL_TAG    IndustryCode

/* FUNC(zx_FREE_hrxml_IndustryCode) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->classificationName, free_strs);
  zx_free_attr(c, x->primaryIndicator, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_IndustryCode) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_IndustryCode_s* zx_NEW_hrxml_IndustryCode(struct zx_ctx* c)
{
  struct zx_hrxml_IndustryCode_s* x = ZX_ZALLOC(c, struct zx_hrxml_IndustryCode_s);
  x->gg.g.tok = zx_hrxml_IndustryCode_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_IndustryCode) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->classificationName);
  zx_dup_attr(c, x->primaryIndicator);


}

/* FUNC(zx_DEEP_CLONE_hrxml_IndustryCode) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_IndustryCode_s* zx_DEEP_CLONE_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_IndustryCode_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_IndustryCode_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->classificationName = zx_clone_attr(c, x->classificationName);
  x->primaryIndicator = zx_clone_attr(c, x->primaryIndicator);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_IndustryCode) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_IndustryCode) */

int zx_WALK_WO_hrxml_IndustryCode(struct zx_ctx* c, struct zx_hrxml_IndustryCode_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Insurance
#define EL_STRUCT zx_hrxml_Insurance_s
#define EL_NS     hrxml
#define EL_TAG    Insurance

/* FUNC(zx_FREE_hrxml_Insurance) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Insurance) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Insurance_s* zx_NEW_hrxml_Insurance(struct zx_ctx* c)
{
  struct zx_hrxml_Insurance_s* x = ZX_ZALLOC(c, struct zx_hrxml_Insurance_s);
  x->gg.g.tok = zx_hrxml_Insurance_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Insurance) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_hrxml_Insurance) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Insurance_s* zx_DEEP_CLONE_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Insurance_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Insurance_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Insurance) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Insurance) */

int zx_WALK_WO_hrxml_Insurance(struct zx_ctx* c, struct zx_hrxml_Insurance_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_InternetDomainName
#define EL_STRUCT zx_hrxml_InternetDomainName_s
#define EL_NS     hrxml
#define EL_TAG    InternetDomainName

/* FUNC(zx_FREE_hrxml_InternetDomainName) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->primaryIndicator, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_InternetDomainName) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_InternetDomainName_s* zx_NEW_hrxml_InternetDomainName(struct zx_ctx* c)
{
  struct zx_hrxml_InternetDomainName_s* x = ZX_ZALLOC(c, struct zx_hrxml_InternetDomainName_s);
  x->gg.g.tok = zx_hrxml_InternetDomainName_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_InternetDomainName) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->primaryIndicator);


}

/* FUNC(zx_DEEP_CLONE_hrxml_InternetDomainName) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_InternetDomainName_s* zx_DEEP_CLONE_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_InternetDomainName_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_InternetDomainName_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->primaryIndicator = zx_clone_attr(c, x->primaryIndicator);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_InternetDomainName) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_InternetDomainName) */

int zx_WALK_WO_hrxml_InternetDomainName(struct zx_ctx* c, struct zx_hrxml_InternetDomainName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Inventors
#define EL_STRUCT zx_hrxml_Inventors_s
#define EL_NS     hrxml
#define EL_TAG    Inventors

/* FUNC(zx_FREE_hrxml_Inventors) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->InventorName, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Inventors) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Inventors_s* zx_NEW_hrxml_Inventors(struct zx_ctx* c)
{
  struct zx_hrxml_Inventors_s* x = ZX_ZALLOC(c, struct zx_hrxml_Inventors_s);
  x->gg.g.tok = zx_hrxml_Inventors_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Inventors) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->InventorName);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Inventors) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Inventors_s* zx_DEEP_CLONE_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Inventors_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Inventors_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->InventorName = zx_deep_clone_simple_elems(c,x->InventorName, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Inventors) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->InventorName, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Inventors) */

int zx_WALK_WO_hrxml_Inventors(struct zx_ctx* c, struct zx_hrxml_Inventors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_IssuingAuthority
#define EL_STRUCT zx_hrxml_IssuingAuthority_s
#define EL_NS     hrxml
#define EL_TAG    IssuingAuthority

/* FUNC(zx_FREE_hrxml_IssuingAuthority) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->countryCode, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_IssuingAuthority) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_IssuingAuthority_s* zx_NEW_hrxml_IssuingAuthority(struct zx_ctx* c)
{
  struct zx_hrxml_IssuingAuthority_s* x = ZX_ZALLOC(c, struct zx_hrxml_IssuingAuthority_s);
  x->gg.g.tok = zx_hrxml_IssuingAuthority_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_IssuingAuthority) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->countryCode);


}

/* FUNC(zx_DEEP_CLONE_hrxml_IssuingAuthority) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_IssuingAuthority_s* zx_DEEP_CLONE_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_IssuingAuthority_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_IssuingAuthority_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->countryCode = zx_clone_attr(c, x->countryCode);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_IssuingAuthority) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_IssuingAuthority) */

int zx_WALK_WO_hrxml_IssuingAuthority(struct zx_ctx* c, struct zx_hrxml_IssuingAuthority_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_JobCategory
#define EL_STRUCT zx_hrxml_JobCategory_s
#define EL_NS     hrxml
#define EL_TAG    JobCategory

/* FUNC(zx_FREE_hrxml_JobCategory) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->TaxonomyName->gg;
       e && e->g.tok == zx_hrxml_TaxonomyName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_TaxonomyName(c, (struct zx_hrxml_TaxonomyName_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->CategoryCode, free_strs);
  zx_free_simple_elems(c, x->CategoryDescription, free_strs);
  zx_free_simple_elems(c, x->Comments, free_strs);
  for (e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_JobCategory) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_JobCategory_s* zx_NEW_hrxml_JobCategory(struct zx_ctx* c)
{
  struct zx_hrxml_JobCategory_s* x = ZX_ZALLOC(c, struct zx_hrxml_JobCategory_s);
  x->gg.g.tok = zx_hrxml_JobCategory_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_JobCategory) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->TaxonomyName->gg;
       se && se->g.tok == zx_hrxml_TaxonomyName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_TaxonomyName(c, (struct zx_hrxml_TaxonomyName_s*)se);
  zx_dup_strs_simple_elems(c, x->CategoryCode);
  zx_dup_strs_simple_elems(c, x->CategoryDescription);
  zx_dup_strs_simple_elems(c, x->Comments);
  for (se = &x->JobCategory->gg;
       se && se->g.tok == zx_hrxml_JobCategory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_JobCategory) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_JobCategory_s* zx_DEEP_CLONE_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_JobCategory_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_JobCategory_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->TaxonomyName->gg;
       e && e->g.tok == zx_hrxml_TaxonomyName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_TaxonomyName(c,(struct zx_hrxml_TaxonomyName_s*)e,dup_strs);
  	  if (!enn)
  	      x->TaxonomyName = (struct zx_hrxml_TaxonomyName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->CategoryCode = zx_deep_clone_simple_elems(c,x->CategoryCode, dup_strs);
  x->CategoryDescription = zx_deep_clone_simple_elems(c,x->CategoryDescription, dup_strs);
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  for (enn = 0, e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_JobCategory(c,(struct zx_hrxml_JobCategory_s*)e,dup_strs);
  	  if (!enn)
  	      x->JobCategory = (struct zx_hrxml_JobCategory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_JobCategory) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->TaxonomyName->gg;
       e && e->g.tok == zx_hrxml_TaxonomyName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_TaxonomyName(c, (struct zx_hrxml_TaxonomyName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->CategoryCode, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->CategoryDescription, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_JobCategory) */

int zx_WALK_WO_hrxml_JobCategory(struct zx_ctx* c, struct zx_hrxml_JobCategory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_JobLevelInfo
#define EL_STRUCT zx_hrxml_JobLevelInfo_s
#define EL_NS     hrxml
#define EL_TAG    JobLevelInfo

/* FUNC(zx_FREE_hrxml_JobLevelInfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->JobPlan, free_strs);
  zx_free_simple_elems(c, x->JobGrade, free_strs);
  zx_free_simple_elems(c, x->JobStep, free_strs);
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_JobLevelInfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_JobLevelInfo_s* zx_NEW_hrxml_JobLevelInfo(struct zx_ctx* c)
{
  struct zx_hrxml_JobLevelInfo_s* x = ZX_ZALLOC(c, struct zx_hrxml_JobLevelInfo_s);
  x->gg.g.tok = zx_hrxml_JobLevelInfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_JobLevelInfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->JobPlan);
  zx_dup_strs_simple_elems(c, x->JobGrade);
  zx_dup_strs_simple_elems(c, x->JobStep);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_JobLevelInfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_JobLevelInfo_s* zx_DEEP_CLONE_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_JobLevelInfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_JobLevelInfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->JobPlan = zx_deep_clone_simple_elems(c,x->JobPlan, dup_strs);
  x->JobGrade = zx_deep_clone_simple_elems(c,x->JobGrade, dup_strs);
  x->JobStep = zx_deep_clone_simple_elems(c,x->JobStep, dup_strs);
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_JobLevelInfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->JobPlan, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->JobGrade, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->JobStep, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_JobLevelInfo) */

int zx_WALK_WO_hrxml_JobLevelInfo(struct zx_ctx* c, struct zx_hrxml_JobLevelInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Language
#define EL_STRUCT zx_hrxml_Language_s
#define EL_NS     hrxml
#define EL_TAG    Language

/* FUNC(zx_FREE_hrxml_Language) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->LanguageCode->gg;
       e && e->g.tok == zx_hrxml_LanguageCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LanguageCode(c, (struct zx_hrxml_LanguageCode_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Read, free_strs);
  zx_free_simple_elems(c, x->Write, free_strs);
  zx_free_simple_elems(c, x->Speak, free_strs);
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Language) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Language_s* zx_NEW_hrxml_Language(struct zx_ctx* c)
{
  struct zx_hrxml_Language_s* x = ZX_ZALLOC(c, struct zx_hrxml_Language_s);
  x->gg.g.tok = zx_hrxml_Language_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Language) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->LanguageCode->gg;
       se && se->g.tok == zx_hrxml_LanguageCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LanguageCode(c, (struct zx_hrxml_LanguageCode_s*)se);
  zx_dup_strs_simple_elems(c, x->Read);
  zx_dup_strs_simple_elems(c, x->Write);
  zx_dup_strs_simple_elems(c, x->Speak);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Language) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Language_s* zx_DEEP_CLONE_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Language_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Language_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->LanguageCode->gg;
       e && e->g.tok == zx_hrxml_LanguageCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LanguageCode(c,(struct zx_hrxml_LanguageCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->LanguageCode = (struct zx_hrxml_LanguageCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Read = zx_deep_clone_simple_elems(c,x->Read, dup_strs);
  x->Write = zx_deep_clone_simple_elems(c,x->Write, dup_strs);
  x->Speak = zx_deep_clone_simple_elems(c,x->Speak, dup_strs);
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Language) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->LanguageCode->gg;
       e && e->g.tok == zx_hrxml_LanguageCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LanguageCode(c, (struct zx_hrxml_LanguageCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Read, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Write, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Speak, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Language) */

int zx_WALK_WO_hrxml_Language(struct zx_ctx* c, struct zx_hrxml_Language_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LanguageCode
#define EL_STRUCT zx_hrxml_LanguageCode_s
#define EL_NS     hrxml
#define EL_TAG    LanguageCode

/* FUNC(zx_FREE_hrxml_LanguageCode) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_LanguageCode) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_LanguageCode_s* zx_NEW_hrxml_LanguageCode(struct zx_ctx* c)
{
  struct zx_hrxml_LanguageCode_s* x = ZX_ZALLOC(c, struct zx_hrxml_LanguageCode_s);
  x->gg.g.tok = zx_hrxml_LanguageCode_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_LanguageCode) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_hrxml_LanguageCode) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_LanguageCode_s* zx_DEEP_CLONE_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_LanguageCode_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_LanguageCode_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_hrxml_LanguageCode) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_LanguageCode) */

int zx_WALK_WO_hrxml_LanguageCode(struct zx_ctx* c, struct zx_hrxml_LanguageCode_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Languages
#define EL_STRUCT zx_hrxml_Languages_s
#define EL_NS     hrxml
#define EL_TAG    Languages

/* FUNC(zx_FREE_hrxml_Languages) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Language->gg;
       e && e->g.tok == zx_hrxml_Language_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Language(c, (struct zx_hrxml_Language_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Languages) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Languages_s* zx_NEW_hrxml_Languages(struct zx_ctx* c)
{
  struct zx_hrxml_Languages_s* x = ZX_ZALLOC(c, struct zx_hrxml_Languages_s);
  x->gg.g.tok = zx_hrxml_Languages_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Languages) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Language->gg;
       se && se->g.tok == zx_hrxml_Language_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Language(c, (struct zx_hrxml_Language_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Languages) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Languages_s* zx_DEEP_CLONE_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Languages_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Languages_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Language->gg;
       e && e->g.tok == zx_hrxml_Language_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Language(c,(struct zx_hrxml_Language_s*)e,dup_strs);
  	  if (!enn)
  	      x->Language = (struct zx_hrxml_Language_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Languages) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Language->gg;
       e && e->g.tok == zx_hrxml_Language_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Language(c, (struct zx_hrxml_Language_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Languages) */

int zx_WALK_WO_hrxml_Languages(struct zx_ctx* c, struct zx_hrxml_Languages_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Latitude
#define EL_STRUCT zx_hrxml_Latitude_s
#define EL_NS     hrxml
#define EL_TAG    Latitude

/* FUNC(zx_FREE_hrxml_Latitude) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Latitude) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Latitude_s* zx_NEW_hrxml_Latitude(struct zx_ctx* c)
{
  struct zx_hrxml_Latitude_s* x = ZX_ZALLOC(c, struct zx_hrxml_Latitude_s);
  x->gg.g.tok = zx_hrxml_Latitude_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Latitude) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_hrxml_Latitude) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Latitude_s* zx_DEEP_CLONE_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Latitude_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Latitude_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Latitude) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Latitude) */

int zx_WALK_WO_hrxml_Latitude(struct zx_ctx* c, struct zx_hrxml_Latitude_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LegalClassification
#define EL_STRUCT zx_hrxml_LegalClassification_s
#define EL_NS     hrxml
#define EL_TAG    LegalClassification

/* FUNC(zx_FREE_hrxml_LegalClassification) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->countryCode, free_strs);
  zx_free_attr(c, x->ownership, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_LegalClassification) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_LegalClassification_s* zx_NEW_hrxml_LegalClassification(struct zx_ctx* c)
{
  struct zx_hrxml_LegalClassification_s* x = ZX_ZALLOC(c, struct zx_hrxml_LegalClassification_s);
  x->gg.g.tok = zx_hrxml_LegalClassification_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_LegalClassification) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->countryCode);
  zx_dup_attr(c, x->ownership);


}

/* FUNC(zx_DEEP_CLONE_hrxml_LegalClassification) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_LegalClassification_s* zx_DEEP_CLONE_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_LegalClassification_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_LegalClassification_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->countryCode = zx_clone_attr(c, x->countryCode);
  x->ownership = zx_clone_attr(c, x->ownership);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_LegalClassification) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_LegalClassification) */

int zx_WALK_WO_hrxml_LegalClassification(struct zx_ctx* c, struct zx_hrxml_LegalClassification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LegalId
#define EL_STRUCT zx_hrxml_LegalId_s
#define EL_NS     hrxml
#define EL_TAG    LegalId

/* FUNC(zx_FREE_hrxml_LegalId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_LegalId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_LegalId_s* zx_NEW_hrxml_LegalId(struct zx_ctx* c)
{
  struct zx_hrxml_LegalId_s* x = ZX_ZALLOC(c, struct zx_hrxml_LegalId_s);
  x->gg.g.tok = zx_hrxml_LegalId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_LegalId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_LegalId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_LegalId_s* zx_DEEP_CLONE_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_LegalId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_LegalId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_LegalId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_LegalId) */

int zx_WALK_WO_hrxml_LegalId(struct zx_ctx* c, struct zx_hrxml_LegalId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LegalIdentifiers
#define EL_STRUCT zx_hrxml_LegalIdentifiers_s
#define EL_NS     hrxml
#define EL_TAG    LegalIdentifiers

/* FUNC(zx_FREE_hrxml_LegalIdentifiers) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PersonLegalId->gg;
       e && e->g.tok == zx_hrxml_PersonLegalId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonLegalId(c, (struct zx_hrxml_PersonLegalId_s*)e, free_strs);
  }
  for (e = &x->MilitaryStatus->gg;
       e && e->g.tok == zx_hrxml_MilitaryStatus_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_MilitaryStatus(c, (struct zx_hrxml_MilitaryStatus_s*)e, free_strs);
  }
  for (e = &x->VisaStatus->gg;
       e && e->g.tok == zx_hrxml_VisaStatus_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_VisaStatus(c, (struct zx_hrxml_VisaStatus_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Citizenship, free_strs);
  zx_free_simple_elems(c, x->Residency, free_strs);
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_LegalIdentifiers) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_LegalIdentifiers_s* zx_NEW_hrxml_LegalIdentifiers(struct zx_ctx* c)
{
  struct zx_hrxml_LegalIdentifiers_s* x = ZX_ZALLOC(c, struct zx_hrxml_LegalIdentifiers_s);
  x->gg.g.tok = zx_hrxml_LegalIdentifiers_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_LegalIdentifiers) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PersonLegalId->gg;
       se && se->g.tok == zx_hrxml_PersonLegalId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonLegalId(c, (struct zx_hrxml_PersonLegalId_s*)se);
  for (se = &x->MilitaryStatus->gg;
       se && se->g.tok == zx_hrxml_MilitaryStatus_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_MilitaryStatus(c, (struct zx_hrxml_MilitaryStatus_s*)se);
  for (se = &x->VisaStatus->gg;
       se && se->g.tok == zx_hrxml_VisaStatus_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_VisaStatus(c, (struct zx_hrxml_VisaStatus_s*)se);
  zx_dup_strs_simple_elems(c, x->Citizenship);
  zx_dup_strs_simple_elems(c, x->Residency);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_LegalIdentifiers) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_LegalIdentifiers_s* zx_DEEP_CLONE_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_LegalIdentifiers_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_LegalIdentifiers_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PersonLegalId->gg;
       e && e->g.tok == zx_hrxml_PersonLegalId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonLegalId(c,(struct zx_hrxml_PersonLegalId_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonLegalId = (struct zx_hrxml_PersonLegalId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->MilitaryStatus->gg;
       e && e->g.tok == zx_hrxml_MilitaryStatus_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_MilitaryStatus(c,(struct zx_hrxml_MilitaryStatus_s*)e,dup_strs);
  	  if (!enn)
  	      x->MilitaryStatus = (struct zx_hrxml_MilitaryStatus_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->VisaStatus->gg;
       e && e->g.tok == zx_hrxml_VisaStatus_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_VisaStatus(c,(struct zx_hrxml_VisaStatus_s*)e,dup_strs);
  	  if (!enn)
  	      x->VisaStatus = (struct zx_hrxml_VisaStatus_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Citizenship = zx_deep_clone_simple_elems(c,x->Citizenship, dup_strs);
  x->Residency = zx_deep_clone_simple_elems(c,x->Residency, dup_strs);
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_LegalIdentifiers) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PersonLegalId->gg;
       e && e->g.tok == zx_hrxml_PersonLegalId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonLegalId(c, (struct zx_hrxml_PersonLegalId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->MilitaryStatus->gg;
       e && e->g.tok == zx_hrxml_MilitaryStatus_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_MilitaryStatus(c, (struct zx_hrxml_MilitaryStatus_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->VisaStatus->gg;
       e && e->g.tok == zx_hrxml_VisaStatus_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_VisaStatus(c, (struct zx_hrxml_VisaStatus_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Citizenship, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Residency, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_LegalIdentifiers) */

int zx_WALK_WO_hrxml_LegalIdentifiers(struct zx_ctx* c, struct zx_hrxml_LegalIdentifiers_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LicenseOrCertification
#define EL_STRUCT zx_hrxml_LicenseOrCertification_s
#define EL_NS     hrxml
#define EL_TAG    LicenseOrCertification

/* FUNC(zx_FREE_hrxml_LicenseOrCertification) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Name, free_strs);
  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  for (e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)e, free_strs);
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }
  for (e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_LicenseOrCertification) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_LicenseOrCertification_s* zx_NEW_hrxml_LicenseOrCertification(struct zx_ctx* c)
{
  struct zx_hrxml_LicenseOrCertification_s* x = ZX_ZALLOC(c, struct zx_hrxml_LicenseOrCertification_s);
  x->gg.g.tok = zx_hrxml_LicenseOrCertification_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_LicenseOrCertification) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Name);
  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->IssuingAuthority->gg;
       se && se->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->EffectiveDate->gg;
       se && se->g.tok == zx_hrxml_EffectiveDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_LicenseOrCertification) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_LicenseOrCertification_s* zx_DEEP_CLONE_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_LicenseOrCertification_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_LicenseOrCertification_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IssuingAuthority(c,(struct zx_hrxml_IssuingAuthority_s*)e,dup_strs);
  	  if (!enn)
  	      x->IssuingAuthority = (struct zx_hrxml_IssuingAuthority_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EffectiveDate(c,(struct zx_hrxml_EffectiveDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EffectiveDate = (struct zx_hrxml_EffectiveDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_LicenseOrCertification) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_LicenseOrCertification) */

int zx_WALK_WO_hrxml_LicenseOrCertification(struct zx_ctx* c, struct zx_hrxml_LicenseOrCertification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LicensesAndCertifications
#define EL_STRUCT zx_hrxml_LicensesAndCertifications_s
#define EL_NS     hrxml
#define EL_TAG    LicensesAndCertifications

/* FUNC(zx_FREE_hrxml_LicensesAndCertifications) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->LicenseOrCertification->gg;
       e && e->g.tok == zx_hrxml_LicenseOrCertification_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LicenseOrCertification(c, (struct zx_hrxml_LicenseOrCertification_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_LicensesAndCertifications) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_LicensesAndCertifications_s* zx_NEW_hrxml_LicensesAndCertifications(struct zx_ctx* c)
{
  struct zx_hrxml_LicensesAndCertifications_s* x = ZX_ZALLOC(c, struct zx_hrxml_LicensesAndCertifications_s);
  x->gg.g.tok = zx_hrxml_LicensesAndCertifications_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_LicensesAndCertifications) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->LicenseOrCertification->gg;
       se && se->g.tok == zx_hrxml_LicenseOrCertification_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LicenseOrCertification(c, (struct zx_hrxml_LicenseOrCertification_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_LicensesAndCertifications) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_LicensesAndCertifications_s* zx_DEEP_CLONE_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_LicensesAndCertifications_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_LicensesAndCertifications_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->LicenseOrCertification->gg;
       e && e->g.tok == zx_hrxml_LicenseOrCertification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LicenseOrCertification(c,(struct zx_hrxml_LicenseOrCertification_s*)e,dup_strs);
  	  if (!enn)
  	      x->LicenseOrCertification = (struct zx_hrxml_LicenseOrCertification_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_LicensesAndCertifications) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->LicenseOrCertification->gg;
       e && e->g.tok == zx_hrxml_LicenseOrCertification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LicenseOrCertification(c, (struct zx_hrxml_LicenseOrCertification_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_LicensesAndCertifications) */

int zx_WALK_WO_hrxml_LicensesAndCertifications(struct zx_ctx* c, struct zx_hrxml_LicensesAndCertifications_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_List
#define EL_STRUCT zx_hrxml_List_s
#define EL_NS     hrxml
#define EL_TAG    List

/* FUNC(zx_FREE_hrxml_List) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Item, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_List) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_List_s* zx_NEW_hrxml_List(struct zx_ctx* c)
{
  struct zx_hrxml_List_s* x = ZX_ZALLOC(c, struct zx_hrxml_List_s);
  x->gg.g.tok = zx_hrxml_List_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_List) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Item);

}

/* FUNC(zx_DEEP_CLONE_hrxml_List) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_List_s* zx_DEEP_CLONE_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_List_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_List_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Item = zx_deep_clone_simple_elems(c,x->Item, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_List) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Item, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_List) */

int zx_WALK_WO_hrxml_List(struct zx_ctx* c, struct zx_hrxml_List_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LocalInstitutionClassification
#define EL_STRUCT zx_hrxml_LocalInstitutionClassification_s
#define EL_NS     hrxml
#define EL_TAG    LocalInstitutionClassification

/* FUNC(zx_FREE_hrxml_LocalInstitutionClassification) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_LocalInstitutionClassification) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_LocalInstitutionClassification_s* zx_NEW_hrxml_LocalInstitutionClassification(struct zx_ctx* c)
{
  struct zx_hrxml_LocalInstitutionClassification_s* x = ZX_ZALLOC(c, struct zx_hrxml_LocalInstitutionClassification_s);
  x->gg.g.tok = zx_hrxml_LocalInstitutionClassification_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_LocalInstitutionClassification) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_LocalInstitutionClassification) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_LocalInstitutionClassification_s* zx_DEEP_CLONE_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_LocalInstitutionClassification_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_LocalInstitutionClassification_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_LocalInstitutionClassification) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_LocalInstitutionClassification) */

int zx_WALK_WO_hrxml_LocalInstitutionClassification(struct zx_ctx* c, struct zx_hrxml_LocalInstitutionClassification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LocationSummary
#define EL_STRUCT zx_hrxml_LocationSummary_s
#define EL_NS     hrxml
#define EL_TAG    LocationSummary

/* FUNC(zx_FREE_hrxml_LocationSummary) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Municipality, free_strs);
  zx_free_simple_elems(c, x->Region, free_strs);
  zx_free_simple_elems(c, x->CountryCode, free_strs);
  zx_free_simple_elems(c, x->PostalCode, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_LocationSummary) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_LocationSummary_s* zx_NEW_hrxml_LocationSummary(struct zx_ctx* c)
{
  struct zx_hrxml_LocationSummary_s* x = ZX_ZALLOC(c, struct zx_hrxml_LocationSummary_s);
  x->gg.g.tok = zx_hrxml_LocationSummary_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_LocationSummary) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Municipality);
  zx_dup_strs_simple_elems(c, x->Region);
  zx_dup_strs_simple_elems(c, x->CountryCode);
  zx_dup_strs_simple_elems(c, x->PostalCode);

}

/* FUNC(zx_DEEP_CLONE_hrxml_LocationSummary) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_LocationSummary_s* zx_DEEP_CLONE_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_LocationSummary_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_LocationSummary_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Municipality = zx_deep_clone_simple_elems(c,x->Municipality, dup_strs);
  x->Region = zx_deep_clone_simple_elems(c,x->Region, dup_strs);
  x->CountryCode = zx_deep_clone_simple_elems(c,x->CountryCode, dup_strs);
  x->PostalCode = zx_deep_clone_simple_elems(c,x->PostalCode, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_LocationSummary) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Municipality, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Region, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->CountryCode, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PostalCode, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_LocationSummary) */

int zx_WALK_WO_hrxml_LocationSummary(struct zx_ctx* c, struct zx_hrxml_LocationSummary_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Longitude
#define EL_STRUCT zx_hrxml_Longitude_s
#define EL_NS     hrxml
#define EL_TAG    Longitude

/* FUNC(zx_FREE_hrxml_Longitude) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Longitude) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Longitude_s* zx_NEW_hrxml_Longitude(struct zx_ctx* c)
{
  struct zx_hrxml_Longitude_s* x = ZX_ZALLOC(c, struct zx_hrxml_Longitude_s);
  x->gg.g.tok = zx_hrxml_Longitude_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Longitude) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_hrxml_Longitude) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Longitude_s* zx_DEEP_CLONE_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Longitude_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Longitude_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Longitude) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Longitude) */

int zx_WALK_WO_hrxml_Longitude(struct zx_ctx* c, struct zx_hrxml_Longitude_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_LowestPossibleValue
#define EL_STRUCT zx_hrxml_LowestPossibleValue_s
#define EL_NS     hrxml
#define EL_TAG    LowestPossibleValue

/* FUNC(zx_FREE_hrxml_LowestPossibleValue) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)e, free_strs);
  }
  for (e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_LowestPossibleValue) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_LowestPossibleValue_s* zx_NEW_hrxml_LowestPossibleValue(struct zx_ctx* c)
{
  struct zx_hrxml_LowestPossibleValue_s* x = ZX_ZALLOC(c, struct zx_hrxml_LowestPossibleValue_s);
  x->gg.g.tok = zx_hrxml_LowestPossibleValue_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_LowestPossibleValue) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->NumericValue->gg;
       se && se->g.tok == zx_hrxml_NumericValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)se);
  for (se = &x->StringValue->gg;
       se && se->g.tok == zx_hrxml_StringValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_LowestPossibleValue) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_LowestPossibleValue_s* zx_DEEP_CLONE_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_LowestPossibleValue_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_LowestPossibleValue_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_NumericValue(c,(struct zx_hrxml_NumericValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->NumericValue = (struct zx_hrxml_NumericValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StringValue(c,(struct zx_hrxml_StringValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->StringValue = (struct zx_hrxml_StringValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_LowestPossibleValue) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->NumericValue->gg;
       e && e->g.tok == zx_hrxml_NumericValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_NumericValue(c, (struct zx_hrxml_NumericValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->StringValue->gg;
       e && e->g.tok == zx_hrxml_StringValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StringValue(c, (struct zx_hrxml_StringValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_LowestPossibleValue) */

int zx_WALK_WO_hrxml_LowestPossibleValue(struct zx_ctx* c, struct zx_hrxml_LowestPossibleValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MatchedObjectId
#define EL_STRUCT zx_hrxml_MatchedObjectId_s
#define EL_NS     hrxml
#define EL_TAG    MatchedObjectId

/* FUNC(zx_FREE_hrxml_MatchedObjectId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_MatchedObjectId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_MatchedObjectId_s* zx_NEW_hrxml_MatchedObjectId(struct zx_ctx* c)
{
  struct zx_hrxml_MatchedObjectId_s* x = ZX_ZALLOC(c, struct zx_hrxml_MatchedObjectId_s);
  x->gg.g.tok = zx_hrxml_MatchedObjectId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_MatchedObjectId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_MatchedObjectId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_MatchedObjectId_s* zx_DEEP_CLONE_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_MatchedObjectId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_MatchedObjectId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_MatchedObjectId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_MatchedObjectId) */

int zx_WALK_WO_hrxml_MatchedObjectId(struct zx_ctx* c, struct zx_hrxml_MatchedObjectId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Measure
#define EL_STRUCT zx_hrxml_Measure_s
#define EL_NS     hrxml
#define EL_TAG    Measure

/* FUNC(zx_FREE_hrxml_Measure) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->measureType, free_strs);

  zx_free_simple_elems(c, x->MeasureSystem, free_strs);
  zx_free_simple_elems(c, x->MeasureValue, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Measure) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Measure_s* zx_NEW_hrxml_Measure(struct zx_ctx* c)
{
  struct zx_hrxml_Measure_s* x = ZX_ZALLOC(c, struct zx_hrxml_Measure_s);
  x->gg.g.tok = zx_hrxml_Measure_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Measure) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->measureType);

  zx_dup_strs_simple_elems(c, x->MeasureSystem);
  zx_dup_strs_simple_elems(c, x->MeasureValue);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Measure) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Measure_s* zx_DEEP_CLONE_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Measure_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Measure_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->measureType = zx_clone_attr(c, x->measureType);

  x->MeasureSystem = zx_deep_clone_simple_elems(c,x->MeasureSystem, dup_strs);
  x->MeasureValue = zx_deep_clone_simple_elems(c,x->MeasureValue, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Measure) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->MeasureSystem, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MeasureValue, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Measure) */

int zx_WALK_WO_hrxml_Measure(struct zx_ctx* c, struct zx_hrxml_Measure_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MilitaryHistory
#define EL_STRUCT zx_hrxml_MilitaryHistory_s
#define EL_NS     hrxml
#define EL_TAG    MilitaryHistory

/* FUNC(zx_FREE_hrxml_MilitaryHistory) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->CountryServed, free_strs);
  for (e = &x->ServiceNumber->gg;
       e && e->g.tok == zx_hrxml_ServiceNumber_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ServiceNumber(c, (struct zx_hrxml_ServiceNumber_s*)e, free_strs);
  }
  for (e = &x->ServiceDetail->gg;
       e && e->g.tok == zx_hrxml_ServiceDetail_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ServiceDetail(c, (struct zx_hrxml_ServiceDetail_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->ServiceStatus, free_strs);
  zx_free_simple_elems(c, x->Comments, free_strs);
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_MilitaryHistory) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_MilitaryHistory_s* zx_NEW_hrxml_MilitaryHistory(struct zx_ctx* c)
{
  struct zx_hrxml_MilitaryHistory_s* x = ZX_ZALLOC(c, struct zx_hrxml_MilitaryHistory_s);
  x->gg.g.tok = zx_hrxml_MilitaryHistory_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_MilitaryHistory) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->CountryServed);
  for (se = &x->ServiceNumber->gg;
       se && se->g.tok == zx_hrxml_ServiceNumber_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ServiceNumber(c, (struct zx_hrxml_ServiceNumber_s*)se);
  for (se = &x->ServiceDetail->gg;
       se && se->g.tok == zx_hrxml_ServiceDetail_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ServiceDetail(c, (struct zx_hrxml_ServiceDetail_s*)se);
  zx_dup_strs_simple_elems(c, x->ServiceStatus);
  zx_dup_strs_simple_elems(c, x->Comments);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_MilitaryHistory) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_MilitaryHistory_s* zx_DEEP_CLONE_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_MilitaryHistory_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_MilitaryHistory_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->CountryServed = zx_deep_clone_simple_elems(c,x->CountryServed, dup_strs);
  for (enn = 0, e = &x->ServiceNumber->gg;
       e && e->g.tok == zx_hrxml_ServiceNumber_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ServiceNumber(c,(struct zx_hrxml_ServiceNumber_s*)e,dup_strs);
  	  if (!enn)
  	      x->ServiceNumber = (struct zx_hrxml_ServiceNumber_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ServiceDetail->gg;
       e && e->g.tok == zx_hrxml_ServiceDetail_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ServiceDetail(c,(struct zx_hrxml_ServiceDetail_s*)e,dup_strs);
  	  if (!enn)
  	      x->ServiceDetail = (struct zx_hrxml_ServiceDetail_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->ServiceStatus = zx_deep_clone_simple_elems(c,x->ServiceStatus, dup_strs);
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_MilitaryHistory) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->CountryServed, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->ServiceNumber->gg;
       e && e->g.tok == zx_hrxml_ServiceNumber_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ServiceNumber(c, (struct zx_hrxml_ServiceNumber_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ServiceDetail->gg;
       e && e->g.tok == zx_hrxml_ServiceDetail_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ServiceDetail(c, (struct zx_hrxml_ServiceDetail_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->ServiceStatus, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_MilitaryHistory) */

int zx_WALK_WO_hrxml_MilitaryHistory(struct zx_ctx* c, struct zx_hrxml_MilitaryHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MilitaryStatus
#define EL_STRUCT zx_hrxml_MilitaryStatus_s
#define EL_NS     hrxml
#define EL_TAG    MilitaryStatus

/* FUNC(zx_FREE_hrxml_MilitaryStatus) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_MilitaryStatus) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_MilitaryStatus_s* zx_NEW_hrxml_MilitaryStatus(struct zx_ctx* c)
{
  struct zx_hrxml_MilitaryStatus_s* x = ZX_ZALLOC(c, struct zx_hrxml_MilitaryStatus_s);
  x->gg.g.tok = zx_hrxml_MilitaryStatus_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_MilitaryStatus) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_hrxml_MilitaryStatus) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_MilitaryStatus_s* zx_DEEP_CLONE_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_MilitaryStatus_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_MilitaryStatus_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_MilitaryStatus) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_MilitaryStatus) */

int zx_WALK_WO_hrxml_MilitaryStatus(struct zx_ctx* c, struct zx_hrxml_MilitaryStatus_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Mobile
#define EL_STRUCT zx_hrxml_Mobile_s
#define EL_NS     hrxml
#define EL_TAG    Mobile

/* FUNC(zx_FREE_hrxml_Mobile) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->smsEnabled, free_strs);

  zx_free_simple_elems(c, x->FormattedNumber, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Mobile) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Mobile_s* zx_NEW_hrxml_Mobile(struct zx_ctx* c)
{
  struct zx_hrxml_Mobile_s* x = ZX_ZALLOC(c, struct zx_hrxml_Mobile_s);
  x->gg.g.tok = zx_hrxml_Mobile_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Mobile) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->smsEnabled);

  zx_dup_strs_simple_elems(c, x->FormattedNumber);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Mobile) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Mobile_s* zx_DEEP_CLONE_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Mobile_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Mobile_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->smsEnabled = zx_clone_attr(c, x->smsEnabled);

  x->FormattedNumber = zx_deep_clone_simple_elems(c,x->FormattedNumber, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Mobile) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->FormattedNumber, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Mobile) */

int zx_WALK_WO_hrxml_Mobile(struct zx_ctx* c, struct zx_hrxml_Mobile_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_MostRecentDate
#define EL_STRUCT zx_hrxml_MostRecentDate_s
#define EL_NS     hrxml
#define EL_TAG    MostRecentDate

/* FUNC(zx_FREE_hrxml_MostRecentDate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateDescription, free_strs);

  zx_free_simple_elems(c, x->AnyDate, free_strs);
  zx_free_simple_elems(c, x->YearMonth, free_strs);
  zx_free_simple_elems(c, x->Year, free_strs);
  zx_free_simple_elems(c, x->MonthDay, free_strs);
  zx_free_simple_elems(c, x->StringDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_MostRecentDate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_MostRecentDate_s* zx_NEW_hrxml_MostRecentDate(struct zx_ctx* c)
{
  struct zx_hrxml_MostRecentDate_s* x = ZX_ZALLOC(c, struct zx_hrxml_MostRecentDate_s);
  x->gg.g.tok = zx_hrxml_MostRecentDate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_MostRecentDate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateDescription);

  zx_dup_strs_simple_elems(c, x->AnyDate);
  zx_dup_strs_simple_elems(c, x->YearMonth);
  zx_dup_strs_simple_elems(c, x->Year);
  zx_dup_strs_simple_elems(c, x->MonthDay);
  zx_dup_strs_simple_elems(c, x->StringDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_MostRecentDate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_MostRecentDate_s* zx_DEEP_CLONE_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_MostRecentDate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_MostRecentDate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateDescription = zx_clone_attr(c, x->dateDescription);

  x->AnyDate = zx_deep_clone_simple_elems(c,x->AnyDate, dup_strs);
  x->YearMonth = zx_deep_clone_simple_elems(c,x->YearMonth, dup_strs);
  x->Year = zx_deep_clone_simple_elems(c,x->Year, dup_strs);
  x->MonthDay = zx_deep_clone_simple_elems(c,x->MonthDay, dup_strs);
  x->StringDate = zx_deep_clone_simple_elems(c,x->StringDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_MostRecentDate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AnyDate, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->YearMonth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Year, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDay, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StringDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_MostRecentDate) */

int zx_WALK_WO_hrxml_MostRecentDate(struct zx_ctx* c, struct zx_hrxml_MostRecentDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_NonXMLResume
#define EL_STRUCT zx_hrxml_NonXMLResume_s
#define EL_NS     hrxml
#define EL_TAG    NonXMLResume

/* FUNC(zx_FREE_hrxml_NonXMLResume) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->TextResume, free_strs);
  zx_free_simple_elems(c, x->LinkToResume, free_strs);
  for (e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);
  zx_free_simple_elems(c, x->RevisionDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_NonXMLResume) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_NonXMLResume_s* zx_NEW_hrxml_NonXMLResume(struct zx_ctx* c)
{
  struct zx_hrxml_NonXMLResume_s* x = ZX_ZALLOC(c, struct zx_hrxml_NonXMLResume_s);
  x->gg.g.tok = zx_hrxml_NonXMLResume_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_NonXMLResume) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->TextResume);
  zx_dup_strs_simple_elems(c, x->LinkToResume);
  for (se = &x->SupportingMaterials->gg;
       se && se->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);
  zx_dup_strs_simple_elems(c, x->RevisionDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_NonXMLResume) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_NonXMLResume_s* zx_DEEP_CLONE_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_NonXMLResume_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_NonXMLResume_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->TextResume = zx_deep_clone_simple_elems(c,x->TextResume, dup_strs);
  x->LinkToResume = zx_deep_clone_simple_elems(c,x->LinkToResume, dup_strs);
  for (enn = 0, e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SupportingMaterials(c,(struct zx_hrxml_SupportingMaterials_s*)e,dup_strs);
  	  if (!enn)
  	      x->SupportingMaterials = (struct zx_hrxml_SupportingMaterials_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  x->RevisionDate = zx_deep_clone_simple_elems(c,x->RevisionDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_NonXMLResume) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->TextResume, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->LinkToResume, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->RevisionDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_NonXMLResume) */

int zx_WALK_WO_hrxml_NonXMLResume(struct zx_ctx* c, struct zx_hrxml_NonXMLResume_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_NumericValue
#define EL_STRUCT zx_hrxml_NumericValue_s
#define EL_NS     hrxml
#define EL_TAG    NumericValue

/* FUNC(zx_FREE_hrxml_NumericValue) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->description, free_strs);
  zx_free_attr(c, x->interval, free_strs);
  zx_free_attr(c, x->maxValue, free_strs);
  zx_free_attr(c, x->minValue, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_NumericValue) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_NumericValue_s* zx_NEW_hrxml_NumericValue(struct zx_ctx* c)
{
  struct zx_hrxml_NumericValue_s* x = ZX_ZALLOC(c, struct zx_hrxml_NumericValue_s);
  x->gg.g.tok = zx_hrxml_NumericValue_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_NumericValue) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->description);
  zx_dup_attr(c, x->interval);
  zx_dup_attr(c, x->maxValue);
  zx_dup_attr(c, x->minValue);


}

/* FUNC(zx_DEEP_CLONE_hrxml_NumericValue) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_NumericValue_s* zx_DEEP_CLONE_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_NumericValue_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_NumericValue_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->description = zx_clone_attr(c, x->description);
  x->interval = zx_clone_attr(c, x->interval);
  x->maxValue = zx_clone_attr(c, x->maxValue);
  x->minValue = zx_clone_attr(c, x->minValue);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_NumericValue) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_NumericValue) */

int zx_WALK_WO_hrxml_NumericValue(struct zx_ctx* c, struct zx_hrxml_NumericValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrgIndustry
#define EL_STRUCT zx_hrxml_OrgIndustry_s
#define EL_NS     hrxml
#define EL_TAG    OrgIndustry

/* FUNC(zx_FREE_hrxml_OrgIndustry) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->primaryIndicator, free_strs);

  zx_free_simple_elems(c, x->IndustryDescription, free_strs);
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OrgIndustry) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OrgIndustry_s* zx_NEW_hrxml_OrgIndustry(struct zx_ctx* c)
{
  struct zx_hrxml_OrgIndustry_s* x = ZX_ZALLOC(c, struct zx_hrxml_OrgIndustry_s);
  x->gg.g.tok = zx_hrxml_OrgIndustry_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OrgIndustry) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->primaryIndicator);

  zx_dup_strs_simple_elems(c, x->IndustryDescription);
  for (se = &x->IndustryCode->gg;
       se && se->g.tok == zx_hrxml_IndustryCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_OrgIndustry) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OrgIndustry_s* zx_DEEP_CLONE_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OrgIndustry_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OrgIndustry_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->primaryIndicator = zx_clone_attr(c, x->primaryIndicator);

  x->IndustryDescription = zx_deep_clone_simple_elems(c,x->IndustryDescription, dup_strs);
  for (enn = 0, e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IndustryCode(c,(struct zx_hrxml_IndustryCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->IndustryCode = (struct zx_hrxml_IndustryCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OrgIndustry) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->IndustryDescription, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OrgIndustry) */

int zx_WALK_WO_hrxml_OrgIndustry(struct zx_ctx* c, struct zx_hrxml_OrgIndustry_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrgInfo
#define EL_STRUCT zx_hrxml_OrgInfo_s
#define EL_NS     hrxml
#define EL_TAG    OrgInfo

/* FUNC(zx_FREE_hrxml_OrgInfo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PositionLocation->gg;
       e && e->g.tok == zx_hrxml_PositionLocation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PositionLocation(c, (struct zx_hrxml_PositionLocation_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->WebSite, free_strs);
  for (e = &x->LocationSummary->gg;
       e && e->g.tok == zx_hrxml_LocationSummary_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OrgInfo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OrgInfo_s* zx_NEW_hrxml_OrgInfo(struct zx_ctx* c)
{
  struct zx_hrxml_OrgInfo_s* x = ZX_ZALLOC(c, struct zx_hrxml_OrgInfo_s);
  x->gg.g.tok = zx_hrxml_OrgInfo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OrgInfo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PositionLocation->gg;
       se && se->g.tok == zx_hrxml_PositionLocation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PositionLocation(c, (struct zx_hrxml_PositionLocation_s*)se);
  zx_dup_strs_simple_elems(c, x->WebSite);
  for (se = &x->LocationSummary->gg;
       se && se->g.tok == zx_hrxml_LocationSummary_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_OrgInfo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OrgInfo_s* zx_DEEP_CLONE_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OrgInfo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OrgInfo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PositionLocation->gg;
       e && e->g.tok == zx_hrxml_PositionLocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PositionLocation(c,(struct zx_hrxml_PositionLocation_s*)e,dup_strs);
  	  if (!enn)
  	      x->PositionLocation = (struct zx_hrxml_PositionLocation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->WebSite = zx_deep_clone_simple_elems(c,x->WebSite, dup_strs);
  for (enn = 0, e = &x->LocationSummary->gg;
       e && e->g.tok == zx_hrxml_LocationSummary_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LocationSummary(c,(struct zx_hrxml_LocationSummary_s*)e,dup_strs);
  	  if (!enn)
  	      x->LocationSummary = (struct zx_hrxml_LocationSummary_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OrgInfo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PositionLocation->gg;
       e && e->g.tok == zx_hrxml_PositionLocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PositionLocation(c, (struct zx_hrxml_PositionLocation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->WebSite, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->LocationSummary->gg;
       e && e->g.tok == zx_hrxml_LocationSummary_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OrgInfo) */

int zx_WALK_WO_hrxml_OrgInfo(struct zx_ctx* c, struct zx_hrxml_OrgInfo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrgName
#define EL_STRUCT zx_hrxml_OrgName_s
#define EL_NS     hrxml
#define EL_TAG    OrgName

/* FUNC(zx_FREE_hrxml_OrgName) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->organizationType, free_strs);

  zx_free_simple_elems(c, x->OrganizationName, free_strs);
  for (e = &x->OrgName->gg;
       e && e->g.tok == zx_hrxml_OrgName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrgName(c, (struct zx_hrxml_OrgName_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OrgName) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OrgName_s* zx_NEW_hrxml_OrgName(struct zx_ctx* c)
{
  struct zx_hrxml_OrgName_s* x = ZX_ZALLOC(c, struct zx_hrxml_OrgName_s);
  x->gg.g.tok = zx_hrxml_OrgName_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OrgName) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->organizationType);

  zx_dup_strs_simple_elems(c, x->OrganizationName);
  for (se = &x->OrgName->gg;
       se && se->g.tok == zx_hrxml_OrgName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrgName(c, (struct zx_hrxml_OrgName_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_OrgName) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OrgName_s* zx_DEEP_CLONE_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OrgName_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OrgName_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->organizationType = zx_clone_attr(c, x->organizationType);

  x->OrganizationName = zx_deep_clone_simple_elems(c,x->OrganizationName, dup_strs);
  for (enn = 0, e = &x->OrgName->gg;
       e && e->g.tok == zx_hrxml_OrgName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrgName(c,(struct zx_hrxml_OrgName_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrgName = (struct zx_hrxml_OrgName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OrgName) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->OrganizationName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->OrgName->gg;
       e && e->g.tok == zx_hrxml_OrgName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrgName(c, (struct zx_hrxml_OrgName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OrgName) */

int zx_WALK_WO_hrxml_OrgName(struct zx_ctx* c, struct zx_hrxml_OrgName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Organization
#define EL_STRUCT zx_hrxml_Organization_s
#define EL_NS     hrxml
#define EL_TAG    Organization

/* FUNC(zx_FREE_hrxml_Organization) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Organization) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Organization_s* zx_NEW_hrxml_Organization(struct zx_ctx* c)
{
  struct zx_hrxml_Organization_s* x = ZX_ZALLOC(c, struct zx_hrxml_Organization_s);
  x->gg.g.tok = zx_hrxml_Organization_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Organization) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_hrxml_Organization) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Organization_s* zx_DEEP_CLONE_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Organization_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Organization_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Organization) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Organization) */

int zx_WALK_WO_hrxml_Organization(struct zx_ctx* c, struct zx_hrxml_Organization_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationId
#define EL_STRUCT zx_hrxml_OrganizationId_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationId

/* FUNC(zx_FREE_hrxml_OrganizationId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OrganizationId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OrganizationId_s* zx_NEW_hrxml_OrganizationId(struct zx_ctx* c)
{
  struct zx_hrxml_OrganizationId_s* x = ZX_ZALLOC(c, struct zx_hrxml_OrganizationId_s);
  x->gg.g.tok = zx_hrxml_OrganizationId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OrganizationId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_OrganizationId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OrganizationId_s* zx_DEEP_CLONE_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OrganizationId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OrganizationId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OrganizationId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OrganizationId) */

int zx_WALK_WO_hrxml_OrganizationId(struct zx_ctx* c, struct zx_hrxml_OrganizationId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationUnit
#define EL_STRUCT zx_hrxml_OrganizationUnit_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationUnit

/* FUNC(zx_FREE_hrxml_OrganizationUnit) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->attendanceStatus, free_strs);
  zx_free_attr(c, x->organizationType, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OrganizationUnit) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OrganizationUnit_s* zx_NEW_hrxml_OrganizationUnit(struct zx_ctx* c)
{
  struct zx_hrxml_OrganizationUnit_s* x = ZX_ZALLOC(c, struct zx_hrxml_OrganizationUnit_s);
  x->gg.g.tok = zx_hrxml_OrganizationUnit_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OrganizationUnit) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->attendanceStatus);
  zx_dup_attr(c, x->organizationType);


}

/* FUNC(zx_DEEP_CLONE_hrxml_OrganizationUnit) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OrganizationUnit_s* zx_DEEP_CLONE_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OrganizationUnit_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OrganizationUnit_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->attendanceStatus = zx_clone_attr(c, x->attendanceStatus);
  x->organizationType = zx_clone_attr(c, x->organizationType);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OrganizationUnit) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OrganizationUnit) */

int zx_WALK_WO_hrxml_OrganizationUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationUnit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationalUnit
#define EL_STRUCT zx_hrxml_OrganizationalUnit_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationalUnit

/* FUNC(zx_FREE_hrxml_OrganizationalUnit) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->hierarchicalRole, free_strs);
  zx_free_attr(c, x->typeOfGroup, free_strs);

  zx_free_simple_elems(c, x->OrganizationalUnitName, free_strs);
  for (e = &x->OrganizationalUnitId->gg;
       e && e->g.tok == zx_hrxml_OrganizationalUnitId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrganizationalUnitId(c, (struct zx_hrxml_OrganizationalUnitId_s*)e, free_strs);
  }
  for (e = &x->OrganizationId->gg;
       e && e->g.tok == zx_hrxml_OrganizationId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)e, free_strs);
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, free_strs);
  }
  for (e = &x->AccountingCode->gg;
       e && e->g.tok == zx_hrxml_AccountingCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_AccountingCode(c, (struct zx_hrxml_AccountingCode_s*)e, free_strs);
  }
  for (e = &x->WorkSite->gg;
       e && e->g.tok == zx_hrxml_WorkSite_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)e, free_strs);
  }
  for (e = &x->RelatedOrganizationalUnit->gg;
       e && e->g.tok == zx_hrxml_RelatedOrganizationalUnit_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RelatedOrganizationalUnit(c, (struct zx_hrxml_RelatedOrganizationalUnit_s*)e, free_strs);
  }
  for (e = &x->PersonMember->gg;
       e && e->g.tok == zx_hrxml_PersonMember_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonMember(c, (struct zx_hrxml_PersonMember_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OrganizationalUnit) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OrganizationalUnit_s* zx_NEW_hrxml_OrganizationalUnit(struct zx_ctx* c)
{
  struct zx_hrxml_OrganizationalUnit_s* x = ZX_ZALLOC(c, struct zx_hrxml_OrganizationalUnit_s);
  x->gg.g.tok = zx_hrxml_OrganizationalUnit_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OrganizationalUnit) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->hierarchicalRole);
  zx_dup_attr(c, x->typeOfGroup);

  zx_dup_strs_simple_elems(c, x->OrganizationalUnitName);
  for (se = &x->OrganizationalUnitId->gg;
       se && se->g.tok == zx_hrxml_OrganizationalUnitId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrganizationalUnitId(c, (struct zx_hrxml_OrganizationalUnitId_s*)se);
  for (se = &x->OrganizationId->gg;
       se && se->g.tok == zx_hrxml_OrganizationId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)se);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->IndustryCode->gg;
       se && se->g.tok == zx_hrxml_IndustryCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);
  for (se = &x->AccountingCode->gg;
       se && se->g.tok == zx_hrxml_AccountingCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_AccountingCode(c, (struct zx_hrxml_AccountingCode_s*)se);
  for (se = &x->WorkSite->gg;
       se && se->g.tok == zx_hrxml_WorkSite_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)se);
  for (se = &x->RelatedOrganizationalUnit->gg;
       se && se->g.tok == zx_hrxml_RelatedOrganizationalUnit_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RelatedOrganizationalUnit(c, (struct zx_hrxml_RelatedOrganizationalUnit_s*)se);
  for (se = &x->PersonMember->gg;
       se && se->g.tok == zx_hrxml_PersonMember_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonMember(c, (struct zx_hrxml_PersonMember_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_OrganizationalUnit) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OrganizationalUnit_s* zx_DEEP_CLONE_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OrganizationalUnit_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OrganizationalUnit_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->hierarchicalRole = zx_clone_attr(c, x->hierarchicalRole);
  x->typeOfGroup = zx_clone_attr(c, x->typeOfGroup);

  x->OrganizationalUnitName = zx_deep_clone_simple_elems(c,x->OrganizationalUnitName, dup_strs);
  for (enn = 0, e = &x->OrganizationalUnitId->gg;
       e && e->g.tok == zx_hrxml_OrganizationalUnitId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrganizationalUnitId(c,(struct zx_hrxml_OrganizationalUnitId_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrganizationalUnitId = (struct zx_hrxml_OrganizationalUnitId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OrganizationId->gg;
       e && e->g.tok == zx_hrxml_OrganizationId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrganizationId(c,(struct zx_hrxml_OrganizationId_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrganizationId = (struct zx_hrxml_OrganizationId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IndustryCode(c,(struct zx_hrxml_IndustryCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->IndustryCode = (struct zx_hrxml_IndustryCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AccountingCode->gg;
       e && e->g.tok == zx_hrxml_AccountingCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_AccountingCode(c,(struct zx_hrxml_AccountingCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->AccountingCode = (struct zx_hrxml_AccountingCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->WorkSite->gg;
       e && e->g.tok == zx_hrxml_WorkSite_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_WorkSite(c,(struct zx_hrxml_WorkSite_s*)e,dup_strs);
  	  if (!enn)
  	      x->WorkSite = (struct zx_hrxml_WorkSite_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RelatedOrganizationalUnit->gg;
       e && e->g.tok == zx_hrxml_RelatedOrganizationalUnit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RelatedOrganizationalUnit(c,(struct zx_hrxml_RelatedOrganizationalUnit_s*)e,dup_strs);
  	  if (!enn)
  	      x->RelatedOrganizationalUnit = (struct zx_hrxml_RelatedOrganizationalUnit_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PersonMember->gg;
       e && e->g.tok == zx_hrxml_PersonMember_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonMember(c,(struct zx_hrxml_PersonMember_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonMember = (struct zx_hrxml_PersonMember_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OrganizationalUnit) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->OrganizationalUnitName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->OrganizationalUnitId->gg;
       e && e->g.tok == zx_hrxml_OrganizationalUnitId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrganizationalUnitId(c, (struct zx_hrxml_OrganizationalUnitId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OrganizationId->gg;
       e && e->g.tok == zx_hrxml_OrganizationId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AccountingCode->gg;
       e && e->g.tok == zx_hrxml_AccountingCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_AccountingCode(c, (struct zx_hrxml_AccountingCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->WorkSite->gg;
       e && e->g.tok == zx_hrxml_WorkSite_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RelatedOrganizationalUnit->gg;
       e && e->g.tok == zx_hrxml_RelatedOrganizationalUnit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RelatedOrganizationalUnit(c, (struct zx_hrxml_RelatedOrganizationalUnit_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PersonMember->gg;
       e && e->g.tok == zx_hrxml_PersonMember_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonMember(c, (struct zx_hrxml_PersonMember_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OrganizationalUnit) */

int zx_WALK_WO_hrxml_OrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OrganizationalUnitId
#define EL_STRUCT zx_hrxml_OrganizationalUnitId_s
#define EL_NS     hrxml
#define EL_TAG    OrganizationalUnitId

/* FUNC(zx_FREE_hrxml_OrganizationalUnitId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OrganizationalUnitId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OrganizationalUnitId_s* zx_NEW_hrxml_OrganizationalUnitId(struct zx_ctx* c)
{
  struct zx_hrxml_OrganizationalUnitId_s* x = ZX_ZALLOC(c, struct zx_hrxml_OrganizationalUnitId_s);
  x->gg.g.tok = zx_hrxml_OrganizationalUnitId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OrganizationalUnitId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_OrganizationalUnitId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OrganizationalUnitId_s* zx_DEEP_CLONE_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OrganizationalUnitId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OrganizationalUnitId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OrganizationalUnitId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OrganizationalUnitId) */

int zx_WALK_WO_hrxml_OrganizationalUnitId(struct zx_ctx* c, struct zx_hrxml_OrganizationalUnitId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OriginalDate
#define EL_STRUCT zx_hrxml_OriginalDate_s
#define EL_NS     hrxml
#define EL_TAG    OriginalDate

/* FUNC(zx_FREE_hrxml_OriginalDate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateDescription, free_strs);

  zx_free_simple_elems(c, x->AnyDate, free_strs);
  zx_free_simple_elems(c, x->YearMonth, free_strs);
  zx_free_simple_elems(c, x->Year, free_strs);
  zx_free_simple_elems(c, x->MonthDay, free_strs);
  zx_free_simple_elems(c, x->StringDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OriginalDate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OriginalDate_s* zx_NEW_hrxml_OriginalDate(struct zx_ctx* c)
{
  struct zx_hrxml_OriginalDate_s* x = ZX_ZALLOC(c, struct zx_hrxml_OriginalDate_s);
  x->gg.g.tok = zx_hrxml_OriginalDate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OriginalDate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateDescription);

  zx_dup_strs_simple_elems(c, x->AnyDate);
  zx_dup_strs_simple_elems(c, x->YearMonth);
  zx_dup_strs_simple_elems(c, x->Year);
  zx_dup_strs_simple_elems(c, x->MonthDay);
  zx_dup_strs_simple_elems(c, x->StringDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_OriginalDate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OriginalDate_s* zx_DEEP_CLONE_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OriginalDate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OriginalDate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateDescription = zx_clone_attr(c, x->dateDescription);

  x->AnyDate = zx_deep_clone_simple_elems(c,x->AnyDate, dup_strs);
  x->YearMonth = zx_deep_clone_simple_elems(c,x->YearMonth, dup_strs);
  x->Year = zx_deep_clone_simple_elems(c,x->Year, dup_strs);
  x->MonthDay = zx_deep_clone_simple_elems(c,x->MonthDay, dup_strs);
  x->StringDate = zx_deep_clone_simple_elems(c,x->StringDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OriginalDate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AnyDate, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->YearMonth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Year, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDay, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StringDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OriginalDate) */

int zx_WALK_WO_hrxml_OriginalDate(struct zx_ctx* c, struct zx_hrxml_OriginalDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherBenefits
#define EL_STRUCT zx_hrxml_OtherBenefits_s
#define EL_NS     hrxml
#define EL_TAG    OtherBenefits

/* FUNC(zx_FREE_hrxml_OtherBenefits) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OtherBenefits) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OtherBenefits_s* zx_NEW_hrxml_OtherBenefits(struct zx_ctx* c)
{
  struct zx_hrxml_OtherBenefits_s* x = ZX_ZALLOC(c, struct zx_hrxml_OtherBenefits_s);
  x->gg.g.tok = zx_hrxml_OtherBenefits_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OtherBenefits) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_hrxml_OtherBenefits) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OtherBenefits_s* zx_DEEP_CLONE_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OtherBenefits_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OtherBenefits_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OtherBenefits) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OtherBenefits) */

int zx_WALK_WO_hrxml_OtherBenefits(struct zx_ctx* c, struct zx_hrxml_OtherBenefits_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherCompensation
#define EL_STRUCT zx_hrxml_OtherCompensation_s
#define EL_NS     hrxml
#define EL_TAG    OtherCompensation

/* FUNC(zx_FREE_hrxml_OtherCompensation) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OtherCompensation) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OtherCompensation_s* zx_NEW_hrxml_OtherCompensation(struct zx_ctx* c)
{
  struct zx_hrxml_OtherCompensation_s* x = ZX_ZALLOC(c, struct zx_hrxml_OtherCompensation_s);
  x->gg.g.tok = zx_hrxml_OtherCompensation_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OtherCompensation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);


}

/* FUNC(zx_DEEP_CLONE_hrxml_OtherCompensation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OtherCompensation_s* zx_DEEP_CLONE_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OtherCompensation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OtherCompensation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OtherCompensation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OtherCompensation) */

int zx_WALK_WO_hrxml_OtherCompensation(struct zx_ctx* c, struct zx_hrxml_OtherCompensation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherDescriptors
#define EL_STRUCT zx_hrxml_OtherDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    OtherDescriptors

/* FUNC(zx_FREE_hrxml_OtherDescriptors) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Name, free_strs);
  zx_free_simple_elems(c, x->Applicable, free_strs);
  zx_free_simple_elems(c, x->Value, free_strs);
  for (e = &x->List->gg;
       e && e->g.tok == zx_hrxml_List_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_List(c, (struct zx_hrxml_List_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OtherDescriptors) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OtherDescriptors_s* zx_NEW_hrxml_OtherDescriptors(struct zx_ctx* c)
{
  struct zx_hrxml_OtherDescriptors_s* x = ZX_ZALLOC(c, struct zx_hrxml_OtherDescriptors_s);
  x->gg.g.tok = zx_hrxml_OtherDescriptors_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OtherDescriptors) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Name);
  zx_dup_strs_simple_elems(c, x->Applicable);
  zx_dup_strs_simple_elems(c, x->Value);
  for (se = &x->List->gg;
       se && se->g.tok == zx_hrxml_List_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_List(c, (struct zx_hrxml_List_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_OtherDescriptors) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OtherDescriptors_s* zx_DEEP_CLONE_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OtherDescriptors_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OtherDescriptors_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  x->Applicable = zx_deep_clone_simple_elems(c,x->Applicable, dup_strs);
  x->Value = zx_deep_clone_simple_elems(c,x->Value, dup_strs);
  for (enn = 0, e = &x->List->gg;
       e && e->g.tok == zx_hrxml_List_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_List(c,(struct zx_hrxml_List_s*)e,dup_strs);
  	  if (!enn)
  	      x->List = (struct zx_hrxml_List_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OtherDescriptors) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Applicable, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Value, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->List->gg;
       e && e->g.tok == zx_hrxml_List_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_List(c, (struct zx_hrxml_List_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OtherDescriptors) */

int zx_WALK_WO_hrxml_OtherDescriptors(struct zx_ctx* c, struct zx_hrxml_OtherDescriptors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherHonors
#define EL_STRUCT zx_hrxml_OtherHonors_s
#define EL_NS     hrxml
#define EL_TAG    OtherHonors

/* FUNC(zx_FREE_hrxml_OtherHonors) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OtherHonors) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OtherHonors_s* zx_NEW_hrxml_OtherHonors(struct zx_ctx* c)
{
  struct zx_hrxml_OtherHonors_s* x = ZX_ZALLOC(c, struct zx_hrxml_OtherHonors_s);
  x->gg.g.tok = zx_hrxml_OtherHonors_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OtherHonors) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);


}

/* FUNC(zx_DEEP_CLONE_hrxml_OtherHonors) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OtherHonors_s* zx_DEEP_CLONE_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OtherHonors_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OtherHonors_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OtherHonors) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OtherHonors) */

int zx_WALK_WO_hrxml_OtherHonors(struct zx_ctx* c, struct zx_hrxml_OtherHonors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherPay
#define EL_STRUCT zx_hrxml_OtherPay_s
#define EL_NS     hrxml
#define EL_TAG    OtherPay

/* FUNC(zx_FREE_hrxml_OtherPay) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->currencyCode, free_strs);
  zx_free_attr(c, x->otherInterval, free_strs);
  zx_free_attr(c, x->otherPayType, free_strs);

  zx_free_simple_elems(c, x->OtherPayAmountMin, free_strs);
  zx_free_simple_elems(c, x->OtherPayAmountMax, free_strs);
  zx_free_simple_elems(c, x->OtherPayCalculation, free_strs);
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OtherPay) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OtherPay_s* zx_NEW_hrxml_OtherPay(struct zx_ctx* c)
{
  struct zx_hrxml_OtherPay_s* x = ZX_ZALLOC(c, struct zx_hrxml_OtherPay_s);
  x->gg.g.tok = zx_hrxml_OtherPay_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OtherPay) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->currencyCode);
  zx_dup_attr(c, x->otherInterval);
  zx_dup_attr(c, x->otherPayType);

  zx_dup_strs_simple_elems(c, x->OtherPayAmountMin);
  zx_dup_strs_simple_elems(c, x->OtherPayAmountMax);
  zx_dup_strs_simple_elems(c, x->OtherPayCalculation);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_OtherPay) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OtherPay_s* zx_DEEP_CLONE_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OtherPay_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OtherPay_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->currencyCode = zx_clone_attr(c, x->currencyCode);
  x->otherInterval = zx_clone_attr(c, x->otherInterval);
  x->otherPayType = zx_clone_attr(c, x->otherPayType);

  x->OtherPayAmountMin = zx_deep_clone_simple_elems(c,x->OtherPayAmountMin, dup_strs);
  x->OtherPayAmountMax = zx_deep_clone_simple_elems(c,x->OtherPayAmountMax, dup_strs);
  x->OtherPayCalculation = zx_deep_clone_simple_elems(c,x->OtherPayCalculation, dup_strs);
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OtherPay) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->OtherPayAmountMin, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->OtherPayAmountMax, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->OtherPayCalculation, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OtherPay) */

int zx_WALK_WO_hrxml_OtherPay(struct zx_ctx* c, struct zx_hrxml_OtherPay_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_OtherPublication
#define EL_STRUCT zx_hrxml_OtherPublication_s
#define EL_NS     hrxml
#define EL_TAG    OtherPublication

/* FUNC(zx_FREE_hrxml_OtherPublication) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);

  zx_free_simple_elems(c, x->Title, free_strs);
  zx_free_simple_elems(c, x->Name, free_strs);
  for (e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Link, free_strs);
  zx_free_simple_elems(c, x->Abstract, free_strs);
  for (e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);
  zx_free_simple_elems(c, x->ISSN, free_strs);
  zx_free_simple_elems(c, x->ISBN, free_strs);
  zx_free_simple_elems(c, x->NumberOfPages, free_strs);
  zx_free_simple_elems(c, x->PublisherName, free_strs);
  zx_free_simple_elems(c, x->PublisherLocation, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_OtherPublication) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_OtherPublication_s* zx_NEW_hrxml_OtherPublication(struct zx_ctx* c)
{
  struct zx_hrxml_OtherPublication_s* x = ZX_ZALLOC(c, struct zx_hrxml_OtherPublication_s);
  x->gg.g.tok = zx_hrxml_OtherPublication_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_OtherPublication) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);

  zx_dup_strs_simple_elems(c, x->Title);
  zx_dup_strs_simple_elems(c, x->Name);
  for (se = &x->PublicationDate->gg;
       se && se->g.tok == zx_hrxml_PublicationDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)se);
  zx_dup_strs_simple_elems(c, x->Link);
  zx_dup_strs_simple_elems(c, x->Abstract);
  for (se = &x->Copyright->gg;
       se && se->g.tok == zx_hrxml_Copyright_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);
  zx_dup_strs_simple_elems(c, x->ISSN);
  zx_dup_strs_simple_elems(c, x->ISBN);
  zx_dup_strs_simple_elems(c, x->NumberOfPages);
  zx_dup_strs_simple_elems(c, x->PublisherName);
  zx_dup_strs_simple_elems(c, x->PublisherLocation);

}

/* FUNC(zx_DEEP_CLONE_hrxml_OtherPublication) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_OtherPublication_s* zx_DEEP_CLONE_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_OtherPublication_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_OtherPublication_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);

  x->Title = zx_deep_clone_simple_elems(c,x->Title, dup_strs);
  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  for (enn = 0, e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PublicationDate(c,(struct zx_hrxml_PublicationDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->PublicationDate = (struct zx_hrxml_PublicationDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Link = zx_deep_clone_simple_elems(c,x->Link, dup_strs);
  x->Abstract = zx_deep_clone_simple_elems(c,x->Abstract, dup_strs);
  for (enn = 0, e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Copyright(c,(struct zx_hrxml_Copyright_s*)e,dup_strs);
  	  if (!enn)
  	      x->Copyright = (struct zx_hrxml_Copyright_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  x->ISSN = zx_deep_clone_simple_elems(c,x->ISSN, dup_strs);
  x->ISBN = zx_deep_clone_simple_elems(c,x->ISBN, dup_strs);
  x->NumberOfPages = zx_deep_clone_simple_elems(c,x->NumberOfPages, dup_strs);
  x->PublisherName = zx_deep_clone_simple_elems(c,x->PublisherName, dup_strs);
  x->PublisherLocation = zx_deep_clone_simple_elems(c,x->PublisherLocation, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_OtherPublication) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Title, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PublicationDate->gg;
       e && e->g.tok == zx_hrxml_PublicationDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PublicationDate(c, (struct zx_hrxml_PublicationDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Link, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Abstract, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Copyright->gg;
       e && e->g.tok == zx_hrxml_Copyright_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Copyright(c, (struct zx_hrxml_Copyright_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->ISSN, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->ISBN, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->NumberOfPages, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PublisherName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PublisherLocation, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_OtherPublication) */

int zx_WALK_WO_hrxml_OtherPublication(struct zx_ctx* c, struct zx_hrxml_OtherPublication_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Pager
#define EL_STRUCT zx_hrxml_Pager_s
#define EL_NS     hrxml
#define EL_TAG    Pager

/* FUNC(zx_FREE_hrxml_Pager) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->FormattedNumber, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Pager) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Pager_s* zx_NEW_hrxml_Pager(struct zx_ctx* c)
{
  struct zx_hrxml_Pager_s* x = ZX_ZALLOC(c, struct zx_hrxml_Pager_s);
  x->gg.g.tok = zx_hrxml_Pager_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Pager) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->FormattedNumber);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Pager) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Pager_s* zx_DEEP_CLONE_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Pager_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Pager_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->FormattedNumber = zx_deep_clone_simple_elems(c,x->FormattedNumber, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Pager) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->FormattedNumber, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Pager) */

int zx_WALK_WO_hrxml_Pager(struct zx_ctx* c, struct zx_hrxml_Pager_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ParkingInstructions
#define EL_STRUCT zx_hrxml_ParkingInstructions_s
#define EL_NS     hrxml
#define EL_TAG    ParkingInstructions

/* FUNC(zx_FREE_hrxml_ParkingInstructions) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ParkingInstructions) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ParkingInstructions_s* zx_NEW_hrxml_ParkingInstructions(struct zx_ctx* c)
{
  struct zx_hrxml_ParkingInstructions_s* x = ZX_ZALLOC(c, struct zx_hrxml_ParkingInstructions_s);
  x->gg.g.tok = zx_hrxml_ParkingInstructions_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ParkingInstructions) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);


}

/* FUNC(zx_DEEP_CLONE_hrxml_ParkingInstructions) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ParkingInstructions_s* zx_DEEP_CLONE_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ParkingInstructions_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ParkingInstructions_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ParkingInstructions) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ParkingInstructions) */

int zx_WALK_WO_hrxml_ParkingInstructions(struct zx_ctx* c, struct zx_hrxml_ParkingInstructions_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Patent
#define EL_STRUCT zx_hrxml_Patent_s
#define EL_NS     hrxml
#define EL_TAG    Patent

/* FUNC(zx_FREE_hrxml_Patent) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->PatentTitle, free_strs);
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }
  for (e = &x->Inventors->gg;
       e && e->g.tok == zx_hrxml_Inventors_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Inventors(c, (struct zx_hrxml_Inventors_s*)e, free_strs);
  }
  for (e = &x->PatentDetail->gg;
       e && e->g.tok == zx_hrxml_PatentDetail_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PatentDetail(c, (struct zx_hrxml_PatentDetail_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Link, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Patent) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Patent_s* zx_NEW_hrxml_Patent(struct zx_ctx* c)
{
  struct zx_hrxml_Patent_s* x = ZX_ZALLOC(c, struct zx_hrxml_Patent_s);
  x->gg.g.tok = zx_hrxml_Patent_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Patent) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->PatentTitle);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->Inventors->gg;
       se && se->g.tok == zx_hrxml_Inventors_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Inventors(c, (struct zx_hrxml_Inventors_s*)se);
  for (se = &x->PatentDetail->gg;
       se && se->g.tok == zx_hrxml_PatentDetail_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PatentDetail(c, (struct zx_hrxml_PatentDetail_s*)se);
  zx_dup_strs_simple_elems(c, x->Link);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Patent) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Patent_s* zx_DEEP_CLONE_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Patent_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Patent_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->PatentTitle = zx_deep_clone_simple_elems(c,x->PatentTitle, dup_strs);
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Inventors->gg;
       e && e->g.tok == zx_hrxml_Inventors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Inventors(c,(struct zx_hrxml_Inventors_s*)e,dup_strs);
  	  if (!enn)
  	      x->Inventors = (struct zx_hrxml_Inventors_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PatentDetail->gg;
       e && e->g.tok == zx_hrxml_PatentDetail_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PatentDetail(c,(struct zx_hrxml_PatentDetail_s*)e,dup_strs);
  	  if (!enn)
  	      x->PatentDetail = (struct zx_hrxml_PatentDetail_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Link = zx_deep_clone_simple_elems(c,x->Link, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Patent) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->PatentTitle, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Inventors->gg;
       e && e->g.tok == zx_hrxml_Inventors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Inventors(c, (struct zx_hrxml_Inventors_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PatentDetail->gg;
       e && e->g.tok == zx_hrxml_PatentDetail_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PatentDetail(c, (struct zx_hrxml_PatentDetail_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Link, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Patent) */

int zx_WALK_WO_hrxml_Patent(struct zx_ctx* c, struct zx_hrxml_Patent_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PatentDetail
#define EL_STRUCT zx_hrxml_PatentDetail_s
#define EL_NS     hrxml
#define EL_TAG    PatentDetail

/* FUNC(zx_FREE_hrxml_PatentDetail) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)e, free_strs);
  }
  for (e = &x->PatentMilestone->gg;
       e && e->g.tok == zx_hrxml_PatentMilestone_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PatentMilestone(c, (struct zx_hrxml_PatentMilestone_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PatentDetail) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PatentDetail_s* zx_NEW_hrxml_PatentDetail(struct zx_ctx* c)
{
  struct zx_hrxml_PatentDetail_s* x = ZX_ZALLOC(c, struct zx_hrxml_PatentDetail_s);
  x->gg.g.tok = zx_hrxml_PatentDetail_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PatentDetail) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->IssuingAuthority->gg;
       se && se->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se);
  for (se = &x->PatentMilestone->gg;
       se && se->g.tok == zx_hrxml_PatentMilestone_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PatentMilestone(c, (struct zx_hrxml_PatentMilestone_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PatentDetail) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PatentDetail_s* zx_DEEP_CLONE_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PatentDetail_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PatentDetail_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IssuingAuthority(c,(struct zx_hrxml_IssuingAuthority_s*)e,dup_strs);
  	  if (!enn)
  	      x->IssuingAuthority = (struct zx_hrxml_IssuingAuthority_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PatentMilestone->gg;
       e && e->g.tok == zx_hrxml_PatentMilestone_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PatentMilestone(c,(struct zx_hrxml_PatentMilestone_s*)e,dup_strs);
  	  if (!enn)
  	      x->PatentMilestone = (struct zx_hrxml_PatentMilestone_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PatentDetail) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PatentMilestone->gg;
       e && e->g.tok == zx_hrxml_PatentMilestone_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PatentMilestone(c, (struct zx_hrxml_PatentMilestone_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PatentDetail) */

int zx_WALK_WO_hrxml_PatentDetail(struct zx_ctx* c, struct zx_hrxml_PatentDetail_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PatentHistory
#define EL_STRUCT zx_hrxml_PatentHistory_s
#define EL_NS     hrxml
#define EL_TAG    PatentHistory

/* FUNC(zx_FREE_hrxml_PatentHistory) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Patent->gg;
       e && e->g.tok == zx_hrxml_Patent_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Patent(c, (struct zx_hrxml_Patent_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PatentHistory) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PatentHistory_s* zx_NEW_hrxml_PatentHistory(struct zx_ctx* c)
{
  struct zx_hrxml_PatentHistory_s* x = ZX_ZALLOC(c, struct zx_hrxml_PatentHistory_s);
  x->gg.g.tok = zx_hrxml_PatentHistory_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PatentHistory) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Patent->gg;
       se && se->g.tok == zx_hrxml_Patent_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Patent(c, (struct zx_hrxml_Patent_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PatentHistory) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PatentHistory_s* zx_DEEP_CLONE_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PatentHistory_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PatentHistory_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Patent->gg;
       e && e->g.tok == zx_hrxml_Patent_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Patent(c,(struct zx_hrxml_Patent_s*)e,dup_strs);
  	  if (!enn)
  	      x->Patent = (struct zx_hrxml_Patent_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PatentHistory) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Patent->gg;
       e && e->g.tok == zx_hrxml_Patent_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Patent(c, (struct zx_hrxml_Patent_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PatentHistory) */

int zx_WALK_WO_hrxml_PatentHistory(struct zx_ctx* c, struct zx_hrxml_PatentHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PatentMilestone
#define EL_STRUCT zx_hrxml_PatentMilestone_s
#define EL_NS     hrxml
#define EL_TAG    PatentMilestone

/* FUNC(zx_FREE_hrxml_PatentMilestone) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  for (e = &x->Status->gg;
       e && e->g.tok == zx_hrxml_Status_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Status(c, (struct zx_hrxml_Status_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Date, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PatentMilestone) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PatentMilestone_s* zx_NEW_hrxml_PatentMilestone(struct zx_ctx* c)
{
  struct zx_hrxml_PatentMilestone_s* x = ZX_ZALLOC(c, struct zx_hrxml_PatentMilestone_s);
  x->gg.g.tok = zx_hrxml_PatentMilestone_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PatentMilestone) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->Status->gg;
       se && se->g.tok == zx_hrxml_Status_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Status(c, (struct zx_hrxml_Status_s*)se);
  zx_dup_strs_simple_elems(c, x->Date);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PatentMilestone) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PatentMilestone_s* zx_DEEP_CLONE_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PatentMilestone_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PatentMilestone_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Status->gg;
       e && e->g.tok == zx_hrxml_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Status(c,(struct zx_hrxml_Status_s*)e,dup_strs);
  	  if (!enn)
  	      x->Status = (struct zx_hrxml_Status_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Date = zx_deep_clone_simple_elems(c,x->Date, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PatentMilestone) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Status->gg;
       e && e->g.tok == zx_hrxml_Status_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Status(c, (struct zx_hrxml_Status_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Date, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PatentMilestone) */

int zx_WALK_WO_hrxml_PatentMilestone(struct zx_ctx* c, struct zx_hrxml_PatentMilestone_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonDescriptors
#define EL_STRUCT zx_hrxml_PersonDescriptors_s
#define EL_NS     hrxml
#define EL_TAG    PersonDescriptors

/* FUNC(zx_FREE_hrxml_PersonDescriptors) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->LegalIdentifiers->gg;
       e && e->g.tok == zx_hrxml_LegalIdentifiers_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LegalIdentifiers(c, (struct zx_hrxml_LegalIdentifiers_s*)e, free_strs);
  }
  for (e = &x->DemographicDescriptors->gg;
       e && e->g.tok == zx_hrxml_DemographicDescriptors_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DemographicDescriptors(c, (struct zx_hrxml_DemographicDescriptors_s*)e, free_strs);
  }
  for (e = &x->BiologicalDescriptors->gg;
       e && e->g.tok == zx_hrxml_BiologicalDescriptors_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_BiologicalDescriptors(c, (struct zx_hrxml_BiologicalDescriptors_s*)e, free_strs);
  }
  for (e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)e, free_strs);
  }
  for (e = &x->OtherDescriptors->gg;
       e && e->g.tok == zx_hrxml_OtherDescriptors_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OtherDescriptors(c, (struct zx_hrxml_OtherDescriptors_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PersonDescriptors) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PersonDescriptors_s* zx_NEW_hrxml_PersonDescriptors(struct zx_ctx* c)
{
  struct zx_hrxml_PersonDescriptors_s* x = ZX_ZALLOC(c, struct zx_hrxml_PersonDescriptors_s);
  x->gg.g.tok = zx_hrxml_PersonDescriptors_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PersonDescriptors) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->LegalIdentifiers->gg;
       se && se->g.tok == zx_hrxml_LegalIdentifiers_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LegalIdentifiers(c, (struct zx_hrxml_LegalIdentifiers_s*)se);
  for (se = &x->DemographicDescriptors->gg;
       se && se->g.tok == zx_hrxml_DemographicDescriptors_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DemographicDescriptors(c, (struct zx_hrxml_DemographicDescriptors_s*)se);
  for (se = &x->BiologicalDescriptors->gg;
       se && se->g.tok == zx_hrxml_BiologicalDescriptors_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_BiologicalDescriptors(c, (struct zx_hrxml_BiologicalDescriptors_s*)se);
  for (se = &x->SupportingMaterials->gg;
       se && se->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se);
  for (se = &x->OtherDescriptors->gg;
       se && se->g.tok == zx_hrxml_OtherDescriptors_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OtherDescriptors(c, (struct zx_hrxml_OtherDescriptors_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PersonDescriptors) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PersonDescriptors_s* zx_DEEP_CLONE_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PersonDescriptors_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PersonDescriptors_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->LegalIdentifiers->gg;
       e && e->g.tok == zx_hrxml_LegalIdentifiers_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LegalIdentifiers(c,(struct zx_hrxml_LegalIdentifiers_s*)e,dup_strs);
  	  if (!enn)
  	      x->LegalIdentifiers = (struct zx_hrxml_LegalIdentifiers_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DemographicDescriptors->gg;
       e && e->g.tok == zx_hrxml_DemographicDescriptors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DemographicDescriptors(c,(struct zx_hrxml_DemographicDescriptors_s*)e,dup_strs);
  	  if (!enn)
  	      x->DemographicDescriptors = (struct zx_hrxml_DemographicDescriptors_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->BiologicalDescriptors->gg;
       e && e->g.tok == zx_hrxml_BiologicalDescriptors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_BiologicalDescriptors(c,(struct zx_hrxml_BiologicalDescriptors_s*)e,dup_strs);
  	  if (!enn)
  	      x->BiologicalDescriptors = (struct zx_hrxml_BiologicalDescriptors_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SupportingMaterials(c,(struct zx_hrxml_SupportingMaterials_s*)e,dup_strs);
  	  if (!enn)
  	      x->SupportingMaterials = (struct zx_hrxml_SupportingMaterials_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OtherDescriptors->gg;
       e && e->g.tok == zx_hrxml_OtherDescriptors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OtherDescriptors(c,(struct zx_hrxml_OtherDescriptors_s*)e,dup_strs);
  	  if (!enn)
  	      x->OtherDescriptors = (struct zx_hrxml_OtherDescriptors_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PersonDescriptors) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->LegalIdentifiers->gg;
       e && e->g.tok == zx_hrxml_LegalIdentifiers_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LegalIdentifiers(c, (struct zx_hrxml_LegalIdentifiers_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DemographicDescriptors->gg;
       e && e->g.tok == zx_hrxml_DemographicDescriptors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DemographicDescriptors(c, (struct zx_hrxml_DemographicDescriptors_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->BiologicalDescriptors->gg;
       e && e->g.tok == zx_hrxml_BiologicalDescriptors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_BiologicalDescriptors(c, (struct zx_hrxml_BiologicalDescriptors_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OtherDescriptors->gg;
       e && e->g.tok == zx_hrxml_OtherDescriptors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OtherDescriptors(c, (struct zx_hrxml_OtherDescriptors_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PersonDescriptors) */

int zx_WALK_WO_hrxml_PersonDescriptors(struct zx_ctx* c, struct zx_hrxml_PersonDescriptors_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonId
#define EL_STRUCT zx_hrxml_PersonId_s
#define EL_NS     hrxml
#define EL_TAG    PersonId

/* FUNC(zx_FREE_hrxml_PersonId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PersonId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PersonId_s* zx_NEW_hrxml_PersonId(struct zx_ctx* c)
{
  struct zx_hrxml_PersonId_s* x = ZX_ZALLOC(c, struct zx_hrxml_PersonId_s);
  x->gg.g.tok = zx_hrxml_PersonId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PersonId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PersonId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PersonId_s* zx_DEEP_CLONE_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PersonId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PersonId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PersonId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PersonId) */

int zx_WALK_WO_hrxml_PersonId(struct zx_ctx* c, struct zx_hrxml_PersonId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonLegalId
#define EL_STRUCT zx_hrxml_PersonLegalId_s
#define EL_NS     hrxml
#define EL_TAG    PersonLegalId

/* FUNC(zx_FREE_hrxml_PersonLegalId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->countryCode, free_strs);
  zx_free_attr(c, x->documentType, free_strs);
  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->idSource, free_strs);
  zx_free_attr(c, x->issuingRegion, free_strs);
  zx_free_attr(c, x->jurisdiction, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PersonLegalId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PersonLegalId_s* zx_NEW_hrxml_PersonLegalId(struct zx_ctx* c)
{
  struct zx_hrxml_PersonLegalId_s* x = ZX_ZALLOC(c, struct zx_hrxml_PersonLegalId_s);
  x->gg.g.tok = zx_hrxml_PersonLegalId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PersonLegalId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->countryCode);
  zx_dup_attr(c, x->documentType);
  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->idSource);
  zx_dup_attr(c, x->issuingRegion);
  zx_dup_attr(c, x->jurisdiction);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PersonLegalId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PersonLegalId_s* zx_DEEP_CLONE_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PersonLegalId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PersonLegalId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->countryCode = zx_clone_attr(c, x->countryCode);
  x->documentType = zx_clone_attr(c, x->documentType);
  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->idSource = zx_clone_attr(c, x->idSource);
  x->issuingRegion = zx_clone_attr(c, x->issuingRegion);
  x->jurisdiction = zx_clone_attr(c, x->jurisdiction);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PersonLegalId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PersonLegalId) */

int zx_WALK_WO_hrxml_PersonLegalId(struct zx_ctx* c, struct zx_hrxml_PersonLegalId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonMember
#define EL_STRUCT zx_hrxml_PersonMember_s
#define EL_NS     hrxml
#define EL_TAG    PersonMember

/* FUNC(zx_FREE_hrxml_PersonMember) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, free_strs);
  }
  for (e = &x->PersonId->gg;
       e && e->g.tok == zx_hrxml_PersonId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonId(c, (struct zx_hrxml_PersonId_s*)e, free_strs);
  }
  for (e = &x->PersonRole->gg;
       e && e->g.tok == zx_hrxml_PersonRole_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonRole(c, (struct zx_hrxml_PersonRole_s*)e, free_strs);
  }
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PersonMember) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PersonMember_s* zx_NEW_hrxml_PersonMember(struct zx_ctx* c)
{
  struct zx_hrxml_PersonMember_s* x = ZX_ZALLOC(c, struct zx_hrxml_PersonMember_s);
  x->gg.g.tok = zx_hrxml_PersonMember_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PersonMember) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PersonName->gg;
       se && se->g.tok == zx_hrxml_PersonName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  for (se = &x->PersonId->gg;
       se && se->g.tok == zx_hrxml_PersonId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonId(c, (struct zx_hrxml_PersonId_s*)se);
  for (se = &x->PersonRole->gg;
       se && se->g.tok == zx_hrxml_PersonRole_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonRole(c, (struct zx_hrxml_PersonRole_s*)se);
  for (se = &x->ContactMethod->gg;
       se && se->g.tok == zx_hrxml_ContactMethod_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PersonMember) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PersonMember_s* zx_DEEP_CLONE_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PersonMember_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PersonMember_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonName(c,(struct zx_hrxml_PersonName_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonName = (struct zx_hrxml_PersonName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PersonId->gg;
       e && e->g.tok == zx_hrxml_PersonId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonId(c,(struct zx_hrxml_PersonId_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonId = (struct zx_hrxml_PersonId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PersonRole->gg;
       e && e->g.tok == zx_hrxml_PersonRole_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonRole(c,(struct zx_hrxml_PersonRole_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonRole = (struct zx_hrxml_PersonRole_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactMethod(c,(struct zx_hrxml_ContactMethod_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactMethod = (struct zx_hrxml_ContactMethod_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PersonMember) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PersonId->gg;
       e && e->g.tok == zx_hrxml_PersonId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonId(c, (struct zx_hrxml_PersonId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PersonRole->gg;
       e && e->g.tok == zx_hrxml_PersonRole_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonRole(c, (struct zx_hrxml_PersonRole_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PersonMember) */

int zx_WALK_WO_hrxml_PersonMember(struct zx_ctx* c, struct zx_hrxml_PersonMember_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonName
#define EL_STRUCT zx_hrxml_PersonName_s
#define EL_NS     hrxml
#define EL_TAG    PersonName

/* FUNC(zx_FREE_hrxml_PersonName) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->script, free_strs);

  zx_free_simple_elems(c, x->FormattedName, free_strs);
  zx_free_simple_elems(c, x->LegalName, free_strs);
  zx_free_simple_elems(c, x->GivenName, free_strs);
  zx_free_simple_elems(c, x->PreferredGivenName, free_strs);
  zx_free_simple_elems(c, x->MiddleName, free_strs);
  for (e = &x->FamilyName->gg;
       e && e->g.tok == zx_hrxml_FamilyName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)e, free_strs);
  }
  for (e = &x->Affix->gg;
       e && e->g.tok == zx_hrxml_Affix_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)e, free_strs);
  }
  for (e = &x->AlternateScript->gg;
       e && e->g.tok == zx_hrxml_AlternateScript_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_AlternateScript(c, (struct zx_hrxml_AlternateScript_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PersonName) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PersonName_s* zx_NEW_hrxml_PersonName(struct zx_ctx* c)
{
  struct zx_hrxml_PersonName_s* x = ZX_ZALLOC(c, struct zx_hrxml_PersonName_s);
  x->gg.g.tok = zx_hrxml_PersonName_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PersonName) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->script);

  zx_dup_strs_simple_elems(c, x->FormattedName);
  zx_dup_strs_simple_elems(c, x->LegalName);
  zx_dup_strs_simple_elems(c, x->GivenName);
  zx_dup_strs_simple_elems(c, x->PreferredGivenName);
  zx_dup_strs_simple_elems(c, x->MiddleName);
  for (se = &x->FamilyName->gg;
       se && se->g.tok == zx_hrxml_FamilyName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)se);
  for (se = &x->Affix->gg;
       se && se->g.tok == zx_hrxml_Affix_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)se);
  for (se = &x->AlternateScript->gg;
       se && se->g.tok == zx_hrxml_AlternateScript_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_AlternateScript(c, (struct zx_hrxml_AlternateScript_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PersonName) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PersonName_s* zx_DEEP_CLONE_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PersonName_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PersonName_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->script = zx_clone_attr(c, x->script);

  x->FormattedName = zx_deep_clone_simple_elems(c,x->FormattedName, dup_strs);
  x->LegalName = zx_deep_clone_simple_elems(c,x->LegalName, dup_strs);
  x->GivenName = zx_deep_clone_simple_elems(c,x->GivenName, dup_strs);
  x->PreferredGivenName = zx_deep_clone_simple_elems(c,x->PreferredGivenName, dup_strs);
  x->MiddleName = zx_deep_clone_simple_elems(c,x->MiddleName, dup_strs);
  for (enn = 0, e = &x->FamilyName->gg;
       e && e->g.tok == zx_hrxml_FamilyName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_FamilyName(c,(struct zx_hrxml_FamilyName_s*)e,dup_strs);
  	  if (!enn)
  	      x->FamilyName = (struct zx_hrxml_FamilyName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Affix->gg;
       e && e->g.tok == zx_hrxml_Affix_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Affix(c,(struct zx_hrxml_Affix_s*)e,dup_strs);
  	  if (!enn)
  	      x->Affix = (struct zx_hrxml_Affix_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AlternateScript->gg;
       e && e->g.tok == zx_hrxml_AlternateScript_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_AlternateScript(c,(struct zx_hrxml_AlternateScript_s*)e,dup_strs);
  	  if (!enn)
  	      x->AlternateScript = (struct zx_hrxml_AlternateScript_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PersonName) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->FormattedName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->LegalName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->GivenName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PreferredGivenName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MiddleName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->FamilyName->gg;
       e && e->g.tok == zx_hrxml_FamilyName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_FamilyName(c, (struct zx_hrxml_FamilyName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Affix->gg;
       e && e->g.tok == zx_hrxml_Affix_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Affix(c, (struct zx_hrxml_Affix_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AlternateScript->gg;
       e && e->g.tok == zx_hrxml_AlternateScript_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_AlternateScript(c, (struct zx_hrxml_AlternateScript_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PersonName) */

int zx_WALK_WO_hrxml_PersonName(struct zx_ctx* c, struct zx_hrxml_PersonName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonRole
#define EL_STRUCT zx_hrxml_PersonRole_s
#define EL_NS     hrxml
#define EL_TAG    PersonRole

/* FUNC(zx_FREE_hrxml_PersonRole) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->leader, free_strs);

  zx_free_simple_elems(c, x->RoleName, free_strs);
  for (e = &x->RoleId->gg;
       e && e->g.tok == zx_hrxml_RoleId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RoleId(c, (struct zx_hrxml_RoleId_s*)e, free_strs);
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PersonRole) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PersonRole_s* zx_NEW_hrxml_PersonRole(struct zx_ctx* c)
{
  struct zx_hrxml_PersonRole_s* x = ZX_ZALLOC(c, struct zx_hrxml_PersonRole_s);
  x->gg.g.tok = zx_hrxml_PersonRole_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PersonRole) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->leader);

  zx_dup_strs_simple_elems(c, x->RoleName);
  for (se = &x->RoleId->gg;
       se && se->g.tok == zx_hrxml_RoleId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RoleId(c, (struct zx_hrxml_RoleId_s*)se);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PersonRole) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PersonRole_s* zx_DEEP_CLONE_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PersonRole_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PersonRole_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->leader = zx_clone_attr(c, x->leader);

  x->RoleName = zx_deep_clone_simple_elems(c,x->RoleName, dup_strs);
  for (enn = 0, e = &x->RoleId->gg;
       e && e->g.tok == zx_hrxml_RoleId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RoleId(c,(struct zx_hrxml_RoleId_s*)e,dup_strs);
  	  if (!enn)
  	      x->RoleId = (struct zx_hrxml_RoleId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PersonRole) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->RoleName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->RoleId->gg;
       e && e->g.tok == zx_hrxml_RoleId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RoleId(c, (struct zx_hrxml_RoleId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PersonRole) */

int zx_WALK_WO_hrxml_PersonRole(struct zx_ctx* c, struct zx_hrxml_PersonRole_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PersonalData
#define EL_STRUCT zx_hrxml_PersonalData_s
#define EL_NS     hrxml
#define EL_TAG    PersonalData

/* FUNC(zx_FREE_hrxml_PersonalData) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PersonId->gg;
       e && e->g.tok == zx_hrxml_PersonId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonId(c, (struct zx_hrxml_PersonId_s*)e, free_strs);
  }
  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, free_strs);
  }
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, free_strs);
  }
  for (e = &x->PersonDescriptors->gg;
       e && e->g.tok == zx_hrxml_PersonDescriptors_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonDescriptors(c, (struct zx_hrxml_PersonDescriptors_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PersonalData) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PersonalData_s* zx_NEW_hrxml_PersonalData(struct zx_ctx* c)
{
  struct zx_hrxml_PersonalData_s* x = ZX_ZALLOC(c, struct zx_hrxml_PersonalData_s);
  x->gg.g.tok = zx_hrxml_PersonalData_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PersonalData) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PersonId->gg;
       se && se->g.tok == zx_hrxml_PersonId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonId(c, (struct zx_hrxml_PersonId_s*)se);
  for (se = &x->PersonName->gg;
       se && se->g.tok == zx_hrxml_PersonName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  for (se = &x->ContactMethod->gg;
       se && se->g.tok == zx_hrxml_ContactMethod_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);
  for (se = &x->PersonDescriptors->gg;
       se && se->g.tok == zx_hrxml_PersonDescriptors_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonDescriptors(c, (struct zx_hrxml_PersonDescriptors_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PersonalData) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PersonalData_s* zx_DEEP_CLONE_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PersonalData_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PersonalData_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PersonId->gg;
       e && e->g.tok == zx_hrxml_PersonId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonId(c,(struct zx_hrxml_PersonId_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonId = (struct zx_hrxml_PersonId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonName(c,(struct zx_hrxml_PersonName_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonName = (struct zx_hrxml_PersonName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactMethod(c,(struct zx_hrxml_ContactMethod_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactMethod = (struct zx_hrxml_ContactMethod_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PersonDescriptors->gg;
       e && e->g.tok == zx_hrxml_PersonDescriptors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonDescriptors(c,(struct zx_hrxml_PersonDescriptors_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonDescriptors = (struct zx_hrxml_PersonDescriptors_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PersonalData) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PersonId->gg;
       e && e->g.tok == zx_hrxml_PersonId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonId(c, (struct zx_hrxml_PersonId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PersonDescriptors->gg;
       e && e->g.tok == zx_hrxml_PersonDescriptors_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonDescriptors(c, (struct zx_hrxml_PersonDescriptors_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PersonalData) */

int zx_WALK_WO_hrxml_PersonalData(struct zx_ctx* c, struct zx_hrxml_PersonalData_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PhysicalLocation
#define EL_STRUCT zx_hrxml_PhysicalLocation_s
#define EL_NS     hrxml
#define EL_TAG    PhysicalLocation

/* FUNC(zx_FREE_hrxml_PhysicalLocation) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Name, free_strs);
  for (e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)e, free_strs);
  }
  for (e = &x->SpatialLocation->gg;
       e && e->g.tok == zx_hrxml_SpatialLocation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SpatialLocation(c, (struct zx_hrxml_SpatialLocation_s*)e, free_strs);
  }
  for (e = &x->TravelDirections->gg;
       e && e->g.tok == zx_hrxml_TravelDirections_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)e, free_strs);
  }
  for (e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)e, free_strs);
  }
  for (e = &x->Area->gg;
       e && e->g.tok == zx_hrxml_Area_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Area(c, (struct zx_hrxml_Area_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PhysicalLocation) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PhysicalLocation_s* zx_NEW_hrxml_PhysicalLocation(struct zx_ctx* c)
{
  struct zx_hrxml_PhysicalLocation_s* x = ZX_ZALLOC(c, struct zx_hrxml_PhysicalLocation_s);
  x->gg.g.tok = zx_hrxml_PhysicalLocation_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PhysicalLocation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  zx_dup_strs_simple_elems(c, x->Name);
  for (se = &x->EffectiveDate->gg;
       se && se->g.tok == zx_hrxml_EffectiveDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se);
  for (se = &x->SpatialLocation->gg;
       se && se->g.tok == zx_hrxml_SpatialLocation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SpatialLocation(c, (struct zx_hrxml_SpatialLocation_s*)se);
  for (se = &x->TravelDirections->gg;
       se && se->g.tok == zx_hrxml_TravelDirections_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)se);
  for (se = &x->PostalAddress->gg;
       se && se->g.tok == zx_hrxml_PostalAddress_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se);
  for (se = &x->Area->gg;
       se && se->g.tok == zx_hrxml_Area_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Area(c, (struct zx_hrxml_Area_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PhysicalLocation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PhysicalLocation_s* zx_DEEP_CLONE_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PhysicalLocation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PhysicalLocation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  for (enn = 0, e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EffectiveDate(c,(struct zx_hrxml_EffectiveDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EffectiveDate = (struct zx_hrxml_EffectiveDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SpatialLocation->gg;
       e && e->g.tok == zx_hrxml_SpatialLocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SpatialLocation(c,(struct zx_hrxml_SpatialLocation_s*)e,dup_strs);
  	  if (!enn)
  	      x->SpatialLocation = (struct zx_hrxml_SpatialLocation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->TravelDirections->gg;
       e && e->g.tok == zx_hrxml_TravelDirections_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_TravelDirections(c,(struct zx_hrxml_TravelDirections_s*)e,dup_strs);
  	  if (!enn)
  	      x->TravelDirections = (struct zx_hrxml_TravelDirections_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PostalAddress(c,(struct zx_hrxml_PostalAddress_s*)e,dup_strs);
  	  if (!enn)
  	      x->PostalAddress = (struct zx_hrxml_PostalAddress_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Area->gg;
       e && e->g.tok == zx_hrxml_Area_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Area(c,(struct zx_hrxml_Area_s*)e,dup_strs);
  	  if (!enn)
  	      x->Area = (struct zx_hrxml_Area_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PhysicalLocation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SpatialLocation->gg;
       e && e->g.tok == zx_hrxml_SpatialLocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SpatialLocation(c, (struct zx_hrxml_SpatialLocation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->TravelDirections->gg;
       e && e->g.tok == zx_hrxml_TravelDirections_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Area->gg;
       e && e->g.tok == zx_hrxml_Area_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Area(c, (struct zx_hrxml_Area_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PhysicalLocation) */

int zx_WALK_WO_hrxml_PhysicalLocation(struct zx_ctx* c, struct zx_hrxml_PhysicalLocation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionHistory
#define EL_STRUCT zx_hrxml_PositionHistory_s
#define EL_NS     hrxml
#define EL_TAG    PositionHistory

/* FUNC(zx_FREE_hrxml_PositionHistory) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->currentEmployer, free_strs);
  zx_free_attr(c, x->positionType, free_strs);

  zx_free_simple_elems(c, x->Title, free_strs);
  for (e = &x->OrgName->gg;
       e && e->g.tok == zx_hrxml_OrgName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrgName(c, (struct zx_hrxml_OrgName_s*)e, free_strs);
  }
  for (e = &x->OrgInfo->gg;
       e && e->g.tok == zx_hrxml_OrgInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrgInfo(c, (struct zx_hrxml_OrgInfo_s*)e, free_strs);
  }
  for (e = &x->OrgIndustry->gg;
       e && e->g.tok == zx_hrxml_OrgIndustry_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrgIndustry(c, (struct zx_hrxml_OrgIndustry_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->OrgSize, free_strs);
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }
  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, free_strs);
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, free_strs);
  }
  for (e = &x->Compensation->gg;
       e && e->g.tok == zx_hrxml_Compensation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Compensation(c, (struct zx_hrxml_Compensation_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);
  for (e = &x->Verification->gg;
       e && e->g.tok == zx_hrxml_Verification_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Verification(c, (struct zx_hrxml_Verification_s*)e, free_strs);
  }
  for (e = &x->JobLevelInfo->gg;
       e && e->g.tok == zx_hrxml_JobLevelInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_JobLevelInfo(c, (struct zx_hrxml_JobLevelInfo_s*)e, free_strs);
  }
  for (e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)e, free_strs);
  }
  for (e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PositionHistory) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PositionHistory_s* zx_NEW_hrxml_PositionHistory(struct zx_ctx* c)
{
  struct zx_hrxml_PositionHistory_s* x = ZX_ZALLOC(c, struct zx_hrxml_PositionHistory_s);
  x->gg.g.tok = zx_hrxml_PositionHistory_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PositionHistory) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->currentEmployer);
  zx_dup_attr(c, x->positionType);

  zx_dup_strs_simple_elems(c, x->Title);
  for (se = &x->OrgName->gg;
       se && se->g.tok == zx_hrxml_OrgName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrgName(c, (struct zx_hrxml_OrgName_s*)se);
  for (se = &x->OrgInfo->gg;
       se && se->g.tok == zx_hrxml_OrgInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrgInfo(c, (struct zx_hrxml_OrgInfo_s*)se);
  for (se = &x->OrgIndustry->gg;
       se && se->g.tok == zx_hrxml_OrgIndustry_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrgIndustry(c, (struct zx_hrxml_OrgIndustry_s*)se);
  zx_dup_strs_simple_elems(c, x->OrgSize);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->StartDate->gg;
       se && se->g.tok == zx_hrxml_StartDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg;
       se && se->g.tok == zx_hrxml_EndDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);
  for (se = &x->Compensation->gg;
       se && se->g.tok == zx_hrxml_Compensation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Compensation(c, (struct zx_hrxml_Compensation_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);
  for (se = &x->Verification->gg;
       se && se->g.tok == zx_hrxml_Verification_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Verification(c, (struct zx_hrxml_Verification_s*)se);
  for (se = &x->JobLevelInfo->gg;
       se && se->g.tok == zx_hrxml_JobLevelInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_JobLevelInfo(c, (struct zx_hrxml_JobLevelInfo_s*)se);
  for (se = &x->JobCategory->gg;
       se && se->g.tok == zx_hrxml_JobCategory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se);
  for (se = &x->Competency->gg;
       se && se->g.tok == zx_hrxml_Competency_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PositionHistory) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PositionHistory_s* zx_DEEP_CLONE_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PositionHistory_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PositionHistory_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->currentEmployer = zx_clone_attr(c, x->currentEmployer);
  x->positionType = zx_clone_attr(c, x->positionType);

  x->Title = zx_deep_clone_simple_elems(c,x->Title, dup_strs);
  for (enn = 0, e = &x->OrgName->gg;
       e && e->g.tok == zx_hrxml_OrgName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrgName(c,(struct zx_hrxml_OrgName_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrgName = (struct zx_hrxml_OrgName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OrgInfo->gg;
       e && e->g.tok == zx_hrxml_OrgInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrgInfo(c,(struct zx_hrxml_OrgInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrgInfo = (struct zx_hrxml_OrgInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OrgIndustry->gg;
       e && e->g.tok == zx_hrxml_OrgIndustry_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrgIndustry(c,(struct zx_hrxml_OrgIndustry_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrgIndustry = (struct zx_hrxml_OrgIndustry_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->OrgSize = zx_deep_clone_simple_elems(c,x->OrgSize, dup_strs);
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StartDate(c,(struct zx_hrxml_StartDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->StartDate = (struct zx_hrxml_StartDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EndDate(c,(struct zx_hrxml_EndDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EndDate = (struct zx_hrxml_EndDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Compensation->gg;
       e && e->g.tok == zx_hrxml_Compensation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Compensation(c,(struct zx_hrxml_Compensation_s*)e,dup_strs);
  	  if (!enn)
  	      x->Compensation = (struct zx_hrxml_Compensation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  for (enn = 0, e = &x->Verification->gg;
       e && e->g.tok == zx_hrxml_Verification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Verification(c,(struct zx_hrxml_Verification_s*)e,dup_strs);
  	  if (!enn)
  	      x->Verification = (struct zx_hrxml_Verification_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->JobLevelInfo->gg;
       e && e->g.tok == zx_hrxml_JobLevelInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_JobLevelInfo(c,(struct zx_hrxml_JobLevelInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->JobLevelInfo = (struct zx_hrxml_JobLevelInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_JobCategory(c,(struct zx_hrxml_JobCategory_s*)e,dup_strs);
  	  if (!enn)
  	      x->JobCategory = (struct zx_hrxml_JobCategory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Competency(c,(struct zx_hrxml_Competency_s*)e,dup_strs);
  	  if (!enn)
  	      x->Competency = (struct zx_hrxml_Competency_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PositionHistory) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Title, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->OrgName->gg;
       e && e->g.tok == zx_hrxml_OrgName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrgName(c, (struct zx_hrxml_OrgName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OrgInfo->gg;
       e && e->g.tok == zx_hrxml_OrgInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrgInfo(c, (struct zx_hrxml_OrgInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OrgIndustry->gg;
       e && e->g.tok == zx_hrxml_OrgIndustry_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrgIndustry(c, (struct zx_hrxml_OrgIndustry_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->OrgSize, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Compensation->gg;
       e && e->g.tok == zx_hrxml_Compensation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Compensation(c, (struct zx_hrxml_Compensation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Verification->gg;
       e && e->g.tok == zx_hrxml_Verification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Verification(c, (struct zx_hrxml_Verification_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->JobLevelInfo->gg;
       e && e->g.tok == zx_hrxml_JobLevelInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_JobLevelInfo(c, (struct zx_hrxml_JobLevelInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PositionHistory) */

int zx_WALK_WO_hrxml_PositionHistory(struct zx_ctx* c, struct zx_hrxml_PositionHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionLocation
#define EL_STRUCT zx_hrxml_PositionLocation_s
#define EL_NS     hrxml
#define EL_TAG    PositionLocation

/* FUNC(zx_FREE_hrxml_PositionLocation) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);

  zx_free_simple_elems(c, x->CountryCode, free_strs);
  zx_free_simple_elems(c, x->PostalCode, free_strs);
  zx_free_simple_elems(c, x->Region, free_strs);
  zx_free_simple_elems(c, x->Municipality, free_strs);
  for (e = &x->DeliveryAddress->gg;
       e && e->g.tok == zx_hrxml_DeliveryAddress_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DeliveryAddress(c, (struct zx_hrxml_DeliveryAddress_s*)e, free_strs);
  }
  for (e = &x->Recipient->gg;
       e && e->g.tok == zx_hrxml_Recipient_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Recipient(c, (struct zx_hrxml_Recipient_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PositionLocation) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PositionLocation_s* zx_NEW_hrxml_PositionLocation(struct zx_ctx* c)
{
  struct zx_hrxml_PositionLocation_s* x = ZX_ZALLOC(c, struct zx_hrxml_PositionLocation_s);
  x->gg.g.tok = zx_hrxml_PositionLocation_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PositionLocation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);

  zx_dup_strs_simple_elems(c, x->CountryCode);
  zx_dup_strs_simple_elems(c, x->PostalCode);
  zx_dup_strs_simple_elems(c, x->Region);
  zx_dup_strs_simple_elems(c, x->Municipality);
  for (se = &x->DeliveryAddress->gg;
       se && se->g.tok == zx_hrxml_DeliveryAddress_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DeliveryAddress(c, (struct zx_hrxml_DeliveryAddress_s*)se);
  for (se = &x->Recipient->gg;
       se && se->g.tok == zx_hrxml_Recipient_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Recipient(c, (struct zx_hrxml_Recipient_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PositionLocation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PositionLocation_s* zx_DEEP_CLONE_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PositionLocation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PositionLocation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);

  x->CountryCode = zx_deep_clone_simple_elems(c,x->CountryCode, dup_strs);
  x->PostalCode = zx_deep_clone_simple_elems(c,x->PostalCode, dup_strs);
  x->Region = zx_deep_clone_simple_elems(c,x->Region, dup_strs);
  x->Municipality = zx_deep_clone_simple_elems(c,x->Municipality, dup_strs);
  for (enn = 0, e = &x->DeliveryAddress->gg;
       e && e->g.tok == zx_hrxml_DeliveryAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DeliveryAddress(c,(struct zx_hrxml_DeliveryAddress_s*)e,dup_strs);
  	  if (!enn)
  	      x->DeliveryAddress = (struct zx_hrxml_DeliveryAddress_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Recipient->gg;
       e && e->g.tok == zx_hrxml_Recipient_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Recipient(c,(struct zx_hrxml_Recipient_s*)e,dup_strs);
  	  if (!enn)
  	      x->Recipient = (struct zx_hrxml_Recipient_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PositionLocation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->CountryCode, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PostalCode, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Region, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Municipality, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->DeliveryAddress->gg;
       e && e->g.tok == zx_hrxml_DeliveryAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DeliveryAddress(c, (struct zx_hrxml_DeliveryAddress_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Recipient->gg;
       e && e->g.tok == zx_hrxml_Recipient_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Recipient(c, (struct zx_hrxml_Recipient_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PositionLocation) */

int zx_WALK_WO_hrxml_PositionLocation(struct zx_ctx* c, struct zx_hrxml_PositionLocation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionMatching
#define EL_STRUCT zx_hrxml_PositionMatching_s
#define EL_NS     hrxml
#define EL_TAG    PositionMatching

/* FUNC(zx_FREE_hrxml_PositionMatching) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Company->gg;
       e && e->g.tok == zx_hrxml_Company_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Company(c, (struct zx_hrxml_Company_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->CompanyScale, free_strs);
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, free_strs);
  }
  for (e = &x->PhysicalLocation->gg;
       e && e->g.tok == zx_hrxml_PhysicalLocation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PhysicalLocation(c, (struct zx_hrxml_PhysicalLocation_s*)e, free_strs);
  }
  for (e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->PositionTitle, free_strs);
  zx_free_simple_elems(c, x->PositionClassification, free_strs);
  for (e = &x->PositionSchedule->gg;
       e && e->g.tok == zx_hrxml_PositionSchedule_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PositionSchedule(c, (struct zx_hrxml_PositionSchedule_s*)e, free_strs);
  }
  for (e = &x->Shift->gg;
       e && e->g.tok == zx_hrxml_Shift_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Shift(c, (struct zx_hrxml_Shift_s*)e, free_strs);
  }
  for (e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)e, free_strs);
  }
  for (e = &x->RemunerationPackage->gg;
       e && e->g.tok == zx_hrxml_RemunerationPackage_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RemunerationPackage(c, (struct zx_hrxml_RemunerationPackage_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->WorkStyle, free_strs);
  for (e = &x->DressCode->gg;
       e && e->g.tok == zx_hrxml_DressCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)e, free_strs);
  }
  for (e = &x->Travel->gg;
       e && e->g.tok == zx_hrxml_Travel_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Travel(c, (struct zx_hrxml_Travel_s*)e, free_strs);
  }
  for (e = &x->Relocation->gg;
       e && e->g.tok == zx_hrxml_Relocation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Relocation(c, (struct zx_hrxml_Relocation_s*)e, free_strs);
  }
  for (e = &x->PreferredLanguage->gg;
       e && e->g.tok == zx_hrxml_PreferredLanguage_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PreferredLanguage(c, (struct zx_hrxml_PreferredLanguage_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PositionMatching) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PositionMatching_s* zx_NEW_hrxml_PositionMatching(struct zx_ctx* c)
{
  struct zx_hrxml_PositionMatching_s* x = ZX_ZALLOC(c, struct zx_hrxml_PositionMatching_s);
  x->gg.g.tok = zx_hrxml_PositionMatching_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PositionMatching) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Company->gg;
       se && se->g.tok == zx_hrxml_Company_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Company(c, (struct zx_hrxml_Company_s*)se);
  zx_dup_strs_simple_elems(c, x->CompanyScale);
  for (se = &x->IndustryCode->gg;
       se && se->g.tok == zx_hrxml_IndustryCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);
  for (se = &x->PhysicalLocation->gg;
       se && se->g.tok == zx_hrxml_PhysicalLocation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PhysicalLocation(c, (struct zx_hrxml_PhysicalLocation_s*)se);
  for (se = &x->JobCategory->gg;
       se && se->g.tok == zx_hrxml_JobCategory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se);
  zx_dup_strs_simple_elems(c, x->PositionTitle);
  zx_dup_strs_simple_elems(c, x->PositionClassification);
  for (se = &x->PositionSchedule->gg;
       se && se->g.tok == zx_hrxml_PositionSchedule_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PositionSchedule(c, (struct zx_hrxml_PositionSchedule_s*)se);
  for (se = &x->Shift->gg;
       se && se->g.tok == zx_hrxml_Shift_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Shift(c, (struct zx_hrxml_Shift_s*)se);
  for (se = &x->Competency->gg;
       se && se->g.tok == zx_hrxml_Competency_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se);
  for (se = &x->RemunerationPackage->gg;
       se && se->g.tok == zx_hrxml_RemunerationPackage_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RemunerationPackage(c, (struct zx_hrxml_RemunerationPackage_s*)se);
  zx_dup_strs_simple_elems(c, x->WorkStyle);
  for (se = &x->DressCode->gg;
       se && se->g.tok == zx_hrxml_DressCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)se);
  for (se = &x->Travel->gg;
       se && se->g.tok == zx_hrxml_Travel_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Travel(c, (struct zx_hrxml_Travel_s*)se);
  for (se = &x->Relocation->gg;
       se && se->g.tok == zx_hrxml_Relocation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Relocation(c, (struct zx_hrxml_Relocation_s*)se);
  for (se = &x->PreferredLanguage->gg;
       se && se->g.tok == zx_hrxml_PreferredLanguage_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PreferredLanguage(c, (struct zx_hrxml_PreferredLanguage_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PositionMatching) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PositionMatching_s* zx_DEEP_CLONE_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PositionMatching_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PositionMatching_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Company->gg;
       e && e->g.tok == zx_hrxml_Company_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Company(c,(struct zx_hrxml_Company_s*)e,dup_strs);
  	  if (!enn)
  	      x->Company = (struct zx_hrxml_Company_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->CompanyScale = zx_deep_clone_simple_elems(c,x->CompanyScale, dup_strs);
  for (enn = 0, e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IndustryCode(c,(struct zx_hrxml_IndustryCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->IndustryCode = (struct zx_hrxml_IndustryCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PhysicalLocation->gg;
       e && e->g.tok == zx_hrxml_PhysicalLocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PhysicalLocation(c,(struct zx_hrxml_PhysicalLocation_s*)e,dup_strs);
  	  if (!enn)
  	      x->PhysicalLocation = (struct zx_hrxml_PhysicalLocation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_JobCategory(c,(struct zx_hrxml_JobCategory_s*)e,dup_strs);
  	  if (!enn)
  	      x->JobCategory = (struct zx_hrxml_JobCategory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->PositionTitle = zx_deep_clone_simple_elems(c,x->PositionTitle, dup_strs);
  x->PositionClassification = zx_deep_clone_simple_elems(c,x->PositionClassification, dup_strs);
  for (enn = 0, e = &x->PositionSchedule->gg;
       e && e->g.tok == zx_hrxml_PositionSchedule_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PositionSchedule(c,(struct zx_hrxml_PositionSchedule_s*)e,dup_strs);
  	  if (!enn)
  	      x->PositionSchedule = (struct zx_hrxml_PositionSchedule_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Shift->gg;
       e && e->g.tok == zx_hrxml_Shift_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Shift(c,(struct zx_hrxml_Shift_s*)e,dup_strs);
  	  if (!enn)
  	      x->Shift = (struct zx_hrxml_Shift_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Competency(c,(struct zx_hrxml_Competency_s*)e,dup_strs);
  	  if (!enn)
  	      x->Competency = (struct zx_hrxml_Competency_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RemunerationPackage->gg;
       e && e->g.tok == zx_hrxml_RemunerationPackage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RemunerationPackage(c,(struct zx_hrxml_RemunerationPackage_s*)e,dup_strs);
  	  if (!enn)
  	      x->RemunerationPackage = (struct zx_hrxml_RemunerationPackage_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->WorkStyle = zx_deep_clone_simple_elems(c,x->WorkStyle, dup_strs);
  for (enn = 0, e = &x->DressCode->gg;
       e && e->g.tok == zx_hrxml_DressCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DressCode(c,(struct zx_hrxml_DressCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->DressCode = (struct zx_hrxml_DressCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Travel->gg;
       e && e->g.tok == zx_hrxml_Travel_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Travel(c,(struct zx_hrxml_Travel_s*)e,dup_strs);
  	  if (!enn)
  	      x->Travel = (struct zx_hrxml_Travel_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Relocation->gg;
       e && e->g.tok == zx_hrxml_Relocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Relocation(c,(struct zx_hrxml_Relocation_s*)e,dup_strs);
  	  if (!enn)
  	      x->Relocation = (struct zx_hrxml_Relocation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PreferredLanguage->gg;
       e && e->g.tok == zx_hrxml_PreferredLanguage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PreferredLanguage(c,(struct zx_hrxml_PreferredLanguage_s*)e,dup_strs);
  	  if (!enn)
  	      x->PreferredLanguage = (struct zx_hrxml_PreferredLanguage_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PositionMatching) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Company->gg;
       e && e->g.tok == zx_hrxml_Company_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Company(c, (struct zx_hrxml_Company_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->CompanyScale, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PhysicalLocation->gg;
       e && e->g.tok == zx_hrxml_PhysicalLocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PhysicalLocation(c, (struct zx_hrxml_PhysicalLocation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->PositionTitle, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PositionClassification, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PositionSchedule->gg;
       e && e->g.tok == zx_hrxml_PositionSchedule_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PositionSchedule(c, (struct zx_hrxml_PositionSchedule_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Shift->gg;
       e && e->g.tok == zx_hrxml_Shift_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Shift(c, (struct zx_hrxml_Shift_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RemunerationPackage->gg;
       e && e->g.tok == zx_hrxml_RemunerationPackage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RemunerationPackage(c, (struct zx_hrxml_RemunerationPackage_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->WorkStyle, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->DressCode->gg;
       e && e->g.tok == zx_hrxml_DressCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Travel->gg;
       e && e->g.tok == zx_hrxml_Travel_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Travel(c, (struct zx_hrxml_Travel_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Relocation->gg;
       e && e->g.tok == zx_hrxml_Relocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Relocation(c, (struct zx_hrxml_Relocation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PreferredLanguage->gg;
       e && e->g.tok == zx_hrxml_PreferredLanguage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PreferredLanguage(c, (struct zx_hrxml_PreferredLanguage_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PositionMatching) */

int zx_WALK_WO_hrxml_PositionMatching(struct zx_ctx* c, struct zx_hrxml_PositionMatching_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionPosting
#define EL_STRUCT zx_hrxml_PositionPosting_s
#define EL_NS     hrxml
#define EL_TAG    PositionPosting

/* FUNC(zx_FREE_hrxml_PositionPosting) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Title, free_strs);
  zx_free_simple_elems(c, x->Link, free_strs);
  for (e = &x->SearchCriteria->gg;
       e && e->g.tok == zx_hrxml_SearchCriteria_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SearchCriteria(c, (struct zx_hrxml_SearchCriteria_s*)e, free_strs);
  }
  for (e = &x->SearchResult->gg;
       e && e->g.tok == zx_hrxml_SearchResult_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SearchResult(c, (struct zx_hrxml_SearchResult_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PositionPosting) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PositionPosting_s* zx_NEW_hrxml_PositionPosting(struct zx_ctx* c)
{
  struct zx_hrxml_PositionPosting_s* x = ZX_ZALLOC(c, struct zx_hrxml_PositionPosting_s);
  x->gg.g.tok = zx_hrxml_PositionPosting_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PositionPosting) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  zx_dup_strs_simple_elems(c, x->Title);
  zx_dup_strs_simple_elems(c, x->Link);
  for (se = &x->SearchCriteria->gg;
       se && se->g.tok == zx_hrxml_SearchCriteria_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SearchCriteria(c, (struct zx_hrxml_SearchCriteria_s*)se);
  for (se = &x->SearchResult->gg;
       se && se->g.tok == zx_hrxml_SearchResult_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SearchResult(c, (struct zx_hrxml_SearchResult_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PositionPosting) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PositionPosting_s* zx_DEEP_CLONE_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PositionPosting_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PositionPosting_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Title = zx_deep_clone_simple_elems(c,x->Title, dup_strs);
  x->Link = zx_deep_clone_simple_elems(c,x->Link, dup_strs);
  for (enn = 0, e = &x->SearchCriteria->gg;
       e && e->g.tok == zx_hrxml_SearchCriteria_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SearchCriteria(c,(struct zx_hrxml_SearchCriteria_s*)e,dup_strs);
  	  if (!enn)
  	      x->SearchCriteria = (struct zx_hrxml_SearchCriteria_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SearchResult->gg;
       e && e->g.tok == zx_hrxml_SearchResult_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SearchResult(c,(struct zx_hrxml_SearchResult_s*)e,dup_strs);
  	  if (!enn)
  	      x->SearchResult = (struct zx_hrxml_SearchResult_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PositionPosting) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Title, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Link, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->SearchCriteria->gg;
       e && e->g.tok == zx_hrxml_SearchCriteria_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SearchCriteria(c, (struct zx_hrxml_SearchCriteria_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SearchResult->gg;
       e && e->g.tok == zx_hrxml_SearchResult_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SearchResult(c, (struct zx_hrxml_SearchResult_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PositionPosting) */

int zx_WALK_WO_hrxml_PositionPosting(struct zx_ctx* c, struct zx_hrxml_PositionPosting_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PositionSchedule
#define EL_STRUCT zx_hrxml_PositionSchedule_s
#define EL_NS     hrxml
#define EL_TAG    PositionSchedule

/* FUNC(zx_FREE_hrxml_PositionSchedule) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->percentage, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PositionSchedule) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PositionSchedule_s* zx_NEW_hrxml_PositionSchedule(struct zx_ctx* c)
{
  struct zx_hrxml_PositionSchedule_s* x = ZX_ZALLOC(c, struct zx_hrxml_PositionSchedule_s);
  x->gg.g.tok = zx_hrxml_PositionSchedule_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PositionSchedule) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->percentage);


}

/* FUNC(zx_DEEP_CLONE_hrxml_PositionSchedule) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PositionSchedule_s* zx_DEEP_CLONE_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PositionSchedule_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PositionSchedule_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->percentage = zx_clone_attr(c, x->percentage);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PositionSchedule) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PositionSchedule) */

int zx_WALK_WO_hrxml_PositionSchedule(struct zx_ctx* c, struct zx_hrxml_PositionSchedule_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PostalAddress
#define EL_STRUCT zx_hrxml_PostalAddress_s
#define EL_NS     hrxml
#define EL_TAG    PostalAddress

/* FUNC(zx_FREE_hrxml_PostalAddress) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);

  zx_free_simple_elems(c, x->CountryCode, free_strs);
  zx_free_simple_elems(c, x->PostalCode, free_strs);
  zx_free_simple_elems(c, x->Region, free_strs);
  zx_free_simple_elems(c, x->Municipality, free_strs);
  for (e = &x->DeliveryAddress->gg;
       e && e->g.tok == zx_hrxml_DeliveryAddress_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DeliveryAddress(c, (struct zx_hrxml_DeliveryAddress_s*)e, free_strs);
  }
  for (e = &x->Recipient->gg;
       e && e->g.tok == zx_hrxml_Recipient_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Recipient(c, (struct zx_hrxml_Recipient_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PostalAddress) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PostalAddress_s* zx_NEW_hrxml_PostalAddress(struct zx_ctx* c)
{
  struct zx_hrxml_PostalAddress_s* x = ZX_ZALLOC(c, struct zx_hrxml_PostalAddress_s);
  x->gg.g.tok = zx_hrxml_PostalAddress_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PostalAddress) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);

  zx_dup_strs_simple_elems(c, x->CountryCode);
  zx_dup_strs_simple_elems(c, x->PostalCode);
  zx_dup_strs_simple_elems(c, x->Region);
  zx_dup_strs_simple_elems(c, x->Municipality);
  for (se = &x->DeliveryAddress->gg;
       se && se->g.tok == zx_hrxml_DeliveryAddress_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DeliveryAddress(c, (struct zx_hrxml_DeliveryAddress_s*)se);
  for (se = &x->Recipient->gg;
       se && se->g.tok == zx_hrxml_Recipient_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Recipient(c, (struct zx_hrxml_Recipient_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PostalAddress) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PostalAddress_s* zx_DEEP_CLONE_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PostalAddress_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PostalAddress_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);

  x->CountryCode = zx_deep_clone_simple_elems(c,x->CountryCode, dup_strs);
  x->PostalCode = zx_deep_clone_simple_elems(c,x->PostalCode, dup_strs);
  x->Region = zx_deep_clone_simple_elems(c,x->Region, dup_strs);
  x->Municipality = zx_deep_clone_simple_elems(c,x->Municipality, dup_strs);
  for (enn = 0, e = &x->DeliveryAddress->gg;
       e && e->g.tok == zx_hrxml_DeliveryAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DeliveryAddress(c,(struct zx_hrxml_DeliveryAddress_s*)e,dup_strs);
  	  if (!enn)
  	      x->DeliveryAddress = (struct zx_hrxml_DeliveryAddress_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Recipient->gg;
       e && e->g.tok == zx_hrxml_Recipient_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Recipient(c,(struct zx_hrxml_Recipient_s*)e,dup_strs);
  	  if (!enn)
  	      x->Recipient = (struct zx_hrxml_Recipient_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PostalAddress) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->CountryCode, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PostalCode, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Region, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Municipality, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->DeliveryAddress->gg;
       e && e->g.tok == zx_hrxml_DeliveryAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DeliveryAddress(c, (struct zx_hrxml_DeliveryAddress_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Recipient->gg;
       e && e->g.tok == zx_hrxml_Recipient_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Recipient(c, (struct zx_hrxml_Recipient_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PostalAddress) */

int zx_WALK_WO_hrxml_PostalAddress(struct zx_ctx* c, struct zx_hrxml_PostalAddress_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PreferredLanguage
#define EL_STRUCT zx_hrxml_PreferredLanguage_s
#define EL_NS     hrxml
#define EL_TAG    PreferredLanguage

/* FUNC(zx_FREE_hrxml_PreferredLanguage) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PreferredLanguage) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PreferredLanguage_s* zx_NEW_hrxml_PreferredLanguage(struct zx_ctx* c)
{
  struct zx_hrxml_PreferredLanguage_s* x = ZX_ZALLOC(c, struct zx_hrxml_PreferredLanguage_s);
  x->gg.g.tok = zx_hrxml_PreferredLanguage_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PreferredLanguage) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_hrxml_PreferredLanguage) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PreferredLanguage_s* zx_DEEP_CLONE_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PreferredLanguage_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PreferredLanguage_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PreferredLanguage) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PreferredLanguage) */

int zx_WALK_WO_hrxml_PreferredLanguage(struct zx_ctx* c, struct zx_hrxml_PreferredLanguage_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PreferredPosition
#define EL_STRUCT zx_hrxml_PreferredPosition_s
#define EL_NS     hrxml
#define EL_TAG    PreferredPosition

/* FUNC(zx_FREE_hrxml_PreferredPosition) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Company->gg;
       e && e->g.tok == zx_hrxml_Company_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Company(c, (struct zx_hrxml_Company_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->CompanyScale, free_strs);
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, free_strs);
  }
  for (e = &x->PhysicalLocation->gg;
       e && e->g.tok == zx_hrxml_PhysicalLocation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PhysicalLocation(c, (struct zx_hrxml_PhysicalLocation_s*)e, free_strs);
  }
  for (e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->PositionTitle, free_strs);
  zx_free_simple_elems(c, x->PositionClassification, free_strs);
  for (e = &x->PositionSchedule->gg;
       e && e->g.tok == zx_hrxml_PositionSchedule_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PositionSchedule(c, (struct zx_hrxml_PositionSchedule_s*)e, free_strs);
  }
  for (e = &x->Shift->gg;
       e && e->g.tok == zx_hrxml_Shift_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Shift(c, (struct zx_hrxml_Shift_s*)e, free_strs);
  }
  for (e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)e, free_strs);
  }
  for (e = &x->RemunerationPackage->gg;
       e && e->g.tok == zx_hrxml_RemunerationPackage_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RemunerationPackage(c, (struct zx_hrxml_RemunerationPackage_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->WorkStyle, free_strs);
  for (e = &x->DressCode->gg;
       e && e->g.tok == zx_hrxml_DressCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)e, free_strs);
  }
  for (e = &x->Travel->gg;
       e && e->g.tok == zx_hrxml_Travel_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Travel(c, (struct zx_hrxml_Travel_s*)e, free_strs);
  }
  for (e = &x->Relocation->gg;
       e && e->g.tok == zx_hrxml_Relocation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Relocation(c, (struct zx_hrxml_Relocation_s*)e, free_strs);
  }
  for (e = &x->PreferredLanguage->gg;
       e && e->g.tok == zx_hrxml_PreferredLanguage_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PreferredLanguage(c, (struct zx_hrxml_PreferredLanguage_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }
  for (e = &x->Commute->gg;
       e && e->g.tok == zx_hrxml_Commute_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Commute(c, (struct zx_hrxml_Commute_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PreferredPosition) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PreferredPosition_s* zx_NEW_hrxml_PreferredPosition(struct zx_ctx* c)
{
  struct zx_hrxml_PreferredPosition_s* x = ZX_ZALLOC(c, struct zx_hrxml_PreferredPosition_s);
  x->gg.g.tok = zx_hrxml_PreferredPosition_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PreferredPosition) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Company->gg;
       se && se->g.tok == zx_hrxml_Company_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Company(c, (struct zx_hrxml_Company_s*)se);
  zx_dup_strs_simple_elems(c, x->CompanyScale);
  for (se = &x->IndustryCode->gg;
       se && se->g.tok == zx_hrxml_IndustryCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);
  for (se = &x->PhysicalLocation->gg;
       se && se->g.tok == zx_hrxml_PhysicalLocation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PhysicalLocation(c, (struct zx_hrxml_PhysicalLocation_s*)se);
  for (se = &x->JobCategory->gg;
       se && se->g.tok == zx_hrxml_JobCategory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)se);
  zx_dup_strs_simple_elems(c, x->PositionTitle);
  zx_dup_strs_simple_elems(c, x->PositionClassification);
  for (se = &x->PositionSchedule->gg;
       se && se->g.tok == zx_hrxml_PositionSchedule_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PositionSchedule(c, (struct zx_hrxml_PositionSchedule_s*)se);
  for (se = &x->Shift->gg;
       se && se->g.tok == zx_hrxml_Shift_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Shift(c, (struct zx_hrxml_Shift_s*)se);
  for (se = &x->Competency->gg;
       se && se->g.tok == zx_hrxml_Competency_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se);
  for (se = &x->RemunerationPackage->gg;
       se && se->g.tok == zx_hrxml_RemunerationPackage_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RemunerationPackage(c, (struct zx_hrxml_RemunerationPackage_s*)se);
  zx_dup_strs_simple_elems(c, x->WorkStyle);
  for (se = &x->DressCode->gg;
       se && se->g.tok == zx_hrxml_DressCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)se);
  for (se = &x->Travel->gg;
       se && se->g.tok == zx_hrxml_Travel_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Travel(c, (struct zx_hrxml_Travel_s*)se);
  for (se = &x->Relocation->gg;
       se && se->g.tok == zx_hrxml_Relocation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Relocation(c, (struct zx_hrxml_Relocation_s*)se);
  for (se = &x->PreferredLanguage->gg;
       se && se->g.tok == zx_hrxml_PreferredLanguage_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PreferredLanguage(c, (struct zx_hrxml_PreferredLanguage_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);
  for (se = &x->Commute->gg;
       se && se->g.tok == zx_hrxml_Commute_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Commute(c, (struct zx_hrxml_Commute_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PreferredPosition) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PreferredPosition_s* zx_DEEP_CLONE_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PreferredPosition_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PreferredPosition_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Company->gg;
       e && e->g.tok == zx_hrxml_Company_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Company(c,(struct zx_hrxml_Company_s*)e,dup_strs);
  	  if (!enn)
  	      x->Company = (struct zx_hrxml_Company_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->CompanyScale = zx_deep_clone_simple_elems(c,x->CompanyScale, dup_strs);
  for (enn = 0, e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IndustryCode(c,(struct zx_hrxml_IndustryCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->IndustryCode = (struct zx_hrxml_IndustryCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PhysicalLocation->gg;
       e && e->g.tok == zx_hrxml_PhysicalLocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PhysicalLocation(c,(struct zx_hrxml_PhysicalLocation_s*)e,dup_strs);
  	  if (!enn)
  	      x->PhysicalLocation = (struct zx_hrxml_PhysicalLocation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_JobCategory(c,(struct zx_hrxml_JobCategory_s*)e,dup_strs);
  	  if (!enn)
  	      x->JobCategory = (struct zx_hrxml_JobCategory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->PositionTitle = zx_deep_clone_simple_elems(c,x->PositionTitle, dup_strs);
  x->PositionClassification = zx_deep_clone_simple_elems(c,x->PositionClassification, dup_strs);
  for (enn = 0, e = &x->PositionSchedule->gg;
       e && e->g.tok == zx_hrxml_PositionSchedule_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PositionSchedule(c,(struct zx_hrxml_PositionSchedule_s*)e,dup_strs);
  	  if (!enn)
  	      x->PositionSchedule = (struct zx_hrxml_PositionSchedule_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Shift->gg;
       e && e->g.tok == zx_hrxml_Shift_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Shift(c,(struct zx_hrxml_Shift_s*)e,dup_strs);
  	  if (!enn)
  	      x->Shift = (struct zx_hrxml_Shift_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Competency(c,(struct zx_hrxml_Competency_s*)e,dup_strs);
  	  if (!enn)
  	      x->Competency = (struct zx_hrxml_Competency_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RemunerationPackage->gg;
       e && e->g.tok == zx_hrxml_RemunerationPackage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RemunerationPackage(c,(struct zx_hrxml_RemunerationPackage_s*)e,dup_strs);
  	  if (!enn)
  	      x->RemunerationPackage = (struct zx_hrxml_RemunerationPackage_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->WorkStyle = zx_deep_clone_simple_elems(c,x->WorkStyle, dup_strs);
  for (enn = 0, e = &x->DressCode->gg;
       e && e->g.tok == zx_hrxml_DressCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DressCode(c,(struct zx_hrxml_DressCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->DressCode = (struct zx_hrxml_DressCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Travel->gg;
       e && e->g.tok == zx_hrxml_Travel_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Travel(c,(struct zx_hrxml_Travel_s*)e,dup_strs);
  	  if (!enn)
  	      x->Travel = (struct zx_hrxml_Travel_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Relocation->gg;
       e && e->g.tok == zx_hrxml_Relocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Relocation(c,(struct zx_hrxml_Relocation_s*)e,dup_strs);
  	  if (!enn)
  	      x->Relocation = (struct zx_hrxml_Relocation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PreferredLanguage->gg;
       e && e->g.tok == zx_hrxml_PreferredLanguage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PreferredLanguage(c,(struct zx_hrxml_PreferredLanguage_s*)e,dup_strs);
  	  if (!enn)
  	      x->PreferredLanguage = (struct zx_hrxml_PreferredLanguage_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Commute->gg;
       e && e->g.tok == zx_hrxml_Commute_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Commute(c,(struct zx_hrxml_Commute_s*)e,dup_strs);
  	  if (!enn)
  	      x->Commute = (struct zx_hrxml_Commute_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PreferredPosition) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Company->gg;
       e && e->g.tok == zx_hrxml_Company_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Company(c, (struct zx_hrxml_Company_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->CompanyScale, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PhysicalLocation->gg;
       e && e->g.tok == zx_hrxml_PhysicalLocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PhysicalLocation(c, (struct zx_hrxml_PhysicalLocation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->JobCategory->gg;
       e && e->g.tok == zx_hrxml_JobCategory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_JobCategory(c, (struct zx_hrxml_JobCategory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->PositionTitle, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PositionClassification, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->PositionSchedule->gg;
       e && e->g.tok == zx_hrxml_PositionSchedule_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PositionSchedule(c, (struct zx_hrxml_PositionSchedule_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Shift->gg;
       e && e->g.tok == zx_hrxml_Shift_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Shift(c, (struct zx_hrxml_Shift_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RemunerationPackage->gg;
       e && e->g.tok == zx_hrxml_RemunerationPackage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RemunerationPackage(c, (struct zx_hrxml_RemunerationPackage_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->WorkStyle, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->DressCode->gg;
       e && e->g.tok == zx_hrxml_DressCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DressCode(c, (struct zx_hrxml_DressCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Travel->gg;
       e && e->g.tok == zx_hrxml_Travel_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Travel(c, (struct zx_hrxml_Travel_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Relocation->gg;
       e && e->g.tok == zx_hrxml_Relocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Relocation(c, (struct zx_hrxml_Relocation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PreferredLanguage->gg;
       e && e->g.tok == zx_hrxml_PreferredLanguage_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PreferredLanguage(c, (struct zx_hrxml_PreferredLanguage_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Commute->gg;
       e && e->g.tok == zx_hrxml_Commute_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Commute(c, (struct zx_hrxml_Commute_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PreferredPosition) */

int zx_WALK_WO_hrxml_PreferredPosition(struct zx_ctx* c, struct zx_hrxml_PreferredPosition_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PrehireRemuneration
#define EL_STRUCT zx_hrxml_PrehireRemuneration_s
#define EL_NS     hrxml
#define EL_TAG    PrehireRemuneration

/* FUNC(zx_FREE_hrxml_PrehireRemuneration) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->BasePay->gg;
       e && e->g.tok == zx_hrxml_BasePay_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_BasePay(c, (struct zx_hrxml_BasePay_s*)e, free_strs);
  }
  for (e = &x->OtherPay->gg;
       e && e->g.tok == zx_hrxml_OtherPay_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OtherPay(c, (struct zx_hrxml_OtherPay_s*)e, free_strs);
  }
  for (e = &x->Benefits->gg;
       e && e->g.tok == zx_hrxml_Benefits_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Benefits(c, (struct zx_hrxml_Benefits_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PrehireRemuneration) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PrehireRemuneration_s* zx_NEW_hrxml_PrehireRemuneration(struct zx_ctx* c)
{
  struct zx_hrxml_PrehireRemuneration_s* x = ZX_ZALLOC(c, struct zx_hrxml_PrehireRemuneration_s);
  x->gg.g.tok = zx_hrxml_PrehireRemuneration_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PrehireRemuneration) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->BasePay->gg;
       se && se->g.tok == zx_hrxml_BasePay_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_BasePay(c, (struct zx_hrxml_BasePay_s*)se);
  for (se = &x->OtherPay->gg;
       se && se->g.tok == zx_hrxml_OtherPay_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OtherPay(c, (struct zx_hrxml_OtherPay_s*)se);
  for (se = &x->Benefits->gg;
       se && se->g.tok == zx_hrxml_Benefits_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Benefits(c, (struct zx_hrxml_Benefits_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PrehireRemuneration) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PrehireRemuneration_s* zx_DEEP_CLONE_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PrehireRemuneration_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PrehireRemuneration_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->BasePay->gg;
       e && e->g.tok == zx_hrxml_BasePay_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_BasePay(c,(struct zx_hrxml_BasePay_s*)e,dup_strs);
  	  if (!enn)
  	      x->BasePay = (struct zx_hrxml_BasePay_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OtherPay->gg;
       e && e->g.tok == zx_hrxml_OtherPay_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OtherPay(c,(struct zx_hrxml_OtherPay_s*)e,dup_strs);
  	  if (!enn)
  	      x->OtherPay = (struct zx_hrxml_OtherPay_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Benefits->gg;
       e && e->g.tok == zx_hrxml_Benefits_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Benefits(c,(struct zx_hrxml_Benefits_s*)e,dup_strs);
  	  if (!enn)
  	      x->Benefits = (struct zx_hrxml_Benefits_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PrehireRemuneration) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->BasePay->gg;
       e && e->g.tok == zx_hrxml_BasePay_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_BasePay(c, (struct zx_hrxml_BasePay_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OtherPay->gg;
       e && e->g.tok == zx_hrxml_OtherPay_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OtherPay(c, (struct zx_hrxml_OtherPay_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Benefits->gg;
       e && e->g.tok == zx_hrxml_Benefits_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Benefits(c, (struct zx_hrxml_Benefits_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PrehireRemuneration) */

int zx_WALK_WO_hrxml_PrehireRemuneration(struct zx_ctx* c, struct zx_hrxml_PrehireRemuneration_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PrimaryLanguage
#define EL_STRUCT zx_hrxml_PrimaryLanguage_s
#define EL_NS     hrxml
#define EL_TAG    PrimaryLanguage

/* FUNC(zx_FREE_hrxml_PrimaryLanguage) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PrimaryLanguage) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PrimaryLanguage_s* zx_NEW_hrxml_PrimaryLanguage(struct zx_ctx* c)
{
  struct zx_hrxml_PrimaryLanguage_s* x = ZX_ZALLOC(c, struct zx_hrxml_PrimaryLanguage_s);
  x->gg.g.tok = zx_hrxml_PrimaryLanguage_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PrimaryLanguage) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_hrxml_PrimaryLanguage) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PrimaryLanguage_s* zx_DEEP_CLONE_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PrimaryLanguage_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PrimaryLanguage_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PrimaryLanguage) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PrimaryLanguage) */

int zx_WALK_WO_hrxml_PrimaryLanguage(struct zx_ctx* c, struct zx_hrxml_PrimaryLanguage_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ProfessionalAssociations
#define EL_STRUCT zx_hrxml_ProfessionalAssociations_s
#define EL_NS     hrxml
#define EL_TAG    ProfessionalAssociations

/* FUNC(zx_FREE_hrxml_ProfessionalAssociations) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Association->gg;
       e && e->g.tok == zx_hrxml_Association_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Association(c, (struct zx_hrxml_Association_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ProfessionalAssociations) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ProfessionalAssociations_s* zx_NEW_hrxml_ProfessionalAssociations(struct zx_ctx* c)
{
  struct zx_hrxml_ProfessionalAssociations_s* x = ZX_ZALLOC(c, struct zx_hrxml_ProfessionalAssociations_s);
  x->gg.g.tok = zx_hrxml_ProfessionalAssociations_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ProfessionalAssociations) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Association->gg;
       se && se->g.tok == zx_hrxml_Association_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Association(c, (struct zx_hrxml_Association_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ProfessionalAssociations) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ProfessionalAssociations_s* zx_DEEP_CLONE_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ProfessionalAssociations_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ProfessionalAssociations_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Association->gg;
       e && e->g.tok == zx_hrxml_Association_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Association(c,(struct zx_hrxml_Association_s*)e,dup_strs);
  	  if (!enn)
  	      x->Association = (struct zx_hrxml_Association_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ProfessionalAssociations) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Association->gg;
       e && e->g.tok == zx_hrxml_Association_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Association(c, (struct zx_hrxml_Association_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ProfessionalAssociations) */

int zx_WALK_WO_hrxml_ProfessionalAssociations(struct zx_ctx* c, struct zx_hrxml_ProfessionalAssociations_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ProfileId
#define EL_STRUCT zx_hrxml_ProfileId_s
#define EL_NS     hrxml
#define EL_TAG    ProfileId

/* FUNC(zx_FREE_hrxml_ProfileId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ProfileId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ProfileId_s* zx_NEW_hrxml_ProfileId(struct zx_ctx* c)
{
  struct zx_hrxml_ProfileId_s* x = ZX_ZALLOC(c, struct zx_hrxml_ProfileId_s);
  x->gg.g.tok = zx_hrxml_ProfileId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ProfileId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ProfileId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ProfileId_s* zx_DEEP_CLONE_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ProfileId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ProfileId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ProfileId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ProfileId) */

int zx_WALK_WO_hrxml_ProfileId(struct zx_ctx* c, struct zx_hrxml_ProfileId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ProgramId
#define EL_STRUCT zx_hrxml_ProgramId_s
#define EL_NS     hrxml
#define EL_TAG    ProgramId

/* FUNC(zx_FREE_hrxml_ProgramId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ProgramId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ProgramId_s* zx_NEW_hrxml_ProgramId(struct zx_ctx* c)
{
  struct zx_hrxml_ProgramId_s* x = ZX_ZALLOC(c, struct zx_hrxml_ProgramId_s);
  x->gg.g.tok = zx_hrxml_ProgramId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ProgramId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ProgramId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ProgramId_s* zx_DEEP_CLONE_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ProgramId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ProgramId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ProgramId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ProgramId) */

int zx_WALK_WO_hrxml_ProgramId(struct zx_ctx* c, struct zx_hrxml_ProgramId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PublicationDate
#define EL_STRUCT zx_hrxml_PublicationDate_s
#define EL_NS     hrxml
#define EL_TAG    PublicationDate

/* FUNC(zx_FREE_hrxml_PublicationDate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateDescription, free_strs);

  zx_free_simple_elems(c, x->AnyDate, free_strs);
  zx_free_simple_elems(c, x->YearMonth, free_strs);
  zx_free_simple_elems(c, x->Year, free_strs);
  zx_free_simple_elems(c, x->MonthDay, free_strs);
  zx_free_simple_elems(c, x->StringDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PublicationDate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PublicationDate_s* zx_NEW_hrxml_PublicationDate(struct zx_ctx* c)
{
  struct zx_hrxml_PublicationDate_s* x = ZX_ZALLOC(c, struct zx_hrxml_PublicationDate_s);
  x->gg.g.tok = zx_hrxml_PublicationDate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PublicationDate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateDescription);

  zx_dup_strs_simple_elems(c, x->AnyDate);
  zx_dup_strs_simple_elems(c, x->YearMonth);
  zx_dup_strs_simple_elems(c, x->Year);
  zx_dup_strs_simple_elems(c, x->MonthDay);
  zx_dup_strs_simple_elems(c, x->StringDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PublicationDate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PublicationDate_s* zx_DEEP_CLONE_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PublicationDate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PublicationDate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateDescription = zx_clone_attr(c, x->dateDescription);

  x->AnyDate = zx_deep_clone_simple_elems(c,x->AnyDate, dup_strs);
  x->YearMonth = zx_deep_clone_simple_elems(c,x->YearMonth, dup_strs);
  x->Year = zx_deep_clone_simple_elems(c,x->Year, dup_strs);
  x->MonthDay = zx_deep_clone_simple_elems(c,x->MonthDay, dup_strs);
  x->StringDate = zx_deep_clone_simple_elems(c,x->StringDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PublicationDate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AnyDate, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->YearMonth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Year, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDay, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StringDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PublicationDate) */

int zx_WALK_WO_hrxml_PublicationDate(struct zx_ctx* c, struct zx_hrxml_PublicationDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PublicationHistory
#define EL_STRUCT zx_hrxml_PublicationHistory_s
#define EL_NS     hrxml
#define EL_TAG    PublicationHistory

/* FUNC(zx_FREE_hrxml_PublicationHistory) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->FormattedPublicationDescription->gg;
       e && e->g.tok == zx_hrxml_FormattedPublicationDescription_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_FormattedPublicationDescription(c, (struct zx_hrxml_FormattedPublicationDescription_s*)e, free_strs);
  }
  for (e = &x->Article->gg;
       e && e->g.tok == zx_hrxml_Article_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Article(c, (struct zx_hrxml_Article_s*)e, free_strs);
  }
  for (e = &x->Book->gg;
       e && e->g.tok == zx_hrxml_Book_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Book(c, (struct zx_hrxml_Book_s*)e, free_strs);
  }
  for (e = &x->ConferencePaper->gg;
       e && e->g.tok == zx_hrxml_ConferencePaper_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ConferencePaper(c, (struct zx_hrxml_ConferencePaper_s*)e, free_strs);
  }
  for (e = &x->OtherPublication->gg;
       e && e->g.tok == zx_hrxml_OtherPublication_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OtherPublication(c, (struct zx_hrxml_OtherPublication_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PublicationHistory) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PublicationHistory_s* zx_NEW_hrxml_PublicationHistory(struct zx_ctx* c)
{
  struct zx_hrxml_PublicationHistory_s* x = ZX_ZALLOC(c, struct zx_hrxml_PublicationHistory_s);
  x->gg.g.tok = zx_hrxml_PublicationHistory_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PublicationHistory) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->FormattedPublicationDescription->gg;
       se && se->g.tok == zx_hrxml_FormattedPublicationDescription_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_FormattedPublicationDescription(c, (struct zx_hrxml_FormattedPublicationDescription_s*)se);
  for (se = &x->Article->gg;
       se && se->g.tok == zx_hrxml_Article_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Article(c, (struct zx_hrxml_Article_s*)se);
  for (se = &x->Book->gg;
       se && se->g.tok == zx_hrxml_Book_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Book(c, (struct zx_hrxml_Book_s*)se);
  for (se = &x->ConferencePaper->gg;
       se && se->g.tok == zx_hrxml_ConferencePaper_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ConferencePaper(c, (struct zx_hrxml_ConferencePaper_s*)se);
  for (se = &x->OtherPublication->gg;
       se && se->g.tok == zx_hrxml_OtherPublication_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OtherPublication(c, (struct zx_hrxml_OtherPublication_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_PublicationHistory) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PublicationHistory_s* zx_DEEP_CLONE_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PublicationHistory_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PublicationHistory_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->FormattedPublicationDescription->gg;
       e && e->g.tok == zx_hrxml_FormattedPublicationDescription_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_FormattedPublicationDescription(c,(struct zx_hrxml_FormattedPublicationDescription_s*)e,dup_strs);
  	  if (!enn)
  	      x->FormattedPublicationDescription = (struct zx_hrxml_FormattedPublicationDescription_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Article->gg;
       e && e->g.tok == zx_hrxml_Article_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Article(c,(struct zx_hrxml_Article_s*)e,dup_strs);
  	  if (!enn)
  	      x->Article = (struct zx_hrxml_Article_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Book->gg;
       e && e->g.tok == zx_hrxml_Book_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Book(c,(struct zx_hrxml_Book_s*)e,dup_strs);
  	  if (!enn)
  	      x->Book = (struct zx_hrxml_Book_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ConferencePaper->gg;
       e && e->g.tok == zx_hrxml_ConferencePaper_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ConferencePaper(c,(struct zx_hrxml_ConferencePaper_s*)e,dup_strs);
  	  if (!enn)
  	      x->ConferencePaper = (struct zx_hrxml_ConferencePaper_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OtherPublication->gg;
       e && e->g.tok == zx_hrxml_OtherPublication_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OtherPublication(c,(struct zx_hrxml_OtherPublication_s*)e,dup_strs);
  	  if (!enn)
  	      x->OtherPublication = (struct zx_hrxml_OtherPublication_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PublicationHistory) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->FormattedPublicationDescription->gg;
       e && e->g.tok == zx_hrxml_FormattedPublicationDescription_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_FormattedPublicationDescription(c, (struct zx_hrxml_FormattedPublicationDescription_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Article->gg;
       e && e->g.tok == zx_hrxml_Article_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Article(c, (struct zx_hrxml_Article_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Book->gg;
       e && e->g.tok == zx_hrxml_Book_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Book(c, (struct zx_hrxml_Book_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ConferencePaper->gg;
       e && e->g.tok == zx_hrxml_ConferencePaper_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ConferencePaper(c, (struct zx_hrxml_ConferencePaper_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OtherPublication->gg;
       e && e->g.tok == zx_hrxml_OtherPublication_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OtherPublication(c, (struct zx_hrxml_OtherPublication_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PublicationHistory) */

int zx_WALK_WO_hrxml_PublicationHistory(struct zx_ctx* c, struct zx_hrxml_PublicationHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_PublicationLanguage
#define EL_STRUCT zx_hrxml_PublicationLanguage_s
#define EL_NS     hrxml
#define EL_TAG    PublicationLanguage

/* FUNC(zx_FREE_hrxml_PublicationLanguage) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_PublicationLanguage) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_PublicationLanguage_s* zx_NEW_hrxml_PublicationLanguage(struct zx_ctx* c)
{
  struct zx_hrxml_PublicationLanguage_s* x = ZX_ZALLOC(c, struct zx_hrxml_PublicationLanguage_s);
  x->gg.g.tok = zx_hrxml_PublicationLanguage_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_PublicationLanguage) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_hrxml_PublicationLanguage) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_PublicationLanguage_s* zx_DEEP_CLONE_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_PublicationLanguage_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_PublicationLanguage_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_hrxml_PublicationLanguage) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_PublicationLanguage) */

int zx_WALK_WO_hrxml_PublicationLanguage(struct zx_ctx* c, struct zx_hrxml_PublicationLanguage_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Qualifications
#define EL_STRUCT zx_hrxml_Qualifications_s
#define EL_NS     hrxml
#define EL_TAG    Qualifications

/* FUNC(zx_FREE_hrxml_Qualifications) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->QualificationSummary, free_strs);
  for (e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Qualifications) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Qualifications_s* zx_NEW_hrxml_Qualifications(struct zx_ctx* c)
{
  struct zx_hrxml_Qualifications_s* x = ZX_ZALLOC(c, struct zx_hrxml_Qualifications_s);
  x->gg.g.tok = zx_hrxml_Qualifications_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Qualifications) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->QualificationSummary);
  for (se = &x->Competency->gg;
       se && se->g.tok == zx_hrxml_Competency_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Qualifications) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Qualifications_s* zx_DEEP_CLONE_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Qualifications_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Qualifications_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->QualificationSummary = zx_deep_clone_simple_elems(c,x->QualificationSummary, dup_strs);
  for (enn = 0, e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Competency(c,(struct zx_hrxml_Competency_s*)e,dup_strs);
  	  if (!enn)
  	      x->Competency = (struct zx_hrxml_Competency_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Qualifications) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->QualificationSummary, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Competency->gg;
       e && e->g.tok == zx_hrxml_Competency_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Competency(c, (struct zx_hrxml_Competency_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Qualifications) */

int zx_WALK_WO_hrxml_Qualifications(struct zx_ctx* c, struct zx_hrxml_Qualifications_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RankAchieved
#define EL_STRUCT zx_hrxml_RankAchieved_s
#define EL_NS     hrxml
#define EL_TAG    RankAchieved

/* FUNC(zx_FREE_hrxml_RankAchieved) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->StartRank, free_strs);
  zx_free_simple_elems(c, x->CurrentOrEndRank, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_RankAchieved) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_RankAchieved_s* zx_NEW_hrxml_RankAchieved(struct zx_ctx* c)
{
  struct zx_hrxml_RankAchieved_s* x = ZX_ZALLOC(c, struct zx_hrxml_RankAchieved_s);
  x->gg.g.tok = zx_hrxml_RankAchieved_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_RankAchieved) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->StartRank);
  zx_dup_strs_simple_elems(c, x->CurrentOrEndRank);

}

/* FUNC(zx_DEEP_CLONE_hrxml_RankAchieved) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_RankAchieved_s* zx_DEEP_CLONE_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_RankAchieved_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_RankAchieved_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->StartRank = zx_deep_clone_simple_elems(c,x->StartRank, dup_strs);
  x->CurrentOrEndRank = zx_deep_clone_simple_elems(c,x->CurrentOrEndRank, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_RankAchieved) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->StartRank, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->CurrentOrEndRank, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_RankAchieved) */

int zx_WALK_WO_hrxml_RankAchieved(struct zx_ctx* c, struct zx_hrxml_RankAchieved_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RankedResult
#define EL_STRUCT zx_hrxml_RankedResult_s
#define EL_NS     hrxml
#define EL_TAG    RankedResult

/* FUNC(zx_FREE_hrxml_RankedResult) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->CriterionName, free_strs);
  zx_free_simple_elems(c, x->Requested, free_strs);
  zx_free_simple_elems(c, x->Offered, free_strs);
  for (e = &x->Score->gg;
       e && e->g.tok == zx_hrxml_Score_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Score(c, (struct zx_hrxml_Score_s*)e, free_strs);
  }
  for (e = &x->Weight->gg;
       e && e->g.tok == zx_hrxml_Weight_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }
  for (e = &x->RankedResult->gg;
       e && e->g.tok == zx_hrxml_RankedResult_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RankedResult(c, (struct zx_hrxml_RankedResult_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_RankedResult) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_RankedResult_s* zx_NEW_hrxml_RankedResult(struct zx_ctx* c)
{
  struct zx_hrxml_RankedResult_s* x = ZX_ZALLOC(c, struct zx_hrxml_RankedResult_s);
  x->gg.g.tok = zx_hrxml_RankedResult_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_RankedResult) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->CriterionName);
  zx_dup_strs_simple_elems(c, x->Requested);
  zx_dup_strs_simple_elems(c, x->Offered);
  for (se = &x->Score->gg;
       se && se->g.tok == zx_hrxml_Score_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Score(c, (struct zx_hrxml_Score_s*)se);
  for (se = &x->Weight->gg;
       se && se->g.tok == zx_hrxml_Weight_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);
  for (se = &x->RankedResult->gg;
       se && se->g.tok == zx_hrxml_RankedResult_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RankedResult(c, (struct zx_hrxml_RankedResult_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_RankedResult) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_RankedResult_s* zx_DEEP_CLONE_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_RankedResult_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_RankedResult_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->CriterionName = zx_deep_clone_simple_elems(c,x->CriterionName, dup_strs);
  x->Requested = zx_deep_clone_simple_elems(c,x->Requested, dup_strs);
  x->Offered = zx_deep_clone_simple_elems(c,x->Offered, dup_strs);
  for (enn = 0, e = &x->Score->gg;
       e && e->g.tok == zx_hrxml_Score_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Score(c,(struct zx_hrxml_Score_s*)e,dup_strs);
  	  if (!enn)
  	      x->Score = (struct zx_hrxml_Score_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Weight->gg;
       e && e->g.tok == zx_hrxml_Weight_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Weight(c,(struct zx_hrxml_Weight_s*)e,dup_strs);
  	  if (!enn)
  	      x->Weight = (struct zx_hrxml_Weight_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RankedResult->gg;
       e && e->g.tok == zx_hrxml_RankedResult_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RankedResult(c,(struct zx_hrxml_RankedResult_s*)e,dup_strs);
  	  if (!enn)
  	      x->RankedResult = (struct zx_hrxml_RankedResult_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_RankedResult) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->CriterionName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Requested, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Offered, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Score->gg;
       e && e->g.tok == zx_hrxml_Score_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Score(c, (struct zx_hrxml_Score_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Weight->gg;
       e && e->g.tok == zx_hrxml_Weight_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RankedResult->gg;
       e && e->g.tok == zx_hrxml_RankedResult_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RankedResult(c, (struct zx_hrxml_RankedResult_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_RankedResult) */

int zx_WALK_WO_hrxml_RankedResult(struct zx_ctx* c, struct zx_hrxml_RankedResult_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RankedSearchResults
#define EL_STRUCT zx_hrxml_RankedSearchResults_s
#define EL_NS     hrxml
#define EL_TAG    RankedSearchResults

/* FUNC(zx_FREE_hrxml_RankedSearchResults) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->RankedResult->gg;
       e && e->g.tok == zx_hrxml_RankedResult_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RankedResult(c, (struct zx_hrxml_RankedResult_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_RankedSearchResults) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_RankedSearchResults_s* zx_NEW_hrxml_RankedSearchResults(struct zx_ctx* c)
{
  struct zx_hrxml_RankedSearchResults_s* x = ZX_ZALLOC(c, struct zx_hrxml_RankedSearchResults_s);
  x->gg.g.tok = zx_hrxml_RankedSearchResults_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_RankedSearchResults) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->RankedResult->gg;
       se && se->g.tok == zx_hrxml_RankedResult_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RankedResult(c, (struct zx_hrxml_RankedResult_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_RankedSearchResults) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_RankedSearchResults_s* zx_DEEP_CLONE_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_RankedSearchResults_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_RankedSearchResults_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->RankedResult->gg;
       e && e->g.tok == zx_hrxml_RankedResult_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RankedResult(c,(struct zx_hrxml_RankedResult_s*)e,dup_strs);
  	  if (!enn)
  	      x->RankedResult = (struct zx_hrxml_RankedResult_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_RankedSearchResults) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->RankedResult->gg;
       e && e->g.tok == zx_hrxml_RankedResult_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RankedResult(c, (struct zx_hrxml_RankedResult_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_RankedSearchResults) */

int zx_WALK_WO_hrxml_RankedSearchResults(struct zx_ctx* c, struct zx_hrxml_RankedSearchResults_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Recipient
#define EL_STRUCT zx_hrxml_Recipient_s
#define EL_NS     hrxml
#define EL_TAG    Recipient

/* FUNC(zx_FREE_hrxml_Recipient) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->AdditionalText, free_strs);
  for (e = &x->Organization->gg;
       e && e->g.tok == zx_hrxml_Organization_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Organization(c, (struct zx_hrxml_Organization_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->OrganizationName, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Recipient) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Recipient_s* zx_NEW_hrxml_Recipient(struct zx_ctx* c)
{
  struct zx_hrxml_Recipient_s* x = ZX_ZALLOC(c, struct zx_hrxml_Recipient_s);
  x->gg.g.tok = zx_hrxml_Recipient_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Recipient) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PersonName->gg;
       se && se->g.tok == zx_hrxml_PersonName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  zx_dup_strs_simple_elems(c, x->AdditionalText);
  for (se = &x->Organization->gg;
       se && se->g.tok == zx_hrxml_Organization_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Organization(c, (struct zx_hrxml_Organization_s*)se);
  zx_dup_strs_simple_elems(c, x->OrganizationName);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Recipient) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Recipient_s* zx_DEEP_CLONE_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Recipient_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Recipient_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonName(c,(struct zx_hrxml_PersonName_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonName = (struct zx_hrxml_PersonName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->AdditionalText = zx_deep_clone_simple_elems(c,x->AdditionalText, dup_strs);
  for (enn = 0, e = &x->Organization->gg;
       e && e->g.tok == zx_hrxml_Organization_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Organization(c,(struct zx_hrxml_Organization_s*)e,dup_strs);
  	  if (!enn)
  	      x->Organization = (struct zx_hrxml_Organization_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->OrganizationName = zx_deep_clone_simple_elems(c,x->OrganizationName, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Recipient) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->AdditionalText, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Organization->gg;
       e && e->g.tok == zx_hrxml_Organization_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Organization(c, (struct zx_hrxml_Organization_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->OrganizationName, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Recipient) */

int zx_WALK_WO_hrxml_Recipient(struct zx_ctx* c, struct zx_hrxml_Recipient_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Reference
#define EL_STRUCT zx_hrxml_Reference_s
#define EL_NS     hrxml
#define EL_TAG    Reference

/* FUNC(zx_FREE_hrxml_Reference) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);

  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->PositionTitle, free_strs);
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Reference) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Reference_s* zx_NEW_hrxml_Reference(struct zx_ctx* c)
{
  struct zx_hrxml_Reference_s* x = ZX_ZALLOC(c, struct zx_hrxml_Reference_s);
  x->gg.g.tok = zx_hrxml_Reference_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Reference) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);

  for (se = &x->PersonName->gg;
       se && se->g.tok == zx_hrxml_PersonName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)se);
  zx_dup_strs_simple_elems(c, x->PositionTitle);
  for (se = &x->ContactMethod->gg;
       se && se->g.tok == zx_hrxml_ContactMethod_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Reference) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Reference_s* zx_DEEP_CLONE_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Reference_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Reference_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);

  for (enn = 0, e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonName(c,(struct zx_hrxml_PersonName_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonName = (struct zx_hrxml_PersonName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->PositionTitle = zx_deep_clone_simple_elems(c,x->PositionTitle, dup_strs);
  for (enn = 0, e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactMethod(c,(struct zx_hrxml_ContactMethod_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactMethod = (struct zx_hrxml_ContactMethod_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Reference) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PersonName->gg;
       e && e->g.tok == zx_hrxml_PersonName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonName(c, (struct zx_hrxml_PersonName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->PositionTitle, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->ContactMethod->gg;
       e && e->g.tok == zx_hrxml_ContactMethod_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactMethod(c, (struct zx_hrxml_ContactMethod_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Reference) */

int zx_WALK_WO_hrxml_Reference(struct zx_ctx* c, struct zx_hrxml_Reference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_References
#define EL_STRUCT zx_hrxml_References_s
#define EL_NS     hrxml
#define EL_TAG    References

/* FUNC(zx_FREE_hrxml_References) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Reference->gg;
       e && e->g.tok == zx_hrxml_Reference_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Reference(c, (struct zx_hrxml_Reference_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_References) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_References_s* zx_NEW_hrxml_References(struct zx_ctx* c)
{
  struct zx_hrxml_References_s* x = ZX_ZALLOC(c, struct zx_hrxml_References_s);
  x->gg.g.tok = zx_hrxml_References_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_References) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Reference->gg;
       se && se->g.tok == zx_hrxml_Reference_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Reference(c, (struct zx_hrxml_Reference_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_References) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_References_s* zx_DEEP_CLONE_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_References_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_References_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Reference->gg;
       e && e->g.tok == zx_hrxml_Reference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Reference(c,(struct zx_hrxml_Reference_s*)e,dup_strs);
  	  if (!enn)
  	      x->Reference = (struct zx_hrxml_Reference_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_References) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Reference->gg;
       e && e->g.tok == zx_hrxml_Reference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Reference(c, (struct zx_hrxml_Reference_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_References) */

int zx_WALK_WO_hrxml_References(struct zx_ctx* c, struct zx_hrxml_References_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelatedOrganization
#define EL_STRUCT zx_hrxml_RelatedOrganization_s
#define EL_NS     hrxml
#define EL_TAG    RelatedOrganization

/* FUNC(zx_FREE_hrxml_RelatedOrganization) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->relationship, free_strs);

  zx_free_simple_elems(c, x->OrganizationName, free_strs);
  for (e = &x->OrganizationId->gg;
       e && e->g.tok == zx_hrxml_OrganizationId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)e, free_strs);
  }
  for (e = &x->TaxId->gg;
       e && e->g.tok == zx_hrxml_TaxId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_TaxId(c, (struct zx_hrxml_TaxId_s*)e, free_strs);
  }
  for (e = &x->LegalId->gg;
       e && e->g.tok == zx_hrxml_LegalId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LegalId(c, (struct zx_hrxml_LegalId_s*)e, free_strs);
  }
  for (e = &x->DunsNumber->gg;
       e && e->g.tok == zx_hrxml_DunsNumber_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DunsNumber(c, (struct zx_hrxml_DunsNumber_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->IsPublicCompany, free_strs);
  for (e = &x->Stock->gg;
       e && e->g.tok == zx_hrxml_Stock_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Stock(c, (struct zx_hrxml_Stock_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->MissionStatement, free_strs);
  zx_free_simple_elems(c, x->ValueStatement, free_strs);
  for (e = &x->InternetDomainName->gg;
       e && e->g.tok == zx_hrxml_InternetDomainName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)e, free_strs);
  }
  for (e = &x->DoingBusinessAs->gg;
       e && e->g.tok == zx_hrxml_DoingBusinessAs_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DoingBusinessAs(c, (struct zx_hrxml_DoingBusinessAs_s*)e, free_strs);
  }
  for (e = &x->LegalClassification->gg;
       e && e->g.tok == zx_hrxml_LegalClassification_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LegalClassification(c, (struct zx_hrxml_LegalClassification_s*)e, free_strs);
  }
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Headcount, free_strs);
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }
  for (e = &x->WorkSite->gg;
       e && e->g.tok == zx_hrxml_WorkSite_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)e, free_strs);
  }
  for (e = &x->ContactInfo->gg;
       e && e->g.tok == zx_hrxml_ContactInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)e, free_strs);
  }
  for (e = &x->RelatedOrganization->gg;
       e && e->g.tok == zx_hrxml_RelatedOrganization_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RelatedOrganization(c, (struct zx_hrxml_RelatedOrganization_s*)e, free_strs);
  }
  for (e = &x->OrganizationalUnit->gg;
       e && e->g.tok == zx_hrxml_OrganizationalUnit_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrganizationalUnit(c, (struct zx_hrxml_OrganizationalUnit_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_RelatedOrganization) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_RelatedOrganization_s* zx_NEW_hrxml_RelatedOrganization(struct zx_ctx* c)
{
  struct zx_hrxml_RelatedOrganization_s* x = ZX_ZALLOC(c, struct zx_hrxml_RelatedOrganization_s);
  x->gg.g.tok = zx_hrxml_RelatedOrganization_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_RelatedOrganization) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->relationship);

  zx_dup_strs_simple_elems(c, x->OrganizationName);
  for (se = &x->OrganizationId->gg;
       se && se->g.tok == zx_hrxml_OrganizationId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)se);
  for (se = &x->TaxId->gg;
       se && se->g.tok == zx_hrxml_TaxId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_TaxId(c, (struct zx_hrxml_TaxId_s*)se);
  for (se = &x->LegalId->gg;
       se && se->g.tok == zx_hrxml_LegalId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LegalId(c, (struct zx_hrxml_LegalId_s*)se);
  for (se = &x->DunsNumber->gg;
       se && se->g.tok == zx_hrxml_DunsNumber_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DunsNumber(c, (struct zx_hrxml_DunsNumber_s*)se);
  zx_dup_strs_simple_elems(c, x->IsPublicCompany);
  for (se = &x->Stock->gg;
       se && se->g.tok == zx_hrxml_Stock_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Stock(c, (struct zx_hrxml_Stock_s*)se);
  zx_dup_strs_simple_elems(c, x->MissionStatement);
  zx_dup_strs_simple_elems(c, x->ValueStatement);
  for (se = &x->InternetDomainName->gg;
       se && se->g.tok == zx_hrxml_InternetDomainName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)se);
  for (se = &x->DoingBusinessAs->gg;
       se && se->g.tok == zx_hrxml_DoingBusinessAs_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DoingBusinessAs(c, (struct zx_hrxml_DoingBusinessAs_s*)se);
  for (se = &x->LegalClassification->gg;
       se && se->g.tok == zx_hrxml_LegalClassification_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LegalClassification(c, (struct zx_hrxml_LegalClassification_s*)se);
  for (se = &x->IndustryCode->gg;
       se && se->g.tok == zx_hrxml_IndustryCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);
  zx_dup_strs_simple_elems(c, x->Headcount);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->WorkSite->gg;
       se && se->g.tok == zx_hrxml_WorkSite_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)se);
  for (se = &x->ContactInfo->gg;
       se && se->g.tok == zx_hrxml_ContactInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)se);
  for (se = &x->RelatedOrganization->gg;
       se && se->g.tok == zx_hrxml_RelatedOrganization_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RelatedOrganization(c, (struct zx_hrxml_RelatedOrganization_s*)se);
  for (se = &x->OrganizationalUnit->gg;
       se && se->g.tok == zx_hrxml_OrganizationalUnit_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrganizationalUnit(c, (struct zx_hrxml_OrganizationalUnit_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_RelatedOrganization) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_RelatedOrganization_s* zx_DEEP_CLONE_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_RelatedOrganization_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_RelatedOrganization_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->relationship = zx_clone_attr(c, x->relationship);

  x->OrganizationName = zx_deep_clone_simple_elems(c,x->OrganizationName, dup_strs);
  for (enn = 0, e = &x->OrganizationId->gg;
       e && e->g.tok == zx_hrxml_OrganizationId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrganizationId(c,(struct zx_hrxml_OrganizationId_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrganizationId = (struct zx_hrxml_OrganizationId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->TaxId->gg;
       e && e->g.tok == zx_hrxml_TaxId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_TaxId(c,(struct zx_hrxml_TaxId_s*)e,dup_strs);
  	  if (!enn)
  	      x->TaxId = (struct zx_hrxml_TaxId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->LegalId->gg;
       e && e->g.tok == zx_hrxml_LegalId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LegalId(c,(struct zx_hrxml_LegalId_s*)e,dup_strs);
  	  if (!enn)
  	      x->LegalId = (struct zx_hrxml_LegalId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DunsNumber->gg;
       e && e->g.tok == zx_hrxml_DunsNumber_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DunsNumber(c,(struct zx_hrxml_DunsNumber_s*)e,dup_strs);
  	  if (!enn)
  	      x->DunsNumber = (struct zx_hrxml_DunsNumber_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->IsPublicCompany = zx_deep_clone_simple_elems(c,x->IsPublicCompany, dup_strs);
  for (enn = 0, e = &x->Stock->gg;
       e && e->g.tok == zx_hrxml_Stock_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Stock(c,(struct zx_hrxml_Stock_s*)e,dup_strs);
  	  if (!enn)
  	      x->Stock = (struct zx_hrxml_Stock_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->MissionStatement = zx_deep_clone_simple_elems(c,x->MissionStatement, dup_strs);
  x->ValueStatement = zx_deep_clone_simple_elems(c,x->ValueStatement, dup_strs);
  for (enn = 0, e = &x->InternetDomainName->gg;
       e && e->g.tok == zx_hrxml_InternetDomainName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_InternetDomainName(c,(struct zx_hrxml_InternetDomainName_s*)e,dup_strs);
  	  if (!enn)
  	      x->InternetDomainName = (struct zx_hrxml_InternetDomainName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DoingBusinessAs->gg;
       e && e->g.tok == zx_hrxml_DoingBusinessAs_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DoingBusinessAs(c,(struct zx_hrxml_DoingBusinessAs_s*)e,dup_strs);
  	  if (!enn)
  	      x->DoingBusinessAs = (struct zx_hrxml_DoingBusinessAs_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->LegalClassification->gg;
       e && e->g.tok == zx_hrxml_LegalClassification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LegalClassification(c,(struct zx_hrxml_LegalClassification_s*)e,dup_strs);
  	  if (!enn)
  	      x->LegalClassification = (struct zx_hrxml_LegalClassification_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IndustryCode(c,(struct zx_hrxml_IndustryCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->IndustryCode = (struct zx_hrxml_IndustryCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Headcount = zx_deep_clone_simple_elems(c,x->Headcount, dup_strs);
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->WorkSite->gg;
       e && e->g.tok == zx_hrxml_WorkSite_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_WorkSite(c,(struct zx_hrxml_WorkSite_s*)e,dup_strs);
  	  if (!enn)
  	      x->WorkSite = (struct zx_hrxml_WorkSite_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ContactInfo->gg;
       e && e->g.tok == zx_hrxml_ContactInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactInfo(c,(struct zx_hrxml_ContactInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactInfo = (struct zx_hrxml_ContactInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RelatedOrganization->gg;
       e && e->g.tok == zx_hrxml_RelatedOrganization_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RelatedOrganization(c,(struct zx_hrxml_RelatedOrganization_s*)e,dup_strs);
  	  if (!enn)
  	      x->RelatedOrganization = (struct zx_hrxml_RelatedOrganization_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OrganizationalUnit->gg;
       e && e->g.tok == zx_hrxml_OrganizationalUnit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrganizationalUnit(c,(struct zx_hrxml_OrganizationalUnit_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrganizationalUnit = (struct zx_hrxml_OrganizationalUnit_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_RelatedOrganization) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->OrganizationName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->OrganizationId->gg;
       e && e->g.tok == zx_hrxml_OrganizationId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->TaxId->gg;
       e && e->g.tok == zx_hrxml_TaxId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_TaxId(c, (struct zx_hrxml_TaxId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->LegalId->gg;
       e && e->g.tok == zx_hrxml_LegalId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LegalId(c, (struct zx_hrxml_LegalId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DunsNumber->gg;
       e && e->g.tok == zx_hrxml_DunsNumber_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DunsNumber(c, (struct zx_hrxml_DunsNumber_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->IsPublicCompany, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Stock->gg;
       e && e->g.tok == zx_hrxml_Stock_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Stock(c, (struct zx_hrxml_Stock_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->MissionStatement, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->ValueStatement, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->InternetDomainName->gg;
       e && e->g.tok == zx_hrxml_InternetDomainName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DoingBusinessAs->gg;
       e && e->g.tok == zx_hrxml_DoingBusinessAs_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DoingBusinessAs(c, (struct zx_hrxml_DoingBusinessAs_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->LegalClassification->gg;
       e && e->g.tok == zx_hrxml_LegalClassification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LegalClassification(c, (struct zx_hrxml_LegalClassification_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Headcount, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->WorkSite->gg;
       e && e->g.tok == zx_hrxml_WorkSite_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ContactInfo->gg;
       e && e->g.tok == zx_hrxml_ContactInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RelatedOrganization->gg;
       e && e->g.tok == zx_hrxml_RelatedOrganization_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RelatedOrganization(c, (struct zx_hrxml_RelatedOrganization_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OrganizationalUnit->gg;
       e && e->g.tok == zx_hrxml_OrganizationalUnit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrganizationalUnit(c, (struct zx_hrxml_OrganizationalUnit_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_RelatedOrganization) */

int zx_WALK_WO_hrxml_RelatedOrganization(struct zx_ctx* c, struct zx_hrxml_RelatedOrganization_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelatedOrganizationalUnit
#define EL_STRUCT zx_hrxml_RelatedOrganizationalUnit_s
#define EL_NS     hrxml
#define EL_TAG    RelatedOrganizationalUnit

/* FUNC(zx_FREE_hrxml_RelatedOrganizationalUnit) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->hierarchicalRole, free_strs);
  zx_free_attr(c, x->natureOfRelationship, free_strs);
  zx_free_attr(c, x->relationship, free_strs);
  zx_free_attr(c, x->typeOfGroup, free_strs);

  zx_free_simple_elems(c, x->OrganizationalUnitName, free_strs);
  for (e = &x->OrganizationalUnitId->gg;
       e && e->g.tok == zx_hrxml_OrganizationalUnitId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrganizationalUnitId(c, (struct zx_hrxml_OrganizationalUnitId_s*)e, free_strs);
  }
  for (e = &x->OrganizationId->gg;
       e && e->g.tok == zx_hrxml_OrganizationId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)e, free_strs);
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, free_strs);
  }
  for (e = &x->AccountingCode->gg;
       e && e->g.tok == zx_hrxml_AccountingCode_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_AccountingCode(c, (struct zx_hrxml_AccountingCode_s*)e, free_strs);
  }
  for (e = &x->WorkSite->gg;
       e && e->g.tok == zx_hrxml_WorkSite_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)e, free_strs);
  }
  for (e = &x->RelatedOrganizationalUnit->gg;
       e && e->g.tok == zx_hrxml_RelatedOrganizationalUnit_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RelatedOrganizationalUnit(c, (struct zx_hrxml_RelatedOrganizationalUnit_s*)e, free_strs);
  }
  for (e = &x->PersonMember->gg;
       e && e->g.tok == zx_hrxml_PersonMember_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PersonMember(c, (struct zx_hrxml_PersonMember_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_RelatedOrganizationalUnit) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_RelatedOrganizationalUnit_s* zx_NEW_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c)
{
  struct zx_hrxml_RelatedOrganizationalUnit_s* x = ZX_ZALLOC(c, struct zx_hrxml_RelatedOrganizationalUnit_s);
  x->gg.g.tok = zx_hrxml_RelatedOrganizationalUnit_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_RelatedOrganizationalUnit) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->hierarchicalRole);
  zx_dup_attr(c, x->natureOfRelationship);
  zx_dup_attr(c, x->relationship);
  zx_dup_attr(c, x->typeOfGroup);

  zx_dup_strs_simple_elems(c, x->OrganizationalUnitName);
  for (se = &x->OrganizationalUnitId->gg;
       se && se->g.tok == zx_hrxml_OrganizationalUnitId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrganizationalUnitId(c, (struct zx_hrxml_OrganizationalUnitId_s*)se);
  for (se = &x->OrganizationId->gg;
       se && se->g.tok == zx_hrxml_OrganizationId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)se);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->IndustryCode->gg;
       se && se->g.tok == zx_hrxml_IndustryCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)se);
  for (se = &x->AccountingCode->gg;
       se && se->g.tok == zx_hrxml_AccountingCode_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_AccountingCode(c, (struct zx_hrxml_AccountingCode_s*)se);
  for (se = &x->WorkSite->gg;
       se && se->g.tok == zx_hrxml_WorkSite_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)se);
  for (se = &x->RelatedOrganizationalUnit->gg;
       se && se->g.tok == zx_hrxml_RelatedOrganizationalUnit_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RelatedOrganizationalUnit(c, (struct zx_hrxml_RelatedOrganizationalUnit_s*)se);
  for (se = &x->PersonMember->gg;
       se && se->g.tok == zx_hrxml_PersonMember_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PersonMember(c, (struct zx_hrxml_PersonMember_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_RelatedOrganizationalUnit) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_RelatedOrganizationalUnit_s* zx_DEEP_CLONE_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_RelatedOrganizationalUnit_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_RelatedOrganizationalUnit_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->hierarchicalRole = zx_clone_attr(c, x->hierarchicalRole);
  x->natureOfRelationship = zx_clone_attr(c, x->natureOfRelationship);
  x->relationship = zx_clone_attr(c, x->relationship);
  x->typeOfGroup = zx_clone_attr(c, x->typeOfGroup);

  x->OrganizationalUnitName = zx_deep_clone_simple_elems(c,x->OrganizationalUnitName, dup_strs);
  for (enn = 0, e = &x->OrganizationalUnitId->gg;
       e && e->g.tok == zx_hrxml_OrganizationalUnitId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrganizationalUnitId(c,(struct zx_hrxml_OrganizationalUnitId_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrganizationalUnitId = (struct zx_hrxml_OrganizationalUnitId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OrganizationId->gg;
       e && e->g.tok == zx_hrxml_OrganizationId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrganizationId(c,(struct zx_hrxml_OrganizationId_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrganizationId = (struct zx_hrxml_OrganizationId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IndustryCode(c,(struct zx_hrxml_IndustryCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->IndustryCode = (struct zx_hrxml_IndustryCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->AccountingCode->gg;
       e && e->g.tok == zx_hrxml_AccountingCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_AccountingCode(c,(struct zx_hrxml_AccountingCode_s*)e,dup_strs);
  	  if (!enn)
  	      x->AccountingCode = (struct zx_hrxml_AccountingCode_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->WorkSite->gg;
       e && e->g.tok == zx_hrxml_WorkSite_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_WorkSite(c,(struct zx_hrxml_WorkSite_s*)e,dup_strs);
  	  if (!enn)
  	      x->WorkSite = (struct zx_hrxml_WorkSite_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->RelatedOrganizationalUnit->gg;
       e && e->g.tok == zx_hrxml_RelatedOrganizationalUnit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RelatedOrganizationalUnit(c,(struct zx_hrxml_RelatedOrganizationalUnit_s*)e,dup_strs);
  	  if (!enn)
  	      x->RelatedOrganizationalUnit = (struct zx_hrxml_RelatedOrganizationalUnit_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PersonMember->gg;
       e && e->g.tok == zx_hrxml_PersonMember_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PersonMember(c,(struct zx_hrxml_PersonMember_s*)e,dup_strs);
  	  if (!enn)
  	      x->PersonMember = (struct zx_hrxml_PersonMember_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_RelatedOrganizationalUnit) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->OrganizationalUnitName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->OrganizationalUnitId->gg;
       e && e->g.tok == zx_hrxml_OrganizationalUnitId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrganizationalUnitId(c, (struct zx_hrxml_OrganizationalUnitId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OrganizationId->gg;
       e && e->g.tok == zx_hrxml_OrganizationId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrganizationId(c, (struct zx_hrxml_OrganizationId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->IndustryCode->gg;
       e && e->g.tok == zx_hrxml_IndustryCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IndustryCode(c, (struct zx_hrxml_IndustryCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->AccountingCode->gg;
       e && e->g.tok == zx_hrxml_AccountingCode_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_AccountingCode(c, (struct zx_hrxml_AccountingCode_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->WorkSite->gg;
       e && e->g.tok == zx_hrxml_WorkSite_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_WorkSite(c, (struct zx_hrxml_WorkSite_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->RelatedOrganizationalUnit->gg;
       e && e->g.tok == zx_hrxml_RelatedOrganizationalUnit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RelatedOrganizationalUnit(c, (struct zx_hrxml_RelatedOrganizationalUnit_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PersonMember->gg;
       e && e->g.tok == zx_hrxml_PersonMember_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PersonMember(c, (struct zx_hrxml_PersonMember_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_RelatedOrganizationalUnit) */

int zx_WALK_WO_hrxml_RelatedOrganizationalUnit(struct zx_ctx* c, struct zx_hrxml_RelatedOrganizationalUnit_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelatedPositionPostings
#define EL_STRUCT zx_hrxml_RelatedPositionPostings_s
#define EL_NS     hrxml
#define EL_TAG    RelatedPositionPostings

/* FUNC(zx_FREE_hrxml_RelatedPositionPostings) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->PositionPosting->gg;
       e && e->g.tok == zx_hrxml_PositionPosting_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PositionPosting(c, (struct zx_hrxml_PositionPosting_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_RelatedPositionPostings) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_RelatedPositionPostings_s* zx_NEW_hrxml_RelatedPositionPostings(struct zx_ctx* c)
{
  struct zx_hrxml_RelatedPositionPostings_s* x = ZX_ZALLOC(c, struct zx_hrxml_RelatedPositionPostings_s);
  x->gg.g.tok = zx_hrxml_RelatedPositionPostings_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_RelatedPositionPostings) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->PositionPosting->gg;
       se && se->g.tok == zx_hrxml_PositionPosting_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PositionPosting(c, (struct zx_hrxml_PositionPosting_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_RelatedPositionPostings) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_RelatedPositionPostings_s* zx_DEEP_CLONE_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_RelatedPositionPostings_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_RelatedPositionPostings_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->PositionPosting->gg;
       e && e->g.tok == zx_hrxml_PositionPosting_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PositionPosting(c,(struct zx_hrxml_PositionPosting_s*)e,dup_strs);
  	  if (!enn)
  	      x->PositionPosting = (struct zx_hrxml_PositionPosting_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_RelatedPositionPostings) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->PositionPosting->gg;
       e && e->g.tok == zx_hrxml_PositionPosting_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PositionPosting(c, (struct zx_hrxml_PositionPosting_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_RelatedPositionPostings) */

int zx_WALK_WO_hrxml_RelatedPositionPostings(struct zx_ctx* c, struct zx_hrxml_RelatedPositionPostings_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Relocation
#define EL_STRUCT zx_hrxml_Relocation_s
#define EL_NS     hrxml
#define EL_TAG    Relocation

/* FUNC(zx_FREE_hrxml_Relocation) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->relocationConsidered, free_strs);

  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Relocation) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Relocation_s* zx_NEW_hrxml_Relocation(struct zx_ctx* c)
{
  struct zx_hrxml_Relocation_s* x = ZX_ZALLOC(c, struct zx_hrxml_Relocation_s);
  x->gg.g.tok = zx_hrxml_Relocation_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Relocation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->relocationConsidered);

  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Relocation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Relocation_s* zx_DEEP_CLONE_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Relocation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Relocation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->relocationConsidered = zx_clone_attr(c, x->relocationConsidered);

  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Relocation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Relocation) */

int zx_WALK_WO_hrxml_Relocation(struct zx_ctx* c, struct zx_hrxml_Relocation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RelocationAssistance
#define EL_STRUCT zx_hrxml_RelocationAssistance_s
#define EL_NS     hrxml
#define EL_TAG    RelocationAssistance

/* FUNC(zx_FREE_hrxml_RelocationAssistance) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->companyOffered, free_strs);

  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_RelocationAssistance) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_RelocationAssistance_s* zx_NEW_hrxml_RelocationAssistance(struct zx_ctx* c)
{
  struct zx_hrxml_RelocationAssistance_s* x = ZX_ZALLOC(c, struct zx_hrxml_RelocationAssistance_s);
  x->gg.g.tok = zx_hrxml_RelocationAssistance_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_RelocationAssistance) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->companyOffered);

  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_RelocationAssistance) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_RelocationAssistance_s* zx_DEEP_CLONE_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_RelocationAssistance_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_RelocationAssistance_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->companyOffered = zx_clone_attr(c, x->companyOffered);

  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_RelocationAssistance) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_RelocationAssistance) */

int zx_WALK_WO_hrxml_RelocationAssistance(struct zx_ctx* c, struct zx_hrxml_RelocationAssistance_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RemunerationPackage
#define EL_STRUCT zx_hrxml_RemunerationPackage_s
#define EL_NS     hrxml
#define EL_TAG    RemunerationPackage

/* FUNC(zx_FREE_hrxml_RemunerationPackage) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->BasePay->gg;
       e && e->g.tok == zx_hrxml_BasePay_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_BasePay(c, (struct zx_hrxml_BasePay_s*)e, free_strs);
  }
  for (e = &x->OtherPay->gg;
       e && e->g.tok == zx_hrxml_OtherPay_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OtherPay(c, (struct zx_hrxml_OtherPay_s*)e, free_strs);
  }
  for (e = &x->Benefits->gg;
       e && e->g.tok == zx_hrxml_Benefits_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Benefits(c, (struct zx_hrxml_Benefits_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_RemunerationPackage) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_RemunerationPackage_s* zx_NEW_hrxml_RemunerationPackage(struct zx_ctx* c)
{
  struct zx_hrxml_RemunerationPackage_s* x = ZX_ZALLOC(c, struct zx_hrxml_RemunerationPackage_s);
  x->gg.g.tok = zx_hrxml_RemunerationPackage_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_RemunerationPackage) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->BasePay->gg;
       se && se->g.tok == zx_hrxml_BasePay_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_BasePay(c, (struct zx_hrxml_BasePay_s*)se);
  for (se = &x->OtherPay->gg;
       se && se->g.tok == zx_hrxml_OtherPay_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OtherPay(c, (struct zx_hrxml_OtherPay_s*)se);
  for (se = &x->Benefits->gg;
       se && se->g.tok == zx_hrxml_Benefits_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Benefits(c, (struct zx_hrxml_Benefits_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_RemunerationPackage) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_RemunerationPackage_s* zx_DEEP_CLONE_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_RemunerationPackage_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_RemunerationPackage_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->BasePay->gg;
       e && e->g.tok == zx_hrxml_BasePay_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_BasePay(c,(struct zx_hrxml_BasePay_s*)e,dup_strs);
  	  if (!enn)
  	      x->BasePay = (struct zx_hrxml_BasePay_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OtherPay->gg;
       e && e->g.tok == zx_hrxml_OtherPay_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OtherPay(c,(struct zx_hrxml_OtherPay_s*)e,dup_strs);
  	  if (!enn)
  	      x->OtherPay = (struct zx_hrxml_OtherPay_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Benefits->gg;
       e && e->g.tok == zx_hrxml_Benefits_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Benefits(c,(struct zx_hrxml_Benefits_s*)e,dup_strs);
  	  if (!enn)
  	      x->Benefits = (struct zx_hrxml_Benefits_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_RemunerationPackage) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->BasePay->gg;
       e && e->g.tok == zx_hrxml_BasePay_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_BasePay(c, (struct zx_hrxml_BasePay_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OtherPay->gg;
       e && e->g.tok == zx_hrxml_OtherPay_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OtherPay(c, (struct zx_hrxml_OtherPay_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Benefits->gg;
       e && e->g.tok == zx_hrxml_Benefits_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Benefits(c, (struct zx_hrxml_Benefits_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_RemunerationPackage) */

int zx_WALK_WO_hrxml_RemunerationPackage(struct zx_ctx* c, struct zx_hrxml_RemunerationPackage_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Resume
#define EL_STRUCT zx_hrxml_Resume_s
#define EL_NS     hrxml
#define EL_TAG    Resume

/* FUNC(zx_FREE_hrxml_Resume) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);

  zx_free_simple_elems(c, x->ResumeId, free_strs);
  zx_free_simple_elems(c, x->DistributionGuidelines, free_strs);
  for (e = &x->StructuredXMLResume->gg;
       e && e->g.tok == zx_hrxml_StructuredXMLResume_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StructuredXMLResume(c, (struct zx_hrxml_StructuredXMLResume_s*)e, free_strs);
  }
  for (e = &x->NonXMLResume->gg;
       e && e->g.tok == zx_hrxml_NonXMLResume_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_NonXMLResume(c, (struct zx_hrxml_NonXMLResume_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Resume) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Resume_s* zx_NEW_hrxml_Resume(struct zx_ctx* c)
{
  struct zx_hrxml_Resume_s* x = ZX_ZALLOC(c, struct zx_hrxml_Resume_s);
  x->gg.g.tok = zx_hrxml_Resume_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Resume) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);

  zx_dup_strs_simple_elems(c, x->ResumeId);
  zx_dup_strs_simple_elems(c, x->DistributionGuidelines);
  for (se = &x->StructuredXMLResume->gg;
       se && se->g.tok == zx_hrxml_StructuredXMLResume_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StructuredXMLResume(c, (struct zx_hrxml_StructuredXMLResume_s*)se);
  for (se = &x->NonXMLResume->gg;
       se && se->g.tok == zx_hrxml_NonXMLResume_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_NonXMLResume(c, (struct zx_hrxml_NonXMLResume_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Resume) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Resume_s* zx_DEEP_CLONE_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Resume_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Resume_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);

  x->ResumeId = zx_deep_clone_simple_elems(c,x->ResumeId, dup_strs);
  x->DistributionGuidelines = zx_deep_clone_simple_elems(c,x->DistributionGuidelines, dup_strs);
  for (enn = 0, e = &x->StructuredXMLResume->gg;
       e && e->g.tok == zx_hrxml_StructuredXMLResume_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StructuredXMLResume(c,(struct zx_hrxml_StructuredXMLResume_s*)e,dup_strs);
  	  if (!enn)
  	      x->StructuredXMLResume = (struct zx_hrxml_StructuredXMLResume_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->NonXMLResume->gg;
       e && e->g.tok == zx_hrxml_NonXMLResume_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_NonXMLResume(c,(struct zx_hrxml_NonXMLResume_s*)e,dup_strs);
  	  if (!enn)
  	      x->NonXMLResume = (struct zx_hrxml_NonXMLResume_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Resume) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->ResumeId, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->DistributionGuidelines, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->StructuredXMLResume->gg;
       e && e->g.tok == zx_hrxml_StructuredXMLResume_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StructuredXMLResume(c, (struct zx_hrxml_StructuredXMLResume_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->NonXMLResume->gg;
       e && e->g.tok == zx_hrxml_NonXMLResume_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_NonXMLResume(c, (struct zx_hrxml_NonXMLResume_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Resume) */

int zx_WALK_WO_hrxml_Resume(struct zx_ctx* c, struct zx_hrxml_Resume_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ResumeAdditionalItem
#define EL_STRUCT zx_hrxml_ResumeAdditionalItem_s
#define EL_NS     hrxml
#define EL_TAG    ResumeAdditionalItem

/* FUNC(zx_FREE_hrxml_ResumeAdditionalItem) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);

  for (e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)e, free_strs);
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ResumeAdditionalItem) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ResumeAdditionalItem_s* zx_NEW_hrxml_ResumeAdditionalItem(struct zx_ctx* c)
{
  struct zx_hrxml_ResumeAdditionalItem_s* x = ZX_ZALLOC(c, struct zx_hrxml_ResumeAdditionalItem_s);
  x->gg.g.tok = zx_hrxml_ResumeAdditionalItem_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ResumeAdditionalItem) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);

  for (se = &x->EffectiveDate->gg;
       se && se->g.tok == zx_hrxml_EffectiveDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ResumeAdditionalItem) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ResumeAdditionalItem_s* zx_DEEP_CLONE_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ResumeAdditionalItem_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ResumeAdditionalItem_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);

  for (enn = 0, e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EffectiveDate(c,(struct zx_hrxml_EffectiveDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EffectiveDate = (struct zx_hrxml_EffectiveDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ResumeAdditionalItem) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ResumeAdditionalItem) */

int zx_WALK_WO_hrxml_ResumeAdditionalItem(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItem_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ResumeAdditionalItems
#define EL_STRUCT zx_hrxml_ResumeAdditionalItems_s
#define EL_NS     hrxml
#define EL_TAG    ResumeAdditionalItems

/* FUNC(zx_FREE_hrxml_ResumeAdditionalItems) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->ResumeAdditionalItem->gg;
       e && e->g.tok == zx_hrxml_ResumeAdditionalItem_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ResumeAdditionalItem(c, (struct zx_hrxml_ResumeAdditionalItem_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ResumeAdditionalItems) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ResumeAdditionalItems_s* zx_NEW_hrxml_ResumeAdditionalItems(struct zx_ctx* c)
{
  struct zx_hrxml_ResumeAdditionalItems_s* x = ZX_ZALLOC(c, struct zx_hrxml_ResumeAdditionalItems_s);
  x->gg.g.tok = zx_hrxml_ResumeAdditionalItems_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ResumeAdditionalItems) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ResumeAdditionalItem->gg;
       se && se->g.tok == zx_hrxml_ResumeAdditionalItem_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ResumeAdditionalItem(c, (struct zx_hrxml_ResumeAdditionalItem_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ResumeAdditionalItems) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ResumeAdditionalItems_s* zx_DEEP_CLONE_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ResumeAdditionalItems_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ResumeAdditionalItems_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ResumeAdditionalItem->gg;
       e && e->g.tok == zx_hrxml_ResumeAdditionalItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ResumeAdditionalItem(c,(struct zx_hrxml_ResumeAdditionalItem_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResumeAdditionalItem = (struct zx_hrxml_ResumeAdditionalItem_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ResumeAdditionalItems) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ResumeAdditionalItem->gg;
       e && e->g.tok == zx_hrxml_ResumeAdditionalItem_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ResumeAdditionalItem(c, (struct zx_hrxml_ResumeAdditionalItem_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ResumeAdditionalItems) */

int zx_WALK_WO_hrxml_ResumeAdditionalItems(struct zx_ctx* c, struct zx_hrxml_ResumeAdditionalItems_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_RoleId
#define EL_STRUCT zx_hrxml_RoleId_s
#define EL_NS     hrxml
#define EL_TAG    RoleId

/* FUNC(zx_FREE_hrxml_RoleId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_RoleId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_RoleId_s* zx_NEW_hrxml_RoleId(struct zx_ctx* c)
{
  struct zx_hrxml_RoleId_s* x = ZX_ZALLOC(c, struct zx_hrxml_RoleId_s);
  x->gg.g.tok = zx_hrxml_RoleId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_RoleId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_RoleId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_RoleId_s* zx_DEEP_CLONE_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_RoleId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_RoleId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_RoleId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_RoleId) */

int zx_WALK_WO_hrxml_RoleId(struct zx_ctx* c, struct zx_hrxml_RoleId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SEPPhysicalLocation
#define EL_STRUCT zx_hrxml_SEPPhysicalLocation_s
#define EL_NS     hrxml
#define EL_TAG    SEPPhysicalLocation

/* FUNC(zx_FREE_hrxml_SEPPhysicalLocation) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Name, free_strs);
  for (e = &x->SpatialLocation->gg;
       e && e->g.tok == zx_hrxml_SpatialLocation_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SpatialLocation(c, (struct zx_hrxml_SpatialLocation_s*)e, free_strs);
  }
  for (e = &x->TravelDirections->gg;
       e && e->g.tok == zx_hrxml_TravelDirections_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)e, free_strs);
  }
  for (e = &x->Area->gg;
       e && e->g.tok == zx_hrxml_Area_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Area(c, (struct zx_hrxml_Area_s*)e, free_strs);
  }
  for (e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SEPPhysicalLocation) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SEPPhysicalLocation_s* zx_NEW_hrxml_SEPPhysicalLocation(struct zx_ctx* c)
{
  struct zx_hrxml_SEPPhysicalLocation_s* x = ZX_ZALLOC(c, struct zx_hrxml_SEPPhysicalLocation_s);
  x->gg.g.tok = zx_hrxml_SEPPhysicalLocation_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SEPPhysicalLocation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  zx_dup_strs_simple_elems(c, x->Name);
  for (se = &x->SpatialLocation->gg;
       se && se->g.tok == zx_hrxml_SpatialLocation_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SpatialLocation(c, (struct zx_hrxml_SpatialLocation_s*)se);
  for (se = &x->TravelDirections->gg;
       se && se->g.tok == zx_hrxml_TravelDirections_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)se);
  for (se = &x->Area->gg;
       se && se->g.tok == zx_hrxml_Area_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Area(c, (struct zx_hrxml_Area_s*)se);
  for (se = &x->PostalAddress->gg;
       se && se->g.tok == zx_hrxml_PostalAddress_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SEPPhysicalLocation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SEPPhysicalLocation_s* zx_DEEP_CLONE_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SEPPhysicalLocation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SEPPhysicalLocation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  for (enn = 0, e = &x->SpatialLocation->gg;
       e && e->g.tok == zx_hrxml_SpatialLocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SpatialLocation(c,(struct zx_hrxml_SpatialLocation_s*)e,dup_strs);
  	  if (!enn)
  	      x->SpatialLocation = (struct zx_hrxml_SpatialLocation_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->TravelDirections->gg;
       e && e->g.tok == zx_hrxml_TravelDirections_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_TravelDirections(c,(struct zx_hrxml_TravelDirections_s*)e,dup_strs);
  	  if (!enn)
  	      x->TravelDirections = (struct zx_hrxml_TravelDirections_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Area->gg;
       e && e->g.tok == zx_hrxml_Area_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Area(c,(struct zx_hrxml_Area_s*)e,dup_strs);
  	  if (!enn)
  	      x->Area = (struct zx_hrxml_Area_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PostalAddress(c,(struct zx_hrxml_PostalAddress_s*)e,dup_strs);
  	  if (!enn)
  	      x->PostalAddress = (struct zx_hrxml_PostalAddress_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SEPPhysicalLocation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->SpatialLocation->gg;
       e && e->g.tok == zx_hrxml_SpatialLocation_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SpatialLocation(c, (struct zx_hrxml_SpatialLocation_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->TravelDirections->gg;
       e && e->g.tok == zx_hrxml_TravelDirections_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Area->gg;
       e && e->g.tok == zx_hrxml_Area_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Area(c, (struct zx_hrxml_Area_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SEPPhysicalLocation) */

int zx_WALK_WO_hrxml_SEPPhysicalLocation(struct zx_ctx* c, struct zx_hrxml_SEPPhysicalLocation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SafetyEquipment
#define EL_STRUCT zx_hrxml_SafetyEquipment_s
#define EL_NS     hrxml
#define EL_TAG    SafetyEquipment

/* FUNC(zx_FREE_hrxml_SafetyEquipment) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->suppliedByOrganization, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SafetyEquipment) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SafetyEquipment_s* zx_NEW_hrxml_SafetyEquipment(struct zx_ctx* c)
{
  struct zx_hrxml_SafetyEquipment_s* x = ZX_ZALLOC(c, struct zx_hrxml_SafetyEquipment_s);
  x->gg.g.tok = zx_hrxml_SafetyEquipment_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SafetyEquipment) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->suppliedByOrganization);


}

/* FUNC(zx_DEEP_CLONE_hrxml_SafetyEquipment) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SafetyEquipment_s* zx_DEEP_CLONE_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SafetyEquipment_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SafetyEquipment_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->suppliedByOrganization = zx_clone_attr(c, x->suppliedByOrganization);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SafetyEquipment) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SafetyEquipment) */

int zx_WALK_WO_hrxml_SafetyEquipment(struct zx_ctx* c, struct zx_hrxml_SafetyEquipment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_School
#define EL_STRUCT zx_hrxml_School_s
#define EL_NS     hrxml
#define EL_TAG    School

/* FUNC(zx_FREE_hrxml_School) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);

  for (e = &x->InternetDomainName->gg;
       e && e->g.tok == zx_hrxml_InternetDomainName_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)e, free_strs);
  }
  for (e = &x->SchoolId->gg;
       e && e->g.tok == zx_hrxml_SchoolId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SchoolId(c, (struct zx_hrxml_SchoolId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->SchoolName, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_School) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_School_s* zx_NEW_hrxml_School(struct zx_ctx* c)
{
  struct zx_hrxml_School_s* x = ZX_ZALLOC(c, struct zx_hrxml_School_s);
  x->gg.g.tok = zx_hrxml_School_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_School) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);

  for (se = &x->InternetDomainName->gg;
       se && se->g.tok == zx_hrxml_InternetDomainName_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)se);
  for (se = &x->SchoolId->gg;
       se && se->g.tok == zx_hrxml_SchoolId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SchoolId(c, (struct zx_hrxml_SchoolId_s*)se);
  zx_dup_strs_simple_elems(c, x->SchoolName);

}

/* FUNC(zx_DEEP_CLONE_hrxml_School) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_School_s* zx_DEEP_CLONE_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_School_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_School_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);

  for (enn = 0, e = &x->InternetDomainName->gg;
       e && e->g.tok == zx_hrxml_InternetDomainName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_InternetDomainName(c,(struct zx_hrxml_InternetDomainName_s*)e,dup_strs);
  	  if (!enn)
  	      x->InternetDomainName = (struct zx_hrxml_InternetDomainName_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SchoolId->gg;
       e && e->g.tok == zx_hrxml_SchoolId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SchoolId(c,(struct zx_hrxml_SchoolId_s*)e,dup_strs);
  	  if (!enn)
  	      x->SchoolId = (struct zx_hrxml_SchoolId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->SchoolName = zx_deep_clone_simple_elems(c,x->SchoolName, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_School) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->InternetDomainName->gg;
       e && e->g.tok == zx_hrxml_InternetDomainName_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_InternetDomainName(c, (struct zx_hrxml_InternetDomainName_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SchoolId->gg;
       e && e->g.tok == zx_hrxml_SchoolId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SchoolId(c, (struct zx_hrxml_SchoolId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->SchoolName, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_School) */

int zx_WALK_WO_hrxml_School(struct zx_ctx* c, struct zx_hrxml_School_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SchoolId
#define EL_STRUCT zx_hrxml_SchoolId_s
#define EL_NS     hrxml
#define EL_TAG    SchoolId

/* FUNC(zx_FREE_hrxml_SchoolId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SchoolId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SchoolId_s* zx_NEW_hrxml_SchoolId(struct zx_ctx* c)
{
  struct zx_hrxml_SchoolId_s* x = ZX_ZALLOC(c, struct zx_hrxml_SchoolId_s);
  x->gg.g.tok = zx_hrxml_SchoolId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SchoolId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SchoolId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SchoolId_s* zx_DEEP_CLONE_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SchoolId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SchoolId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SchoolId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SchoolId) */

int zx_WALK_WO_hrxml_SchoolId(struct zx_ctx* c, struct zx_hrxml_SchoolId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SchoolOrInstitution
#define EL_STRUCT zx_hrxml_SchoolOrInstitution_s
#define EL_NS     hrxml
#define EL_TAG    SchoolOrInstitution

/* FUNC(zx_FREE_hrxml_SchoolOrInstitution) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->schoolType, free_strs);

  zx_free_simple_elems(c, x->SchoolName, free_strs);
  for (e = &x->School->gg;
       e && e->g.tok == zx_hrxml_School_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_School(c, (struct zx_hrxml_School_s*)e, free_strs);
  }
  for (e = &x->LocationSummary->gg;
       e && e->g.tok == zx_hrxml_LocationSummary_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)e, free_strs);
  }
  for (e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)e, free_strs);
  }
  for (e = &x->OrganizationUnit->gg;
       e && e->g.tok == zx_hrxml_OrganizationUnit_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_OrganizationUnit(c, (struct zx_hrxml_OrganizationUnit_s*)e, free_strs);
  }
  for (e = &x->Degree->gg;
       e && e->g.tok == zx_hrxml_Degree_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Degree(c, (struct zx_hrxml_Degree_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Major, free_strs);
  zx_free_simple_elems(c, x->Minor, free_strs);
  for (e = &x->Measure->gg;
       e && e->g.tok == zx_hrxml_Measure_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Measure(c, (struct zx_hrxml_Measure_s*)e, free_strs);
  }
  for (e = &x->DatesOfAttendance->gg;
       e && e->g.tok == zx_hrxml_DatesOfAttendance_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DatesOfAttendance(c, (struct zx_hrxml_DatesOfAttendance_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);
  zx_free_simple_elems(c, x->ISCEDInstitutionClassification, free_strs);
  for (e = &x->LocalInstitutionClassification->gg;
       e && e->g.tok == zx_hrxml_LocalInstitutionClassification_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LocalInstitutionClassification(c, (struct zx_hrxml_LocalInstitutionClassification_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SchoolOrInstitution) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SchoolOrInstitution_s* zx_NEW_hrxml_SchoolOrInstitution(struct zx_ctx* c)
{
  struct zx_hrxml_SchoolOrInstitution_s* x = ZX_ZALLOC(c, struct zx_hrxml_SchoolOrInstitution_s);
  x->gg.g.tok = zx_hrxml_SchoolOrInstitution_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SchoolOrInstitution) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->schoolType);

  zx_dup_strs_simple_elems(c, x->SchoolName);
  for (se = &x->School->gg;
       se && se->g.tok == zx_hrxml_School_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_School(c, (struct zx_hrxml_School_s*)se);
  for (se = &x->LocationSummary->gg;
       se && se->g.tok == zx_hrxml_LocationSummary_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)se);
  for (se = &x->PostalAddress->gg;
       se && se->g.tok == zx_hrxml_PostalAddress_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se);
  for (se = &x->OrganizationUnit->gg;
       se && se->g.tok == zx_hrxml_OrganizationUnit_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_OrganizationUnit(c, (struct zx_hrxml_OrganizationUnit_s*)se);
  for (se = &x->Degree->gg;
       se && se->g.tok == zx_hrxml_Degree_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Degree(c, (struct zx_hrxml_Degree_s*)se);
  zx_dup_strs_simple_elems(c, x->Major);
  zx_dup_strs_simple_elems(c, x->Minor);
  for (se = &x->Measure->gg;
       se && se->g.tok == zx_hrxml_Measure_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Measure(c, (struct zx_hrxml_Measure_s*)se);
  for (se = &x->DatesOfAttendance->gg;
       se && se->g.tok == zx_hrxml_DatesOfAttendance_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DatesOfAttendance(c, (struct zx_hrxml_DatesOfAttendance_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);
  zx_dup_strs_simple_elems(c, x->ISCEDInstitutionClassification);
  for (se = &x->LocalInstitutionClassification->gg;
       se && se->g.tok == zx_hrxml_LocalInstitutionClassification_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LocalInstitutionClassification(c, (struct zx_hrxml_LocalInstitutionClassification_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SchoolOrInstitution) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SchoolOrInstitution_s* zx_DEEP_CLONE_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SchoolOrInstitution_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SchoolOrInstitution_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->schoolType = zx_clone_attr(c, x->schoolType);

  x->SchoolName = zx_deep_clone_simple_elems(c,x->SchoolName, dup_strs);
  for (enn = 0, e = &x->School->gg;
       e && e->g.tok == zx_hrxml_School_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_School(c,(struct zx_hrxml_School_s*)e,dup_strs);
  	  if (!enn)
  	      x->School = (struct zx_hrxml_School_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->LocationSummary->gg;
       e && e->g.tok == zx_hrxml_LocationSummary_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LocationSummary(c,(struct zx_hrxml_LocationSummary_s*)e,dup_strs);
  	  if (!enn)
  	      x->LocationSummary = (struct zx_hrxml_LocationSummary_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PostalAddress(c,(struct zx_hrxml_PostalAddress_s*)e,dup_strs);
  	  if (!enn)
  	      x->PostalAddress = (struct zx_hrxml_PostalAddress_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->OrganizationUnit->gg;
       e && e->g.tok == zx_hrxml_OrganizationUnit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_OrganizationUnit(c,(struct zx_hrxml_OrganizationUnit_s*)e,dup_strs);
  	  if (!enn)
  	      x->OrganizationUnit = (struct zx_hrxml_OrganizationUnit_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Degree->gg;
       e && e->g.tok == zx_hrxml_Degree_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Degree(c,(struct zx_hrxml_Degree_s*)e,dup_strs);
  	  if (!enn)
  	      x->Degree = (struct zx_hrxml_Degree_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Major = zx_deep_clone_simple_elems(c,x->Major, dup_strs);
  x->Minor = zx_deep_clone_simple_elems(c,x->Minor, dup_strs);
  for (enn = 0, e = &x->Measure->gg;
       e && e->g.tok == zx_hrxml_Measure_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Measure(c,(struct zx_hrxml_Measure_s*)e,dup_strs);
  	  if (!enn)
  	      x->Measure = (struct zx_hrxml_Measure_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DatesOfAttendance->gg;
       e && e->g.tok == zx_hrxml_DatesOfAttendance_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DatesOfAttendance(c,(struct zx_hrxml_DatesOfAttendance_s*)e,dup_strs);
  	  if (!enn)
  	      x->DatesOfAttendance = (struct zx_hrxml_DatesOfAttendance_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  x->ISCEDInstitutionClassification = zx_deep_clone_simple_elems(c,x->ISCEDInstitutionClassification, dup_strs);
  for (enn = 0, e = &x->LocalInstitutionClassification->gg;
       e && e->g.tok == zx_hrxml_LocalInstitutionClassification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LocalInstitutionClassification(c,(struct zx_hrxml_LocalInstitutionClassification_s*)e,dup_strs);
  	  if (!enn)
  	      x->LocalInstitutionClassification = (struct zx_hrxml_LocalInstitutionClassification_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SchoolOrInstitution) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->SchoolName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->School->gg;
       e && e->g.tok == zx_hrxml_School_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_School(c, (struct zx_hrxml_School_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->LocationSummary->gg;
       e && e->g.tok == zx_hrxml_LocationSummary_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LocationSummary(c, (struct zx_hrxml_LocationSummary_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->OrganizationUnit->gg;
       e && e->g.tok == zx_hrxml_OrganizationUnit_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_OrganizationUnit(c, (struct zx_hrxml_OrganizationUnit_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Degree->gg;
       e && e->g.tok == zx_hrxml_Degree_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Degree(c, (struct zx_hrxml_Degree_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Major, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Minor, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Measure->gg;
       e && e->g.tok == zx_hrxml_Measure_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Measure(c, (struct zx_hrxml_Measure_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DatesOfAttendance->gg;
       e && e->g.tok == zx_hrxml_DatesOfAttendance_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DatesOfAttendance(c, (struct zx_hrxml_DatesOfAttendance_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->ISCEDInstitutionClassification, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->LocalInstitutionClassification->gg;
       e && e->g.tok == zx_hrxml_LocalInstitutionClassification_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LocalInstitutionClassification(c, (struct zx_hrxml_LocalInstitutionClassification_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SchoolOrInstitution) */

int zx_WALK_WO_hrxml_SchoolOrInstitution(struct zx_ctx* c, struct zx_hrxml_SchoolOrInstitution_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Score
#define EL_STRUCT zx_hrxml_Score_s
#define EL_NS     hrxml
#define EL_TAG    Score

/* FUNC(zx_FREE_hrxml_Score) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->unitOfMeasure, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Score) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Score_s* zx_NEW_hrxml_Score(struct zx_ctx* c)
{
  struct zx_hrxml_Score_s* x = ZX_ZALLOC(c, struct zx_hrxml_Score_s);
  x->gg.g.tok = zx_hrxml_Score_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Score) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->unitOfMeasure);


}

/* FUNC(zx_DEEP_CLONE_hrxml_Score) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Score_s* zx_DEEP_CLONE_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Score_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Score_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->unitOfMeasure = zx_clone_attr(c, x->unitOfMeasure);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Score) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Score) */

int zx_WALK_WO_hrxml_Score(struct zx_ctx* c, struct zx_hrxml_Score_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchCriteria
#define EL_STRUCT zx_hrxml_SearchCriteria_s
#define EL_NS     hrxml
#define EL_TAG    SearchCriteria

/* FUNC(zx_FREE_hrxml_SearchCriteria) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->SearchCriteriaId->gg;
       e && e->g.tok == zx_hrxml_SearchCriteriaId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SearchCriteriaId(c, (struct zx_hrxml_SearchCriteriaId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->SearchTarget, free_strs);
  for (e = &x->UserId->gg;
       e && e->g.tok == zx_hrxml_UserId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserId(c, (struct zx_hrxml_UserId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->SearchTimeStamp, free_strs);
  zx_free_simple_elems(c, x->SearchString, free_strs);
  for (e = &x->SearchCriterion->gg;
       e && e->g.tok == zx_hrxml_SearchCriterion_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SearchCriterion(c, (struct zx_hrxml_SearchCriterion_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SearchCriteria) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SearchCriteria_s* zx_NEW_hrxml_SearchCriteria(struct zx_ctx* c)
{
  struct zx_hrxml_SearchCriteria_s* x = ZX_ZALLOC(c, struct zx_hrxml_SearchCriteria_s);
  x->gg.g.tok = zx_hrxml_SearchCriteria_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SearchCriteria) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->SearchCriteriaId->gg;
       se && se->g.tok == zx_hrxml_SearchCriteriaId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SearchCriteriaId(c, (struct zx_hrxml_SearchCriteriaId_s*)se);
  zx_dup_strs_simple_elems(c, x->SearchTarget);
  for (se = &x->UserId->gg;
       se && se->g.tok == zx_hrxml_UserId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserId(c, (struct zx_hrxml_UserId_s*)se);
  zx_dup_strs_simple_elems(c, x->SearchTimeStamp);
  zx_dup_strs_simple_elems(c, x->SearchString);
  for (se = &x->SearchCriterion->gg;
       se && se->g.tok == zx_hrxml_SearchCriterion_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SearchCriterion(c, (struct zx_hrxml_SearchCriterion_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SearchCriteria) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SearchCriteria_s* zx_DEEP_CLONE_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SearchCriteria_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SearchCriteria_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->SearchCriteriaId->gg;
       e && e->g.tok == zx_hrxml_SearchCriteriaId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SearchCriteriaId(c,(struct zx_hrxml_SearchCriteriaId_s*)e,dup_strs);
  	  if (!enn)
  	      x->SearchCriteriaId = (struct zx_hrxml_SearchCriteriaId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->SearchTarget = zx_deep_clone_simple_elems(c,x->SearchTarget, dup_strs);
  for (enn = 0, e = &x->UserId->gg;
       e && e->g.tok == zx_hrxml_UserId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserId(c,(struct zx_hrxml_UserId_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserId = (struct zx_hrxml_UserId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->SearchTimeStamp = zx_deep_clone_simple_elems(c,x->SearchTimeStamp, dup_strs);
  x->SearchString = zx_deep_clone_simple_elems(c,x->SearchString, dup_strs);
  for (enn = 0, e = &x->SearchCriterion->gg;
       e && e->g.tok == zx_hrxml_SearchCriterion_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SearchCriterion(c,(struct zx_hrxml_SearchCriterion_s*)e,dup_strs);
  	  if (!enn)
  	      x->SearchCriterion = (struct zx_hrxml_SearchCriterion_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SearchCriteria) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->SearchCriteriaId->gg;
       e && e->g.tok == zx_hrxml_SearchCriteriaId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SearchCriteriaId(c, (struct zx_hrxml_SearchCriteriaId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->SearchTarget, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->UserId->gg;
       e && e->g.tok == zx_hrxml_UserId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserId(c, (struct zx_hrxml_UserId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->SearchTimeStamp, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->SearchString, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->SearchCriterion->gg;
       e && e->g.tok == zx_hrxml_SearchCriterion_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SearchCriterion(c, (struct zx_hrxml_SearchCriterion_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SearchCriteria) */

int zx_WALK_WO_hrxml_SearchCriteria(struct zx_ctx* c, struct zx_hrxml_SearchCriteria_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchCriteriaId
#define EL_STRUCT zx_hrxml_SearchCriteriaId_s
#define EL_NS     hrxml
#define EL_TAG    SearchCriteriaId

/* FUNC(zx_FREE_hrxml_SearchCriteriaId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SearchCriteriaId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SearchCriteriaId_s* zx_NEW_hrxml_SearchCriteriaId(struct zx_ctx* c)
{
  struct zx_hrxml_SearchCriteriaId_s* x = ZX_ZALLOC(c, struct zx_hrxml_SearchCriteriaId_s);
  x->gg.g.tok = zx_hrxml_SearchCriteriaId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SearchCriteriaId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SearchCriteriaId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SearchCriteriaId_s* zx_DEEP_CLONE_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SearchCriteriaId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SearchCriteriaId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SearchCriteriaId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SearchCriteriaId) */

int zx_WALK_WO_hrxml_SearchCriteriaId(struct zx_ctx* c, struct zx_hrxml_SearchCriteriaId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchCriterion
#define EL_STRUCT zx_hrxml_SearchCriterion_s
#define EL_NS     hrxml
#define EL_TAG    SearchCriterion

/* FUNC(zx_FREE_hrxml_SearchCriterion) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->CriterionName, free_strs);
  zx_free_simple_elems(c, x->CriterionValue, free_strs);
  for (e = &x->Weight->gg;
       e && e->g.tok == zx_hrxml_Weight_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SearchCriterion) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SearchCriterion_s* zx_NEW_hrxml_SearchCriterion(struct zx_ctx* c)
{
  struct zx_hrxml_SearchCriterion_s* x = ZX_ZALLOC(c, struct zx_hrxml_SearchCriterion_s);
  x->gg.g.tok = zx_hrxml_SearchCriterion_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SearchCriterion) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->CriterionName);
  zx_dup_strs_simple_elems(c, x->CriterionValue);
  for (se = &x->Weight->gg;
       se && se->g.tok == zx_hrxml_Weight_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SearchCriterion) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SearchCriterion_s* zx_DEEP_CLONE_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SearchCriterion_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SearchCriterion_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->CriterionName = zx_deep_clone_simple_elems(c,x->CriterionName, dup_strs);
  x->CriterionValue = zx_deep_clone_simple_elems(c,x->CriterionValue, dup_strs);
  for (enn = 0, e = &x->Weight->gg;
       e && e->g.tok == zx_hrxml_Weight_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Weight(c,(struct zx_hrxml_Weight_s*)e,dup_strs);
  	  if (!enn)
  	      x->Weight = (struct zx_hrxml_Weight_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SearchCriterion) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->CriterionName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->CriterionValue, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Weight->gg;
       e && e->g.tok == zx_hrxml_Weight_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Weight(c, (struct zx_hrxml_Weight_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SearchCriterion) */

int zx_WALK_WO_hrxml_SearchCriterion(struct zx_ctx* c, struct zx_hrxml_SearchCriterion_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchRelevanceScore
#define EL_STRUCT zx_hrxml_SearchRelevanceScore_s
#define EL_NS     hrxml
#define EL_TAG    SearchRelevanceScore

/* FUNC(zx_FREE_hrxml_SearchRelevanceScore) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->unitOfMeasure, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SearchRelevanceScore) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SearchRelevanceScore_s* zx_NEW_hrxml_SearchRelevanceScore(struct zx_ctx* c)
{
  struct zx_hrxml_SearchRelevanceScore_s* x = ZX_ZALLOC(c, struct zx_hrxml_SearchRelevanceScore_s);
  x->gg.g.tok = zx_hrxml_SearchRelevanceScore_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SearchRelevanceScore) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->unitOfMeasure);


}

/* FUNC(zx_DEEP_CLONE_hrxml_SearchRelevanceScore) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SearchRelevanceScore_s* zx_DEEP_CLONE_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SearchRelevanceScore_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SearchRelevanceScore_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->unitOfMeasure = zx_clone_attr(c, x->unitOfMeasure);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SearchRelevanceScore) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SearchRelevanceScore) */

int zx_WALK_WO_hrxml_SearchRelevanceScore(struct zx_ctx* c, struct zx_hrxml_SearchRelevanceScore_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchResult
#define EL_STRUCT zx_hrxml_SearchResult_s
#define EL_NS     hrxml
#define EL_TAG    SearchResult

/* FUNC(zx_FREE_hrxml_SearchResult) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->SearchResultId->gg;
       e && e->g.tok == zx_hrxml_SearchResultId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SearchResultId(c, (struct zx_hrxml_SearchResultId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->SearchTarget, free_strs);
  for (e = &x->UserId->gg;
       e && e->g.tok == zx_hrxml_UserId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserId(c, (struct zx_hrxml_UserId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->SearchTimeStamp, free_strs);
  for (e = &x->MatchedObjectId->gg;
       e && e->g.tok == zx_hrxml_MatchedObjectId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_MatchedObjectId(c, (struct zx_hrxml_MatchedObjectId_s*)e, free_strs);
  }
  for (e = &x->SearchRelevanceScore->gg;
       e && e->g.tok == zx_hrxml_SearchRelevanceScore_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SearchRelevanceScore(c, (struct zx_hrxml_SearchRelevanceScore_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->SearchRelevanceRank, free_strs);
  zx_free_simple_elems(c, x->SearchResultCount, free_strs);
  for (e = &x->RankedSearchResults->gg;
       e && e->g.tok == zx_hrxml_RankedSearchResults_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RankedSearchResults(c, (struct zx_hrxml_RankedSearchResults_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SearchResult) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SearchResult_s* zx_NEW_hrxml_SearchResult(struct zx_ctx* c)
{
  struct zx_hrxml_SearchResult_s* x = ZX_ZALLOC(c, struct zx_hrxml_SearchResult_s);
  x->gg.g.tok = zx_hrxml_SearchResult_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SearchResult) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->SearchResultId->gg;
       se && se->g.tok == zx_hrxml_SearchResultId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SearchResultId(c, (struct zx_hrxml_SearchResultId_s*)se);
  zx_dup_strs_simple_elems(c, x->SearchTarget);
  for (se = &x->UserId->gg;
       se && se->g.tok == zx_hrxml_UserId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserId(c, (struct zx_hrxml_UserId_s*)se);
  zx_dup_strs_simple_elems(c, x->SearchTimeStamp);
  for (se = &x->MatchedObjectId->gg;
       se && se->g.tok == zx_hrxml_MatchedObjectId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_MatchedObjectId(c, (struct zx_hrxml_MatchedObjectId_s*)se);
  for (se = &x->SearchRelevanceScore->gg;
       se && se->g.tok == zx_hrxml_SearchRelevanceScore_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SearchRelevanceScore(c, (struct zx_hrxml_SearchRelevanceScore_s*)se);
  zx_dup_strs_simple_elems(c, x->SearchRelevanceRank);
  zx_dup_strs_simple_elems(c, x->SearchResultCount);
  for (se = &x->RankedSearchResults->gg;
       se && se->g.tok == zx_hrxml_RankedSearchResults_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RankedSearchResults(c, (struct zx_hrxml_RankedSearchResults_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SearchResult) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SearchResult_s* zx_DEEP_CLONE_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SearchResult_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SearchResult_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->SearchResultId->gg;
       e && e->g.tok == zx_hrxml_SearchResultId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SearchResultId(c,(struct zx_hrxml_SearchResultId_s*)e,dup_strs);
  	  if (!enn)
  	      x->SearchResultId = (struct zx_hrxml_SearchResultId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->SearchTarget = zx_deep_clone_simple_elems(c,x->SearchTarget, dup_strs);
  for (enn = 0, e = &x->UserId->gg;
       e && e->g.tok == zx_hrxml_UserId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserId(c,(struct zx_hrxml_UserId_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserId = (struct zx_hrxml_UserId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->SearchTimeStamp = zx_deep_clone_simple_elems(c,x->SearchTimeStamp, dup_strs);
  for (enn = 0, e = &x->MatchedObjectId->gg;
       e && e->g.tok == zx_hrxml_MatchedObjectId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_MatchedObjectId(c,(struct zx_hrxml_MatchedObjectId_s*)e,dup_strs);
  	  if (!enn)
  	      x->MatchedObjectId = (struct zx_hrxml_MatchedObjectId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SearchRelevanceScore->gg;
       e && e->g.tok == zx_hrxml_SearchRelevanceScore_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SearchRelevanceScore(c,(struct zx_hrxml_SearchRelevanceScore_s*)e,dup_strs);
  	  if (!enn)
  	      x->SearchRelevanceScore = (struct zx_hrxml_SearchRelevanceScore_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->SearchRelevanceRank = zx_deep_clone_simple_elems(c,x->SearchRelevanceRank, dup_strs);
  x->SearchResultCount = zx_deep_clone_simple_elems(c,x->SearchResultCount, dup_strs);
  for (enn = 0, e = &x->RankedSearchResults->gg;
       e && e->g.tok == zx_hrxml_RankedSearchResults_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RankedSearchResults(c,(struct zx_hrxml_RankedSearchResults_s*)e,dup_strs);
  	  if (!enn)
  	      x->RankedSearchResults = (struct zx_hrxml_RankedSearchResults_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SearchResult) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->SearchResultId->gg;
       e && e->g.tok == zx_hrxml_SearchResultId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SearchResultId(c, (struct zx_hrxml_SearchResultId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->SearchTarget, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->UserId->gg;
       e && e->g.tok == zx_hrxml_UserId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserId(c, (struct zx_hrxml_UserId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->SearchTimeStamp, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->MatchedObjectId->gg;
       e && e->g.tok == zx_hrxml_MatchedObjectId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_MatchedObjectId(c, (struct zx_hrxml_MatchedObjectId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SearchRelevanceScore->gg;
       e && e->g.tok == zx_hrxml_SearchRelevanceScore_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SearchRelevanceScore(c, (struct zx_hrxml_SearchRelevanceScore_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->SearchRelevanceRank, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->SearchResultCount, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->RankedSearchResults->gg;
       e && e->g.tok == zx_hrxml_RankedSearchResults_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RankedSearchResults(c, (struct zx_hrxml_RankedSearchResults_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SearchResult) */

int zx_WALK_WO_hrxml_SearchResult(struct zx_ctx* c, struct zx_hrxml_SearchResult_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SearchResultId
#define EL_STRUCT zx_hrxml_SearchResultId_s
#define EL_NS     hrxml
#define EL_TAG    SearchResultId

/* FUNC(zx_FREE_hrxml_SearchResultId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SearchResultId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SearchResultId_s* zx_NEW_hrxml_SearchResultId(struct zx_ctx* c)
{
  struct zx_hrxml_SearchResultId_s* x = ZX_ZALLOC(c, struct zx_hrxml_SearchResultId_s);
  x->gg.g.tok = zx_hrxml_SearchResultId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SearchResultId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SearchResultId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SearchResultId_s* zx_DEEP_CLONE_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SearchResultId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SearchResultId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SearchResultId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SearchResultId) */

int zx_WALK_WO_hrxml_SearchResultId(struct zx_ctx* c, struct zx_hrxml_SearchResultId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SecurityCredential
#define EL_STRUCT zx_hrxml_SecurityCredential_s
#define EL_NS     hrxml
#define EL_TAG    SecurityCredential

/* FUNC(zx_FREE_hrxml_SecurityCredential) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Name, free_strs);
  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  for (e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)e, free_strs);
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }
  for (e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SecurityCredential) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SecurityCredential_s* zx_NEW_hrxml_SecurityCredential(struct zx_ctx* c)
{
  struct zx_hrxml_SecurityCredential_s* x = ZX_ZALLOC(c, struct zx_hrxml_SecurityCredential_s);
  x->gg.g.tok = zx_hrxml_SecurityCredential_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SecurityCredential) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Name);
  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  for (se = &x->IssuingAuthority->gg;
       se && se->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)se);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->EffectiveDate->gg;
       se && se->g.tok == zx_hrxml_EffectiveDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SecurityCredential) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SecurityCredential_s* zx_DEEP_CLONE_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SecurityCredential_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SecurityCredential_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IssuingAuthority(c,(struct zx_hrxml_IssuingAuthority_s*)e,dup_strs);
  	  if (!enn)
  	      x->IssuingAuthority = (struct zx_hrxml_IssuingAuthority_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EffectiveDate(c,(struct zx_hrxml_EffectiveDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EffectiveDate = (struct zx_hrxml_EffectiveDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SecurityCredential) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->IssuingAuthority->gg;
       e && e->g.tok == zx_hrxml_IssuingAuthority_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IssuingAuthority(c, (struct zx_hrxml_IssuingAuthority_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EffectiveDate->gg;
       e && e->g.tok == zx_hrxml_EffectiveDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EffectiveDate(c, (struct zx_hrxml_EffectiveDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SecurityCredential) */

int zx_WALK_WO_hrxml_SecurityCredential(struct zx_ctx* c, struct zx_hrxml_SecurityCredential_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SecurityCredentials
#define EL_STRUCT zx_hrxml_SecurityCredentials_s
#define EL_NS     hrxml
#define EL_TAG    SecurityCredentials

/* FUNC(zx_FREE_hrxml_SecurityCredentials) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->SecurityCredential->gg;
       e && e->g.tok == zx_hrxml_SecurityCredential_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SecurityCredential(c, (struct zx_hrxml_SecurityCredential_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SecurityCredentials) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SecurityCredentials_s* zx_NEW_hrxml_SecurityCredentials(struct zx_ctx* c)
{
  struct zx_hrxml_SecurityCredentials_s* x = ZX_ZALLOC(c, struct zx_hrxml_SecurityCredentials_s);
  x->gg.g.tok = zx_hrxml_SecurityCredentials_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SecurityCredentials) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->SecurityCredential->gg;
       se && se->g.tok == zx_hrxml_SecurityCredential_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SecurityCredential(c, (struct zx_hrxml_SecurityCredential_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SecurityCredentials) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SecurityCredentials_s* zx_DEEP_CLONE_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SecurityCredentials_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SecurityCredentials_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->SecurityCredential->gg;
       e && e->g.tok == zx_hrxml_SecurityCredential_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SecurityCredential(c,(struct zx_hrxml_SecurityCredential_s*)e,dup_strs);
  	  if (!enn)
  	      x->SecurityCredential = (struct zx_hrxml_SecurityCredential_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SecurityCredentials) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->SecurityCredential->gg;
       e && e->g.tok == zx_hrxml_SecurityCredential_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SecurityCredential(c, (struct zx_hrxml_SecurityCredential_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SecurityCredentials) */

int zx_WALK_WO_hrxml_SecurityCredentials(struct zx_ctx* c, struct zx_hrxml_SecurityCredentials_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ServiceDetail
#define EL_STRUCT zx_hrxml_ServiceDetail_s
#define EL_NS     hrxml
#define EL_TAG    ServiceDetail

/* FUNC(zx_FREE_hrxml_ServiceDetail) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->branch, free_strs);

  zx_free_simple_elems(c, x->UnitOrDivision, free_strs);
  for (e = &x->RankAchieved->gg;
       e && e->g.tok == zx_hrxml_RankAchieved_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_RankAchieved(c, (struct zx_hrxml_RankAchieved_s*)e, free_strs);
  }
  for (e = &x->DatesOfService->gg;
       e && e->g.tok == zx_hrxml_DatesOfService_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_DatesOfService(c, (struct zx_hrxml_DatesOfService_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Campaign, free_strs);
  zx_free_simple_elems(c, x->AreaOfExpertise, free_strs);
  zx_free_simple_elems(c, x->RecognitionAchieved, free_strs);
  zx_free_simple_elems(c, x->DisciplinaryAction, free_strs);
  zx_free_simple_elems(c, x->DischargeStatus, free_strs);
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ServiceDetail) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ServiceDetail_s* zx_NEW_hrxml_ServiceDetail(struct zx_ctx* c)
{
  struct zx_hrxml_ServiceDetail_s* x = ZX_ZALLOC(c, struct zx_hrxml_ServiceDetail_s);
  x->gg.g.tok = zx_hrxml_ServiceDetail_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ServiceDetail) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->branch);

  zx_dup_strs_simple_elems(c, x->UnitOrDivision);
  for (se = &x->RankAchieved->gg;
       se && se->g.tok == zx_hrxml_RankAchieved_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_RankAchieved(c, (struct zx_hrxml_RankAchieved_s*)se);
  for (se = &x->DatesOfService->gg;
       se && se->g.tok == zx_hrxml_DatesOfService_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_DatesOfService(c, (struct zx_hrxml_DatesOfService_s*)se);
  zx_dup_strs_simple_elems(c, x->Campaign);
  zx_dup_strs_simple_elems(c, x->AreaOfExpertise);
  zx_dup_strs_simple_elems(c, x->RecognitionAchieved);
  zx_dup_strs_simple_elems(c, x->DisciplinaryAction);
  zx_dup_strs_simple_elems(c, x->DischargeStatus);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ServiceDetail) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ServiceDetail_s* zx_DEEP_CLONE_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ServiceDetail_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ServiceDetail_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->branch = zx_clone_attr(c, x->branch);

  x->UnitOrDivision = zx_deep_clone_simple_elems(c,x->UnitOrDivision, dup_strs);
  for (enn = 0, e = &x->RankAchieved->gg;
       e && e->g.tok == zx_hrxml_RankAchieved_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_RankAchieved(c,(struct zx_hrxml_RankAchieved_s*)e,dup_strs);
  	  if (!enn)
  	      x->RankAchieved = (struct zx_hrxml_RankAchieved_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->DatesOfService->gg;
       e && e->g.tok == zx_hrxml_DatesOfService_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_DatesOfService(c,(struct zx_hrxml_DatesOfService_s*)e,dup_strs);
  	  if (!enn)
  	      x->DatesOfService = (struct zx_hrxml_DatesOfService_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Campaign = zx_deep_clone_simple_elems(c,x->Campaign, dup_strs);
  x->AreaOfExpertise = zx_deep_clone_simple_elems(c,x->AreaOfExpertise, dup_strs);
  x->RecognitionAchieved = zx_deep_clone_simple_elems(c,x->RecognitionAchieved, dup_strs);
  x->DisciplinaryAction = zx_deep_clone_simple_elems(c,x->DisciplinaryAction, dup_strs);
  x->DischargeStatus = zx_deep_clone_simple_elems(c,x->DischargeStatus, dup_strs);
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ServiceDetail) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->UnitOrDivision, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->RankAchieved->gg;
       e && e->g.tok == zx_hrxml_RankAchieved_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_RankAchieved(c, (struct zx_hrxml_RankAchieved_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->DatesOfService->gg;
       e && e->g.tok == zx_hrxml_DatesOfService_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_DatesOfService(c, (struct zx_hrxml_DatesOfService_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Campaign, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->AreaOfExpertise, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->RecognitionAchieved, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->DisciplinaryAction, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->DischargeStatus, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ServiceDetail) */

int zx_WALK_WO_hrxml_ServiceDetail(struct zx_ctx* c, struct zx_hrxml_ServiceDetail_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ServiceNumber
#define EL_STRUCT zx_hrxml_ServiceNumber_s
#define EL_NS     hrxml
#define EL_TAG    ServiceNumber

/* FUNC(zx_FREE_hrxml_ServiceNumber) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ServiceNumber) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ServiceNumber_s* zx_NEW_hrxml_ServiceNumber(struct zx_ctx* c)
{
  struct zx_hrxml_ServiceNumber_s* x = ZX_ZALLOC(c, struct zx_hrxml_ServiceNumber_s);
  x->gg.g.tok = zx_hrxml_ServiceNumber_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ServiceNumber) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ServiceNumber) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ServiceNumber_s* zx_DEEP_CLONE_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ServiceNumber_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ServiceNumber_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ServiceNumber) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ServiceNumber) */

int zx_WALK_WO_hrxml_ServiceNumber(struct zx_ctx* c, struct zx_hrxml_ServiceNumber_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Shift
#define EL_STRUCT zx_hrxml_Shift_s
#define EL_NS     hrxml
#define EL_TAG    Shift

/* FUNC(zx_FREE_hrxml_Shift) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->shiftPeriod, free_strs);

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Name, free_strs);
  zx_free_simple_elems(c, x->Hours, free_strs);
  zx_free_simple_elems(c, x->StartTime, free_strs);
  zx_free_simple_elems(c, x->EndTime, free_strs);
  zx_free_simple_elems(c, x->PayTypeHours, free_strs);
  zx_free_simple_elems(c, x->Comments, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Shift) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Shift_s* zx_NEW_hrxml_Shift(struct zx_ctx* c)
{
  struct zx_hrxml_Shift_s* x = ZX_ZALLOC(c, struct zx_hrxml_Shift_s);
  x->gg.g.tok = zx_hrxml_Shift_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Shift) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->shiftPeriod);

  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  zx_dup_strs_simple_elems(c, x->Name);
  zx_dup_strs_simple_elems(c, x->Hours);
  zx_dup_strs_simple_elems(c, x->StartTime);
  zx_dup_strs_simple_elems(c, x->EndTime);
  zx_dup_strs_simple_elems(c, x->PayTypeHours);
  zx_dup_strs_simple_elems(c, x->Comments);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Shift) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Shift_s* zx_DEEP_CLONE_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Shift_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Shift_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->shiftPeriod = zx_clone_attr(c, x->shiftPeriod);

  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Name = zx_deep_clone_simple_elems(c,x->Name, dup_strs);
  x->Hours = zx_deep_clone_simple_elems(c,x->Hours, dup_strs);
  x->StartTime = zx_deep_clone_simple_elems(c,x->StartTime, dup_strs);
  x->EndTime = zx_deep_clone_simple_elems(c,x->EndTime, dup_strs);
  x->PayTypeHours = zx_deep_clone_simple_elems(c,x->PayTypeHours, dup_strs);
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Shift) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Name, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Hours, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StartTime, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->EndTime, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PayTypeHours, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Shift) */

int zx_WALK_WO_hrxml_Shift(struct zx_ctx* c, struct zx_hrxml_Shift_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SourceType
#define EL_STRUCT zx_hrxml_SourceType_s
#define EL_NS     hrxml
#define EL_TAG    SourceType

/* FUNC(zx_FREE_hrxml_SourceType) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->StandardValue, free_strs);
  zx_free_simple_elems(c, x->NonStandardValue, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SourceType) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SourceType_s* zx_NEW_hrxml_SourceType(struct zx_ctx* c)
{
  struct zx_hrxml_SourceType_s* x = ZX_ZALLOC(c, struct zx_hrxml_SourceType_s);
  x->gg.g.tok = zx_hrxml_SourceType_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SourceType) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->StandardValue);
  zx_dup_strs_simple_elems(c, x->NonStandardValue);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SourceType) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SourceType_s* zx_DEEP_CLONE_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SourceType_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SourceType_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->StandardValue = zx_deep_clone_simple_elems(c,x->StandardValue, dup_strs);
  x->NonStandardValue = zx_deep_clone_simple_elems(c,x->NonStandardValue, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SourceType) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->StandardValue, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->NonStandardValue, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SourceType) */

int zx_WALK_WO_hrxml_SourceType(struct zx_ctx* c, struct zx_hrxml_SourceType_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpatialLocation
#define EL_STRUCT zx_hrxml_SpatialLocation_s
#define EL_NS     hrxml
#define EL_TAG    SpatialLocation

/* FUNC(zx_FREE_hrxml_SpatialLocation) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Latitude->gg;
       e && e->g.tok == zx_hrxml_Latitude_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Latitude(c, (struct zx_hrxml_Latitude_s*)e, free_strs);
  }
  for (e = &x->Longitude->gg;
       e && e->g.tok == zx_hrxml_Longitude_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Longitude(c, (struct zx_hrxml_Longitude_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Altitude, free_strs);
  zx_free_simple_elems(c, x->AltitudeMeanSeaLevel, free_strs);
  for (e = &x->HorizontalAccuracy->gg;
       e && e->g.tok == zx_hrxml_HorizontalAccuracy_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_HorizontalAccuracy(c, (struct zx_hrxml_HorizontalAccuracy_s*)e, free_strs);
  }
  for (e = &x->VerticalAccuracy->gg;
       e && e->g.tok == zx_hrxml_VerticalAccuracy_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_VerticalAccuracy(c, (struct zx_hrxml_VerticalAccuracy_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SpatialLocation) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SpatialLocation_s* zx_NEW_hrxml_SpatialLocation(struct zx_ctx* c)
{
  struct zx_hrxml_SpatialLocation_s* x = ZX_ZALLOC(c, struct zx_hrxml_SpatialLocation_s);
  x->gg.g.tok = zx_hrxml_SpatialLocation_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SpatialLocation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Latitude->gg;
       se && se->g.tok == zx_hrxml_Latitude_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Latitude(c, (struct zx_hrxml_Latitude_s*)se);
  for (se = &x->Longitude->gg;
       se && se->g.tok == zx_hrxml_Longitude_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Longitude(c, (struct zx_hrxml_Longitude_s*)se);
  zx_dup_strs_simple_elems(c, x->Altitude);
  zx_dup_strs_simple_elems(c, x->AltitudeMeanSeaLevel);
  for (se = &x->HorizontalAccuracy->gg;
       se && se->g.tok == zx_hrxml_HorizontalAccuracy_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_HorizontalAccuracy(c, (struct zx_hrxml_HorizontalAccuracy_s*)se);
  for (se = &x->VerticalAccuracy->gg;
       se && se->g.tok == zx_hrxml_VerticalAccuracy_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_VerticalAccuracy(c, (struct zx_hrxml_VerticalAccuracy_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SpatialLocation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SpatialLocation_s* zx_DEEP_CLONE_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SpatialLocation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SpatialLocation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Latitude->gg;
       e && e->g.tok == zx_hrxml_Latitude_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Latitude(c,(struct zx_hrxml_Latitude_s*)e,dup_strs);
  	  if (!enn)
  	      x->Latitude = (struct zx_hrxml_Latitude_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Longitude->gg;
       e && e->g.tok == zx_hrxml_Longitude_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Longitude(c,(struct zx_hrxml_Longitude_s*)e,dup_strs);
  	  if (!enn)
  	      x->Longitude = (struct zx_hrxml_Longitude_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Altitude = zx_deep_clone_simple_elems(c,x->Altitude, dup_strs);
  x->AltitudeMeanSeaLevel = zx_deep_clone_simple_elems(c,x->AltitudeMeanSeaLevel, dup_strs);
  for (enn = 0, e = &x->HorizontalAccuracy->gg;
       e && e->g.tok == zx_hrxml_HorizontalAccuracy_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_HorizontalAccuracy(c,(struct zx_hrxml_HorizontalAccuracy_s*)e,dup_strs);
  	  if (!enn)
  	      x->HorizontalAccuracy = (struct zx_hrxml_HorizontalAccuracy_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->VerticalAccuracy->gg;
       e && e->g.tok == zx_hrxml_VerticalAccuracy_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_VerticalAccuracy(c,(struct zx_hrxml_VerticalAccuracy_s*)e,dup_strs);
  	  if (!enn)
  	      x->VerticalAccuracy = (struct zx_hrxml_VerticalAccuracy_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SpatialLocation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Latitude->gg;
       e && e->g.tok == zx_hrxml_Latitude_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Latitude(c, (struct zx_hrxml_Latitude_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Longitude->gg;
       e && e->g.tok == zx_hrxml_Longitude_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Longitude(c, (struct zx_hrxml_Longitude_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Altitude, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->AltitudeMeanSeaLevel, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->HorizontalAccuracy->gg;
       e && e->g.tok == zx_hrxml_HorizontalAccuracy_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_HorizontalAccuracy(c, (struct zx_hrxml_HorizontalAccuracy_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->VerticalAccuracy->gg;
       e && e->g.tok == zx_hrxml_VerticalAccuracy_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_VerticalAccuracy(c, (struct zx_hrxml_VerticalAccuracy_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SpatialLocation) */

int zx_WALK_WO_hrxml_SpatialLocation(struct zx_ctx* c, struct zx_hrxml_SpatialLocation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpeakingEvent
#define EL_STRUCT zx_hrxml_SpeakingEvent_s
#define EL_NS     hrxml
#define EL_TAG    SpeakingEvent

/* FUNC(zx_FREE_hrxml_SpeakingEvent) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->type, free_strs);

  zx_free_simple_elems(c, x->Title, free_strs);
  zx_free_simple_elems(c, x->Role, free_strs);
  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, free_strs);
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->EventName, free_strs);
  zx_free_simple_elems(c, x->EventType, free_strs);
  zx_free_simple_elems(c, x->Location, free_strs);
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->AffiliatedOrganization, free_strs);
  zx_free_simple_elems(c, x->Link, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SpeakingEvent) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SpeakingEvent_s* zx_NEW_hrxml_SpeakingEvent(struct zx_ctx* c)
{
  struct zx_hrxml_SpeakingEvent_s* x = ZX_ZALLOC(c, struct zx_hrxml_SpeakingEvent_s);
  x->gg.g.tok = zx_hrxml_SpeakingEvent_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SpeakingEvent) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->type);

  zx_dup_strs_simple_elems(c, x->Title);
  zx_dup_strs_simple_elems(c, x->Role);
  for (se = &x->StartDate->gg;
       se && se->g.tok == zx_hrxml_StartDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)se);
  for (se = &x->EndDate->gg;
       se && se->g.tok == zx_hrxml_EndDate_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)se);
  zx_dup_strs_simple_elems(c, x->EventName);
  zx_dup_strs_simple_elems(c, x->EventType);
  zx_dup_strs_simple_elems(c, x->Location);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  zx_dup_strs_simple_elems(c, x->AffiliatedOrganization);
  zx_dup_strs_simple_elems(c, x->Link);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SpeakingEvent) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SpeakingEvent_s* zx_DEEP_CLONE_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SpeakingEvent_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SpeakingEvent_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->type = zx_clone_attr(c, x->type);

  x->Title = zx_deep_clone_simple_elems(c,x->Title, dup_strs);
  x->Role = zx_deep_clone_simple_elems(c,x->Role, dup_strs);
  for (enn = 0, e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_StartDate(c,(struct zx_hrxml_StartDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->StartDate = (struct zx_hrxml_StartDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EndDate(c,(struct zx_hrxml_EndDate_s*)e,dup_strs);
  	  if (!enn)
  	      x->EndDate = (struct zx_hrxml_EndDate_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->EventName = zx_deep_clone_simple_elems(c,x->EventName, dup_strs);
  x->EventType = zx_deep_clone_simple_elems(c,x->EventType, dup_strs);
  x->Location = zx_deep_clone_simple_elems(c,x->Location, dup_strs);
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->AffiliatedOrganization = zx_deep_clone_simple_elems(c,x->AffiliatedOrganization, dup_strs);
  x->Link = zx_deep_clone_simple_elems(c,x->Link, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SpeakingEvent) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Title, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Role, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->StartDate->gg;
       e && e->g.tok == zx_hrxml_StartDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_StartDate(c, (struct zx_hrxml_StartDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EndDate->gg;
       e && e->g.tok == zx_hrxml_EndDate_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EndDate(c, (struct zx_hrxml_EndDate_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->EventName, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->EventType, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Location, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->AffiliatedOrganization, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Link, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SpeakingEvent) */

int zx_WALK_WO_hrxml_SpeakingEvent(struct zx_ctx* c, struct zx_hrxml_SpeakingEvent_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpeakingEventsHistory
#define EL_STRUCT zx_hrxml_SpeakingEventsHistory_s
#define EL_NS     hrxml
#define EL_TAG    SpeakingEventsHistory

/* FUNC(zx_FREE_hrxml_SpeakingEventsHistory) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->SpeakingEvent->gg;
       e && e->g.tok == zx_hrxml_SpeakingEvent_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SpeakingEvent(c, (struct zx_hrxml_SpeakingEvent_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SpeakingEventsHistory) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SpeakingEventsHistory_s* zx_NEW_hrxml_SpeakingEventsHistory(struct zx_ctx* c)
{
  struct zx_hrxml_SpeakingEventsHistory_s* x = ZX_ZALLOC(c, struct zx_hrxml_SpeakingEventsHistory_s);
  x->gg.g.tok = zx_hrxml_SpeakingEventsHistory_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SpeakingEventsHistory) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->SpeakingEvent->gg;
       se && se->g.tok == zx_hrxml_SpeakingEvent_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SpeakingEvent(c, (struct zx_hrxml_SpeakingEvent_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SpeakingEventsHistory) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SpeakingEventsHistory_s* zx_DEEP_CLONE_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SpeakingEventsHistory_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SpeakingEventsHistory_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->SpeakingEvent->gg;
       e && e->g.tok == zx_hrxml_SpeakingEvent_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SpeakingEvent(c,(struct zx_hrxml_SpeakingEvent_s*)e,dup_strs);
  	  if (!enn)
  	      x->SpeakingEvent = (struct zx_hrxml_SpeakingEvent_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SpeakingEventsHistory) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->SpeakingEvent->gg;
       e && e->g.tok == zx_hrxml_SpeakingEvent_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SpeakingEvent(c, (struct zx_hrxml_SpeakingEvent_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SpeakingEventsHistory) */

int zx_WALK_WO_hrxml_SpeakingEventsHistory(struct zx_ctx* c, struct zx_hrxml_SpeakingEventsHistory_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SpecifiedCompetencyReference
#define EL_STRUCT zx_hrxml_SpecifiedCompetencyReference_s
#define EL_NS     hrxml
#define EL_TAG    SpecifiedCompetencyReference

/* FUNC(zx_FREE_hrxml_SpecifiedCompetencyReference) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->CompetencyId->gg;
       e && e->g.tok == zx_hrxml_CompetencyId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_CompetencyId(c, (struct zx_hrxml_CompetencyId_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->ProficencyLevel, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SpecifiedCompetencyReference) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SpecifiedCompetencyReference_s* zx_NEW_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c)
{
  struct zx_hrxml_SpecifiedCompetencyReference_s* x = ZX_ZALLOC(c, struct zx_hrxml_SpecifiedCompetencyReference_s);
  x->gg.g.tok = zx_hrxml_SpecifiedCompetencyReference_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SpecifiedCompetencyReference) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->CompetencyId->gg;
       se && se->g.tok == zx_hrxml_CompetencyId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_CompetencyId(c, (struct zx_hrxml_CompetencyId_s*)se);
  zx_dup_strs_simple_elems(c, x->ProficencyLevel);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SpecifiedCompetencyReference) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SpecifiedCompetencyReference_s* zx_DEEP_CLONE_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SpecifiedCompetencyReference_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SpecifiedCompetencyReference_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->CompetencyId->gg;
       e && e->g.tok == zx_hrxml_CompetencyId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_CompetencyId(c,(struct zx_hrxml_CompetencyId_s*)e,dup_strs);
  	  if (!enn)
  	      x->CompetencyId = (struct zx_hrxml_CompetencyId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->ProficencyLevel = zx_deep_clone_simple_elems(c,x->ProficencyLevel, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SpecifiedCompetencyReference) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->CompetencyId->gg;
       e && e->g.tok == zx_hrxml_CompetencyId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_CompetencyId(c, (struct zx_hrxml_CompetencyId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->ProficencyLevel, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SpecifiedCompetencyReference) */

int zx_WALK_WO_hrxml_SpecifiedCompetencyReference(struct zx_ctx* c, struct zx_hrxml_SpecifiedCompetencyReference_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StartDate
#define EL_STRUCT zx_hrxml_StartDate_s
#define EL_NS     hrxml
#define EL_TAG    StartDate

/* FUNC(zx_FREE_hrxml_StartDate) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateDescription, free_strs);

  zx_free_simple_elems(c, x->AnyDate, free_strs);
  zx_free_simple_elems(c, x->YearMonth, free_strs);
  zx_free_simple_elems(c, x->Year, free_strs);
  zx_free_simple_elems(c, x->MonthDay, free_strs);
  zx_free_simple_elems(c, x->StringDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_StartDate) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_StartDate_s* zx_NEW_hrxml_StartDate(struct zx_ctx* c)
{
  struct zx_hrxml_StartDate_s* x = ZX_ZALLOC(c, struct zx_hrxml_StartDate_s);
  x->gg.g.tok = zx_hrxml_StartDate_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_StartDate) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateDescription);

  zx_dup_strs_simple_elems(c, x->AnyDate);
  zx_dup_strs_simple_elems(c, x->YearMonth);
  zx_dup_strs_simple_elems(c, x->Year);
  zx_dup_strs_simple_elems(c, x->MonthDay);
  zx_dup_strs_simple_elems(c, x->StringDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_StartDate) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_StartDate_s* zx_DEEP_CLONE_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_StartDate_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_StartDate_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateDescription = zx_clone_attr(c, x->dateDescription);

  x->AnyDate = zx_deep_clone_simple_elems(c,x->AnyDate, dup_strs);
  x->YearMonth = zx_deep_clone_simple_elems(c,x->YearMonth, dup_strs);
  x->Year = zx_deep_clone_simple_elems(c,x->Year, dup_strs);
  x->MonthDay = zx_deep_clone_simple_elems(c,x->MonthDay, dup_strs);
  x->StringDate = zx_deep_clone_simple_elems(c,x->StringDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_StartDate) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AnyDate, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->YearMonth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Year, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDay, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StringDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_StartDate) */

int zx_WALK_WO_hrxml_StartDate(struct zx_ctx* c, struct zx_hrxml_StartDate_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StartingCompensation
#define EL_STRUCT zx_hrxml_StartingCompensation_s
#define EL_NS     hrxml
#define EL_TAG    StartingCompensation

/* FUNC(zx_FREE_hrxml_StartingCompensation) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->currency, free_strs);
  zx_free_attr(c, x->intervalType, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_StartingCompensation) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_StartingCompensation_s* zx_NEW_hrxml_StartingCompensation(struct zx_ctx* c)
{
  struct zx_hrxml_StartingCompensation_s* x = ZX_ZALLOC(c, struct zx_hrxml_StartingCompensation_s);
  x->gg.g.tok = zx_hrxml_StartingCompensation_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_StartingCompensation) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->currency);
  zx_dup_attr(c, x->intervalType);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);


}

/* FUNC(zx_DEEP_CLONE_hrxml_StartingCompensation) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_StartingCompensation_s* zx_DEEP_CLONE_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_StartingCompensation_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_StartingCompensation_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->currency = zx_clone_attr(c, x->currency);
  x->intervalType = zx_clone_attr(c, x->intervalType);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_StartingCompensation) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_StartingCompensation) */

int zx_WALK_WO_hrxml_StartingCompensation(struct zx_ctx* c, struct zx_hrxml_StartingCompensation_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Status
#define EL_STRUCT zx_hrxml_Status_s
#define EL_NS     hrxml
#define EL_TAG    Status

/* FUNC(zx_FREE_hrxml_Status) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Status) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Status_s* zx_NEW_hrxml_Status(struct zx_ctx* c)
{
  struct zx_hrxml_Status_s* x = ZX_ZALLOC(c, struct zx_hrxml_Status_s);
  x->gg.g.tok = zx_hrxml_Status_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Status) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);


}

/* FUNC(zx_DEEP_CLONE_hrxml_Status) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Status_s* zx_DEEP_CLONE_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Status_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Status_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Status) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Status) */

int zx_WALK_WO_hrxml_Status(struct zx_ctx* c, struct zx_hrxml_Status_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Stock
#define EL_STRUCT zx_hrxml_Stock_s
#define EL_NS     hrxml
#define EL_TAG    Stock

/* FUNC(zx_FREE_hrxml_Stock) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Symbol, free_strs);
  zx_free_simple_elems(c, x->Exchange, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Stock) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Stock_s* zx_NEW_hrxml_Stock(struct zx_ctx* c)
{
  struct zx_hrxml_Stock_s* x = ZX_ZALLOC(c, struct zx_hrxml_Stock_s);
  x->gg.g.tok = zx_hrxml_Stock_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Stock) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->Id->gg;
       se && se->g.tok == zx_hrxml_Id_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Id(c, (struct zx_hrxml_Id_s*)se);
  zx_dup_strs_simple_elems(c, x->Symbol);
  zx_dup_strs_simple_elems(c, x->Exchange);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Stock) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Stock_s* zx_DEEP_CLONE_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Stock_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Stock_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Id(c,(struct zx_hrxml_Id_s*)e,dup_strs);
  	  if (!enn)
  	      x->Id = (struct zx_hrxml_Id_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Symbol = zx_deep_clone_simple_elems(c,x->Symbol, dup_strs);
  x->Exchange = zx_deep_clone_simple_elems(c,x->Exchange, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Stock) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Id->gg;
       e && e->g.tok == zx_hrxml_Id_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Id(c, (struct zx_hrxml_Id_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Symbol, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Exchange, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Stock) */

int zx_WALK_WO_hrxml_Stock(struct zx_ctx* c, struct zx_hrxml_Stock_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StringValue
#define EL_STRUCT zx_hrxml_StringValue_s
#define EL_NS     hrxml
#define EL_TAG    StringValue

/* FUNC(zx_FREE_hrxml_StringValue) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->description, free_strs);
  zx_free_attr(c, x->maxValue, free_strs);
  zx_free_attr(c, x->minValue, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_StringValue) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_StringValue_s* zx_NEW_hrxml_StringValue(struct zx_ctx* c)
{
  struct zx_hrxml_StringValue_s* x = ZX_ZALLOC(c, struct zx_hrxml_StringValue_s);
  x->gg.g.tok = zx_hrxml_StringValue_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_StringValue) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->description);
  zx_dup_attr(c, x->maxValue);
  zx_dup_attr(c, x->minValue);


}

/* FUNC(zx_DEEP_CLONE_hrxml_StringValue) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_StringValue_s* zx_DEEP_CLONE_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_StringValue_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_StringValue_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->description = zx_clone_attr(c, x->description);
  x->maxValue = zx_clone_attr(c, x->maxValue);
  x->minValue = zx_clone_attr(c, x->minValue);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_StringValue) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_StringValue) */

int zx_WALK_WO_hrxml_StringValue(struct zx_ctx* c, struct zx_hrxml_StringValue_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_StructuredXMLResume
#define EL_STRUCT zx_hrxml_StructuredXMLResume_s
#define EL_NS     hrxml
#define EL_TAG    StructuredXMLResume

/* FUNC(zx_FREE_hrxml_StructuredXMLResume) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->ContactInfo->gg;
       e && e->g.tok == zx_hrxml_ContactInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->ExecutiveSummary, free_strs);
  zx_free_simple_elems(c, x->Objective, free_strs);
  for (e = &x->EmploymentHistory->gg;
       e && e->g.tok == zx_hrxml_EmploymentHistory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EmploymentHistory(c, (struct zx_hrxml_EmploymentHistory_s*)e, free_strs);
  }
  for (e = &x->EducationHistory->gg;
       e && e->g.tok == zx_hrxml_EducationHistory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EducationHistory(c, (struct zx_hrxml_EducationHistory_s*)e, free_strs);
  }
  for (e = &x->LicensesAndCertifications->gg;
       e && e->g.tok == zx_hrxml_LicensesAndCertifications_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_LicensesAndCertifications(c, (struct zx_hrxml_LicensesAndCertifications_s*)e, free_strs);
  }
  for (e = &x->MilitaryHistory->gg;
       e && e->g.tok == zx_hrxml_MilitaryHistory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_MilitaryHistory(c, (struct zx_hrxml_MilitaryHistory_s*)e, free_strs);
  }
  for (e = &x->PatentHistory->gg;
       e && e->g.tok == zx_hrxml_PatentHistory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PatentHistory(c, (struct zx_hrxml_PatentHistory_s*)e, free_strs);
  }
  for (e = &x->PublicationHistory->gg;
       e && e->g.tok == zx_hrxml_PublicationHistory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PublicationHistory(c, (struct zx_hrxml_PublicationHistory_s*)e, free_strs);
  }
  for (e = &x->SpeakingEventsHistory->gg;
       e && e->g.tok == zx_hrxml_SpeakingEventsHistory_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SpeakingEventsHistory(c, (struct zx_hrxml_SpeakingEventsHistory_s*)e, free_strs);
  }
  for (e = &x->Qualifications->gg;
       e && e->g.tok == zx_hrxml_Qualifications_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Qualifications(c, (struct zx_hrxml_Qualifications_s*)e, free_strs);
  }
  for (e = &x->Languages->gg;
       e && e->g.tok == zx_hrxml_Languages_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Languages(c, (struct zx_hrxml_Languages_s*)e, free_strs);
  }
  for (e = &x->Achievements->gg;
       e && e->g.tok == zx_hrxml_Achievements_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Achievements(c, (struct zx_hrxml_Achievements_s*)e, free_strs);
  }
  for (e = &x->Associations->gg;
       e && e->g.tok == zx_hrxml_Associations_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Associations(c, (struct zx_hrxml_Associations_s*)e, free_strs);
  }
  for (e = &x->References->gg;
       e && e->g.tok == zx_hrxml_References_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_References(c, (struct zx_hrxml_References_s*)e, free_strs);
  }
  for (e = &x->SecurityCredentials->gg;
       e && e->g.tok == zx_hrxml_SecurityCredentials_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SecurityCredentials(c, (struct zx_hrxml_SecurityCredentials_s*)e, free_strs);
  }
  for (e = &x->ResumeAdditionalItems->gg;
       e && e->g.tok == zx_hrxml_ResumeAdditionalItems_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ResumeAdditionalItems(c, (struct zx_hrxml_ResumeAdditionalItems_s*)e, free_strs);
  }
  for (e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)e, free_strs);
  }
  for (e = &x->ProfessionalAssociations->gg;
       e && e->g.tok == zx_hrxml_ProfessionalAssociations_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ProfessionalAssociations(c, (struct zx_hrxml_ProfessionalAssociations_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->Comments, free_strs);
  zx_free_simple_elems(c, x->RevisionDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_StructuredXMLResume) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_StructuredXMLResume_s* zx_NEW_hrxml_StructuredXMLResume(struct zx_ctx* c)
{
  struct zx_hrxml_StructuredXMLResume_s* x = ZX_ZALLOC(c, struct zx_hrxml_StructuredXMLResume_s);
  x->gg.g.tok = zx_hrxml_StructuredXMLResume_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_StructuredXMLResume) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ContactInfo->gg;
       se && se->g.tok == zx_hrxml_ContactInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)se);
  zx_dup_strs_simple_elems(c, x->ExecutiveSummary);
  zx_dup_strs_simple_elems(c, x->Objective);
  for (se = &x->EmploymentHistory->gg;
       se && se->g.tok == zx_hrxml_EmploymentHistory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EmploymentHistory(c, (struct zx_hrxml_EmploymentHistory_s*)se);
  for (se = &x->EducationHistory->gg;
       se && se->g.tok == zx_hrxml_EducationHistory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EducationHistory(c, (struct zx_hrxml_EducationHistory_s*)se);
  for (se = &x->LicensesAndCertifications->gg;
       se && se->g.tok == zx_hrxml_LicensesAndCertifications_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_LicensesAndCertifications(c, (struct zx_hrxml_LicensesAndCertifications_s*)se);
  for (se = &x->MilitaryHistory->gg;
       se && se->g.tok == zx_hrxml_MilitaryHistory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_MilitaryHistory(c, (struct zx_hrxml_MilitaryHistory_s*)se);
  for (se = &x->PatentHistory->gg;
       se && se->g.tok == zx_hrxml_PatentHistory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PatentHistory(c, (struct zx_hrxml_PatentHistory_s*)se);
  for (se = &x->PublicationHistory->gg;
       se && se->g.tok == zx_hrxml_PublicationHistory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PublicationHistory(c, (struct zx_hrxml_PublicationHistory_s*)se);
  for (se = &x->SpeakingEventsHistory->gg;
       se && se->g.tok == zx_hrxml_SpeakingEventsHistory_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SpeakingEventsHistory(c, (struct zx_hrxml_SpeakingEventsHistory_s*)se);
  for (se = &x->Qualifications->gg;
       se && se->g.tok == zx_hrxml_Qualifications_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Qualifications(c, (struct zx_hrxml_Qualifications_s*)se);
  for (se = &x->Languages->gg;
       se && se->g.tok == zx_hrxml_Languages_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Languages(c, (struct zx_hrxml_Languages_s*)se);
  for (se = &x->Achievements->gg;
       se && se->g.tok == zx_hrxml_Achievements_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Achievements(c, (struct zx_hrxml_Achievements_s*)se);
  for (se = &x->Associations->gg;
       se && se->g.tok == zx_hrxml_Associations_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Associations(c, (struct zx_hrxml_Associations_s*)se);
  for (se = &x->References->gg;
       se && se->g.tok == zx_hrxml_References_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_References(c, (struct zx_hrxml_References_s*)se);
  for (se = &x->SecurityCredentials->gg;
       se && se->g.tok == zx_hrxml_SecurityCredentials_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SecurityCredentials(c, (struct zx_hrxml_SecurityCredentials_s*)se);
  for (se = &x->ResumeAdditionalItems->gg;
       se && se->g.tok == zx_hrxml_ResumeAdditionalItems_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ResumeAdditionalItems(c, (struct zx_hrxml_ResumeAdditionalItems_s*)se);
  for (se = &x->SupportingMaterials->gg;
       se && se->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)se);
  for (se = &x->ProfessionalAssociations->gg;
       se && se->g.tok == zx_hrxml_ProfessionalAssociations_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ProfessionalAssociations(c, (struct zx_hrxml_ProfessionalAssociations_s*)se);
  zx_dup_strs_simple_elems(c, x->Comments);
  zx_dup_strs_simple_elems(c, x->RevisionDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_StructuredXMLResume) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_StructuredXMLResume_s* zx_DEEP_CLONE_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_StructuredXMLResume_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_StructuredXMLResume_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ContactInfo->gg;
       e && e->g.tok == zx_hrxml_ContactInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactInfo(c,(struct zx_hrxml_ContactInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactInfo = (struct zx_hrxml_ContactInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->ExecutiveSummary = zx_deep_clone_simple_elems(c,x->ExecutiveSummary, dup_strs);
  x->Objective = zx_deep_clone_simple_elems(c,x->Objective, dup_strs);
  for (enn = 0, e = &x->EmploymentHistory->gg;
       e && e->g.tok == zx_hrxml_EmploymentHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EmploymentHistory(c,(struct zx_hrxml_EmploymentHistory_s*)e,dup_strs);
  	  if (!enn)
  	      x->EmploymentHistory = (struct zx_hrxml_EmploymentHistory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->EducationHistory->gg;
       e && e->g.tok == zx_hrxml_EducationHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EducationHistory(c,(struct zx_hrxml_EducationHistory_s*)e,dup_strs);
  	  if (!enn)
  	      x->EducationHistory = (struct zx_hrxml_EducationHistory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->LicensesAndCertifications->gg;
       e && e->g.tok == zx_hrxml_LicensesAndCertifications_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_LicensesAndCertifications(c,(struct zx_hrxml_LicensesAndCertifications_s*)e,dup_strs);
  	  if (!enn)
  	      x->LicensesAndCertifications = (struct zx_hrxml_LicensesAndCertifications_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->MilitaryHistory->gg;
       e && e->g.tok == zx_hrxml_MilitaryHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_MilitaryHistory(c,(struct zx_hrxml_MilitaryHistory_s*)e,dup_strs);
  	  if (!enn)
  	      x->MilitaryHistory = (struct zx_hrxml_MilitaryHistory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PatentHistory->gg;
       e && e->g.tok == zx_hrxml_PatentHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PatentHistory(c,(struct zx_hrxml_PatentHistory_s*)e,dup_strs);
  	  if (!enn)
  	      x->PatentHistory = (struct zx_hrxml_PatentHistory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PublicationHistory->gg;
       e && e->g.tok == zx_hrxml_PublicationHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PublicationHistory(c,(struct zx_hrxml_PublicationHistory_s*)e,dup_strs);
  	  if (!enn)
  	      x->PublicationHistory = (struct zx_hrxml_PublicationHistory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SpeakingEventsHistory->gg;
       e && e->g.tok == zx_hrxml_SpeakingEventsHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SpeakingEventsHistory(c,(struct zx_hrxml_SpeakingEventsHistory_s*)e,dup_strs);
  	  if (!enn)
  	      x->SpeakingEventsHistory = (struct zx_hrxml_SpeakingEventsHistory_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Qualifications->gg;
       e && e->g.tok == zx_hrxml_Qualifications_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Qualifications(c,(struct zx_hrxml_Qualifications_s*)e,dup_strs);
  	  if (!enn)
  	      x->Qualifications = (struct zx_hrxml_Qualifications_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Languages->gg;
       e && e->g.tok == zx_hrxml_Languages_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Languages(c,(struct zx_hrxml_Languages_s*)e,dup_strs);
  	  if (!enn)
  	      x->Languages = (struct zx_hrxml_Languages_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Achievements->gg;
       e && e->g.tok == zx_hrxml_Achievements_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Achievements(c,(struct zx_hrxml_Achievements_s*)e,dup_strs);
  	  if (!enn)
  	      x->Achievements = (struct zx_hrxml_Achievements_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Associations->gg;
       e && e->g.tok == zx_hrxml_Associations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Associations(c,(struct zx_hrxml_Associations_s*)e,dup_strs);
  	  if (!enn)
  	      x->Associations = (struct zx_hrxml_Associations_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->References->gg;
       e && e->g.tok == zx_hrxml_References_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_References(c,(struct zx_hrxml_References_s*)e,dup_strs);
  	  if (!enn)
  	      x->References = (struct zx_hrxml_References_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SecurityCredentials->gg;
       e && e->g.tok == zx_hrxml_SecurityCredentials_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SecurityCredentials(c,(struct zx_hrxml_SecurityCredentials_s*)e,dup_strs);
  	  if (!enn)
  	      x->SecurityCredentials = (struct zx_hrxml_SecurityCredentials_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ResumeAdditionalItems->gg;
       e && e->g.tok == zx_hrxml_ResumeAdditionalItems_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ResumeAdditionalItems(c,(struct zx_hrxml_ResumeAdditionalItems_s*)e,dup_strs);
  	  if (!enn)
  	      x->ResumeAdditionalItems = (struct zx_hrxml_ResumeAdditionalItems_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_SupportingMaterials(c,(struct zx_hrxml_SupportingMaterials_s*)e,dup_strs);
  	  if (!enn)
  	      x->SupportingMaterials = (struct zx_hrxml_SupportingMaterials_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ProfessionalAssociations->gg;
       e && e->g.tok == zx_hrxml_ProfessionalAssociations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ProfessionalAssociations(c,(struct zx_hrxml_ProfessionalAssociations_s*)e,dup_strs);
  	  if (!enn)
  	      x->ProfessionalAssociations = (struct zx_hrxml_ProfessionalAssociations_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->Comments = zx_deep_clone_simple_elems(c,x->Comments, dup_strs);
  x->RevisionDate = zx_deep_clone_simple_elems(c,x->RevisionDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_StructuredXMLResume) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ContactInfo->gg;
       e && e->g.tok == zx_hrxml_ContactInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->ExecutiveSummary, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Objective, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->EmploymentHistory->gg;
       e && e->g.tok == zx_hrxml_EmploymentHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EmploymentHistory(c, (struct zx_hrxml_EmploymentHistory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->EducationHistory->gg;
       e && e->g.tok == zx_hrxml_EducationHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EducationHistory(c, (struct zx_hrxml_EducationHistory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->LicensesAndCertifications->gg;
       e && e->g.tok == zx_hrxml_LicensesAndCertifications_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_LicensesAndCertifications(c, (struct zx_hrxml_LicensesAndCertifications_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->MilitaryHistory->gg;
       e && e->g.tok == zx_hrxml_MilitaryHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_MilitaryHistory(c, (struct zx_hrxml_MilitaryHistory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PatentHistory->gg;
       e && e->g.tok == zx_hrxml_PatentHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PatentHistory(c, (struct zx_hrxml_PatentHistory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PublicationHistory->gg;
       e && e->g.tok == zx_hrxml_PublicationHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PublicationHistory(c, (struct zx_hrxml_PublicationHistory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SpeakingEventsHistory->gg;
       e && e->g.tok == zx_hrxml_SpeakingEventsHistory_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SpeakingEventsHistory(c, (struct zx_hrxml_SpeakingEventsHistory_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Qualifications->gg;
       e && e->g.tok == zx_hrxml_Qualifications_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Qualifications(c, (struct zx_hrxml_Qualifications_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Languages->gg;
       e && e->g.tok == zx_hrxml_Languages_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Languages(c, (struct zx_hrxml_Languages_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Achievements->gg;
       e && e->g.tok == zx_hrxml_Achievements_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Achievements(c, (struct zx_hrxml_Achievements_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Associations->gg;
       e && e->g.tok == zx_hrxml_Associations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Associations(c, (struct zx_hrxml_Associations_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->References->gg;
       e && e->g.tok == zx_hrxml_References_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_References(c, (struct zx_hrxml_References_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SecurityCredentials->gg;
       e && e->g.tok == zx_hrxml_SecurityCredentials_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SecurityCredentials(c, (struct zx_hrxml_SecurityCredentials_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ResumeAdditionalItems->gg;
       e && e->g.tok == zx_hrxml_ResumeAdditionalItems_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ResumeAdditionalItems(c, (struct zx_hrxml_ResumeAdditionalItems_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->SupportingMaterials->gg;
       e && e->g.tok == zx_hrxml_SupportingMaterials_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_SupportingMaterials(c, (struct zx_hrxml_SupportingMaterials_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ProfessionalAssociations->gg;
       e && e->g.tok == zx_hrxml_ProfessionalAssociations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ProfessionalAssociations(c, (struct zx_hrxml_ProfessionalAssociations_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->Comments, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->RevisionDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_StructuredXMLResume) */

int zx_WALK_WO_hrxml_StructuredXMLResume(struct zx_ctx* c, struct zx_hrxml_StructuredXMLResume_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SupplierId
#define EL_STRUCT zx_hrxml_SupplierId_s
#define EL_NS     hrxml
#define EL_TAG    SupplierId

/* FUNC(zx_FREE_hrxml_SupplierId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SupplierId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SupplierId_s* zx_NEW_hrxml_SupplierId(struct zx_ctx* c)
{
  struct zx_hrxml_SupplierId_s* x = ZX_ZALLOC(c, struct zx_hrxml_SupplierId_s);
  x->gg.g.tok = zx_hrxml_SupplierId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SupplierId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SupplierId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SupplierId_s* zx_DEEP_CLONE_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SupplierId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SupplierId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SupplierId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SupplierId) */

int zx_WALK_WO_hrxml_SupplierId(struct zx_ctx* c, struct zx_hrxml_SupplierId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_SupportingMaterials
#define EL_STRUCT zx_hrxml_SupportingMaterials_s
#define EL_NS     hrxml
#define EL_TAG    SupportingMaterials

/* FUNC(zx_FREE_hrxml_SupportingMaterials) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Link, free_strs);
  for (e = &x->AttachmentReference->gg;
       e && e->g.tok == zx_hrxml_AttachmentReference_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_AttachmentReference(c, (struct zx_hrxml_AttachmentReference_s*)e, free_strs);
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_SupportingMaterials) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_SupportingMaterials_s* zx_NEW_hrxml_SupportingMaterials(struct zx_ctx* c)
{
  struct zx_hrxml_SupportingMaterials_s* x = ZX_ZALLOC(c, struct zx_hrxml_SupportingMaterials_s);
  x->gg.g.tok = zx_hrxml_SupportingMaterials_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_SupportingMaterials) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Link);
  for (se = &x->AttachmentReference->gg;
       se && se->g.tok == zx_hrxml_AttachmentReference_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_AttachmentReference(c, (struct zx_hrxml_AttachmentReference_s*)se);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_SupportingMaterials) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_SupportingMaterials_s* zx_DEEP_CLONE_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_SupportingMaterials_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_SupportingMaterials_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Link = zx_deep_clone_simple_elems(c,x->Link, dup_strs);
  for (enn = 0, e = &x->AttachmentReference->gg;
       e && e->g.tok == zx_hrxml_AttachmentReference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_AttachmentReference(c,(struct zx_hrxml_AttachmentReference_s*)e,dup_strs);
  	  if (!enn)
  	      x->AttachmentReference = (struct zx_hrxml_AttachmentReference_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_SupportingMaterials) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Link, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->AttachmentReference->gg;
       e && e->g.tok == zx_hrxml_AttachmentReference_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_AttachmentReference(c, (struct zx_hrxml_AttachmentReference_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_SupportingMaterials) */

int zx_WALK_WO_hrxml_SupportingMaterials(struct zx_ctx* c, struct zx_hrxml_SupportingMaterials_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TTYTDD
#define EL_STRUCT zx_hrxml_TTYTDD_s
#define EL_NS     hrxml
#define EL_TAG    TTYTDD

/* FUNC(zx_FREE_hrxml_TTYTDD) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->FormattedNumber, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_TTYTDD) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_TTYTDD_s* zx_NEW_hrxml_TTYTDD(struct zx_ctx* c)
{
  struct zx_hrxml_TTYTDD_s* x = ZX_ZALLOC(c, struct zx_hrxml_TTYTDD_s);
  x->gg.g.tok = zx_hrxml_TTYTDD_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_TTYTDD) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->FormattedNumber);

}

/* FUNC(zx_DEEP_CLONE_hrxml_TTYTDD) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_TTYTDD_s* zx_DEEP_CLONE_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_TTYTDD_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_TTYTDD_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->FormattedNumber = zx_deep_clone_simple_elems(c,x->FormattedNumber, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_TTYTDD) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->FormattedNumber, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_TTYTDD) */

int zx_WALK_WO_hrxml_TTYTDD(struct zx_ctx* c, struct zx_hrxml_TTYTDD_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TaxId
#define EL_STRUCT zx_hrxml_TaxId_s
#define EL_NS     hrxml
#define EL_TAG    TaxId

/* FUNC(zx_FREE_hrxml_TaxId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_TaxId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_TaxId_s* zx_NEW_hrxml_TaxId(struct zx_ctx* c)
{
  struct zx_hrxml_TaxId_s* x = ZX_ZALLOC(c, struct zx_hrxml_TaxId_s);
  x->gg.g.tok = zx_hrxml_TaxId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_TaxId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_TaxId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_TaxId_s* zx_DEEP_CLONE_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_TaxId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_TaxId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_TaxId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_TaxId) */

int zx_WALK_WO_hrxml_TaxId(struct zx_ctx* c, struct zx_hrxml_TaxId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TaxonomyId
#define EL_STRUCT zx_hrxml_TaxonomyId_s
#define EL_NS     hrxml
#define EL_TAG    TaxonomyId

/* FUNC(zx_FREE_hrxml_TaxonomyId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->description, free_strs);
  zx_free_attr(c, x->id, free_strs);
  zx_free_attr(c, x->idOwner, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_TaxonomyId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_TaxonomyId_s* zx_NEW_hrxml_TaxonomyId(struct zx_ctx* c)
{
  struct zx_hrxml_TaxonomyId_s* x = ZX_ZALLOC(c, struct zx_hrxml_TaxonomyId_s);
  x->gg.g.tok = zx_hrxml_TaxonomyId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_TaxonomyId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->description);
  zx_dup_attr(c, x->id);
  zx_dup_attr(c, x->idOwner);


}

/* FUNC(zx_DEEP_CLONE_hrxml_TaxonomyId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_TaxonomyId_s* zx_DEEP_CLONE_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_TaxonomyId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_TaxonomyId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->description = zx_clone_attr(c, x->description);
  x->id = zx_clone_attr(c, x->id);
  x->idOwner = zx_clone_attr(c, x->idOwner);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_TaxonomyId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_TaxonomyId) */

int zx_WALK_WO_hrxml_TaxonomyId(struct zx_ctx* c, struct zx_hrxml_TaxonomyId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TaxonomyName
#define EL_STRUCT zx_hrxml_TaxonomyName_s
#define EL_NS     hrxml
#define EL_TAG    TaxonomyName

/* FUNC(zx_FREE_hrxml_TaxonomyName) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->version, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_TaxonomyName) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_TaxonomyName_s* zx_NEW_hrxml_TaxonomyName(struct zx_ctx* c)
{
  struct zx_hrxml_TaxonomyName_s* x = ZX_ZALLOC(c, struct zx_hrxml_TaxonomyName_s);
  x->gg.g.tok = zx_hrxml_TaxonomyName_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_TaxonomyName) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->version);


}

/* FUNC(zx_DEEP_CLONE_hrxml_TaxonomyName) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_TaxonomyName_s* zx_DEEP_CLONE_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_TaxonomyName_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_TaxonomyName_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->version = zx_clone_attr(c, x->version);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_TaxonomyName) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_TaxonomyName) */

int zx_WALK_WO_hrxml_TaxonomyName(struct zx_ctx* c, struct zx_hrxml_TaxonomyName_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Telephone
#define EL_STRUCT zx_hrxml_Telephone_s
#define EL_NS     hrxml
#define EL_TAG    Telephone

/* FUNC(zx_FREE_hrxml_Telephone) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->FormattedNumber, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Telephone) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Telephone_s* zx_NEW_hrxml_Telephone(struct zx_ctx* c)
{
  struct zx_hrxml_Telephone_s* x = ZX_ZALLOC(c, struct zx_hrxml_Telephone_s);
  x->gg.g.tok = zx_hrxml_Telephone_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Telephone) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->FormattedNumber);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Telephone) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Telephone_s* zx_DEEP_CLONE_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Telephone_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Telephone_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->FormattedNumber = zx_deep_clone_simple_elems(c,x->FormattedNumber, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Telephone) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->FormattedNumber, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Telephone) */

int zx_WALK_WO_hrxml_Telephone(struct zx_ctx* c, struct zx_hrxml_Telephone_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TermOfNotice
#define EL_STRUCT zx_hrxml_TermOfNotice_s
#define EL_NS     hrxml
#define EL_TAG    TermOfNotice

/* FUNC(zx_FREE_hrxml_TermOfNotice) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Value, free_strs);
  zx_free_simple_elems(c, x->Interval, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_TermOfNotice) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_TermOfNotice_s* zx_NEW_hrxml_TermOfNotice(struct zx_ctx* c)
{
  struct zx_hrxml_TermOfNotice_s* x = ZX_ZALLOC(c, struct zx_hrxml_TermOfNotice_s);
  x->gg.g.tok = zx_hrxml_TermOfNotice_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_TermOfNotice) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Value);
  zx_dup_strs_simple_elems(c, x->Interval);

}

/* FUNC(zx_DEEP_CLONE_hrxml_TermOfNotice) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_TermOfNotice_s* zx_DEEP_CLONE_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_TermOfNotice_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_TermOfNotice_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Value = zx_deep_clone_simple_elems(c,x->Value, dup_strs);
  x->Interval = zx_deep_clone_simple_elems(c,x->Interval, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_TermOfNotice) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Value, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Interval, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_TermOfNotice) */

int zx_WALK_WO_hrxml_TermOfNotice(struct zx_ctx* c, struct zx_hrxml_TermOfNotice_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TimeMax
#define EL_STRUCT zx_hrxml_TimeMax_s
#define EL_NS     hrxml
#define EL_TAG    TimeMax

/* FUNC(zx_FREE_hrxml_TimeMax) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->unitOfMeasure, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_TimeMax) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_TimeMax_s* zx_NEW_hrxml_TimeMax(struct zx_ctx* c)
{
  struct zx_hrxml_TimeMax_s* x = ZX_ZALLOC(c, struct zx_hrxml_TimeMax_s);
  x->gg.g.tok = zx_hrxml_TimeMax_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_TimeMax) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->unitOfMeasure);


}

/* FUNC(zx_DEEP_CLONE_hrxml_TimeMax) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_TimeMax_s* zx_DEEP_CLONE_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_TimeMax_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_TimeMax_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->unitOfMeasure = zx_clone_attr(c, x->unitOfMeasure);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_TimeMax) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_TimeMax) */

int zx_WALK_WO_hrxml_TimeMax(struct zx_ctx* c, struct zx_hrxml_TimeMax_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TimeOffAllowance
#define EL_STRUCT zx_hrxml_TimeOffAllowance_s
#define EL_NS     hrxml
#define EL_TAG    TimeOffAllowance

/* FUNC(zx_FREE_hrxml_TimeOffAllowance) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->timeOffType, free_strs);

  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_TimeOffAllowance) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_TimeOffAllowance_s* zx_NEW_hrxml_TimeOffAllowance(struct zx_ctx* c)
{
  struct zx_hrxml_TimeOffAllowance_s* x = ZX_ZALLOC(c, struct zx_hrxml_TimeOffAllowance_s);
  x->gg.g.tok = zx_hrxml_TimeOffAllowance_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_TimeOffAllowance) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->timeOffType);

  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_TimeOffAllowance) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_TimeOffAllowance_s* zx_DEEP_CLONE_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_TimeOffAllowance_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_TimeOffAllowance_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->timeOffType = zx_clone_attr(c, x->timeOffType);

  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_TimeOffAllowance) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_TimeOffAllowance) */

int zx_WALK_WO_hrxml_TimeOffAllowance(struct zx_ctx* c, struct zx_hrxml_TimeOffAllowance_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Travel
#define EL_STRUCT zx_hrxml_Travel_s
#define EL_NS     hrxml
#define EL_TAG    Travel

/* FUNC(zx_FREE_hrxml_Travel) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->Applicable, free_strs);
  zx_free_simple_elems(c, x->TravelFrequency, free_strs);
  zx_free_simple_elems(c, x->TravelConsiderations, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Travel) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Travel_s* zx_NEW_hrxml_Travel(struct zx_ctx* c)
{
  struct zx_hrxml_Travel_s* x = ZX_ZALLOC(c, struct zx_hrxml_Travel_s);
  x->gg.g.tok = zx_hrxml_Travel_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Travel) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->Applicable);
  zx_dup_strs_simple_elems(c, x->TravelFrequency);
  zx_dup_strs_simple_elems(c, x->TravelConsiderations);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Travel) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Travel_s* zx_DEEP_CLONE_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Travel_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Travel_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->Applicable = zx_deep_clone_simple_elems(c,x->Applicable, dup_strs);
  x->TravelFrequency = zx_deep_clone_simple_elems(c,x->TravelFrequency, dup_strs);
  x->TravelConsiderations = zx_deep_clone_simple_elems(c,x->TravelConsiderations, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Travel) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->Applicable, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->TravelFrequency, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->TravelConsiderations, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Travel) */

int zx_WALK_WO_hrxml_Travel(struct zx_ctx* c, struct zx_hrxml_Travel_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_TravelDirections
#define EL_STRUCT zx_hrxml_TravelDirections_s
#define EL_NS     hrxml
#define EL_TAG    TravelDirections

/* FUNC(zx_FREE_hrxml_TravelDirections) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->lang, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_TravelDirections) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_TravelDirections_s* zx_NEW_hrxml_TravelDirections(struct zx_ctx* c)
{
  struct zx_hrxml_TravelDirections_s* x = ZX_ZALLOC(c, struct zx_hrxml_TravelDirections_s);
  x->gg.g.tok = zx_hrxml_TravelDirections_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_TravelDirections) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->lang);


}

/* FUNC(zx_DEEP_CLONE_hrxml_TravelDirections) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_TravelDirections_s* zx_DEEP_CLONE_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_TravelDirections_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_TravelDirections_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->lang = zx_clone_attr(c, x->lang);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_TravelDirections) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_TravelDirections) */

int zx_WALK_WO_hrxml_TravelDirections(struct zx_ctx* c, struct zx_hrxml_TravelDirections_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_UserArea
#define EL_STRUCT zx_hrxml_UserArea_s
#define EL_NS     hrxml
#define EL_TAG    UserArea

/* FUNC(zx_FREE_hrxml_UserArea) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_UserArea) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_UserArea_s* zx_NEW_hrxml_UserArea(struct zx_ctx* c)
{
  struct zx_hrxml_UserArea_s* x = ZX_ZALLOC(c, struct zx_hrxml_UserArea_s);
  x->gg.g.tok = zx_hrxml_UserArea_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_UserArea) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_hrxml_UserArea) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_UserArea_s* zx_DEEP_CLONE_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_UserArea_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_UserArea_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_hrxml_UserArea) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_UserArea) */

int zx_WALK_WO_hrxml_UserArea(struct zx_ctx* c, struct zx_hrxml_UserArea_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_UserId
#define EL_STRUCT zx_hrxml_UserId_s
#define EL_NS     hrxml
#define EL_TAG    UserId

/* FUNC(zx_FREE_hrxml_UserId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_UserId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_UserId_s* zx_NEW_hrxml_UserId(struct zx_ctx* c)
{
  struct zx_hrxml_UserId_s* x = ZX_ZALLOC(c, struct zx_hrxml_UserId_s);
  x->gg.g.tok = zx_hrxml_UserId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_UserId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_UserId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_UserId_s* zx_DEEP_CLONE_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_UserId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_UserId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_UserId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_UserId) */

int zx_WALK_WO_hrxml_UserId(struct zx_ctx* c, struct zx_hrxml_UserId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ValidFrom
#define EL_STRUCT zx_hrxml_ValidFrom_s
#define EL_NS     hrxml
#define EL_TAG    ValidFrom

/* FUNC(zx_FREE_hrxml_ValidFrom) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateDescription, free_strs);

  zx_free_simple_elems(c, x->AnyDate, free_strs);
  zx_free_simple_elems(c, x->YearMonth, free_strs);
  zx_free_simple_elems(c, x->Year, free_strs);
  zx_free_simple_elems(c, x->MonthDay, free_strs);
  zx_free_simple_elems(c, x->StringDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ValidFrom) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ValidFrom_s* zx_NEW_hrxml_ValidFrom(struct zx_ctx* c)
{
  struct zx_hrxml_ValidFrom_s* x = ZX_ZALLOC(c, struct zx_hrxml_ValidFrom_s);
  x->gg.g.tok = zx_hrxml_ValidFrom_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ValidFrom) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateDescription);

  zx_dup_strs_simple_elems(c, x->AnyDate);
  zx_dup_strs_simple_elems(c, x->YearMonth);
  zx_dup_strs_simple_elems(c, x->Year);
  zx_dup_strs_simple_elems(c, x->MonthDay);
  zx_dup_strs_simple_elems(c, x->StringDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ValidFrom) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ValidFrom_s* zx_DEEP_CLONE_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ValidFrom_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ValidFrom_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateDescription = zx_clone_attr(c, x->dateDescription);

  x->AnyDate = zx_deep_clone_simple_elems(c,x->AnyDate, dup_strs);
  x->YearMonth = zx_deep_clone_simple_elems(c,x->YearMonth, dup_strs);
  x->Year = zx_deep_clone_simple_elems(c,x->Year, dup_strs);
  x->MonthDay = zx_deep_clone_simple_elems(c,x->MonthDay, dup_strs);
  x->StringDate = zx_deep_clone_simple_elems(c,x->StringDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ValidFrom) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AnyDate, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->YearMonth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Year, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDay, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StringDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ValidFrom) */

int zx_WALK_WO_hrxml_ValidFrom(struct zx_ctx* c, struct zx_hrxml_ValidFrom_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_ValidTo
#define EL_STRUCT zx_hrxml_ValidTo_s
#define EL_NS     hrxml
#define EL_TAG    ValidTo

/* FUNC(zx_FREE_hrxml_ValidTo) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->dateDescription, free_strs);

  zx_free_simple_elems(c, x->AnyDate, free_strs);
  zx_free_simple_elems(c, x->YearMonth, free_strs);
  zx_free_simple_elems(c, x->Year, free_strs);
  zx_free_simple_elems(c, x->MonthDay, free_strs);
  zx_free_simple_elems(c, x->StringDate, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_ValidTo) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_ValidTo_s* zx_NEW_hrxml_ValidTo(struct zx_ctx* c)
{
  struct zx_hrxml_ValidTo_s* x = ZX_ZALLOC(c, struct zx_hrxml_ValidTo_s);
  x->gg.g.tok = zx_hrxml_ValidTo_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_ValidTo) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->dateDescription);

  zx_dup_strs_simple_elems(c, x->AnyDate);
  zx_dup_strs_simple_elems(c, x->YearMonth);
  zx_dup_strs_simple_elems(c, x->Year);
  zx_dup_strs_simple_elems(c, x->MonthDay);
  zx_dup_strs_simple_elems(c, x->StringDate);

}

/* FUNC(zx_DEEP_CLONE_hrxml_ValidTo) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_ValidTo_s* zx_DEEP_CLONE_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_ValidTo_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_ValidTo_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->dateDescription = zx_clone_attr(c, x->dateDescription);

  x->AnyDate = zx_deep_clone_simple_elems(c,x->AnyDate, dup_strs);
  x->YearMonth = zx_deep_clone_simple_elems(c,x->YearMonth, dup_strs);
  x->Year = zx_deep_clone_simple_elems(c,x->Year, dup_strs);
  x->MonthDay = zx_deep_clone_simple_elems(c,x->MonthDay, dup_strs);
  x->StringDate = zx_deep_clone_simple_elems(c,x->StringDate, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_ValidTo) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->AnyDate, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->YearMonth, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->Year, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->MonthDay, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->StringDate, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_ValidTo) */

int zx_WALK_WO_hrxml_ValidTo(struct zx_ctx* c, struct zx_hrxml_ValidTo_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Verification
#define EL_STRUCT zx_hrxml_Verification_s
#define EL_NS     hrxml
#define EL_TAG    Verification

/* FUNC(zx_FREE_hrxml_Verification) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  for (e = &x->ContactInfo->gg;
       e && e->g.tok == zx_hrxml_ContactInfo_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)e, free_strs);
  }
  zx_free_simple_elems(c, x->ReasonForLeaving, free_strs);
  zx_free_simple_elems(c, x->PermissionToContact, free_strs);
  zx_free_simple_elems(c, x->VerifyEmployment, free_strs);
  zx_free_simple_elems(c, x->EligibleForRehire, free_strs);
  zx_free_simple_elems(c, x->AttendanceRating, free_strs);
  zx_free_simple_elems(c, x->OverallPerformanceRating, free_strs);
  zx_free_simple_elems(c, x->QuestionAnswerPair, free_strs);


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Verification) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Verification_s* zx_NEW_hrxml_Verification(struct zx_ctx* c)
{
  struct zx_hrxml_Verification_s* x = ZX_ZALLOC(c, struct zx_hrxml_Verification_s);
  x->gg.g.tok = zx_hrxml_Verification_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Verification) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  for (se = &x->ContactInfo->gg;
       se && se->g.tok == zx_hrxml_ContactInfo_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)se);
  zx_dup_strs_simple_elems(c, x->ReasonForLeaving);
  zx_dup_strs_simple_elems(c, x->PermissionToContact);
  zx_dup_strs_simple_elems(c, x->VerifyEmployment);
  zx_dup_strs_simple_elems(c, x->EligibleForRehire);
  zx_dup_strs_simple_elems(c, x->AttendanceRating);
  zx_dup_strs_simple_elems(c, x->OverallPerformanceRating);
  zx_dup_strs_simple_elems(c, x->QuestionAnswerPair);

}

/* FUNC(zx_DEEP_CLONE_hrxml_Verification) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Verification_s* zx_DEEP_CLONE_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Verification_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Verification_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  for (enn = 0, e = &x->ContactInfo->gg;
       e && e->g.tok == zx_hrxml_ContactInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ContactInfo(c,(struct zx_hrxml_ContactInfo_s*)e,dup_strs);
  	  if (!enn)
  	      x->ContactInfo = (struct zx_hrxml_ContactInfo_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  x->ReasonForLeaving = zx_deep_clone_simple_elems(c,x->ReasonForLeaving, dup_strs);
  x->PermissionToContact = zx_deep_clone_simple_elems(c,x->PermissionToContact, dup_strs);
  x->VerifyEmployment = zx_deep_clone_simple_elems(c,x->VerifyEmployment, dup_strs);
  x->EligibleForRehire = zx_deep_clone_simple_elems(c,x->EligibleForRehire, dup_strs);
  x->AttendanceRating = zx_deep_clone_simple_elems(c,x->AttendanceRating, dup_strs);
  x->OverallPerformanceRating = zx_deep_clone_simple_elems(c,x->OverallPerformanceRating, dup_strs);
  x->QuestionAnswerPair = zx_deep_clone_simple_elems(c,x->QuestionAnswerPair, dup_strs);

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Verification) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->ContactInfo->gg;
       e && e->g.tok == zx_hrxml_ContactInfo_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ContactInfo(c, (struct zx_hrxml_ContactInfo_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  ret = zx_walk_so_simple_elems(c, x->ReasonForLeaving, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->PermissionToContact, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->VerifyEmployment, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->EligibleForRehire, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->AttendanceRating, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->OverallPerformanceRating, ctx, callback);
  if (ret)
    return ret;
  ret = zx_walk_so_simple_elems(c, x->QuestionAnswerPair, ctx, callback);
  if (ret)
    return ret;

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Verification) */

int zx_WALK_WO_hrxml_Verification(struct zx_ctx* c, struct zx_hrxml_Verification_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_VerticalAccuracy
#define EL_STRUCT zx_hrxml_VerticalAccuracy_s
#define EL_NS     hrxml
#define EL_TAG    VerticalAccuracy

/* FUNC(zx_FREE_hrxml_VerticalAccuracy) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */




  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_VerticalAccuracy) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_VerticalAccuracy_s* zx_NEW_hrxml_VerticalAccuracy(struct zx_ctx* c)
{
  struct zx_hrxml_VerticalAccuracy_s* x = ZX_ZALLOC(c, struct zx_hrxml_VerticalAccuracy_s);
  x->gg.g.tok = zx_hrxml_VerticalAccuracy_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_VerticalAccuracy) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */



}

/* FUNC(zx_DEEP_CLONE_hrxml_VerticalAccuracy) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_VerticalAccuracy_s* zx_DEEP_CLONE_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_VerticalAccuracy_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_VerticalAccuracy_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */



  return x;
}

/* FUNC(zx_WALK_SO_hrxml_VerticalAccuracy) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_VerticalAccuracy) */

int zx_WALK_WO_hrxml_VerticalAccuracy(struct zx_ctx* c, struct zx_hrxml_VerticalAccuracy_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_VisaStatus
#define EL_STRUCT zx_hrxml_VisaStatus_s
#define EL_NS     hrxml
#define EL_TAG    VisaStatus

/* FUNC(zx_FREE_hrxml_VisaStatus) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->countryCode, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_VisaStatus) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_VisaStatus_s* zx_NEW_hrxml_VisaStatus(struct zx_ctx* c)
{
  struct zx_hrxml_VisaStatus_s* x = ZX_ZALLOC(c, struct zx_hrxml_VisaStatus_s);
  x->gg.g.tok = zx_hrxml_VisaStatus_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_VisaStatus) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->countryCode);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);


}

/* FUNC(zx_DEEP_CLONE_hrxml_VisaStatus) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_VisaStatus_s* zx_DEEP_CLONE_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_VisaStatus_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_VisaStatus_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->countryCode = zx_clone_attr(c, x->countryCode);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_VisaStatus) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_VisaStatus) */

int zx_WALK_WO_hrxml_VisaStatus(struct zx_ctx* c, struct zx_hrxml_VisaStatus_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_Weight
#define EL_STRUCT zx_hrxml_Weight_s
#define EL_NS     hrxml
#define EL_TAG    Weight

/* FUNC(zx_FREE_hrxml_Weight) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->description, free_strs);
  zx_free_attr(c, x->interval, free_strs);
  zx_free_attr(c, x->maxValue, free_strs);
  zx_free_attr(c, x->minValue, free_strs);



  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_Weight) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_Weight_s* zx_NEW_hrxml_Weight(struct zx_ctx* c)
{
  struct zx_hrxml_Weight_s* x = ZX_ZALLOC(c, struct zx_hrxml_Weight_s);
  x->gg.g.tok = zx_hrxml_Weight_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_Weight) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->description);
  zx_dup_attr(c, x->interval);
  zx_dup_attr(c, x->maxValue);
  zx_dup_attr(c, x->minValue);


}

/* FUNC(zx_DEEP_CLONE_hrxml_Weight) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_Weight_s* zx_DEEP_CLONE_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_Weight_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_Weight_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->description = zx_clone_attr(c, x->description);
  x->interval = zx_clone_attr(c, x->interval);
  x->maxValue = zx_clone_attr(c, x->maxValue);
  x->minValue = zx_clone_attr(c, x->minValue);


  return x;
}

/* FUNC(zx_WALK_SO_hrxml_Weight) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;


  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_Weight) */

int zx_WALK_WO_hrxml_Weight(struct zx_ctx* c, struct zx_hrxml_Weight_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_WorkSite
#define EL_STRUCT zx_hrxml_WorkSite_s
#define EL_NS     hrxml
#define EL_TAG    WorkSite

/* FUNC(zx_FREE_hrxml_WorkSite) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->WorkSiteName, free_strs);
  for (e = &x->WorkSiteId->gg;
       e && e->g.tok == zx_hrxml_WorkSiteId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_WorkSiteId(c, (struct zx_hrxml_WorkSiteId_s*)e, free_strs);
  }
  for (e = &x->Details->gg;
       e && e->g.tok == zx_hrxml_Details_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Details(c, (struct zx_hrxml_Details_s*)e, free_strs);
  }
  for (e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)e, free_strs);
  }
  for (e = &x->TravelDirections->gg;
       e && e->g.tok == zx_hrxml_TravelDirections_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)e, free_strs);
  }
  for (e = &x->ParkingInstructions->gg;
       e && e->g.tok == zx_hrxml_ParkingInstructions_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_ParkingInstructions(c, (struct zx_hrxml_ParkingInstructions_s*)e, free_strs);
  }
  for (e = &x->WorkSiteEnvironment->gg;
       e && e->g.tok == zx_hrxml_WorkSiteEnvironment_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_WorkSiteEnvironment(c, (struct zx_hrxml_WorkSiteEnvironment_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_WorkSite) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_WorkSite_s* zx_NEW_hrxml_WorkSite(struct zx_ctx* c)
{
  struct zx_hrxml_WorkSite_s* x = ZX_ZALLOC(c, struct zx_hrxml_WorkSite_s);
  x->gg.g.tok = zx_hrxml_WorkSite_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_WorkSite) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->WorkSiteName);
  for (se = &x->WorkSiteId->gg;
       se && se->g.tok == zx_hrxml_WorkSiteId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_WorkSiteId(c, (struct zx_hrxml_WorkSiteId_s*)se);
  for (se = &x->Details->gg;
       se && se->g.tok == zx_hrxml_Details_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Details(c, (struct zx_hrxml_Details_s*)se);
  for (se = &x->PostalAddress->gg;
       se && se->g.tok == zx_hrxml_PostalAddress_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)se);
  for (se = &x->TravelDirections->gg;
       se && se->g.tok == zx_hrxml_TravelDirections_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)se);
  for (se = &x->ParkingInstructions->gg;
       se && se->g.tok == zx_hrxml_ParkingInstructions_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_ParkingInstructions(c, (struct zx_hrxml_ParkingInstructions_s*)se);
  for (se = &x->WorkSiteEnvironment->gg;
       se && se->g.tok == zx_hrxml_WorkSiteEnvironment_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_WorkSiteEnvironment(c, (struct zx_hrxml_WorkSiteEnvironment_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_WorkSite) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_WorkSite_s* zx_DEEP_CLONE_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_WorkSite_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_WorkSite_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->WorkSiteName = zx_deep_clone_simple_elems(c,x->WorkSiteName, dup_strs);
  for (enn = 0, e = &x->WorkSiteId->gg;
       e && e->g.tok == zx_hrxml_WorkSiteId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_WorkSiteId(c,(struct zx_hrxml_WorkSiteId_s*)e,dup_strs);
  	  if (!enn)
  	      x->WorkSiteId = (struct zx_hrxml_WorkSiteId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Details->gg;
       e && e->g.tok == zx_hrxml_Details_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Details(c,(struct zx_hrxml_Details_s*)e,dup_strs);
  	  if (!enn)
  	      x->Details = (struct zx_hrxml_Details_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_PostalAddress(c,(struct zx_hrxml_PostalAddress_s*)e,dup_strs);
  	  if (!enn)
  	      x->PostalAddress = (struct zx_hrxml_PostalAddress_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->TravelDirections->gg;
       e && e->g.tok == zx_hrxml_TravelDirections_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_TravelDirections(c,(struct zx_hrxml_TravelDirections_s*)e,dup_strs);
  	  if (!enn)
  	      x->TravelDirections = (struct zx_hrxml_TravelDirections_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->ParkingInstructions->gg;
       e && e->g.tok == zx_hrxml_ParkingInstructions_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_ParkingInstructions(c,(struct zx_hrxml_ParkingInstructions_s*)e,dup_strs);
  	  if (!enn)
  	      x->ParkingInstructions = (struct zx_hrxml_ParkingInstructions_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->WorkSiteEnvironment->gg;
       e && e->g.tok == zx_hrxml_WorkSiteEnvironment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_WorkSiteEnvironment(c,(struct zx_hrxml_WorkSiteEnvironment_s*)e,dup_strs);
  	  if (!enn)
  	      x->WorkSiteEnvironment = (struct zx_hrxml_WorkSiteEnvironment_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_WorkSite) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->WorkSiteName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->WorkSiteId->gg;
       e && e->g.tok == zx_hrxml_WorkSiteId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_WorkSiteId(c, (struct zx_hrxml_WorkSiteId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Details->gg;
       e && e->g.tok == zx_hrxml_Details_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Details(c, (struct zx_hrxml_Details_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->PostalAddress->gg;
       e && e->g.tok == zx_hrxml_PostalAddress_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_PostalAddress(c, (struct zx_hrxml_PostalAddress_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->TravelDirections->gg;
       e && e->g.tok == zx_hrxml_TravelDirections_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_TravelDirections(c, (struct zx_hrxml_TravelDirections_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->ParkingInstructions->gg;
       e && e->g.tok == zx_hrxml_ParkingInstructions_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_ParkingInstructions(c, (struct zx_hrxml_ParkingInstructions_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->WorkSiteEnvironment->gg;
       e && e->g.tok == zx_hrxml_WorkSiteEnvironment_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_WorkSiteEnvironment(c, (struct zx_hrxml_WorkSiteEnvironment_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_WorkSite) */

int zx_WALK_WO_hrxml_WorkSite(struct zx_ctx* c, struct zx_hrxml_WorkSite_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_WorkSiteEnvironment
#define EL_STRUCT zx_hrxml_WorkSiteEnvironment_s
#define EL_NS     hrxml
#define EL_TAG    WorkSiteEnvironment

/* FUNC(zx_FREE_hrxml_WorkSiteEnvironment) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */


  zx_free_simple_elems(c, x->EnvironmentName, free_strs);
  for (e = &x->EnvironmentId->gg;
       e && e->g.tok == zx_hrxml_EnvironmentId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_EnvironmentId(c, (struct zx_hrxml_EnvironmentId_s*)e, free_strs);
  }
  for (e = &x->WorkSiteId->gg;
       e && e->g.tok == zx_hrxml_WorkSiteId_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_WorkSiteId(c, (struct zx_hrxml_WorkSiteId_s*)e, free_strs);
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, free_strs);
  }
  for (e = &x->Considerations->gg;
       e && e->g.tok == zx_hrxml_Considerations_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_Considerations(c, (struct zx_hrxml_Considerations_s*)e, free_strs);
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_WorkSiteEnvironment) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_WorkSiteEnvironment_s* zx_NEW_hrxml_WorkSiteEnvironment(struct zx_ctx* c)
{
  struct zx_hrxml_WorkSiteEnvironment_s* x = ZX_ZALLOC(c, struct zx_hrxml_WorkSiteEnvironment_s);
  x->gg.g.tok = zx_hrxml_WorkSiteEnvironment_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_WorkSiteEnvironment) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */


  zx_dup_strs_simple_elems(c, x->EnvironmentName);
  for (se = &x->EnvironmentId->gg;
       se && se->g.tok == zx_hrxml_EnvironmentId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_EnvironmentId(c, (struct zx_hrxml_EnvironmentId_s*)se);
  for (se = &x->WorkSiteId->gg;
       se && se->g.tok == zx_hrxml_WorkSiteId_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_WorkSiteId(c, (struct zx_hrxml_WorkSiteId_s*)se);
  for (se = &x->Description->gg;
       se && se->g.tok == zx_hrxml_Description_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Description(c, (struct zx_hrxml_Description_s*)se);
  for (se = &x->Considerations->gg;
       se && se->g.tok == zx_hrxml_Considerations_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_Considerations(c, (struct zx_hrxml_Considerations_s*)se);
  for (se = &x->UserArea->gg;
       se && se->g.tok == zx_hrxml_UserArea_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_WorkSiteEnvironment) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_WorkSiteEnvironment_s* zx_DEEP_CLONE_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_WorkSiteEnvironment_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_WorkSiteEnvironment_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */


  x->EnvironmentName = zx_deep_clone_simple_elems(c,x->EnvironmentName, dup_strs);
  for (enn = 0, e = &x->EnvironmentId->gg;
       e && e->g.tok == zx_hrxml_EnvironmentId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_EnvironmentId(c,(struct zx_hrxml_EnvironmentId_s*)e,dup_strs);
  	  if (!enn)
  	      x->EnvironmentId = (struct zx_hrxml_EnvironmentId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->WorkSiteId->gg;
       e && e->g.tok == zx_hrxml_WorkSiteId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_WorkSiteId(c,(struct zx_hrxml_WorkSiteId_s*)e,dup_strs);
  	  if (!enn)
  	      x->WorkSiteId = (struct zx_hrxml_WorkSiteId_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Description(c,(struct zx_hrxml_Description_s*)e,dup_strs);
  	  if (!enn)
  	      x->Description = (struct zx_hrxml_Description_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->Considerations->gg;
       e && e->g.tok == zx_hrxml_Considerations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_Considerations(c,(struct zx_hrxml_Considerations_s*)e,dup_strs);
  	  if (!enn)
  	      x->Considerations = (struct zx_hrxml_Considerations_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }
  for (enn = 0, e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_UserArea(c,(struct zx_hrxml_UserArea_s*)e,dup_strs);
  	  if (!enn)
  	      x->UserArea = (struct zx_hrxml_UserArea_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_WorkSiteEnvironment) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  ret = zx_walk_so_simple_elems(c, x->EnvironmentName, ctx, callback);
  if (ret)
    return ret;
  for (e = &x->EnvironmentId->gg;
       e && e->g.tok == zx_hrxml_EnvironmentId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_EnvironmentId(c, (struct zx_hrxml_EnvironmentId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->WorkSiteId->gg;
       e && e->g.tok == zx_hrxml_WorkSiteId_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_WorkSiteId(c, (struct zx_hrxml_WorkSiteId_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Description->gg;
       e && e->g.tok == zx_hrxml_Description_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Description(c, (struct zx_hrxml_Description_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->Considerations->gg;
       e && e->g.tok == zx_hrxml_Considerations_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_Considerations(c, (struct zx_hrxml_Considerations_s*)e, ctx, callback);
    if (ret)
      return ret;
  }
  for (e = &x->UserArea->gg;
       e && e->g.tok == zx_hrxml_UserArea_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_UserArea(c, (struct zx_hrxml_UserArea_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_WorkSiteEnvironment) */

int zx_WALK_WO_hrxml_WorkSiteEnvironment(struct zx_ctx* c, struct zx_hrxml_WorkSiteEnvironment_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif




#ifdef EL_NAME
#undef EL_NAME
#endif
#ifdef EL_STRUCT
#undef EL_STRUCT
#endif
#ifdef EL_NS
#undef EL_NS
#endif
#ifdef EL_TAG
#undef EL_TAG
#endif

#define EL_NAME   hrxml_WorkSiteId
#define EL_STRUCT zx_hrxml_WorkSiteId_s
#define EL_NS     hrxml
#define EL_TAG    WorkSiteId

/* FUNC(zx_FREE_hrxml_WorkSiteId) */

/* Depth first traversal of data structure to free it and its subelements. Simple
 * strings are handled as a special case according to the free_strs flag. This
 * is useful if the strings point to underlying data from the wire that was
 * allocated differently. */

/* Called by: */
void zx_FREE_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x, int free_strs)
{
  struct zx_elem_s* e  MAYBE_UNUSED;
  struct zx_elem_s* en MAYBE_UNUSED;

  /* *** deal with xmlns specifications in exc c14n way */

  zx_free_attr(c, x->idOwner, free_strs);
  zx_free_attr(c, x->validFrom, free_strs);
  zx_free_attr(c, x->validTo, free_strs);

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = en) {
    en = (struct zx_elem_s*)e->g.n;
    zx_FREE_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, free_strs);
  }


  zx_free_elem_common(c, &x->gg, free_strs); 
}

/* FUNC(zx_NEW_hrxml_WorkSiteId) */

/* Trivial allocator/constructor for the datatype. */

/* Called by: */
struct zx_hrxml_WorkSiteId_s* zx_NEW_hrxml_WorkSiteId(struct zx_ctx* c)
{
  struct zx_hrxml_WorkSiteId_s* x = ZX_ZALLOC(c, struct zx_hrxml_WorkSiteId_s);
  x->gg.g.tok = zx_hrxml_WorkSiteId_ELEM;
  return x;
}

#ifdef ZX_ENA_AUX

/* FUNC(zx_DUP_STRS_hrxml_WorkSiteId) */

/* Depth first traversal of data structure to copy its simple strings
 * to memory allocated from the memory allocator. The decoder will
 * use the underlying wireprotocol PDU buffer for strings, i.e.
 * strings are not copied - they point to the real data. If the
 * datastructure needs to outlast the protocol data or needs a different
 * memory allocation strategy, you need to call this function.  */

/* Called by: */
void zx_DUP_STRS_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x)
{
  struct zx_elem_s* se  MAYBE_UNUSED;
  zx_dup_strs_common(c, &x->gg);
  /* *** deal with xmlns specifications in exc c14n way */

  zx_dup_attr(c, x->idOwner);
  zx_dup_attr(c, x->validFrom);
  zx_dup_attr(c, x->validTo);

  for (se = &x->IdValue->gg;
       se && se->g.tok == zx_hrxml_IdValue_ELEM;
       se = (struct zx_elem_s*)se->g.n)
    zx_DUP_STRS_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)se);

}

/* FUNC(zx_DEEP_CLONE_hrxml_WorkSiteId) */

/* Depth first traversal of data structure to clone it and its sublements.
 * The simple strings are handled as a special case according to dup_strs flag. */

/* Called by: */
struct zx_hrxml_WorkSiteId_s* zx_DEEP_CLONE_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x, int dup_strs)
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  struct zx_elem_s* en  MAYBE_UNUSED;
  struct zx_elem_s* enn MAYBE_UNUSED;

  x = (struct zx_hrxml_WorkSiteId_s*)zx_clone_elem_common(c, &x->gg, sizeof(struct zx_hrxml_WorkSiteId_s), dup_strs);
  /* *** deal with xmlns specifications in exc c14n way */

  x->idOwner = zx_clone_attr(c, x->idOwner);
  x->validFrom = zx_clone_attr(c, x->validFrom);
  x->validTo = zx_clone_attr(c, x->validTo);

  for (enn = 0, e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
  	  en=(struct zx_elem_s*)zx_DEEP_CLONE_hrxml_IdValue(c,(struct zx_hrxml_IdValue_s*)e,dup_strs);
  	  if (!enn)
  	      x->IdValue = (struct zx_hrxml_IdValue_s*)en;
  	  else
  	      enn->g.n = &en->g;
  	  enn = en;
  }

  return x;
}

/* FUNC(zx_WALK_SO_hrxml_WorkSiteId) */

/* Depth first traversal of the tree in either schema order or the wire order. */
 
int zx_WALK_SO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  struct zx_elem_s* e   MAYBE_UNUSED;
  int ret = callback(&x->gg.g, ctx);
  if (ret)
    return ret;
  
  /* *** deal with xmlns specifications in exc c14n way */


  
  ret = zx_walk_so_unknown_attributes(c, &x->gg, ctx, callback); 
  if (ret)
    return ret;

  for (e = &x->IdValue->gg;
       e && e->g.tok == zx_hrxml_IdValue_ELEM;
       e = (struct zx_elem_s*)e->g.n) {
    ret = zx_WALK_SO_hrxml_IdValue(c, (struct zx_hrxml_IdValue_s*)e, ctx, callback);
    if (ret)
      return ret;
  }

  
  return zx_walk_so_unknown_elems_and_content(c, &x->gg, ctx, callback);
}

/* FUNC(zx_WALK_WO_hrxml_WorkSiteId) */

int zx_WALK_WO_hrxml_WorkSiteId(struct zx_ctx* c, struct zx_hrxml_WorkSiteId_s* x, void* ctx, int (*callback)(struct zx_node_s* node, void* ctx))
{
  ERR("*** walk_wo not implemented %d", 0);
  return 0;
}

#endif


/* EOF -- c/zx-hrxml-aux.c */
