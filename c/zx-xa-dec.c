/* c/zx-xa-dec.c - WARNING: This file was auto generated by xsd2sg.pl. DO NOT EDIT!
 * $Id$ */
/* Code generation design Copyright (c) 2006 Sampo Kellomaki (sampo@iki.fi),
 * All Rights Reserved. NO WARRANTY. See file COPYING for terms and conditions
 * of use. Some aspects of code generation were driven by schema
 * descriptions that were used as input and may be subject to their own copyright.
 * Code generation uses a template, whose copyright statement follows. */

/** dec-templ.c  -  XML decoder template, used in code generation
 ** Copyright (c) 2010 Sampo Kellomaki (sampo@iki.fi), All Rights Reserved.
 ** Copyright (c) 2006-2007 Symlabs (symlabs@symlabs.com), All Rights Reserved.
 ** Author: Sampo Kellomaki (sampo@iki.fi)
 ** This is confidential unpublished proprietary source code of the author.
 ** NO WARRANTY, not even implied warranties. Contains trade secrets.
 ** Distribution prohibited unless authorized in writing.
 ** Licensed under Apache License 2.0, see file COPYING.
 ** Id: dec-templ.c,v 1.30 2008-10-04 23:42:14 sampo Exp $
 **
 ** 28.5.2006, created, Sampo Kellomaki (sampo@iki.fi)
 ** 8.8.2006,  reworked namespace handling --Sampo
 ** 12.8.2006, added special scanning of xmlns to avoid backtracking elem recognition --Sampo
 ** 23.9.2006, added collection of WO information --Sampo
 ** 21.6.2007, improved handling of undeclared namespace prefixes --Sampo
 ** 27.10.2010, CSE refactoring, re-engineered namespace handling --Sampo
 **
 ** N.B: This template is meant to be processed by pd/xsd2sg.pl. Beware
 ** of special markers that xsd2sg.pl expects to find and understand.
 **/

#include "errmac.h"
#include "zx.h"
#include "c/zx-const.h"
#include "c/zx-data.h"
#include "c/zx-xa-data.h"
#define TPF zx_
#include "zx_ext_pt.h"




/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Action
#define EL_STRUCT zx_xa_Action_s
#define EL_NS     xa
#define EL_TAG    Action

/* FUNC(zx_DEC_xa_Action) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Action_s* zx_DEC_xa_Action(struct zx_ctx* c, struct zx_xa_Action_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_ActionMatch_ELEM:
            zx_DEC_xa_ActionMatch(c, (struct zx_xa_ActionMatch_s*)el);
            if (!x->ActionMatch)
              x->ActionMatch = (struct zx_xa_ActionMatch_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_ActionAttributeDesignator
#define EL_STRUCT zx_xa_ActionAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    ActionAttributeDesignator

/* FUNC(zx_DEC_xa_ActionAttributeDesignator) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_ActionAttributeDesignator_s* zx_DEC_xa_ActionAttributeDesignator(struct zx_ctx* c, struct zx_xa_ActionAttributeDesignator_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_AttributeId_ATTR:  x->AttributeId = x->gg.attr; break;
    case zx_DataType_ATTR:  x->DataType = x->gg.attr; break;
    case zx_Issuer_ATTR:  x->Issuer = x->gg.attr; break;
    case zx_MustBePresent_ATTR:  x->MustBePresent = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_ActionMatch
#define EL_STRUCT zx_xa_ActionMatch_s
#define EL_NS     xa
#define EL_TAG    ActionMatch

/* FUNC(zx_DEC_xa_ActionMatch) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_ActionMatch_s* zx_DEC_xa_ActionMatch(struct zx_ctx* c, struct zx_xa_ActionMatch_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_MatchId_ATTR:  x->MatchId = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_AttributeValue_ELEM:
            zx_DEC_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)el);
            if (!x->AttributeValue)
              x->AttributeValue = (struct zx_xa_AttributeValue_s*)el;
            break;
          case zx_xa_ActionAttributeDesignator_ELEM:
            zx_DEC_xa_ActionAttributeDesignator(c, (struct zx_xa_ActionAttributeDesignator_s*)el);
            if (!x->ActionAttributeDesignator)
              x->ActionAttributeDesignator = (struct zx_xa_ActionAttributeDesignator_s*)el;
            break;
          case zx_xa_AttributeSelector_ELEM:
            zx_DEC_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)el);
            if (!x->AttributeSelector)
              x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Actions
#define EL_STRUCT zx_xa_Actions_s
#define EL_NS     xa
#define EL_TAG    Actions

/* FUNC(zx_DEC_xa_Actions) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Actions_s* zx_DEC_xa_Actions(struct zx_ctx* c, struct zx_xa_Actions_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Action_ELEM:
            zx_DEC_xa_Action(c, (struct zx_xa_Action_s*)el);
            if (!x->Action)
              x->Action = (struct zx_xa_Action_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Apply
#define EL_STRUCT zx_xa_Apply_s
#define EL_NS     xa
#define EL_TAG    Apply

/* FUNC(zx_DEC_xa_Apply) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Apply_s* zx_DEC_xa_Apply(struct zx_ctx* c, struct zx_xa_Apply_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_FunctionId_ATTR:  x->FunctionId = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Expression_ELEM:
            zx_DEC_simple_elem(c, el);
            if (!x->Expression)
              x->Expression = el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_AttributeAssignment
#define EL_STRUCT zx_xa_AttributeAssignment_s
#define EL_NS     xa
#define EL_TAG    AttributeAssignment

/* FUNC(zx_DEC_xa_AttributeAssignment) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_AttributeAssignment_s* zx_DEC_xa_AttributeAssignment(struct zx_ctx* c, struct zx_xa_AttributeAssignment_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_AttributeId_ATTR:  x->AttributeId = x->gg.attr; break;
    case zx_DataType_ATTR:  x->DataType = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_AttributeSelector
#define EL_STRUCT zx_xa_AttributeSelector_s
#define EL_NS     xa
#define EL_TAG    AttributeSelector

/* FUNC(zx_DEC_xa_AttributeSelector) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_AttributeSelector_s* zx_DEC_xa_AttributeSelector(struct zx_ctx* c, struct zx_xa_AttributeSelector_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_DataType_ATTR:  x->DataType = x->gg.attr; break;
    case zx_MustBePresent_ATTR:  x->MustBePresent = x->gg.attr; break;
    case zx_RequestContextPath_ATTR:  x->RequestContextPath = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_AttributeValue
#define EL_STRUCT zx_xa_AttributeValue_s
#define EL_NS     xa
#define EL_TAG    AttributeValue

/* FUNC(zx_DEC_xa_AttributeValue) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_AttributeValue_s* zx_DEC_xa_AttributeValue(struct zx_ctx* c, struct zx_xa_AttributeValue_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_DataType_ATTR:  x->DataType = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_CombinerParameter
#define EL_STRUCT zx_xa_CombinerParameter_s
#define EL_NS     xa
#define EL_TAG    CombinerParameter

/* FUNC(zx_DEC_xa_CombinerParameter) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_CombinerParameter_s* zx_DEC_xa_CombinerParameter(struct zx_ctx* c, struct zx_xa_CombinerParameter_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_ParameterName_ATTR:  x->ParameterName = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_AttributeValue_ELEM:
            zx_DEC_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)el);
            if (!x->AttributeValue)
              x->AttributeValue = (struct zx_xa_AttributeValue_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_CombinerParameters
#define EL_STRUCT zx_xa_CombinerParameters_s
#define EL_NS     xa
#define EL_TAG    CombinerParameters

/* FUNC(zx_DEC_xa_CombinerParameters) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_CombinerParameters_s* zx_DEC_xa_CombinerParameters(struct zx_ctx* c, struct zx_xa_CombinerParameters_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_CombinerParameter_ELEM:
            zx_DEC_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)el);
            if (!x->CombinerParameter)
              x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Condition
#define EL_STRUCT zx_xa_Condition_s
#define EL_NS     xa
#define EL_TAG    Condition

/* FUNC(zx_DEC_xa_Condition) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Condition_s* zx_DEC_xa_Condition(struct zx_ctx* c, struct zx_xa_Condition_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Expression_ELEM:
            zx_DEC_simple_elem(c, el);
            if (!x->Expression)
              x->Expression = el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Environment
#define EL_STRUCT zx_xa_Environment_s
#define EL_NS     xa
#define EL_TAG    Environment

/* FUNC(zx_DEC_xa_Environment) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Environment_s* zx_DEC_xa_Environment(struct zx_ctx* c, struct zx_xa_Environment_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_EnvironmentMatch_ELEM:
            zx_DEC_xa_EnvironmentMatch(c, (struct zx_xa_EnvironmentMatch_s*)el);
            if (!x->EnvironmentMatch)
              x->EnvironmentMatch = (struct zx_xa_EnvironmentMatch_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_EnvironmentAttributeDesignator
#define EL_STRUCT zx_xa_EnvironmentAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    EnvironmentAttributeDesignator

/* FUNC(zx_DEC_xa_EnvironmentAttributeDesignator) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_EnvironmentAttributeDesignator_s* zx_DEC_xa_EnvironmentAttributeDesignator(struct zx_ctx* c, struct zx_xa_EnvironmentAttributeDesignator_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_AttributeId_ATTR:  x->AttributeId = x->gg.attr; break;
    case zx_DataType_ATTR:  x->DataType = x->gg.attr; break;
    case zx_Issuer_ATTR:  x->Issuer = x->gg.attr; break;
    case zx_MustBePresent_ATTR:  x->MustBePresent = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_EnvironmentMatch
#define EL_STRUCT zx_xa_EnvironmentMatch_s
#define EL_NS     xa
#define EL_TAG    EnvironmentMatch

/* FUNC(zx_DEC_xa_EnvironmentMatch) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_EnvironmentMatch_s* zx_DEC_xa_EnvironmentMatch(struct zx_ctx* c, struct zx_xa_EnvironmentMatch_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_MatchId_ATTR:  x->MatchId = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_AttributeValue_ELEM:
            zx_DEC_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)el);
            if (!x->AttributeValue)
              x->AttributeValue = (struct zx_xa_AttributeValue_s*)el;
            break;
          case zx_xa_EnvironmentAttributeDesignator_ELEM:
            zx_DEC_xa_EnvironmentAttributeDesignator(c, (struct zx_xa_EnvironmentAttributeDesignator_s*)el);
            if (!x->EnvironmentAttributeDesignator)
              x->EnvironmentAttributeDesignator = (struct zx_xa_EnvironmentAttributeDesignator_s*)el;
            break;
          case zx_xa_AttributeSelector_ELEM:
            zx_DEC_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)el);
            if (!x->AttributeSelector)
              x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Environments
#define EL_STRUCT zx_xa_Environments_s
#define EL_NS     xa
#define EL_TAG    Environments

/* FUNC(zx_DEC_xa_Environments) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Environments_s* zx_DEC_xa_Environments(struct zx_ctx* c, struct zx_xa_Environments_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Environment_ELEM:
            zx_DEC_xa_Environment(c, (struct zx_xa_Environment_s*)el);
            if (!x->Environment)
              x->Environment = (struct zx_xa_Environment_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Function
#define EL_STRUCT zx_xa_Function_s
#define EL_NS     xa
#define EL_TAG    Function

/* FUNC(zx_DEC_xa_Function) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Function_s* zx_DEC_xa_Function(struct zx_ctx* c, struct zx_xa_Function_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_FunctionId_ATTR:  x->FunctionId = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Obligation
#define EL_STRUCT zx_xa_Obligation_s
#define EL_NS     xa
#define EL_TAG    Obligation

/* FUNC(zx_DEC_xa_Obligation) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Obligation_s* zx_DEC_xa_Obligation(struct zx_ctx* c, struct zx_xa_Obligation_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_FulfillOn_ATTR:  x->FulfillOn = x->gg.attr; break;
    case zx_ObligationId_ATTR:  x->ObligationId = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_AttributeAssignment_ELEM:
            zx_DEC_xa_AttributeAssignment(c, (struct zx_xa_AttributeAssignment_s*)el);
            if (!x->AttributeAssignment)
              x->AttributeAssignment = (struct zx_xa_AttributeAssignment_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Obligations
#define EL_STRUCT zx_xa_Obligations_s
#define EL_NS     xa
#define EL_TAG    Obligations

/* FUNC(zx_DEC_xa_Obligations) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Obligations_s* zx_DEC_xa_Obligations(struct zx_ctx* c, struct zx_xa_Obligations_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Obligation_ELEM:
            zx_DEC_xa_Obligation(c, (struct zx_xa_Obligation_s*)el);
            if (!x->Obligation)
              x->Obligation = (struct zx_xa_Obligation_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Policy
#define EL_STRUCT zx_xa_Policy_s
#define EL_NS     xa
#define EL_TAG    Policy

/* FUNC(zx_DEC_xa_Policy) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Policy_s* zx_DEC_xa_Policy(struct zx_ctx* c, struct zx_xa_Policy_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_PolicyId_ATTR:  x->PolicyId = x->gg.attr; break;
    case zx_RuleCombiningAlgId_ATTR:  x->RuleCombiningAlgId = x->gg.attr; break;
    case zx_Version_ATTR:  x->Version = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Description_ELEM:
            zx_DEC_simple_elem(c, el);
            if (!x->Description)
              x->Description = el;
            break;
          case zx_xa_PolicyDefaults_ELEM:
            zx_DEC_xa_PolicyDefaults(c, (struct zx_xa_PolicyDefaults_s*)el);
            if (!x->PolicyDefaults)
              x->PolicyDefaults = (struct zx_xa_PolicyDefaults_s*)el;
            break;
          case zx_xa_Target_ELEM:
            zx_DEC_xa_Target(c, (struct zx_xa_Target_s*)el);
            if (!x->Target)
              x->Target = (struct zx_xa_Target_s*)el;
            break;
          case zx_xa_CombinerParameters_ELEM:
            zx_DEC_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)el);
            if (!x->CombinerParameters)
              x->CombinerParameters = (struct zx_xa_CombinerParameters_s*)el;
            break;
          case zx_xa_RuleCombinerParameters_ELEM:
            zx_DEC_xa_RuleCombinerParameters(c, (struct zx_xa_RuleCombinerParameters_s*)el);
            if (!x->RuleCombinerParameters)
              x->RuleCombinerParameters = (struct zx_xa_RuleCombinerParameters_s*)el;
            break;
          case zx_xa_VariableDefinition_ELEM:
            zx_DEC_xa_VariableDefinition(c, (struct zx_xa_VariableDefinition_s*)el);
            if (!x->VariableDefinition)
              x->VariableDefinition = (struct zx_xa_VariableDefinition_s*)el;
            break;
          case zx_xa_Rule_ELEM:
            zx_DEC_xa_Rule(c, (struct zx_xa_Rule_s*)el);
            if (!x->Rule)
              x->Rule = (struct zx_xa_Rule_s*)el;
            break;
          case zx_xa_Obligations_ELEM:
            zx_DEC_xa_Obligations(c, (struct zx_xa_Obligations_s*)el);
            if (!x->Obligations)
              x->Obligations = (struct zx_xa_Obligations_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_PolicyCombinerParameters
#define EL_STRUCT zx_xa_PolicyCombinerParameters_s
#define EL_NS     xa
#define EL_TAG    PolicyCombinerParameters

/* FUNC(zx_DEC_xa_PolicyCombinerParameters) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_PolicyCombinerParameters_s* zx_DEC_xa_PolicyCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicyCombinerParameters_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_PolicyIdRef_ATTR:  x->PolicyIdRef = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_CombinerParameter_ELEM:
            zx_DEC_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)el);
            if (!x->CombinerParameter)
              x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_PolicyDefaults
#define EL_STRUCT zx_xa_PolicyDefaults_s
#define EL_NS     xa
#define EL_TAG    PolicyDefaults

/* FUNC(zx_DEC_xa_PolicyDefaults) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_PolicyDefaults_s* zx_DEC_xa_PolicyDefaults(struct zx_ctx* c, struct zx_xa_PolicyDefaults_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_XPathVersion_ELEM:
            zx_DEC_simple_elem(c, el);
            if (!x->XPathVersion)
              x->XPathVersion = el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_PolicyIdReference
#define EL_STRUCT zx_xa_PolicyIdReference_s
#define EL_NS     xa
#define EL_TAG    PolicyIdReference

/* FUNC(zx_DEC_xa_PolicyIdReference) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_PolicyIdReference_s* zx_DEC_xa_PolicyIdReference(struct zx_ctx* c, struct zx_xa_PolicyIdReference_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_EarliestVersion_ATTR:  x->EarliestVersion = x->gg.attr; break;
    case zx_LatestVersion_ATTR:  x->LatestVersion = x->gg.attr; break;
    case zx_Version_ATTR:  x->Version = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_PolicySet
#define EL_STRUCT zx_xa_PolicySet_s
#define EL_NS     xa
#define EL_TAG    PolicySet

/* FUNC(zx_DEC_xa_PolicySet) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_PolicySet_s* zx_DEC_xa_PolicySet(struct zx_ctx* c, struct zx_xa_PolicySet_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_PolicyCombiningAlgId_ATTR:  x->PolicyCombiningAlgId = x->gg.attr; break;
    case zx_PolicySetId_ATTR:  x->PolicySetId = x->gg.attr; break;
    case zx_Version_ATTR:  x->Version = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Description_ELEM:
            zx_DEC_simple_elem(c, el);
            if (!x->Description)
              x->Description = el;
            break;
          case zx_xa_PolicySetDefaults_ELEM:
            zx_DEC_xa_PolicySetDefaults(c, (struct zx_xa_PolicySetDefaults_s*)el);
            if (!x->PolicySetDefaults)
              x->PolicySetDefaults = (struct zx_xa_PolicySetDefaults_s*)el;
            break;
          case zx_xa_Target_ELEM:
            zx_DEC_xa_Target(c, (struct zx_xa_Target_s*)el);
            if (!x->Target)
              x->Target = (struct zx_xa_Target_s*)el;
            break;
          case zx_xa_PolicySet_ELEM:
            zx_DEC_xa_PolicySet(c, (struct zx_xa_PolicySet_s*)el);
            if (!x->PolicySet)
              x->PolicySet = (struct zx_xa_PolicySet_s*)el;
            break;
          case zx_xa_Policy_ELEM:
            zx_DEC_xa_Policy(c, (struct zx_xa_Policy_s*)el);
            if (!x->Policy)
              x->Policy = (struct zx_xa_Policy_s*)el;
            break;
          case zx_xa_PolicySetIdReference_ELEM:
            zx_DEC_xa_PolicySetIdReference(c, (struct zx_xa_PolicySetIdReference_s*)el);
            if (!x->PolicySetIdReference)
              x->PolicySetIdReference = (struct zx_xa_PolicySetIdReference_s*)el;
            break;
          case zx_xa_PolicyIdReference_ELEM:
            zx_DEC_xa_PolicyIdReference(c, (struct zx_xa_PolicyIdReference_s*)el);
            if (!x->PolicyIdReference)
              x->PolicyIdReference = (struct zx_xa_PolicyIdReference_s*)el;
            break;
          case zx_xa_CombinerParameters_ELEM:
            zx_DEC_xa_CombinerParameters(c, (struct zx_xa_CombinerParameters_s*)el);
            if (!x->CombinerParameters)
              x->CombinerParameters = (struct zx_xa_CombinerParameters_s*)el;
            break;
          case zx_xa_PolicyCombinerParameters_ELEM:
            zx_DEC_xa_PolicyCombinerParameters(c, (struct zx_xa_PolicyCombinerParameters_s*)el);
            if (!x->PolicyCombinerParameters)
              x->PolicyCombinerParameters = (struct zx_xa_PolicyCombinerParameters_s*)el;
            break;
          case zx_xa_PolicySetCombinerParameters_ELEM:
            zx_DEC_xa_PolicySetCombinerParameters(c, (struct zx_xa_PolicySetCombinerParameters_s*)el);
            if (!x->PolicySetCombinerParameters)
              x->PolicySetCombinerParameters = (struct zx_xa_PolicySetCombinerParameters_s*)el;
            break;
          case zx_xa_Obligations_ELEM:
            zx_DEC_xa_Obligations(c, (struct zx_xa_Obligations_s*)el);
            if (!x->Obligations)
              x->Obligations = (struct zx_xa_Obligations_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_PolicySetCombinerParameters
#define EL_STRUCT zx_xa_PolicySetCombinerParameters_s
#define EL_NS     xa
#define EL_TAG    PolicySetCombinerParameters

/* FUNC(zx_DEC_xa_PolicySetCombinerParameters) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_PolicySetCombinerParameters_s* zx_DEC_xa_PolicySetCombinerParameters(struct zx_ctx* c, struct zx_xa_PolicySetCombinerParameters_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_PolicySetIdRef_ATTR:  x->PolicySetIdRef = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_CombinerParameter_ELEM:
            zx_DEC_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)el);
            if (!x->CombinerParameter)
              x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_PolicySetDefaults
#define EL_STRUCT zx_xa_PolicySetDefaults_s
#define EL_NS     xa
#define EL_TAG    PolicySetDefaults

/* FUNC(zx_DEC_xa_PolicySetDefaults) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_PolicySetDefaults_s* zx_DEC_xa_PolicySetDefaults(struct zx_ctx* c, struct zx_xa_PolicySetDefaults_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_XPathVersion_ELEM:
            zx_DEC_simple_elem(c, el);
            if (!x->XPathVersion)
              x->XPathVersion = el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_PolicySetIdReference
#define EL_STRUCT zx_xa_PolicySetIdReference_s
#define EL_NS     xa
#define EL_TAG    PolicySetIdReference

/* FUNC(zx_DEC_xa_PolicySetIdReference) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_PolicySetIdReference_s* zx_DEC_xa_PolicySetIdReference(struct zx_ctx* c, struct zx_xa_PolicySetIdReference_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_EarliestVersion_ATTR:  x->EarliestVersion = x->gg.attr; break;
    case zx_LatestVersion_ATTR:  x->LatestVersion = x->gg.attr; break;
    case zx_Version_ATTR:  x->Version = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Resource
#define EL_STRUCT zx_xa_Resource_s
#define EL_NS     xa
#define EL_TAG    Resource

/* FUNC(zx_DEC_xa_Resource) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Resource_s* zx_DEC_xa_Resource(struct zx_ctx* c, struct zx_xa_Resource_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_ResourceMatch_ELEM:
            zx_DEC_xa_ResourceMatch(c, (struct zx_xa_ResourceMatch_s*)el);
            if (!x->ResourceMatch)
              x->ResourceMatch = (struct zx_xa_ResourceMatch_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_ResourceAttributeDesignator
#define EL_STRUCT zx_xa_ResourceAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    ResourceAttributeDesignator

/* FUNC(zx_DEC_xa_ResourceAttributeDesignator) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_ResourceAttributeDesignator_s* zx_DEC_xa_ResourceAttributeDesignator(struct zx_ctx* c, struct zx_xa_ResourceAttributeDesignator_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_AttributeId_ATTR:  x->AttributeId = x->gg.attr; break;
    case zx_DataType_ATTR:  x->DataType = x->gg.attr; break;
    case zx_Issuer_ATTR:  x->Issuer = x->gg.attr; break;
    case zx_MustBePresent_ATTR:  x->MustBePresent = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_ResourceMatch
#define EL_STRUCT zx_xa_ResourceMatch_s
#define EL_NS     xa
#define EL_TAG    ResourceMatch

/* FUNC(zx_DEC_xa_ResourceMatch) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_ResourceMatch_s* zx_DEC_xa_ResourceMatch(struct zx_ctx* c, struct zx_xa_ResourceMatch_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_MatchId_ATTR:  x->MatchId = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_AttributeValue_ELEM:
            zx_DEC_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)el);
            if (!x->AttributeValue)
              x->AttributeValue = (struct zx_xa_AttributeValue_s*)el;
            break;
          case zx_xa_ResourceAttributeDesignator_ELEM:
            zx_DEC_xa_ResourceAttributeDesignator(c, (struct zx_xa_ResourceAttributeDesignator_s*)el);
            if (!x->ResourceAttributeDesignator)
              x->ResourceAttributeDesignator = (struct zx_xa_ResourceAttributeDesignator_s*)el;
            break;
          case zx_xa_AttributeSelector_ELEM:
            zx_DEC_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)el);
            if (!x->AttributeSelector)
              x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Resources
#define EL_STRUCT zx_xa_Resources_s
#define EL_NS     xa
#define EL_TAG    Resources

/* FUNC(zx_DEC_xa_Resources) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Resources_s* zx_DEC_xa_Resources(struct zx_ctx* c, struct zx_xa_Resources_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Resource_ELEM:
            zx_DEC_xa_Resource(c, (struct zx_xa_Resource_s*)el);
            if (!x->Resource)
              x->Resource = (struct zx_xa_Resource_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Rule
#define EL_STRUCT zx_xa_Rule_s
#define EL_NS     xa
#define EL_TAG    Rule

/* FUNC(zx_DEC_xa_Rule) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Rule_s* zx_DEC_xa_Rule(struct zx_ctx* c, struct zx_xa_Rule_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_Effect_ATTR:  x->Effect = x->gg.attr; break;
    case zx_RuleId_ATTR:  x->RuleId = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Description_ELEM:
            zx_DEC_simple_elem(c, el);
            if (!x->Description)
              x->Description = el;
            break;
          case zx_xa_Target_ELEM:
            zx_DEC_xa_Target(c, (struct zx_xa_Target_s*)el);
            if (!x->Target)
              x->Target = (struct zx_xa_Target_s*)el;
            break;
          case zx_xa_Condition_ELEM:
            zx_DEC_xa_Condition(c, (struct zx_xa_Condition_s*)el);
            if (!x->Condition)
              x->Condition = (struct zx_xa_Condition_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_RuleCombinerParameters
#define EL_STRUCT zx_xa_RuleCombinerParameters_s
#define EL_NS     xa
#define EL_TAG    RuleCombinerParameters

/* FUNC(zx_DEC_xa_RuleCombinerParameters) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_RuleCombinerParameters_s* zx_DEC_xa_RuleCombinerParameters(struct zx_ctx* c, struct zx_xa_RuleCombinerParameters_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_RuleIdRef_ATTR:  x->RuleIdRef = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_CombinerParameter_ELEM:
            zx_DEC_xa_CombinerParameter(c, (struct zx_xa_CombinerParameter_s*)el);
            if (!x->CombinerParameter)
              x->CombinerParameter = (struct zx_xa_CombinerParameter_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Subject
#define EL_STRUCT zx_xa_Subject_s
#define EL_NS     xa
#define EL_TAG    Subject

/* FUNC(zx_DEC_xa_Subject) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Subject_s* zx_DEC_xa_Subject(struct zx_ctx* c, struct zx_xa_Subject_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_SubjectMatch_ELEM:
            zx_DEC_xa_SubjectMatch(c, (struct zx_xa_SubjectMatch_s*)el);
            if (!x->SubjectMatch)
              x->SubjectMatch = (struct zx_xa_SubjectMatch_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_SubjectAttributeDesignator
#define EL_STRUCT zx_xa_SubjectAttributeDesignator_s
#define EL_NS     xa
#define EL_TAG    SubjectAttributeDesignator

/* FUNC(zx_DEC_xa_SubjectAttributeDesignator) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_SubjectAttributeDesignator_s* zx_DEC_xa_SubjectAttributeDesignator(struct zx_ctx* c, struct zx_xa_SubjectAttributeDesignator_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_AttributeId_ATTR:  x->AttributeId = x->gg.attr; break;
    case zx_DataType_ATTR:  x->DataType = x->gg.attr; break;
    case zx_Issuer_ATTR:  x->Issuer = x->gg.attr; break;
    case zx_MustBePresent_ATTR:  x->MustBePresent = x->gg.attr; break;
    case zx_SubjectCategory_ATTR:  x->SubjectCategory = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_SubjectMatch
#define EL_STRUCT zx_xa_SubjectMatch_s
#define EL_NS     xa
#define EL_TAG    SubjectMatch

/* FUNC(zx_DEC_xa_SubjectMatch) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_SubjectMatch_s* zx_DEC_xa_SubjectMatch(struct zx_ctx* c, struct zx_xa_SubjectMatch_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_MatchId_ATTR:  x->MatchId = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_AttributeValue_ELEM:
            zx_DEC_xa_AttributeValue(c, (struct zx_xa_AttributeValue_s*)el);
            if (!x->AttributeValue)
              x->AttributeValue = (struct zx_xa_AttributeValue_s*)el;
            break;
          case zx_xa_SubjectAttributeDesignator_ELEM:
            zx_DEC_xa_SubjectAttributeDesignator(c, (struct zx_xa_SubjectAttributeDesignator_s*)el);
            if (!x->SubjectAttributeDesignator)
              x->SubjectAttributeDesignator = (struct zx_xa_SubjectAttributeDesignator_s*)el;
            break;
          case zx_xa_AttributeSelector_ELEM:
            zx_DEC_xa_AttributeSelector(c, (struct zx_xa_AttributeSelector_s*)el);
            if (!x->AttributeSelector)
              x->AttributeSelector = (struct zx_xa_AttributeSelector_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Subjects
#define EL_STRUCT zx_xa_Subjects_s
#define EL_NS     xa
#define EL_TAG    Subjects

/* FUNC(zx_DEC_xa_Subjects) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Subjects_s* zx_DEC_xa_Subjects(struct zx_ctx* c, struct zx_xa_Subjects_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Subject_ELEM:
            zx_DEC_xa_Subject(c, (struct zx_xa_Subject_s*)el);
            if (!x->Subject)
              x->Subject = (struct zx_xa_Subject_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_Target
#define EL_STRUCT zx_xa_Target_s
#define EL_NS     xa
#define EL_TAG    Target

/* FUNC(zx_DEC_xa_Target) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_Target_s* zx_DEC_xa_Target(struct zx_ctx* c, struct zx_xa_Target_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Subjects_ELEM:
            zx_DEC_xa_Subjects(c, (struct zx_xa_Subjects_s*)el);
            if (!x->Subjects)
              x->Subjects = (struct zx_xa_Subjects_s*)el;
            break;
          case zx_xa_Resources_ELEM:
            zx_DEC_xa_Resources(c, (struct zx_xa_Resources_s*)el);
            if (!x->Resources)
              x->Resources = (struct zx_xa_Resources_s*)el;
            break;
          case zx_xa_Actions_ELEM:
            zx_DEC_xa_Actions(c, (struct zx_xa_Actions_s*)el);
            if (!x->Actions)
              x->Actions = (struct zx_xa_Actions_s*)el;
            break;
          case zx_xa_Environments_ELEM:
            zx_DEC_xa_Environments(c, (struct zx_xa_Environments_s*)el);
            if (!x->Environments)
              x->Environments = (struct zx_xa_Environments_s*)el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_VariableDefinition
#define EL_STRUCT zx_xa_VariableDefinition_s
#define EL_NS     xa
#define EL_TAG    VariableDefinition

/* FUNC(zx_DEC_xa_VariableDefinition) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_VariableDefinition_s* zx_DEC_xa_VariableDefinition(struct zx_ctx* c, struct zx_xa_VariableDefinition_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_VariableId_ATTR:  x->VariableId = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {
          case zx_xa_Expression_ELEM:
            zx_DEC_simple_elem(c, el);
            if (!x->Expression)
              x->Expression = el;
            break;

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG







/* These macros allow extension macros such as ZX_START_DEC_EXT(x) to be parametrised. */

#define EL_NAME   xa_VariableReference
#define EL_STRUCT zx_xa_VariableReference_s
#define EL_NS     xa
#define EL_TAG    VariableReference

/* FUNC(zx_DEC_xa_VariableReference) */

/*() Element Decoder. When per element decoder is called, the c->p
 * will point to just past the element name. The element has already
 * been allocated to the correct size and the namespace prescan has
 * already been done. */

/* Called by: */
struct zx_xa_VariableReference_s* zx_DEC_xa_VariableReference(struct zx_ctx* c, struct zx_xa_VariableReference_s* x )
{
  int tok MAYBE_UNUSED;  /* Unused in zx_DEC_root() */
  struct zx_elem_s* el;
  struct zx_ns_s* pop_seen;

  ZX_START_DEC_EXT(x);

#if 1 /* NORMALMODE */
  /* The tag name has already been detected. Process attributes until '>' */
  
  for (; c->p; ++c->p) {
    tok = zx_attr_lookup(c, (struct zx_elem_s*)x, (const char*)__FUNCTION__);
    switch (tok) {
    case zx_VariableId_ATTR:  x->VariableId = x->gg.attr; break;

    case ZX_TOK_XMLNS: break;
    case ZX_TOK_ATTR_NOT_FOUND: break;
    case ZX_TOK_ATTR_ERR: return x; 
    case ZX_TOK_NO_ATTR: goto no_attr;
    default: zx_known_attr_wrong_context(c, (struct zx_elem_s*)x);
    }
  }
no_attr:
  if (c->p) {
    ++c->p;
    if (c->p[-1] == '/' && c->p[0] == '>') {  /* <Tag/> without content */
      ++c->p;
      goto out;
    }
  }
#endif

  /* Process contents until '</' */
  
  ZX_START_BODY_DEC_EXT(x);
  
  while (c->p) {
  next_elem:
    /*ZX_SKIP_WS(c,x);    DO NOT SQUASH WS! EXC-CANON NEEDS IT. */
    if (*c->p == '<') {
    potential_tag:
      ++c->p;
      switch (*c->p) {
      case '?':  /* processing instruction <?xml ... ?> */
      case '!':  /* comment <!-- ... --> */
	if (zx_scan_pi_or_comment(c))
	  break;
	goto next_elem;
      case '/':  /* close tag */
	if (!zx_scan_elem_end(c, ((struct zx_elem_s*)x)->g.s, (const char*)__FUNCTION__))
	  return x;
	/* Legitimate close tag. Normal exit from this function. */
	++c->p;
	goto out;
      default:
	if (A_Z_a_z_(*c->p)) {
	  el = zx_elem_lookup(c, (struct zx_elem_s*)x, &pop_seen);
	  if (!el)
	    return x;
	  switch (el->g.tok) {

	  default:
	    zx_known_elem_wrong_context(c, (struct zx_elem_s*)x);
	    break;
	  }
	  zx_pop_seen(pop_seen);
	  goto next_elem;
	}
      }
      /* false alarm <, fall thru */
    }
    if (!zx_scan_data(c, (struct zx_elem_s*)x))
      return x;
    goto potential_tag;
  }
 out:
  zx_dec_reverse_lists((struct zx_elem_s*)x);
  ZX_END_DEC_EXT(x);
  return x;
}

#undef EL_NAME
#undef EL_STRUCT
#undef EL_NS
#undef EL_TAG




/* EOF -- c/zx-xa-dec.c */
